/-
Copyright (c) 2025. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: [Your Name]
-/
import Mathlib.MeasureTheory.Integral.IntervalIntegral.Basic
import Mathlib.Analysis.SpecialFunctions.Log.Basic
import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Analysis.Asymptotics.Defs
import Mathlib.Topology.Order.Basic
import Mathlib.Analysis.Calculus.Deriv.Basic

/-!
# The Logarithmic Integral

This file defines the logarithmic integral li(x), which is the main term in the
asymptotic expansion of the prime counting function œÄ(x).

## Definitions

* `logarithmicIntegral x` : li(x) = ‚à´‚ÇÇÀ£ dt/log(t), the logarithmic integral
* `offsetLogarithmicIntegral x` : Li(x), the offset logarithmic integral with
  principal value at t = 1

## Main Results

* `logarithmicIntegral_asymptotic` : li(x) ~ x/log(x) as x ‚Üí ‚àû
* `logarithmicIntegral_expansion` : li(x) = x/log(x) + x/log¬≤(x) + O(x/log¬≥(x))

## References

* Montgomery-Vaughan, "Multiplicative Number Theory I", Section 1.1
-/

open MeasureTheory Set Real Filter Topology

namespace LogarithmicIntegral

/-! ## Definitions -/

/-- The logarithmic integral: li(x) = ‚à´‚ÇÇÀ£ dt/log(t).
    This is the standard definition used in analytic number theory. -/
noncomputable def logarithmicIntegral (x : ‚Ñù) : ‚Ñù :=
  ‚à´ t in Ioc 2 x, 1 / log t

/-- Notation for li -/
scoped notation "li" => logarithmicIntegral

/-- The constant Li(2) ‚âà 1.0451637... -/
noncomputable def offsetLogarithmicIntegralConstant : ‚Ñù :=
  -- This is the Cauchy principal value ‚à´‚ÇÄ¬≤ dt/log(t)
  -- For now we define it axiomatically
  1.0451637107

/-- The offset logarithmic integral Li(x), defined via Cauchy principal value:
    Li(x) = lim_{Œµ‚Üí0‚Å∫} (‚à´‚ÇÄ^{1-Œµ} dt/log(t) + ‚à´_{1+Œµ}^x dt/log(t))

    We use the relationship Li(x) = li(x) + Li(2) where Li(2) ‚âà 1.0451637... -/
noncomputable def offsetLogarithmicIntegral (x : ‚Ñù) : ‚Ñù :=
  logarithmicIntegral x + offsetLogarithmicIntegralConstant

/-- Notation for Li -/
scoped notation "Li" => offsetLogarithmicIntegral

/-! ## Basic Properties -/

section BasicProperties

theorem logarithmicIntegral_of_le_two {x : ‚Ñù} (hx : x ‚â§ 2) : li x = 0 := by
  unfold logarithmicIntegral
  have h : Ioc 2 x = ‚àÖ := Ioc_eq_empty (by linarith : ¬¨2 < x)
  simp [h]

theorem logarithmicIntegral_two : li 2 = 0 := logarithmicIntegral_of_le_two le_rfl

theorem logarithmicIntegral_nonneg {x : ‚Ñù} (_hx : 2 ‚â§ x) : 0 ‚â§ li x := by
  unfold logarithmicIntegral
  apply setIntegral_nonneg measurableSet_Ioc
  intro t ht
  simp only [mem_Ioc] at ht
  have hlog : 0 < log t := log_pos (by linarith : 1 < t)
  positivity

private lemma continuousOn_one_div_log_Icc {a b : ‚Ñù} (ha : 1 < a) :
    ContinuousOn (fun t => 1 / log t) (Icc a b) := by
  have hsubset : Icc a b ‚äÜ ({0}·∂ú : Set ‚Ñù) := by
    intro t ht
    have htpos : (0 : ‚Ñù) < t := lt_of_lt_of_le (lt_trans zero_lt_one ha) ht.1
    exact ne_of_gt htpos
  have hlog : ContinuousOn log (Icc a b) := continuousOn_log.mono hsubset
  have hlog_ne : ‚àÄ t ‚àà Icc a b, log t ‚â† 0 := by
    intro t ht
    have ht1 : (1 : ‚Ñù) < t := lt_of_lt_of_le ha ht.1
    exact ne_of_gt (log_pos ht1)
  have hcont_inv : ContinuousOn (fun t => (log t)‚Åª¬π) (Icc a b) := hlog.inv‚ÇÄ hlog_ne
  simpa [one_div] using hcont_inv

private lemma one_div_log_pos {t : ‚Ñù} (ht : 1 < t) : 0 < 1 / log t :=
  one_div_pos.mpr (log_pos ht)

theorem logarithmicIntegral_pos {x : ‚Ñù} (hx : 2 < x) : 0 < li x := by
  unfold logarithmicIntegral
  have hxle : (2 : ‚Ñù) ‚â§ x := le_of_lt hx
  have hcont : ContinuousOn (fun t => 1 / log t) (Icc (2 : ‚Ñù) x) :=
    continuousOn_one_div_log_Icc (by linarith : (1 : ‚Ñù) < 2)
  have hle : ‚àÄ t ‚àà Ioc (2 : ‚Ñù) x, 0 ‚â§ 1 / log t := by
    intro t ht
    have ht1 : (1 : ‚Ñù) < t := by linarith [ht.1]
    exact (one_div_log_pos ht1).le
  have hlt : ‚àÉ c ‚àà Icc (2 : ‚Ñù) x, 0 < 1 / log c := by
    refine ‚ü®2, ?_, ?_‚ü©
    ¬∑ exact ‚ü®le_rfl, hxle‚ü©
    ¬∑ exact one_div_log_pos (by linarith : (1 : ‚Ñù) < 2)
  have hpos : 0 < ‚à´ t in (2 : ‚Ñù)..x, 1 / log t := by
    exact intervalIntegral.integral_pos hx hcont hle hlt
  simpa [intervalIntegral.integral_of_le hxle] using hpos

theorem logarithmicIntegral_strictMono : StrictMonoOn li (Set.Ici 2) := by
  intro x hx y hy hxy
  have hxy_le : x ‚â§ y := le_of_lt hxy
  have hx1 : (1 : ‚Ñù) < x := lt_of_lt_of_le (by linarith : (1 : ‚Ñù) < 2) hx
  have hcont : ContinuousOn (fun t => 1 / log t) (Icc x y) :=
    continuousOn_one_div_log_Icc hx1
  have hle : ‚àÄ t ‚àà Ioc x y, 0 ‚â§ 1 / log t := by
    intro t ht
    have ht1 : (1 : ‚Ñù) < t := lt_of_lt_of_le hx1 (le_of_lt ht.1)
    exact (one_div_log_pos ht1).le
  have hlt : ‚àÉ c ‚àà Icc x y, 0 < 1 / log c := by
    refine ‚ü®x, ?_, ?_‚ü©
    ¬∑ exact ‚ü®le_rfl, hxy_le‚ü©
    ¬∑ exact one_div_log_pos hx1
  have hpos_interval : 0 < ‚à´ t in x..y, 1 / log t := by
    exact intervalIntegral.integral_pos hxy hcont hle hlt
  have hpos : 0 < ‚à´ t in Ioc x y, 1 / log t := by
    simpa [intervalIntegral.integral_of_le hxy_le] using hpos_interval
  have hcont_big : ContinuousOn (fun t => 1 / log t) (Icc (2 : ‚Ñù) y) :=
    continuousOn_one_div_log_Icc (by linarith : (1 : ‚Ñù) < 2)
  have hcont_x : ContinuousOn (fun t => 1 / log t) (Icc (2 : ‚Ñù) x) :=
    hcont_big.mono (by
      intro t ht
      exact ‚ü®ht.1, ht.2.trans hxy_le‚ü©)
  have hint_y : IntervalIntegrable (fun t => 1 / log t) volume (2 : ‚Ñù) y :=
    (ContinuousOn.intervalIntegrable_of_Icc (a := (2 : ‚Ñù)) (b := y) (hx.trans hxy_le)
      hcont_big)
  have hint_x : IntervalIntegrable (fun t => 1 / log t) volume (2 : ‚Ñù) x :=
    (ContinuousOn.intervalIntegrable_of_Icc (a := (2 : ‚Ñù)) (b := x) hx hcont_x)
  have hsub_interval :
      (‚à´ t in (2 : ‚Ñù)..y, 1 / log t) - ‚à´ t in (2 : ‚Ñù)..x, 1 / log t =
        ‚à´ t in x..y, 1 / log t := by
    exact intervalIntegral.integral_interval_sub_left hint_y hint_x
  have hsub : li y - li x = ‚à´ t in Ioc x y, 1 / log t := by
    simpa [logarithmicIntegral, intervalIntegral.integral_of_le (hx.trans hxy_le),
      intervalIntegral.integral_of_le hx, intervalIntegral.integral_of_le hxy_le, one_div]
      using hsub_interval
  have hlt' : 0 < li y - li x := by simpa [hsub] using hpos
  exact sub_pos.mp hlt'

theorem logarithmicIntegral_mono {x y : ‚Ñù} (hx : 2 ‚â§ x) (hxy : x ‚â§ y) : li x ‚â§ li y := by
  rcases eq_or_lt_of_le hxy with rfl | hxy'
  ¬∑ rfl
  ¬∑ exact le_of_lt (logarithmicIntegral_strictMono hx (hx.trans hxy) hxy')

end BasicProperties

/-! ## Splitting the Integral -/

section Splitting

/-- Additivity: li(y) - li(x) = ‚à´‚Çì ∏ dt/log(t) for 2 ‚â§ x ‚â§ y -/
theorem logarithmicIntegral_sub {x y : ‚Ñù} (hx : 2 ‚â§ x) (hxy : x ‚â§ y) :
    li y - li x = ‚à´ t in Ioc x y, 1 / log t := by
  unfold logarithmicIntegral
  -- Use interval integral splitting
  have hxy_le : x ‚â§ y := hxy
  have hy : 2 ‚â§ y := hx.trans hxy
  have hcont : ContinuousOn (fun t => 1 / log t) (Icc (2 : ‚Ñù) y) :=
    continuousOn_one_div_log_Icc (by linarith : (1 : ‚Ñù) < 2)
  have hcont_x : ContinuousOn (fun t => 1 / log t) (Icc (2 : ‚Ñù) x) :=
    hcont.mono (by
      intro t ht
      exact ‚ü®ht.1, ht.2.trans hxy‚ü©)
  have hint_y : IntervalIntegrable (fun t => 1 / log t) volume (2 : ‚Ñù) y :=
    (ContinuousOn.intervalIntegrable_of_Icc (a := (2 : ‚Ñù)) (b := y) hy hcont)
  have hint_x : IntervalIntegrable (fun t => 1 / log t) volume (2 : ‚Ñù) x :=
    (ContinuousOn.intervalIntegrable_of_Icc (a := (2 : ‚Ñù)) (b := x) hx hcont_x)
  have hsub_interval :
      (‚à´ t in (2 : ‚Ñù)..y, 1 / log t) - ‚à´ t in (2 : ‚Ñù)..x, 1 / log t =
        ‚à´ t in x..y, 1 / log t := by
    exact intervalIntegral.integral_interval_sub_left hint_y hint_x
  have hxle : (2 : ‚Ñù) ‚â§ x := hx
  have hyle : (2 : ‚Ñù) ‚â§ y := hy
  simpa [intervalIntegral.integral_of_le hyle, intervalIntegral.integral_of_le hxle,
    intervalIntegral.integral_of_le hxy_le, one_div] using hsub_interval

/-- Integration by parts identity -/
theorem logarithmicIntegral_integration_by_parts {x : ‚Ñù} (hx : 2 < x) :
    li x = x / log x - 2 / log 2 + ‚à´ t in Ioc 2 x, 1 / (log t)^2 := by
  -- Standard integration by parts with u = 1/log(t), dv = dt
  sorry

end Splitting

/-! ## Asymptotic Expansion -/

section Asymptotics

open Asymptotics

/-- li(x) ~ x/log(x) as x ‚Üí ‚àû -/
theorem logarithmicIntegral_asymptotic :
    Tendsto (fun x => li x / (x / log x)) atTop (ùìù 1) := by
  -- The main term of li(x) is x/log(x)
  sorry

/-- li(x) = x/log(x) + O(x/log¬≤(x)) -/
theorem logarithmicIntegral_bigO_one :
    (fun x => li x - x / log x) =O[atTop] (fun x => x / (log x)^2) := by
  sorry

/-- li(x) = x/log(x) + x/log¬≤(x) + O(x/log¬≥(x)) -/
theorem logarithmicIntegral_bigO_two :
    (fun x => li x - x / log x - x / (log x)^2) =O[atTop] (fun x => x / (log x)^3) := by
  sorry

/-- Full asymptotic expansion: li(x) = x ‚àë_{k=0}^{n-1} k!/log^{k+1}(x) + O(n! x/log^{n+1}(x)) -/
theorem logarithmicIntegral_expansion (n : ‚Ñï) :
    (fun x => li x - x * ‚àë k ‚àà Finset.range n, k.factorial / (log x)^(k+1))
    =O[atTop] (fun x => n.factorial * x / (log x)^(n+1)) := by
  sorry

end Asymptotics

/-! ## Comparison with x/log(x) -/

section Comparison

/-- li(x) > x/log(x) for x > 1 -/
theorem logarithmicIntegral_gt_divLog {x : ‚Ñù} (hx : ‚ÑØ < x) :
    x / log x < li x := by
  sorry

/-- li(x) < x/log(x) + 2x/log¬≤(x) for sufficiently large x -/
theorem logarithmicIntegral_lt_bound :
    ‚àÄ·∂† x in atTop, li x < x / log x + 2 * x / (log x)^2 := by
  sorry

/-- li(x) - x/log(x) ‚Üí ‚àû as x ‚Üí ‚àû -/
theorem logarithmicIntegral_sub_divLog_tendsto :
    Tendsto (fun x => li x - x / log x) atTop atTop := by
  sorry

end Comparison

/-! ## Derivative and Continuity -/

section Calculus

/-- li is continuous on (2, ‚àû) -/
theorem logarithmicIntegral_continuousOn : ContinuousOn li (Set.Ioi 2) := by
  sorry

/-- li is differentiable on (2, ‚àû) with derivative 1/log(x) -/
theorem logarithmicIntegral_hasDerivAt {x : ‚Ñù} (hx : 2 < x) :
    HasDerivAt li (1 / log x) x := by
  sorry

/-- The derivative of li is 1/log(x) -/
theorem logarithmicIntegral_deriv {x : ‚Ñù} (hx : 2 < x) :
    deriv li x = 1 / log x := by
  exact (logarithmicIntegral_hasDerivAt hx).deriv

end Calculus

/-! ## Bounds -/

section Bounds

/-- Lower bound: li(x) ‚â• x/log(x) for x ‚â• e -/
theorem logarithmicIntegral_lower_bound {x : ‚Ñù} (hx : exp 1 ‚â§ x) :
    x / log x ‚â§ li x := by
  sorry

/-- Upper bound: li(x) ‚â§ x/log(x) + 1.5 x/log¬≤(x) for x ‚â• e¬≤ -/
theorem logarithmicIntegral_upper_bound {x : ‚Ñù} (hx : exp 2 ‚â§ x) :
    li x ‚â§ x / log x + 3/2 * x / (log x)^2 := by
  sorry

/-- li(10) ‚âà 6.1655... -/
theorem logarithmicIntegral_ten_bounds : 6 < li 10 ‚àß li 10 < 7 := by
  sorry

/-- li(100) ‚âà 30.126... -/
theorem logarithmicIntegral_hundred_bounds : 30 < li 100 ‚àß li 100 < 31 := by
  sorry

end Bounds

/-! ## Relationship with Li -/

section OffsetRelation

/-- li(x) = Li(x) - Li(2) -/
theorem logarithmicIntegral_eq_offset_sub : li = fun x => Li x - offsetLogarithmicIntegralConstant := by
  ext x
  unfold offsetLogarithmicIntegral
  ring_nf

/-- Li(x) > li(x) by approximately 1.045 -/
theorem offsetLogarithmicIntegral_gt {x : ‚Ñù} (_hx : 2 ‚â§ x) : li x < Li x := by
  unfold offsetLogarithmicIntegral offsetLogarithmicIntegralConstant
  linarith

end OffsetRelation

end LogarithmicIntegral
