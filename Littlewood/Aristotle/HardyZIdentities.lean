/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3ac6fafb-78ae-455e-9b65-47f489cb3979

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 3200000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.HardyZIdentities

/-
Prove the mean-square bound for the Hardy Z-function.
-/
open Real Complex MeasureTheory Set Filter Topology

-- Define the partial sum S_N(t)
def S (N : ℕ) (t : ℝ) : ℂ := ∑ n ∈ Finset.Icc 1 N, (n : ℂ) ^ (-(1 / 2 : ℂ) - I * t)

-- Declare Z and theta
variable (Z : ℝ → ℝ)
variable (theta : ℝ → ℝ)

-- Assumptions
variable (C_afe : ℝ)
variable (h_afe : ∀ T : ℝ, T ≥ 1 →
  let N := ⌊Real.sqrt (T / (2 * Real.pi))⌋₊
  ∀ t ∈ Set.Icc 1 T,
  abs (Z t - 2 * (Complex.exp (I * theta t) * S N t).re) ≤ C_afe * t ^ (-(1/4 : ℝ)))

variable (C_osc : ℝ)
variable (ε_osc : ℝ)
variable (h_osc : ε_osc > 0 ∧ ∀ T : ℝ, T ≥ 1 →
  let N := ⌊Real.sqrt (T / (2 * Real.pi))⌋₊
  abs (∫ t in Set.Icc 1 T, (Complex.exp (2 * I * theta t) * (S N t)^2).re) ≤ C_osc * T ^ (1/2 + ε_osc))

variable (C_S : ℝ)
variable (h_S : ∀ N : ℕ, N ≥ 1 → ∀ t : ℝ, t ≥ 1 → norm (S N t) ≤ C_S * t ^ (1/4 : ℝ))

-- Theorem
theorem approx_functional_eq :
    ∃ k C : ℝ, k > 0 ∧ C > 0 ∧ ∀ᶠ T in atTop,
      let N := ⌊Real.sqrt (T / (2 * Real.pi))⌋₊
      ∫ t in Set.Icc 1 T, (Z t)^2 ≥ k * ∫ t in Set.Icc 1 T, (S N t).normSq - C * T := by
  refine' ⟨ 1, 1, _, _, _ ⟩ <;> norm_num;
  use 1;
  intro b hb;
  refine' le_trans _ ( MeasureTheory.integral_nonneg fun t => sq_nonneg _ );
  refine' MeasureTheory.setIntegral_nonpos measurableSet_Icc fun t ht => _;
  norm_num [ Complex.normSq_eq_norm_sq ];
  refine' le_trans ( pow_le_pow_left₀ ( norm_nonneg _ ) ( norm_sum_le _ _ ) 2 ) _;
  refine' le_trans ( pow_le_pow_left₀ ( Finset.sum_nonneg fun _ _ => by positivity ) ( Finset.sum_le_sum fun i hi => _ ) _ ) _;
  use fun i => 1;
  · norm_num [ Complex.norm_cpow_of_ne_zero, show i ≠ 0 by linarith [ Finset.mem_Icc.mp hi ] ];
    exact le_trans ( Real.rpow_le_rpow_of_exponent_le ( mod_cast Finset.mem_Icc.mp hi |>.1 ) ( show ( - ( 1 / 2 ) ) ≤ 0 by norm_num ) ) ( by norm_num );
  · norm_num;
    exact le_trans ( pow_le_pow_left₀ ( Nat.cast_nonneg _ ) ( Nat.floor_le ( Real.sqrt_nonneg _ ) ) _ ) ( by rw [ Real.sq_sqrt ( by positivity ) ] ; nlinarith [ Real.pi_gt_three, mul_div_cancel₀ b ( by positivity : ( 2 * Real.pi ) ≠ 0 ) ] )

/-
Prove the pointwise lower bound for the square of the Hardy Z-function.
-/
lemma hardy_square_bound (T : ℝ) (hT : T ≥ 1) (t : ℝ) (ht : t ∈ Set.Icc 1 T) :
  let N := ⌊Real.sqrt (T / (2 * Real.pi))⌋₊
  let ReS := (Complex.exp (I * theta t) * S N t).re
  let E := Z t - 2 * ReS
  (Z t)^2 ≥ 4 * ReS^2 - 4 * |ReS| * abs E := by
  cases abs_cases ( ( Complex.exp ( Complex.I * ( theta t ) ) * S ⌊Real.sqrt ( T / ( 2 * Real.pi ) ) ⌋₊ t |> Complex.re ) ) <;> cases abs_cases ( Z t - 2 * ( Complex.exp ( Complex.I * ( theta t ) ) * S ⌊Real.sqrt ( T / ( 2 * Real.pi ) ) ⌋₊ t |> Complex.re ) ) <;> push_cast [ * ] <;> nlinarith [ sq_nonneg ( Z t - 2 * ( Complex.exp ( Complex.I * ( theta t ) ) * S ⌊Real.sqrt ( T / ( 2 * Real.pi ) ) ⌋₊ t |> Complex.re ) ) ]

/-
Prove the algebraic identity relating the square of the real part of a complex number to its norm square and the real part of its square.
-/
lemma complex_square_re_eq (w : ℂ) : 4 * w.re ^ 2 = 2 * w.normSq + 2 * (w ^ 2).re := by
  simpa [ sq, Complex.normSq_apply ] using by ring;

/-
Prove the pointwise identity for the Hardy Z-function components.
-/
lemma hardy_pointwise_identity (t : ℝ) (N : ℕ) :
  4 * ((Complex.exp (I * theta t) * S N t).re)^2 =
  2 * (S N t).normSq + 2 * (Complex.exp (2 * I * theta t) * (S N t)^2).re := by
    norm_num [ Complex.normSq, Complex.exp_re, Complex.exp_im, sq ] ; ring;
    rw [ show theta t * 2 = 2 * theta t by ring, Real.sin_two_mul, Real.cos_two_mul ] ; rw [ Real.sin_sq, Real.cos_sq ] ; ring;

/-
Check the type of hardy_pointwise_identity.
-/
#check hardy_pointwise_identity

/-
Prove the integrability of the terms in the Hardy Z-function expansion.
-/
lemma integrable_S_normSq (T : ℝ) (hT : T ≥ 1) :
  let N := ⌊Real.sqrt (T / (2 * Real.pi))⌋₊
  MeasureTheory.IntegrableOn (fun t => (S N t).normSq) (Set.Icc 1 T) MeasureTheory.volume := by
    refine' Continuous.integrableOn_Icc _;
    refine' Continuous.comp ( Complex.continuous_normSq ) _;
    refine' continuous_finset_sum _ fun i hi => _;
    exact continuous_const.cpow ( by continuity ) ( by intro a; exact Or.inl <| by norm_cast; aesop )

lemma integrable_osc (T : ℝ) (hT : T ≥ 1) (h_theta : Continuous theta) :
  let N := ⌊Real.sqrt (T / (2 * Real.pi))⌋₊
  MeasureTheory.IntegrableOn (fun t => (Complex.exp (2 * I * theta t) * (S N t)^2).re) (Set.Icc 1 T) MeasureTheory.volume := by
    refine' Continuous.integrableOn_Icc _;
    refine' Complex.continuous_re.comp _;
    refine' Continuous.mul _ _;
    · continuity;
    · refine' Continuous.pow _ _;
      refine' continuous_finset_sum _ fun i hi => _;
      norm_num [ Complex.cpow_def ];
      split_ifs <;> continuity

end Aristotle.HardyZIdentities
