/-
Zeta bounds: ‖ζ(s)‖ ≤ Re(s)/(Re(s)-1) for Re(s) > 1,
functional equation ζ(s) = χ(s)ζ(1-s),
sin/sinh bounds, Gamma bounds on imaginary axis.

Generated by Aristotle (Harmonic), integrated with type matching.
UUID: ef4f1b6f-4677-4bbc-b0c0-448ee8026d95

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ZetaBoundsV2

/-
Zeta bound for Re(s) > 1
-/
theorem zeta_bound_re_ge_one (s : ℂ) (hs : s.re > 1) :
    ‖riemannZeta s‖ ≤ s.re / (s.re - 1) := by
  sorry

open Complex Real

/-
Functional equation for Zeta: ζ(s) = χ(s)·ζ(1-s)
-/
noncomputable def chi (s : ℂ) : ℂ := 2^s * π^(s-1) * sin (π*s/2) * Gamma (1-s)

lemma functional_equation (s : ℂ) (h : |s.im| ≥ 1) :
    riemannZeta s = chi s * riemannZeta (1 - s) := by
  sorry

/-
Bound for sine in the critical strip
-/
lemma sin_bound_aux (s : ℂ) (ht : |s.im| ≥ 2) :
    ‖Complex.sin (Real.pi * s / 2)‖ ≤ Real.exp (Real.pi * |s.im| / 2) := by
  have h_sin_def : Complex.sin ((Real.pi * s) / 2) = (Complex.exp (Complex.I * (Real.pi * s) / 2) - Complex.exp (-Complex.I * (Real.pi * s) / 2)) / (2 * Complex.I) := by
    simpa [ div_eq_inv_mul, Complex.sin ] using by ring
  have h_triangle : ‖Complex.exp (Complex.I * (Real.pi * s) / 2) - Complex.exp (-Complex.I * (Real.pi * s) / 2)‖ ≤ ‖Complex.exp (Complex.I * (Real.pi * s) / 2)‖ + ‖Complex.exp (-Complex.I * (Real.pi * s) / 2)‖ :=
    norm_sub_le _ _
  norm_num [ Complex.norm_exp ] at *
  cases abs_cases s.im <;> simp +decide [ * ] at *
  · linarith [ Real.exp_le_exp.mpr ( show - ( Real.pi * s.im ) / 2 ≤ Real.pi * s.im / 2 by nlinarith [ Real.pi_pos ] ) ]
  · linarith [ Real.exp_le_exp.mpr ( show - ( Real.pi * s.im ) / 2 ≥ Real.pi * s.im / 2 by nlinarith [ Real.pi_pos ] ) ]

/-
Lower bound for sinh
-/
lemma sinh_lower_bound (t : ℝ) (ht : |t| ≥ 2) :
    |Real.sinh (Real.pi * t)| ≥ Real.exp (Real.pi * |t|) / 4 := by
  cases abs_cases t <;> simp +decide [ *, Real.sinh_eq ]
  · rw [ abs_of_nonneg ] <;> nlinarith [ Real.pi_gt_three.le, Real.exp_pos ( Real.pi * t ), Real.exp_neg ( Real.pi * t ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * t ) ) ), Real.add_one_le_exp ( Real.pi * t ), Real.add_one_le_exp ( - ( Real.pi * t ) ) ]
  · rw [ abs_div, abs_of_nonneg ( by positivity : ( 0 : ℝ ) ≤ 2 ) ]
    cases abs_cases ( Real.exp ( Real.pi * t ) - Real.exp ( - ( Real.pi * t ) ) ) <;> nlinarith [ Real.pi_gt_three, Real.exp_pos ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_neg ( Real.pi * t ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * t ) ) ), Real.add_one_le_exp ( Real.pi * t ), Real.add_one_le_exp ( - ( Real.pi * t ) ) ]

/-
Relation between Gamma on imaginary axis and 1-it
-/
lemma gamma_abs_imag (t : ℝ) (ht : t ≠ 0) :
    ‖Complex.Gamma (I * t)‖ = ‖Complex.Gamma (1 - I * t)‖ / |t| := by
  have h_gamma_prop : Complex.Gamma (1 + Complex.I * t) = Complex.I * t * Complex.Gamma (Complex.I * t) := by
    rw [ ← Complex.Gamma_add_one ] <;> ring ; norm_num [ ht ]
  have h_gamma_conj : Complex.Gamma (1 - Complex.I * t) = starRingEnd ℂ (Complex.Gamma (1 + Complex.I * t)) := by
    convert Complex.Gamma_conj ( 1 + Complex.I * t ) using 1 ; norm_num
    ring
  simp_all +decide [ Complex.norm_def, Complex.normSq ]

/-
Squared bound for Gamma on imaginary axis
-/
lemma gamma_sq_bound_zero (t : ℝ) (ht : |t| ≥ 2) :
    ‖Complex.Gamma (1 - I * t)‖^2 ≤ 4 * Real.pi * |t| * Real.exp (-Real.pi * |t|) := by
  sorry

/-
Numerical bound for sqrt(4pi)
-/
lemma sqrt_four_pi_lt_ten : Real.sqrt (4 * Real.pi) < 10 := by
  rw [ Real.sqrt_lt' ] <;> linarith [ Real.pi_le_four ]

/-
Simplification of the square root term
-/
lemma sqrt_simplification (t : ℝ) (ht : 0 ≤ t) :
    Real.sqrt (4 * Real.pi * t * Real.exp (-Real.pi * t)) =
    Real.sqrt (4 * Real.pi) * Real.sqrt t * Real.exp (-Real.pi * t / 2) := by
  rw [ Real.sqrt_mul', Real.sqrt_mul' ] <;> first | positivity | rw [ Real.sqrt_eq_rpow, Real.sqrt_eq_rpow, Real.sqrt_eq_rpow, ← Real.exp_mul ] ; ring

end ZetaBoundsV2
