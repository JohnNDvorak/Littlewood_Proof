/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: db2904a6-2113-42f7-862e-cd92fd81751c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace HardyZConjugation

/-
Definition of the Hardy theta function θ(t).
-/
noncomputable def hardyTheta (t : ℝ) : ℝ :=
  - (t / 2) * Real.log Real.pi + (Complex.log (Complex.Gamma (1 / 4 + Complex.I * (t / 2)))).im

/-
Definition of the Hardy Z function Z(t).
-/
noncomputable def hardyZ (t : ℝ) : ℝ :=
  (Complex.exp (Complex.I * (hardyTheta t)) * riemannZeta (1 / 2 + Complex.I * t)).re

/-
Check the definition of completedRiemannZeta.
-/
#print completedRiemannZeta

/-
Check the definitions of HurwitzZeta.evenKernel and HurwitzZeta.cosKernel.
-/
#print HurwitzZeta.evenKernel
#print HurwitzZeta.cosKernel

/-
The even kernel of the Hurwitz zeta function respects complex conjugation with a sign flip in the parameter.
-/
theorem HurwitzZeta_evenKernel_conj (a : UnitAddCircle) (x : ℝ) :
    HurwitzZeta.evenKernel (-a) x = starRingEnd ℂ (HurwitzZeta.evenKernel a x) := by
      rcases a with ⟨ a ⟩ ; aesop;

/-
The cosine kernel of the Hurwitz zeta function respects complex conjugation with a sign flip in the parameter.
-/
theorem HurwitzZeta_cosKernel_conj (a : UnitAddCircle) (x : ℝ) :
    HurwitzZeta.cosKernel (-a) x = starRingEnd ℂ (HurwitzZeta.cosKernel a x) := by
      -- By definition of even kernel, we know that HurwitzZeta.evenKernel (-a) x = starRingEnd ℂ (HurwitzZeta.evenKernel a x).
      have h_evenKernel : HurwitzZeta.evenKernel (-a) x = starRingEnd ℂ (HurwitzZeta.evenKernel a x) := by
        exact_mod_cast HurwitzZeta_evenKernel_conj a x;
      unfold HurwitzZeta.cosKernel at h_evenKernel ; aesop

/-
Check the definition of HurwitzZeta.completedHurwitzZetaEven₀.
-/
#print HurwitzZeta.completedHurwitzZetaEven₀

/-
Check the type of HurwitzZeta.hurwitzEvenFEPair.
-/
#check HurwitzZeta.hurwitzEvenFEPair

/-
Check the definition of WeakFEPair.Λ₀.
-/
#print WeakFEPair.Λ₀

/-
Check the definition of HurwitzZeta.hurwitzEvenFEPair.
-/
#print HurwitzZeta.hurwitzEvenFEPair

/-
The modified function f_modif of the Hurwitz zeta pair respects complex conjugation with a sign flip in the parameter.
-/
theorem HurwitzZeta_f_modif_conj (a : UnitAddCircle) (x : ℝ) :
    (HurwitzZeta.hurwitzEvenFEPair (-a)).f_modif x = starRingEnd ℂ ((HurwitzZeta.hurwitzEvenFEPair a).f_modif x) := by
      unfold WeakFEPair.f_modif HurwitzZeta.hurwitzEvenFEPair;
      simp +zetaDelta at *;
      rw [ Set.indicator_apply, Set.indicator_apply ] ; aesop

/-
The Λ₀ function of the Hurwitz zeta pair respects complex conjugation with a sign flip in the parameter.
-/
theorem HurwitzZeta_Λ₀_conj (a : UnitAddCircle) (s : ℂ) :
    (HurwitzZeta.hurwitzEvenFEPair (-a)).Λ₀ (starRingEnd ℂ s) = starRingEnd ℂ ((HurwitzZeta.hurwitzEvenFEPair a).Λ₀ s) := by
      rw [ WeakFEPair.Λ₀ ]
      have h_Λ₀_def : ∀ (a : UnitAddCircle) (s : ℂ), (HurwitzZeta.hurwitzEvenFEPair a).Λ₀ s = (∫ x in Set.Ioi 0, (HurwitzZeta.hurwitzEvenFEPair a).f_modif x * x ^ (s - 1)) := by
        intro a s; rw [ WeakFEPair.Λ₀ ] ;
        simp only [mellin, smul_eq_mul]; congr 1; ext t; ring
      simp +decide [ h_Λ₀_def, mellin ];
      rw [ ← integral_conj ];
      refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioi fun x hx => _;
      rw [ mul_comm, Complex.cpow_def_of_ne_zero ( Complex.ofReal_ne_zero.mpr hx.out.ne' ), Complex.cpow_def_of_ne_zero ( Complex.ofReal_ne_zero.mpr hx.out.ne' ) ] ; norm_num ; ring;
      rw [ ← HurwitzZeta_f_modif_conj ] ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ] ; ring;
      field_simp;
      norm_num [ Complex.arg_ofReal_of_nonneg hx.out.le ] ; ring ; norm_num

/-
The completed Hurwitz zeta function (zero part) respects complex conjugation with a sign flip in the parameter.
-/
theorem completedHurwitzZetaEven₀_conj (a : UnitAddCircle) (s : ℂ) :
    HurwitzZeta.completedHurwitzZetaEven₀ (-a) (starRingEnd ℂ s) = starRingEnd ℂ (HurwitzZeta.completedHurwitzZetaEven₀ a s) := by
      rw [ HurwitzZeta.completedHurwitzZetaEven₀, HurwitzZeta.completedHurwitzZetaEven₀ ];
      convert congr_arg ( fun x : ℂ => x / 2 ) ( HurwitzZeta_Λ₀_conj ( a ) ( s / 2 ) ) using 1 ; ring;
      · norm_num [ Complex.ext_iff ];
        erw [ Complex.conj_ofReal ] ; norm_num;
      · norm_num [ div_eq_mul_inv ];
        exact Or.inl ( by erw [ Complex.conj_ofReal ] ; norm_num )

/-
The completed Hurwitz zeta function respects complex conjugation with a sign flip in the parameter.
-/
theorem completedHurwitzZetaEven_conj (a : UnitAddCircle) (s : ℂ) :
    HurwitzZeta.completedHurwitzZetaEven (-a) (starRingEnd ℂ s) = starRingEnd ℂ (HurwitzZeta.completedHurwitzZetaEven a s) := by
      convert congr_arg₂ ( fun x y => x - y ) ( completedHurwitzZetaEven₀_conj a s ) _ using 1;
      convert HurwitzZeta.completedHurwitzZetaEven_eq _ _ using 1;
      rw [ sub_sub ];
      convert congr_arg _ ( HurwitzZeta.completedHurwitzZetaEven_eq a s ) using 1;
      rotate_left;
      exact ( if a = 0 then 1 else 0 ) / ( starRingEnd ℂ ) s + 1 / ( 1 - ( starRingEnd ℂ ) s );
      · aesop;
      · norm_num [ sub_sub ]

/-
The completed Riemann zeta function respects complex conjugation.
-/
theorem completedRiemannZeta_conj (s : ℂ) :
    completedRiemannZeta (starRingEnd ℂ s) = starRingEnd ℂ (completedRiemannZeta s) := by
      convert completedHurwitzZetaEven_conj 0 s using 1 ; aesop ( simp_config := { singlePass := true } ) ;

/-
The completed Riemann zeta function is real on the critical line.
-/
theorem completedRiemannZeta_critical_line_real (t : ℝ) :
    (completedRiemannZeta (1 / 2 + Complex.I * t)).im = 0 := by
      -- By the properties of the completed Riemann zeta function, we have `completedRiemannZeta (1 - s) = completedRiemannZeta s`.
      have h_symm : completedRiemannZeta (1 - (1 / 2 + Complex.I * t)) = completedRiemannZeta (1 / 2 + Complex.I * t) := by
        rw [ completedRiemannZeta_one_sub ];
      -- By the properties of the completed Riemann zeta function, we have `completedRiemannZeta (1 - (1 / 2 + Complex.I * t)) = starRingEnd ℂ (completedRiemannZeta (1 / 2 + Complex.I * t))`.
      have h_conj : completedRiemannZeta (1 - (1 / 2 + Complex.I * t)) = starRingEnd ℂ (completedRiemannZeta (1 / 2 + Complex.I * t)) := by
        rw [ show ( 1 - ( 1 / 2 + Complex.I * t ) ) = starRingEnd ℂ ( 1 / 2 + Complex.I * t ) by norm_num [ Complex.ext_iff ] ]
        exact completedRiemannZeta_conj _
      norm_num [ Complex.ext_iff ] at * ; linarith

end HardyZConjugation