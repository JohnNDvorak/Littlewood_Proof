/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 7145b4c5-92ed-4d3a-955f-6908595c8486

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

KEY RESULT:
- trigPoly_zero_iff_coeffs_zero: Linear independence of cos(gamma*t + phase) for distinct gamma > 0
  via orthogonality (multiply by cos, integrate, take T->infinity limit)

This is essential for Schmidt's oscillation lemma!
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators Real Nat Classical Pointwise
open MeasureTheory

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-! ## Auxiliary Integral Lemmas -/

/-- The integral of cos(omega*t + ph) over [0, T] for omega != 0 is bounded by 2/|omega|. -/
lemma integral_cos_bounded (omega : ℝ) (homega : omega ≠ 0) (ph : ℝ) (T : ℝ) (_hT : 0 ≤ T) :
    |∫ t in (0:ℝ)..T, Real.cos (omega * t + ph)| ≤ 2 / |omega| := by
  have h_deriv : ∀ t ∈ Set.uIcc 0 T,
      HasDerivAt (fun t => Real.sin (omega * t + ph) / omega) (Real.cos (omega * t + ph)) t := by
    intro t _
    have h1 : HasDerivAt (fun t => omega * t + ph) omega t := by
      simpa [mul_one] using (hasDerivAt_id t).const_mul omega |>.add_const ph
    convert h1.sin.div_const omega using 1
    field_simp
  have h_int : IntervalIntegrable (fun t => Real.cos (omega * t + ph)) volume 0 T :=
    (Real.continuous_cos.comp
      ((continuous_const.mul continuous_id').add continuous_const)).intervalIntegrable _ _
  rw [intervalIntegral.integral_eq_sub_of_hasDerivAt h_deriv h_int,
      show Real.sin (omega * T + ph) / omega - Real.sin (omega * 0 + ph) / omega =
        (Real.sin (omega * T + ph) - Real.sin (omega * 0 + ph)) / omega from by ring,
      abs_div]
  apply div_le_div_of_nonneg_right _ (abs_pos.mpr homega).le
  have h1 := Real.sin_le_one (omega * T + ph)
  have h2 := Real.neg_one_le_sin (omega * T + ph)
  have h3 := Real.sin_le_one (omega * 0 + ph)
  have h4 := Real.neg_one_le_sin (omega * 0 + ph)
  rw [abs_le]; constructor <;> linarith

/-- Product-to-sum: cos(a) * cos(b) = (1/2)(cos(a - b) + cos(a + b)). -/
lemma cos_mul_cos_eq (a b : ℝ) :
    Real.cos a * Real.cos b = (1/2) * (Real.cos (a - b) + Real.cos (a + b)) := by
  rw [Real.cos_sub, Real.cos_add]; ring

/-! ## Main Theorem: Linear Independence of Trigonometric Functions -/

/-- A trigonometric polynomial with positive frequencies is identically zero
    iff all its coefficients are zero. -/
lemma trigPoly_zero_iff_coeffs_zero (gammas : Finset ℝ) (hgammas : ∀ g ∈ gammas, g > 0)
    (c : ℝ → ℝ) (phase : ℝ → ℝ) :
    (∀ t : ℝ, ∑ g ∈ gammas, c g * Real.cos (g * t + phase g) = 0) ↔ (∀ g ∈ gammas, c g = 0) := by
  constructor
  · -- Forward: zero function implies zero coefficients
    intro h_zero g hg
    have hcos_cont : ∀ (a b : ℝ), Continuous (fun t => Real.cos (a * t + b)) :=
      fun a b => Real.continuous_cos.comp ((continuous_const.mul continuous_id').add continuous_const)
    have h_integral_zero : ∀ T : ℝ, 0 < T →
        ∑ g' ∈ gammas, c g' * ∫ t in (0:ℝ)..T,
          Real.cos (g' * t + phase g') * Real.cos (g * t + phase g) = 0 := by
      intro T hT
      have hci : ∀ g' ∈ gammas, IntervalIntegrable
          (fun t => c g' * (Real.cos (g' * t + phase g') * Real.cos (g * t + phase g))) volume 0 T :=
        fun g' _ => ((hcos_cont g' (phase g')).mul (hcos_cont g (phase g))).intervalIntegrable 0 T
          |>.const_mul _
      simp_rw [← intervalIntegral.integral_const_mul]
      rw [← intervalIntegral.integral_finset_sum hci]
      have step : ∀ t, ∑ g' ∈ gammas,
          c g' * (Real.cos (g' * t + phase g') * Real.cos (g * t + phase g)) =
          (∑ g' ∈ gammas, c g' * Real.cos (g' * t + phase g')) * Real.cos (g * t + phase g) := by
        intro t
        simp_rw [show ∀ (g' : ℝ),
            c g' * (Real.cos (g' * t + phase g') * Real.cos (g * t + phase g)) =
            (c g' * Real.cos (g' * t + phase g')) * Real.cos (g * t + phase g) from
          fun g' => by ring]
        rw [← Finset.sum_mul]
      simp_rw [step, h_zero, zero_mul, intervalIntegral.integral_zero]
    by_contra hc_ne
    have hg_pos : g > 0 := hgammas g hg
    -- Diagonal bound via FTC
    have h_diag_lower : ∀ T : ℝ, 0 < T →
        |c g * (∫ t in (0:ℝ)..T, Real.cos (g * t + phase g) * Real.cos (g * t + phase g)) -
         c g * T / 2| ≤ |c g| / (2 * g) := by
      intro T hT
      -- Antiderivative of cos²(gt+ph) is t/2 + sin(2gt+2ph)/(4g)
      have h_anti : ∀ t ∈ Set.uIcc 0 T,
          HasDerivAt (fun t => t / 2 + Real.sin (2 * g * t + 2 * phase g) / (4 * g))
            (Real.cos (g * t + phase g) * Real.cos (g * t + phase g)) t := by
        intro t _
        have hd1 : HasDerivAt (fun t => t / 2) (1 / 2 : ℝ) t := by
          simpa using (hasDerivAt_id t).div_const 2
        have hd_inner : HasDerivAt (fun t => 2 * g * t + 2 * phase g) (2 * g) t := by
          simpa [mul_one] using (hasDerivAt_id t).const_mul (2 * g) |>.add_const (2 * phase g)
        have hd2 : HasDerivAt (fun t => Real.sin (2 * g * t + 2 * phase g) / (4 * g))
            (Real.cos (2 * g * t + 2 * phase g) * (2 * g) / (4 * g)) t :=
          hd_inner.sin.div_const (4 * g)
        convert hd1.add hd2 using 1
        -- cos²(x) = 1/2 + cos(2x)/2, and cos(2x)*(2g)/(4g) = cos(2x)/2
        have h := Real.cos_sq (g * t + phase g)
        have h2g : 2 * (g * t + phase g) = 2 * g * t + 2 * phase g := by ring
        rw [h2g] at h
        have hsimp : Real.cos (2 * g * t + 2 * phase g) * (2 * g) / (4 * g) =
            Real.cos (2 * g * t + 2 * phase g) / 2 := by
          field_simp; ring
        rw [hsimp]
        nlinarith [sq (Real.cos (g * t + phase g))]
      have h_int : IntervalIntegrable
          (fun t => Real.cos (g * t + phase g) * Real.cos (g * t + phase g)) volume 0 T :=
        ((hcos_cont g (phase g)).mul (hcos_cont g (phase g))).intervalIntegrable 0 T
      -- Compute the integral via FTC
      set I := ∫ t in (0:ℝ)..T, Real.cos (g * t + phase g) *
          Real.cos (g * t + phase g) with hI_def
      have h_val : I = (T / 2 + Real.sin (2 * g * T + 2 * phase g) / (4 * g)) -
          (0 / 2 + Real.sin (2 * g * 0 + 2 * phase g) / (4 * g)) := by
        rw [hI_def]
        exact intervalIntegral.integral_eq_sub_of_hasDerivAt h_anti h_int
      -- Simplify: c g * I - c g * T/2 = c g * (sin(2gT+2ph) - sin(2ph)) / (4g)
      rw [h_val, show c g * ((T / 2 + Real.sin (2 * g * T + 2 * phase g) / (4 * g)) -
          (0 / 2 + Real.sin (2 * g * 0 + 2 * phase g) / (4 * g))) - c g * T / 2 =
          c g * (Real.sin (2 * g * T + 2 * phase g) -
            Real.sin (2 * g * 0 + 2 * phase g)) / (4 * g) from by ring,
          abs_div, abs_mul, abs_of_pos (by positivity : (0:ℝ) < 4 * g)]
      have h_sin_bound :
          |Real.sin (2 * g * T + 2 * phase g) - Real.sin (2 * g * 0 + 2 * phase g)| ≤ 2 := by
        have h1 := Real.sin_le_one (2 * g * T + 2 * phase g)
        have h2 := Real.neg_one_le_sin (2 * g * T + 2 * phase g)
        have h3 := Real.sin_le_one (2 * g * 0 + 2 * phase g)
        have h4 := Real.neg_one_le_sin (2 * g * 0 + 2 * phase g)
        rw [abs_le]; constructor <;> linarith
      calc |c g| * |Real.sin (2 * g * T + 2 * phase g) -
              Real.sin (2 * g * 0 + 2 * phase g)| / (4 * g)
          ≤ |c g| * 2 / (4 * g) := by gcongr
        _ = |c g| / (2 * g) := by ring
    -- Off-diagonal bound
    have h_offdiag_bound : ∀ g' ∈ gammas, g' ≠ g →
        ∀ T : ℝ, 0 < T →
        |∫ t in (0:ℝ)..T, Real.cos (g' * t + phase g') * Real.cos (g * t + phase g)| ≤
          1 / |g' - g| + 1 / |g' + g| := by
      intro g' hg'mem hne T hT
      have h_diff_ne : g' - g ≠ 0 := sub_ne_zero.mpr hne
      have h_sum_pos : 0 < g' + g := by linarith [hgammas g' hg'mem]
      have h_prod_eq : ∀ t : ℝ,
          Real.cos (g' * t + phase g') * Real.cos (g * t + phase g) =
          (1/2) * Real.cos ((g' - g) * t + (phase g' - phase g)) +
          (1/2) * Real.cos ((g' + g) * t + (phase g' + phase g)) := by
        intro t; rw [cos_mul_cos_eq]; congr 1 <;> ring
      simp_rw [h_prod_eq]
      rw [intervalIntegral.integral_add
            ((hcos_cont (g' - g) (phase g' - phase g)).intervalIntegrable 0 T |>.const_mul _)
            ((hcos_cont (g' + g) (phase g' + phase g)).intervalIntegrable 0 T |>.const_mul _),
          intervalIntegral.integral_const_mul, intervalIntegral.integral_const_mul]
      calc |(1 / 2 * ∫ t in (0:ℝ)..T, Real.cos ((g' - g) * t + (phase g' - phase g))) +
              (1 / 2 * ∫ t in (0:ℝ)..T, Real.cos ((g' + g) * t + (phase g' + phase g)))|
          ≤ |1 / 2 * ∫ t in (0:ℝ)..T, Real.cos ((g' - g) * t + (phase g' - phase g))| +
            |1 / 2 * ∫ t in (0:ℝ)..T, Real.cos ((g' + g) * t + (phase g' + phase g))| :=
              abs_add_le _ _
        _ ≤ (1/2) * (2 / |g' - g|) + (1/2) * (2 / |g' + g|) := by
              gcongr
              · rw [abs_mul, abs_of_nonneg (by norm_num : (0:ℝ) ≤ 1/2)]
                gcongr
                exact integral_cos_bounded _ h_diff_ne _ T hT.le
              · rw [abs_mul, abs_of_nonneg (by norm_num : (0:ℝ) ≤ 1/2)]
                gcongr
                exact integral_cos_bounded _ (ne_of_gt h_sum_pos) _ T hT.le
        _ = 1 / |g' - g| + 1 / |g' + g| := by ring
    -- For large T, diagonal term dominates
    set B := ∑ g' ∈ gammas.erase g, |c g'| * (1 / |g' - g| + 1 / |g' + g|) with hB_def
    have hc_pos : 0 < |c g| := abs_pos.mpr hc_ne
    set T₀ := 2 * (B + |c g| / (2 * g) + 1) / |c g| + 1 with hT₀_def
    have hT₀_pos : 0 < T₀ := by positivity
    have h_sum_zero := h_integral_zero T₀ hT₀_pos
    rw [← Finset.add_sum_erase _ _ hg] at h_sum_zero
    -- h_sum_zero now has (c g * ∫ ...) + ∑ offdiag = 0
    -- Abstract the diagonal integral (after splitting so the term is exposed)
    set D := c g * (∫ t in (0:ℝ)..T₀, Real.cos (g * t + phase g) *
        Real.cos (g * t + phase g)) with hD_def
    have h_diag : |D - c g * T₀ / 2| ≤ |c g| / (2 * g) := h_diag_lower T₀ hT₀_pos
    have h_bound_offdiag : |∑ g' ∈ gammas.erase g, c g' *
        (∫ t in (0:ℝ)..T₀, Real.cos (g' * t + phase g') * Real.cos (g * t + phase g))| ≤ B := by
      calc |∑ g' ∈ gammas.erase g, c g' *
              (∫ t in (0:ℝ)..T₀, Real.cos (g' * t + phase g') * Real.cos (g * t + phase g))|
          ≤ ∑ g' ∈ gammas.erase g, |c g' *
              (∫ t in (0:ℝ)..T₀, Real.cos (g' * t + phase g') * Real.cos (g * t + phase g))| :=
            Finset.abs_sum_le_sum_abs _ _
        _ ≤ ∑ g' ∈ gammas.erase g, |c g'| * (1 / |g' - g| + 1 / |g' + g|) := by
            gcongr with g' hg'
            rw [abs_mul]
            gcongr
            exact h_offdiag_bound g' (Finset.mem_of_mem_erase hg') (Finset.ne_of_mem_erase hg') T₀ hT₀_pos
    have h_diag_eq : D =
        -(∑ g' ∈ gammas.erase g, c g' *
          (∫ t in (0:ℝ)..T₀, Real.cos (g' * t + phase g') * Real.cos (g * t + phase g))) := by
      linarith
    have h_diag_bound : |D| ≤ B := by
      rw [h_diag_eq, abs_neg]; exact h_bound_offdiag
    -- Triangle: |c_g*T₀/2| ≤ |D| + |D - c_g*T₀/2| ≤ B + |c_g|/(2g)
    have h_main : |c g * T₀ / 2| ≤ B + |c g| / (2 * g) := by
      have key : c g * T₀ / 2 = D - (D - c g * T₀ / 2) := (sub_sub_cancel D _).symm
      rw [key, sub_eq_add_neg]
      exact (abs_add_le D _).trans (by rw [abs_neg]; exact add_le_add h_diag_bound h_diag)
    have h_contra : B + |c g| / (2 * g) < |c g| * T₀ / 2 := by
      rw [hT₀_def]
      have : |c g| * ((2 * (B + |c g| / (2 * g) + 1) / |c g| + 1) / 2) =
          B + |c g| / (2 * g) + 1 + |c g| / 2 := by field_simp
      linarith
    have h_abs_eq : |c g * T₀ / 2| = |c g| * T₀ / 2 := by
      rw [show c g * T₀ / 2 = c g * (T₀ / 2) from by ring, abs_mul,
          abs_of_pos (by positivity : (0:ℝ) < T₀ / 2)]
      ring
    linarith
  · -- Backward: zero coefficients implies zero function
    intro h_zero t
    apply Finset.sum_eq_zero
    intro g hg
    rw [h_zero g hg, zero_mul]

end
