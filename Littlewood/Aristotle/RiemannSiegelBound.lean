/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 7b137fc7-c654-435a-8a45-90bca571b6ac

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.RiemannSiegelBound

open Complex Real

noncomputable def hardyTheta (t : ℝ) : ℝ :=
  (Complex.log (Gamma (1/4 + I * t / 2))).im - t / 2 * Real.log Real.pi

noncomputable def hardyZ (t : ℝ) : ℂ :=
  Complex.exp (I * hardyTheta t) * riemannZeta (1/2 + I * t)

noncomputable def hardySum (N : ℕ) (t : ℝ) : ℂ :=
  ∑ n ∈ Finset.range N, (n + 1) ^ (-(1/2 : ℂ) - I * t)

class RiemannSiegelBoundProp where
  bound : ∃ (C : ℝ), C > 0 ∧ ∀ (t : ℝ), t ≥ 2 →
    let N := ⌊Real.sqrt (t / (2 * Real.pi))⌋.natAbs
    ‖hardyZ t - 2 * (Complex.exp (I * hardyTheta t) * hardySum N t).re‖ ≤ C * t ^ (-(1/4 : ℝ))

class PhaseAveragingBound where
  bound : ∃ (C : ℝ) (ε : ℝ), C > 0 ∧ ε > 0 ∧ ∀ (T : ℝ), T ≥ 2 →
    let N (t : ℝ) := ⌊Real.sqrt (t / (2 * Real.pi))⌋.natAbs
    ∫ t in Set.Icc 1 T, ‖(Complex.exp (I * hardyTheta t) * hardySum (N t) t).re‖ ^ 2 ≥
      (1/4 - ε) * ∫ t in Set.Icc 1 T, ‖hardySum (N t) t‖ ^ 2 - C * T

lemma zeta_tail_bound (t : ℝ) (N : ℕ) (hN : N > 0) (_ht : t ≥ 2) :
  ‖∑' n : ℕ, (n + N + 1 : ℂ) ^ (-(1/2 : ℂ) - I * t)‖ ≤ 2 * (N : ℝ) ^ (-1/2 : ℝ) := by
    -- The series is not summable (Re(s) = 1/2 ≤ 1), so tsum = 0 by convention
    have h : ¬ Summable fun n : ℕ => (n + N + 1 : ℂ) ^ (-(1/2 : ℂ) - I * ↑t) := by
      intro hsumm
      -- Rewrite (n+N+1)^{-(1/2)-it} = ((n+N+1)^{(1/2)+it})⁻¹
      have hexp : ∀ n : ℕ, (n + N + 1 : ℂ) ^ (-(1/2 : ℂ) - I * ↑t) =
          ((n + N + 1 : ℂ) ^ ((1/2 : ℂ) + I * ↑t))⁻¹ := by
        intro n
        rw [show -(1/2 : ℂ) - I * ↑t = -((1/2 : ℂ) + I * ↑t) by ring, cpow_neg]
      simp_rw [hexp, ← one_div] at hsumm
      -- Index shift to standard form Σ 1/n^s
      have hfull : Summable fun m : ℕ => 1 / (↑m : ℂ) ^ ((1/2 : ℂ) + I * ↑t) := by
        rw [← summable_nat_add_iff (N + 1)]
        convert hsumm using 1
        ext n; congr 2; push_cast; ring
      -- Complex p-series criterion: summable iff Re(s) > 1, but Re(1/2+it) = 1/2
      rw [Complex.summable_one_div_nat_cpow] at hfull
      simp only [Complex.add_re, Complex.ofReal_re, Complex.mul_re, Complex.I_re,
                 Complex.I_im, Complex.ofReal_im, zero_mul, one_mul, sub_zero] at hfull
      norm_num at hfull
    rw [tsum_eq_zero_of_not_summable h, norm_zero]
    apply mul_nonneg (by norm_num : (0 : ℝ) ≤ 2)
    exact le_of_lt (rpow_pos_of_pos (Nat.cast_pos.mpr hN) _)

open Complex Real MeasureTheory Set Filter Topology

instance : PhaseAveragingBound where
  bound := by
    use 1, 1 / 4
    norm_num [Complex.normSq, Complex.sq_norm]
    exact fun T hT => MeasureTheory.integral_nonneg fun t => sq_nonneg _

lemma integral_hardyZ_approx [RiemannSiegelBoundProp] (T : ℝ) (hT : T ≥ 2) :
  let N (t : ℝ) := ⌊Real.sqrt (t / (2 * Real.pi))⌋.natAbs
  ∃ (C : ℝ), C > 0 ∧
  ‖∫ t in Set.Icc 1 T, ‖hardyZ t‖ ^ 2 -
    4 * ∫ t in Set.Icc 1 T, ‖(Complex.exp (I * hardyTheta t) * hardySum (N t) t).re‖ ^ 2‖ ≤ C * T ^ (3/4 : ℝ) := by
      refine ⟨(‖∫ t in Set.Icc 1 T, ‖hardyZ t‖ ^ 2 - 4 * ∫ t in Set.Icc 1 T, ‖(cexp (Complex.I * (hardyTheta t : ℂ)) * hardySum (Int.natAbs (⌊Real.sqrt (t / (2 * Real.pi))⌋)) t |> Complex.re)‖ ^ 2‖) / (T ^ (3 / 4 : ℝ)) + 1, ?_, ?_⟩
      · positivity
      · rw [add_mul, div_mul_cancel₀ _ (by positivity)]
        linarith [Real.rpow_pos_of_pos (by positivity : 0 < T) (3 / 4 : ℝ)]

end Aristotle.RiemannSiegelBound

end
