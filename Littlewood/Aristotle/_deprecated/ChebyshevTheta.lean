/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2d05fd2c-23a1-4619-b324-a4542d1a4b59

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of Chebyshev's psi function: psi(x) = sum_{n <= x} Lambda(n)
-/
open Nat Real BigOperators ArithmeticFunction Set MeasureTheory Interval

def psi (x : ℝ) : ℝ := ∑ n ∈ Finset.range (Nat.floor x + 1), vonMangoldt n

/-
Definition of Chebyshev's theta function: theta(x) = sum_{p <= x} log p
-/
def theta (x : ℝ) : ℝ := ∑ p ∈ (Finset.range (Nat.floor x + 1)).filter Nat.Prime, Real.log p

/-
Definition of the prime counting function for real arguments: pi(x) = pi(floor(x))
-/
def pi_real (x : ℝ) : ℝ := Nat.primeCounting (Nat.floor x)

/-
Definition of the logarithmic integral function: li(x) = integral from 2 to x of 1/log(t)
-/
noncomputable def li (x : ℝ) : ℝ := ∫ t in (2)..x, 1 / Real.log t

/-
sum_{i <= n} Lambda(i) = sum_{p <= n} floor(log_p n) * log p
-/
theorem sum_vonMangoldt_eq_sum_prime_powers_nat (n : ℕ) :
  ∑ i ∈ Finset.range (n + 1), vonMangoldt i = ∑ p ∈ (Finset.range (n + 1)).filter Nat.Prime, (Nat.log p n) * Real.log p := by
    -- Von Mangoldt sum equals sum over primes of log p times multiplicity
    sorry

/-
psi(n) = sum_{k=1}^{log_2 n} theta(n^{1/k})
-/
theorem psi_nat_eq_sum_theta_nat (n : ℕ) (hn : n ≥ 2) :
  psi n = ∑ k ∈ Finset.Icc 1 (Nat.log 2 n), theta (n ^ (1 / (k : ℝ))) := by
    -- psi equals sum of theta over k-th roots
    sorry

/-
psi(x) = psi(floor(x))
-/
theorem psi_eq_psi_floor (x : ℝ) : psi x = psi (Nat.floor x) := by
  unfold psi;
  norm_num [ Nat.floor_natCast ]

/-
n <= x^{1/k} iff n^k <= x
-/
theorem le_rpow_iff_pow_le (n k : ℕ) (x : ℝ) (hk : k ≥ 1) (hn : n ≥ 1) (hx : x ≥ 0) :
  (n : ℝ) ≤ x ^ (1 / (k : ℝ)) ↔ (n : ℝ) ^ k ≤ x := by
    exact ⟨ fun h => le_trans ( pow_le_pow_left₀ ( by positivity ) h _ ) ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul hx, one_div_mul_cancel ( by positivity ), Real.rpow_one ] ), fun h => le_trans ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ), mul_one_div_cancel ( by positivity ), Real.rpow_one ] ) ( Real.rpow_le_rpow ( by positivity ) h ( by positivity ) ) ⟩

/-
m <= x iff m <= floor(x) for natural number m and non-negative x
-/
theorem nat_le_iff_le_floor (m : ℕ) (x : ℝ) (hx : x ≥ 0) : (m : ℝ) ≤ x ↔ m ≤ Nat.floor x := by
  rw [ Nat.le_floor_iff hx ]

/-
n <= x^{1/k} iff n <= floor(x)^{1/k}
-/
theorem le_rpow_iff_le_floor_rpow (n k : ℕ) (x : ℝ) (hk : k ≥ 1) (hn : n ≥ 1) (hx : x ≥ 0) :
  (n : ℝ) ≤ x ^ (1 / (k : ℝ)) ↔ (n : ℝ) ≤ (Nat.floor x) ^ (1 / (k : ℝ)) := by
    constructor <;> intro h <;> contrapose! h;
    · -- Since $k \geq 1$ and $n \geq 1$, we can raise both sides of $h$ to the power of $k$ to get $\lfloor x \rfloor < n^k$.
      have h_floor : (Nat.floor x : ℝ) < n^k := by
        exact lt_of_le_of_lt ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( Nat.cast_nonneg _ ), one_div_mul_cancel ( by positivity ), Real.rpow_one ] ) ( pow_lt_pow_left₀ h ( by positivity ) ( by positivity ) );
      exact lt_of_lt_of_le ( Real.rpow_lt_rpow ( by positivity ) ( show x < ( n : ℝ ) ^ k by exact lt_of_lt_of_le ( Nat.lt_floor_add_one x ) ( mod_cast h_floor ) ) ( by positivity ) ) ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ), mul_one_div_cancel ( by positivity ), Real.rpow_one ] );
    · exact lt_of_le_of_lt ( Real.rpow_le_rpow ( Nat.cast_nonneg _ ) ( Nat.floor_le hx ) ( by positivity ) ) h

/-
p in range(floor(x^{1/k})) iff p in range(floor(floor(x)^{1/k})) for prime p
-/
theorem mem_range_floor_rpow_iff (p k : ℕ) (x : ℝ) (hk : k ≥ 1) (hp : Nat.Prime p) (hx : x ≥ 0) :
  p ∈ Finset.range (Nat.floor (x ^ (1 / (k : ℝ))) + 1) ↔ p ∈ Finset.range (Nat.floor ((Nat.floor x : ℝ) ^ (1 / (k : ℝ))) + 1) := by
    -- We'll use that $p \leq x^{1/k}$ if and only if $p \leq \lfloor x \rfloor^{1/k}$.
    have h_le : (p : ℝ) ≤ x ^ (1 / (k : ℝ)) ↔ (p : ℝ) ≤ (Nat.floor x : ℝ) ^ (1 / (k : ℝ)) := by
      convert le_rpow_iff_le_floor_rpow p k x hk hp.pos hx using 1;
    convert h_le using 1 <;> norm_num [ Nat.lt_succ_iff ];
    · rw [ Nat.le_floor_iff ( by positivity ) ];
    · rw [ Nat.le_floor_iff ( by positivity ) ]

/-
The set of primes <= x^{1/k} is the same as the set of primes <= floor(x)^{1/k} for x >= 0
-/
theorem filter_prime_le_rpow_eq_filter_prime_le_floor_rpow (x : ℝ) (k : ℕ) (hk : k ≥ 1) (hx : x ≥ 0) :
  (Finset.range (Nat.floor (x ^ (1 / (k : ℝ))) + 1)).filter Nat.Prime =
  (Finset.range (Nat.floor ((Nat.floor x : ℝ) ^ (1 / (k : ℝ))) + 1)).filter Nat.Prime := by
    ext p
    simp [Finset.mem_filter, Finset.mem_range];
    intro hp
    apply Iff.intro;
    · convert mem_range_floor_rpow_iff p k x hk hp hx |> fun h => h.mp using 1;
      · norm_num [ Nat.lt_succ_iff ];
      · norm_num;
    · gcongr;
      exact Nat.floor_le hx

/-
The set of primes <= x^{1/k} is the same as the set of primes <= floor(x)^{1/k} for x >= 0
-/
theorem filter_prime_le_rpow_eq_filter_prime_le_floor_rpow' (x : ℝ) (k : ℕ) (hk : k ≥ 1) (hx : x ≥ 0) :
  (Finset.range (Nat.floor (x ^ (1 / (k : ℝ))) + 1)).filter Nat.Prime =
  (Finset.range (Nat.floor ((Nat.floor x : ℝ) ^ (1 / (k : ℝ))) + 1)).filter Nat.Prime := by
    convert filter_prime_le_rpow_eq_filter_prime_le_floor_rpow x k hk hx using 2

/-
theta(x^{1/k}) = theta(floor(x)^{1/k}) for x >= 0
-/
theorem theta_rpow_eq_theta_floor_rpow' (x : ℝ) (k : ℕ) (hk : k ≥ 1) (hx : x ≥ 0) :
  theta (x ^ (1 / (k : ℝ))) = theta ((Nat.floor x) ^ (1 / (k : ℝ))) := by
    convert congr_arg _ ( filter_prime_le_rpow_eq_filter_prime_le_floor_rpow' x k hk hx ) using 1;
    any_goals exact fun s => ∑ p ∈ s, Real.log p;
    · exact?;
    · exact?

/-
floor(log_2 x) = Nat.log 2 (floor x) for x >= 1
-/
theorem floor_logb_eq_nat_log_floor (x : ℝ) (hx : x ≥ 1) :
  Nat.floor (Real.logb 2 x) = Nat.log 2 (Nat.floor x) := by
    rw [ Nat.floor_eq_iff, Real.le_logb_iff_rpow_le, Real.logb_lt_iff_lt_rpow ] <;> norm_cast;
    · exact ⟨ le_trans ( mod_cast Nat.pow_log_le_self 2 <| Nat.ne_of_gt <| Nat.floor_pos.2 hx ) <| Nat.floor_le <| by positivity, lt_of_lt_of_le ( Nat.lt_floor_add_one x ) <| mod_cast Nat.lt_pow_succ_log_self ( by norm_num ) _ ⟩;
    · linarith;
    · linarith;
    · exact Real.logb_nonneg ( by norm_num ) hx

/-
psi(x) = sum_{k} theta(x^{1/k})
-/
theorem psi_eq_sum_theta (x : ℝ) (hx : x ≥ 2) :
  psi x = ∑ k ∈ Finset.Icc 1 (Nat.floor (Real.logb 2 x)), theta (x ^ (1 / (k : ℝ))) := by
    -- Applying the definitions of `psi` and `theta` and using the equivalence between `theta` and the sum of `theta` over primes up to `x`.
    have h_psi_def : psi x = ∑ k ∈ Finset.Icc 1 (Nat.log 2 (Nat.floor x)), theta (Nat.floor x ^ (1 / k : ℝ)) := by
      convert psi_nat_eq_sum_theta_nat ( Nat.floor x ) _ using 1;
      · exact?;
      · exact Nat.le_floor <| mod_cast hx;
    convert h_psi_def using 2;
    · rw [ floor_logb_eq_nat_log_floor ];
      linarith;
    · apply_rules [ theta_rpow_eq_theta_floor_rpow' ] ; norm_num;
      · linarith [ Finset.mem_Icc.mp ‹_› ];
      · linarith

/-
theta(x) <= x * log x for x >= 1
-/
theorem theta_le_x_log_x (x : ℝ) (hx : x ≥ 1) : theta x ≤ x * Real.log x := by
  have h_theta_bound : theta x ≤ (Nat.primeCounting (Nat.floor x)) * Real.log x := by
    have h_sum_le : ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor x + 1)), Real.log p ≤ (Finset.card (Finset.filter Nat.Prime (Finset.range (Nat.floor x + 1)))) * Real.log x := by
      exact le_trans ( Finset.sum_le_sum fun p hp => Real.log_le_log ( Nat.cast_pos.mpr <| Nat.Prime.pos <| Finset.mem_filter.mp hp |>.2 ) <| Nat.floor_le ( by positivity ) |> le_trans ( Nat.cast_le.mpr <| Finset.mem_range_succ_iff.mp <| Finset.mem_filter.mp hp |>.1 ) ) <| by norm_num;
    convert h_sum_le using 2;
    rw [ Nat.primeCounting ];
    rw [ Nat.primeCounting', Nat.count_eq_card_filter_range ];
  -- Since $\pi(x)$ is the number of primes less than or equal to $x$, we have $\pi(x) \leq x$.
  have h_pi_bound : (Nat.primeCounting (Nat.floor x)) ≤ (Nat.floor x) := by
    rw [ Nat.primeCounting ];
    rw [ Nat.primeCounting', Nat.count_eq_card_filter_range ];
    exact le_trans ( Finset.card_le_card ( show Finset.filter ( fun x => Nat.Prime x ) ( Finset.range ( ⌊x⌋₊ + 1 ) ) ⊆ Finset.Ico 2 ( ⌊x⌋₊ + 1 ) from fun p hp => Finset.mem_Ico.mpr ⟨ Nat.Prime.two_le ( Finset.mem_filter.mp hp |>.2 ), Finset.mem_range.mp ( Finset.mem_filter.mp hp |>.1 ) ⟩ ) ) ( by simp +arith +decide );
  exact h_theta_bound.trans ( mul_le_mul_of_nonneg_right ( Nat.cast_le.mpr h_pi_bound |> le_trans <| Nat.floor_le <| by positivity ) <| Real.log_nonneg hx )

/-
The product of primes in (n, 2n] divides binom(2n, n)
-/
theorem prod_primes_dvd_choose (n : ℕ) (hn : n ≥ 1) :
  (∏ p ∈ (Finset.range (2 * n + 1)).filter (fun p => n < p ∧ Nat.Prime p), p) ∣ Nat.choose (2 * n) n := by
    -- Each prime $p$ in the range $(n, 2n]$ divides $\binom{2n}{n}$ by definition of binomial coefficients.
    have h_prime_div : ∀ p ∈ Finset.filter (fun p => n < p ∧ Nat.Prime p) (Finset.range (2 * n + 1)), p ∣ Nat.choose (2 * n) n := by
      intro p hp;
      apply_mod_cast Nat.Prime.dvd_choose ; aesop;
      · aesop;
      · rw [ two_mul, add_tsub_cancel_left ] ; aesop;
      · grind;
    -- Since the primes in the range (n, 2n] are distinct, their product divides the binomial coefficient.
    have h_distinct_primes : ∀ {S : Finset ℕ}, (∀ p ∈ S, Nat.Prime p) → (∀ p ∈ S, p ∣ Nat.choose (2 * n) n) → (∏ p ∈ S, p) ∣ Nat.choose (2 * n) n := by
      intros S hS_prime hS_div
      induction' S using Finset.induction with p S hS ih;
      · norm_num;
      · rw [ Finset.prod_insert hS ];
        exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( Nat.Coprime.prod_right fun q hq => by have := Nat.coprime_primes ( hS_prime p ( Finset.mem_insert_self p S ) ) ( hS_prime q ( Finset.mem_insert_of_mem hq ) ) ; aesop ) ( hS_div p ( Finset.mem_insert_self p S ) ) ( ih ( fun q hq => hS_prime q ( Finset.mem_insert_of_mem hq ) ) ( fun q hq => hS_div q ( Finset.mem_insert_of_mem hq ) ) );
    exact h_distinct_primes ( fun p hp => by aesop ) h_prime_div

/-
theta(2n) - theta(n) <= log binom(2n, n)
-/
theorem theta_diff_le_log_choose (n : ℕ) (hn : n ≥ 1) :
  theta (2 * n) - theta n ≤ Real.log (Nat.choose (2 * n) n) := by
    -- Chebyshev's argument: product of primes in (n,2n] divides binom(2n,n)
    sorry

/-
theta(n) <= C * n for natural numbers n
-/
theorem theta_le_linear_nat : ∃ C > 0, ∀ n : ℕ, n ≥ 1 → theta n ≤ C * n := by
  use 4 * Real.log 4;
  -- We have theta(2k) - theta(k) <= k * log 4 for all k >= 1.
  have h_diff : ∀ k : ℕ, k ≥ 1 → theta (2 * k) - theta k ≤ k * Real.log 4 := by
    -- By the properties of logarithms, we know that $\log \binom{2n}{n} \leq n \log 4$.
    have h_log_choose_le : ∀ n : ℕ, n ≥ 1 → Real.log (Nat.choose (2 * n) n) ≤ n * Real.log 4 := by
      intro n hn
      have h_binom_le : (Nat.choose (2 * n) n : ℝ) ≤ 4 ^ n := by
        rw_mod_cast [ show 4 ^ n = ( 2 ^ n ) ^ 2 by rw [ pow_right_comm ] ; norm_num ];
        rw [ ← pow_mul' ];
        rw [ ← Nat.sum_range_choose ] ; exact Finset.single_le_sum ( fun x _ => Nat.zero_le _ ) ( Finset.mem_range.mpr ( by linarith ) );
      simpa using Real.log_le_log ( Nat.cast_pos.mpr <| Nat.choose_pos <| by linarith ) h_binom_le;
    exact fun n hn => le_trans ( theta_diff_le_log_choose n hn ) ( h_log_choose_le n hn );
  refine' ⟨ by positivity, fun n hn => _ ⟩;
  induction' n using Nat.strong_induction_on with n ih;
  rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> norm_num at *;
  · exact le_trans ( h_diff k ( by linarith ) ) ( by nlinarith [ ih k ( by linarith ) ( by linarith ), Real.log_nonneg ( show ( 4 : ℝ ) ≥ 1 by norm_num ) ] );
  · -- For the odd case, we use the fact that $\theta(2k+1) \leq \theta(2k+2)$.
    have h_odd : theta (2 * k + 1) ≤ theta (2 * k + 2) := by
      unfold theta;
      norm_cast;
      erw [ Nat.floor_natCast, Nat.floor_natCast ] ; exact Finset.sum_le_sum_of_subset_of_nonneg ( Finset.filter_subset_filter _ <| Finset.range_mono <| by linarith ) fun _ _ _ => Real.log_nonneg <| Nat.one_le_cast.2 <| Nat.Prime.pos <| by aesop;
    have := h_diff ( k + 1 ) ; norm_num [ mul_add ] at *;
    rcases k with ( _ | k ) <;> norm_num at *;
    · norm_num [ Finset.sum_filter, Finset.sum_range_succ, theta ] at *;
      positivity;
    · have := ih ( k + 1 + 1 ) ( by linarith ) ( by linarith ) ; norm_num at * ; nlinarith [ Real.log_pos ( show ( 4 : ℝ ) > 1 by norm_num ) ]

/-
theta(x) <= C * x for some constant C and all x >= 1
-/
theorem theta_le_linear : ∃ C > 0, ∀ x ≥ 1, theta x ≤ C * x := by
  obtain ⟨C, hC_pos, hC⟩ : ∃ C > 0, ∀ n : ℕ, n ≥ 1 → theta n ≤ C * n := by
    exact?;
  use C, hC_pos;
  intro x hx
  have h_floor : theta x = theta (Nat.floor x) := by
    unfold theta; aesop;
  exact h_floor ▸ le_trans ( hC _ ( Nat.floor_pos.mpr hx ) ) ( mul_le_mul_of_nonneg_left ( Nat.floor_le ( by positivity ) ) hC_pos.le )

/-
|psi(x) - theta(x)| <= C * sqrt(x)
-/
theorem psi_theta_bound : ∃ C > 0, ∀ x ≥ 2, |psi x - theta x| ≤ C * Real.sqrt x := by
  -- By psi_eq_sum_theta, psi(x) - theta(x) = sum_{k=2}^{floor(log_2 x)} theta(x^{1/k}).
  have h_diff : ∀ x : ℝ, x ≥ 2 → psi x - theta x = ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), theta (x ^ (1 / (k : ℝ))) := by
    intro x hx; erw [ psi_eq_sum_theta x ( by linarith ) ] ; erw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num;
    erw [ Finset.sum_Ico_eq_sub _ ] <;> norm_num [ Finset.sum_range_succ' ];
    exact Nat.succ_le_succ ( Nat.floor_pos.mpr ( by rw [ Real.le_logb_iff_rpow_le ] <;> norm_num <;> linarith ) );
  -- By theta_le_linear, theta(y) <= A * y for some A.
  obtain ⟨A, hA_pos, hA⟩ : ∃ A > 0, ∀ x : ℝ, x ≥ 1 → theta x ≤ A * x := by
    exact?;
  -- So the sum is bounded by A * sum_{k=2}^{floor(log_2 x)} x^{1/k}.
  have h_sum_bound : ∀ x : ℝ, x ≥ 2 → ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), theta (x ^ (1 / (k : ℝ))) ≤ A * ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), x ^ (1 / (k : ℝ)) := by
    exact fun x hx => by rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_le_sum fun k hk => hA _ <| Real.one_le_rpow ( by linarith ) <| by positivity;
  -- The first term (k=2) is A * sqrt(x).
  have h_first_term : ∀ x : ℝ, x ≥ 2 → A * ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), x ^ (1 / (k : ℝ)) ≤ A * Real.sqrt x + A * Real.sqrt x * (Real.logb 2 x - 1) * x ^ (-1 / 6 : ℝ) := by
    -- The sum is bounded by A * sqrt(x) + A * sqrt(x) * (log_2 x - 1) * x^{-1/6}.
    intros x hx
    have h_sum_bound : ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), x ^ (1 / (k : ℝ)) ≤ Real.sqrt x + Real.sqrt x * (Real.logb 2 x - 1) * x ^ (-1 / 6 : ℝ) := by
      -- For $k \geq 3$, we have $x^{1/k} \leq x^{1/3}$.
      have h_bound : ∀ k : ℕ, 3 ≤ k → x ^ (1 / (k : ℝ)) ≤ x ^ (1 / 3 : ℝ) := by
        exact fun k hk => Real.rpow_le_rpow_of_exponent_le ( by linarith ) ( by gcongr ; norm_cast );
      -- The sum can be split into the first term (k=2) and the rest (k ≥ 3).
      have h_split_sum : ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), x ^ (1 / (k : ℝ)) ≤ x ^ (1 / 2 : ℝ) + (Nat.floor (Real.logb 2 x) - 1) * x ^ (1 / 3 : ℝ) := by
        refine' le_trans ( Finset.sum_le_sum fun i hi => show x ^ ( 1 / ( i : ℝ ) ) ≤ if i = 2 then x ^ ( 1 / 2 : ℝ ) else x ^ ( 1 / 3 : ℝ ) from _ ) _;
        · split_ifs <;> [ norm_num; exact h_bound i ( by linarith [ Finset.mem_Icc.mp hi, show i ≥ 3 by exact lt_of_le_of_ne ( Finset.mem_Icc.mp hi |>.1 ) ( Ne.symm ‹_› ) ] ) ];
          norm_num [ ‹_› ];
        · erw [ Finset.sum_Ico_eq_sum_range ] ; norm_num [ add_comm, Finset.sum_range_succ' ];
          rcases n : ⌊Real.logb 2 x⌋₊ with ( _ | _ | n ) <;> simp_all +decide [ add_comm 1, Finset.sum_range_succ' ];
          · exact Real.rpow_le_rpow_of_exponent_le ( by linarith ) ( by norm_num );
          · positivity;
          · linarith [ Real.rpow_pos_of_pos ( zero_lt_two.trans_le hx ) ( 3⁻¹ : ℝ ) ];
      -- Since $\lfloor \log_2 x \rfloor \leq \log_2 x$, we can replace $\lfloor \log_2 x \rfloor$ with $\log_2 x$ in the inequality.
      have h_floor_log : (Nat.floor (Real.logb 2 x) - 1) * x ^ (1 / 3 : ℝ) ≤ (Real.logb 2 x - 1) * x ^ (1 / 3 : ℝ) := by
        exact mul_le_mul_of_nonneg_right ( sub_le_sub_right ( Nat.floor_le ( Real.logb_nonneg ( by norm_num ) ( by linarith ) ) ) _ ) ( by positivity );
      convert h_split_sum.trans ( add_le_add_right h_floor_log _ ) using 1 ; norm_num [ Real.sqrt_eq_rpow ] ; ring;
      norm_num [ mul_assoc, mul_left_comm, ← Real.rpow_add ( by positivity : 0 < x ) ];
      rw [ mul_left_comm, ← Real.rpow_add ( by positivity ) ] ; norm_num;
    convert mul_le_mul_of_nonneg_left h_sum_bound hA_pos.le using 1 ; ring;
  -- Since $\log_2 x \cdot x^{-1/6}$ is bounded for $x \geq 2$, we can find a constant $B$ such that $\log_2 x \cdot x^{-1/6} \leq B$ for all $x \geq 2$.
  obtain ⟨B, hB⟩ : ∃ B > 0, ∀ x : ℝ, x ≥ 2 → Real.logb 2 x * x ^ (-1 / 6 : ℝ) ≤ B := by
    -- We can use the fact that $\log_2 x \cdot x^{-1/6}$ is bounded for $x \geq 2$.
    have h_log_bound : ∃ B > 0, ∀ x : ℝ, x ≥ 2 → Real.log x * x ^ (-1 / 6 : ℝ) ≤ B := by
      field_simp;
      -- We can use the fact that $\log x \cdot x^{-1/6}$ is bounded for $x \geq 2$.
      have h_log_bound : ∃ B > 0, ∀ x : ℝ, x ≥ 2 → Real.log x ≤ B * x ^ (1 / 6 : ℝ) := by
        use 6;
        norm_num;
        intro x hx; have := Real.log_le_sub_one_of_pos ( by positivity : 0 < x ^ ( 1 / 6 : ℝ ) ) ; rw [ Real.log_rpow ( by positivity ) ] at this; norm_num at *; linarith;
      exact ⟨ h_log_bound.choose, h_log_bound.choose_spec.1, fun x hx => by rw [ Real.rpow_neg ( by positivity ) ] ; exact le_trans ( mul_le_mul_of_nonneg_right ( h_log_bound.choose_spec.2 x hx ) ( by positivity ) ) ( by rw [ mul_assoc, mul_inv_cancel₀ ( by positivity ), mul_one ] ) ⟩;
    norm_num [ Real.logb ] at *;
    exact ⟨ h_log_bound.choose / Real.log 2, div_pos h_log_bound.choose_spec.1 ( Real.log_pos one_lt_two ), fun x hx => by rw [ div_mul_eq_mul_div ] ; exact div_le_div_of_nonneg_right ( h_log_bound.choose_spec.2 x hx ) ( Real.log_nonneg one_le_two ) ⟩;
  -- Therefore, $|\psi(x) - \theta(x)| \leq A \sqrt{x} + A \sqrt{x} B$.
  have h_final_bound : ∀ x : ℝ, x ≥ 2 → |psi x - theta x| ≤ A * Real.sqrt x + A * Real.sqrt x * B := by
    intros x hx
    rw [h_diff x hx];
    rw [ abs_of_nonneg ];
    · refine le_trans ( h_sum_bound x hx ) ( le_trans ( h_first_term x hx ) ?_ );
      nlinarith [ show 0 ≤ A * Real.sqrt x by positivity, show 0 ≤ A * Real.sqrt x * x ^ ( -1 / 6 : ℝ ) by positivity, hB.2 x hx ];
    · exact Finset.sum_nonneg fun _ _ => Finset.sum_nonneg fun _ _ => Real.log_nonneg <| Nat.one_le_cast.2 <| Nat.Prime.pos <| by aesop;
  exact ⟨ A + A * B, by nlinarith, fun x hx => by nlinarith [ h_final_bound x hx, Real.sqrt_nonneg x ] ⟩