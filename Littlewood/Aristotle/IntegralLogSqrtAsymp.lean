/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9674b624-7725-4784-b8c1-6fbb0e902a8f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We proved the asymptotic behavior of the integral of log(sqrt(1/4 + t^2)) from 1 to T.
The proof establishes upper and lower bounds by comparing the integrand to log(t) and log(t) + log(2).
Using the known integral of log(t), we showed the integral is Θ(T * log T).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace IntegralLogSqrtModule

/-
The integral of log(sqrt(1/4 + t^2)) from 1 to T is asymptotically Theta(T * log T).
This is different from MeanSquare.integral_log_sqrt_asymp which integrates log(sqrt(t/2π)).
-/
lemma integral_log_sqrt_quarter_asymp :
    (fun T => ∫ t in (1:ℝ)..T, Real.log (Real.sqrt (1/4 + t^2))) =Θ[Filter.atTop] (fun T => T * Real.log T) := by
      -- We'll use the fact that $\int_1^T \log \sqrt{1/4 + t^2} \, dt = \int_1^T (\log t + \log \sqrt{1 + 1/(4t^2)}) \, dt$.
      suffices h_integral : ∀ T ≥ 1, ∫ t in (1 : ℝ)..T, Real.log (Real.sqrt (1 / 4 + t ^ 2)) ≥ ∫ t in (1 : ℝ)..T, Real.log t ∧ ∫ t in (1 : ℝ)..T, Real.log (Real.sqrt (1 / 4 + t ^ 2)) ≤ ∫ t in (1 : ℝ)..T, Real.log t + Real.log 2 by
        -- Now use the fact that $\int_1^T \log t \, dt = T \log T - T + 1$ and $\int_1^T \log 2 \, dt = T \log 2$.
        suffices h_simp : (fun T => T * Real.log T - T + 1) =O[Filter.atTop] (fun T => ∫ t in (1 : ℝ)..T, Real.log (Real.sqrt (1 / 4 + t ^ 2))) ∧ (fun T => ∫ t in (1 : ℝ)..T, Real.log (Real.sqrt (1 / 4 + t ^ 2))) =O[Filter.atTop] (fun T => T * Real.log T - T + 1 + T * Real.log 2) by
          refine' ⟨ _, _ ⟩;
          · refine' h_simp.2.trans _;
            rw [ Asymptotics.isBigO_iff ];
            refine' ⟨ 3 + Real.log 2, Filter.eventually_atTop.mpr ⟨ 4, fun x hx => _ ⟩ ⟩ ; rw [ Real.norm_of_nonneg, Real.norm_of_nonneg ];
            · nlinarith [ show 1 ≤ Real.log x from by rw [ Real.le_log_iff_exp_le ( by positivity ) ] ; exact Real.exp_one_lt_d9.le.trans ( by norm_num; linarith ), show 0 ≤ x * Real.log x from mul_nonneg ( by positivity ) ( Real.log_nonneg ( by linarith ) ), show 0 ≤ x * Real.log 2 from mul_nonneg ( by positivity ) ( Real.log_nonneg ( by norm_num ) ), Real.log_le_sub_one_of_pos zero_lt_two ];
            · exact mul_nonneg ( by linarith ) ( Real.log_nonneg ( by linarith ) );
            · nlinarith [ Real.log_inv x ▸ Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by linarith ) ), Real.log_pos one_lt_two, mul_inv_cancel₀ ( by linarith : x ≠ 0 ) ];
          · refine' Asymptotics.IsBigO.trans _ h_simp.1;
            rw [ Asymptotics.isBigO_iff ];
            refine' ⟨ 2, Filter.eventually_atTop.mpr ⟨ Real.exp 2, fun x hx => _ ⟩ ⟩ ; rw [ Real.norm_of_nonneg, Real.norm_of_nonneg ] <;> nlinarith [ Real.add_one_le_exp 2, Real.log_exp 2, Real.log_le_log ( by positivity ) hx, Real.log_nonneg ( show x ≥ 1 by linarith [ Real.add_one_le_exp 2, Real.log_exp 2, Real.log_le_log ( by positivity ) hx ] ) ];
        constructor <;> rw [ Asymptotics.isBigO_iff ];
        · refine' ⟨ 2, Filter.eventually_atTop.mpr ⟨ 4, fun x hx => _ ⟩ ⟩ ; rw [ Real.norm_of_nonneg, Real.norm_of_nonneg ];
          · have := h_integral x ( by linarith ) ; rw [ intervalIntegral.integral_add ] at this <;> norm_num at *;
            nlinarith [ show Real.log x ≥ 1 by rw [ ge_iff_le ] ; rw [ Real.le_log_iff_exp_le ( by linarith ) ] ; exact Real.exp_one_lt_d9.le.trans ( by norm_num; linarith ), show Real.log 2 ≥ 1 / 2 by exact Real.log_two_gt_d9.le.trans' <| by norm_num ];
          · exact intervalIntegral.integral_nonneg ( by linarith ) fun t ht => Real.log_nonneg ( Real.le_sqrt_of_sq_le ( by nlinarith [ ht.1 ] ) );
          · nlinarith [ Real.log_inv x ▸ Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by linarith ) ), mul_inv_cancel₀ ( by linarith : x ≠ 0 ) ];
        · -- Now use the fact that $\int_1^T \log t \, dt = T \log T - T + 1$ and $\int_1^T \log 2 \, dt = T \log 2$ to simplify the expression.
          have h_simp : ∀ T ≥ 1, ∫ t in (1 : ℝ)..T, Real.log (Real.sqrt (1 / 4 + t ^ 2)) ≤ T * Real.log T - T + 1 + T * Real.log 2 := by
            intro T hT; specialize h_integral T hT; rw [ intervalIntegral.integral_add ] at h_integral <;> norm_num at *;
            nlinarith [ Real.log_nonneg one_le_two ];
          refine' ⟨ 1, Filter.eventually_atTop.mpr ⟨ 1, fun T hT => _ ⟩ ⟩ ; rw [ Real.norm_of_nonneg <| intervalIntegral.integral_nonneg ( by linarith ) fun x hx => Real.log_nonneg <| Real.le_sqrt_of_sq_le <| by nlinarith [ hx.1 ] ] ; rw [ Real.norm_of_nonneg <| add_nonneg ( by nlinarith [ Real.log_inv ( T : ℝ ), Real.log_le_sub_one_of_pos ( inv_pos.mpr <| show 0 < T by linarith ), mul_inv_cancel₀ ( ne_of_gt <| show 0 < T by linarith ) ] ) <| mul_nonneg ( by linarith ) <| Real.log_nonneg <| by linarith ] ; aesop;
      field_simp;
      intro T hT; constructor <;> refine' intervalIntegral.integral_mono_on _ _ _ _ <;> norm_num <;> try linarith;
      · exact Continuous.intervalIntegrable ( by exact Continuous.log ( by continuity ) fun x => by positivity ) _ _;
      · exact fun x hx₁ hx₂ => Real.log_le_log ( by positivity ) ( by nlinarith [ Real.sqrt_nonneg ( 1 + 4 * x ^ 2 ), Real.mul_self_sqrt ( by positivity : 0 ≤ 1 + 4 * x ^ 2 ) ] );
      · exact Continuous.intervalIntegrable ( by exact Continuous.log ( by continuity ) fun x => by positivity ) _ _;
      · intro x hx₁ hx₂; rw [ ← Real.log_mul ( by positivity ) ( by positivity ) ] ; exact Real.log_le_log ( by positivity ) ( by nlinarith [ Real.mul_self_sqrt ( show 0 ≤ 1 + 4 * x ^ 2 by positivity ) ] ) ;
end IntegralLogSqrtModule
