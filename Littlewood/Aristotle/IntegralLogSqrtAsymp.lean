/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 27269ad8-6ab3-41d5-903c-a3c1bdb55f22

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Integral of log(sqrt(1/4 + t²)) asymptotic.

KEY RESULTS (PROVED):
- integral_log_sqrt_quarter_asymp: ∫₁ᵀ log(√(1/4 + t²)) dt = Θ(T log T)

This is useful for Hardy Z function and related mean value estimates.
The proof bounds log(√(1/4 + t²)) between log(t) and log(2t) for large t.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Filter Asymptotics

/-
The integral of log(sqrt(1/4 + t^2)) from 1 to T is asymptotically Theta of T * log T.
-/
lemma integral_log_sqrt_quarter_asymp :
    (fun T => ∫ t in (1:ℝ)..T, Real.log (Real.sqrt (1/4 + t^2))) =Θ[atTop] (fun T => T * Real.log T) := by
      constructor <;> rw [ Asymptotics.isBigO_iff ];
      · use 2, ?_;
        filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx;
        rw [ Real.norm_of_nonneg, Real.norm_of_nonneg ];
        · refine' le_trans ( intervalIntegral.integral_mono_on _ _ _ _ ) _;
          refine' fun t => Real.log ( 2 * t );
          · linarith;
          · exact Continuous.intervalIntegrable ( by exact Continuous.log ( Real.continuous_sqrt.comp <| by continuity ) fun t => by positivity ) _ _;
          · exact ContinuousOn.intervalIntegrable ( by exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.log ( continuousAt_const.mul continuousAt_id ) ( by linarith [ Set.mem_Icc.mp ( by simpa [ hx.le ] using ht ) ] ) );
          · exact fun t ht => Real.log_le_log ( Real.sqrt_pos.mpr <| by positivity ) <| Real.sqrt_le_iff.mpr ⟨ by nlinarith [ ht.1 ], by nlinarith [ ht.1, ht.2 ] ⟩;
          · rw [ intervalIntegral.integral_congr fun u hu => Real.log_mul ( by norm_num ) ( by linarith [ Set.mem_Icc.mp ( by simpa [ hx.le ] using hu ) ] ) ] ; norm_num;
            nlinarith [ Real.log_pos hx, Real.log_le_sub_one_of_pos zero_lt_two, Real.log_le_log ( by linarith ) hx.le ];
        · exact mul_nonneg ( by positivity ) ( Real.log_nonneg hx.le );
        · exact intervalIntegral.integral_nonneg ( by linarith ) fun t ht => Real.log_nonneg <| Real.le_sqrt_of_sq_le <| by nlinarith [ ht.1 ];
      · use 4;
        -- We'll use the fact that $\log(\sqrt{1/4 + t^2}) = \frac{1}{2} \log(1/4 + t^2)$ to simplify the integral.
        suffices h_simp : ∀ᶠ x in Filter.atTop, x * Real.log x ≤ 4 * ∫ t in (1 : ℝ)..x, Real.log (t) by
          filter_upwards [ h_simp, Filter.eventually_gt_atTop 1 ] with x hx₁ hx₂;
          rw [ Real.norm_of_nonneg ( mul_nonneg ( by positivity ) ( Real.log_nonneg ( by linarith ) ) ), Real.norm_of_nonneg ( intervalIntegral.integral_nonneg ( by linarith ) fun t ht => Real.log_nonneg ( Real.le_sqrt_of_sq_le ( by nlinarith [ ht.1 ] ) ) ) ];
          refine' le_trans hx₁ ( mul_le_mul_of_nonneg_left ( intervalIntegral.integral_mono_on _ _ _ _ ) zero_le_four ) <;> norm_num;
          · linarith;
          · exact Continuous.intervalIntegrable ( by exact Continuous.log ( Real.continuous_sqrt.comp <| by continuity ) fun u => by positivity ) _ _;
          · exact fun t ht₁ ht₂ => Real.log_le_log ( by positivity ) ( Real.le_sqrt_of_sq_le ( by nlinarith ) );
        filter_upwards [ Filter.eventually_gt_atTop ( Real.exp 4 ) ] with x hx using by norm_num; nlinarith [ Real.add_one_le_exp 4, Real.log_exp 4, Real.log_le_log ( by positivity ) hx.le ] ;

end
