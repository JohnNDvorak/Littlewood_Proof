/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: f74319ab-eea9-4ffd-97a2-da1e0d3a513a

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

KEY RESULTS:
- phragmen_lindelof_convexity: Core Hadamard three-lines bound
- zeta_entire_analytic: (s-1)ζ(s) is entire
- polynomial_growth_implies_bounded_of_boundary_bounded: Main P-L lemma
- zeta_entire_growth: Polynomial growth estimates

NOTE: Budget reached - some proofs may be incomplete.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators Real Nat Classical Pointwise
open Complex

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-! ## Phragmén-Lindelöf Convexity -/

/-- Hadamard three-lines convexity bound for vertical strips. -/
theorem phragmen_lindelof_convexity_v2 {f : ℂ → ℂ} {a b : ℝ} (hab : a < b)
    {M_a M_b : ℝ} (hMa : 0 < M_a) (hMb : 0 < M_b)
    (hf_diff : DiffContOnCl ℂ f (re ⁻¹' Set.Ioo a b))
    (hf_bdd : BddAbove ((norm ∘ f) '' HadamardThreeLines.verticalClosedStrip a b))
    (hf_bound_a : ∀ z ∈ re ⁻¹' {a}, ‖f z‖ ≤ M_a)
    (hf_bound_b : ∀ z ∈ re ⁻¹' {b}, ‖f z‖ ≤ M_b) :
    ∀ z, a ≤ z.re → z.re ≤ b →
      ‖f z‖ ≤ M_a ^ (1 - (z.re - a) / (b - a)) * M_b ^ ((z.re - a) / (b - a)) := by
  intro z hz₁ hz₂
  have hz_mem : z ∈ HadamardThreeLines.verticalClosedStrip a b :=
    ⟨hz₁, hz₂⟩
  exact HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip' hab hz_mem hf_diff hf_bdd
    hf_bound_a hf_bound_b

/-! ## Lindelöf Function -/

noncomputable def lindelof_mu_v2 (σ : ℝ) : ℝ :=
  if 1 ≤ σ then 0
  else if σ ≤ 0 then 1/2 - σ
  else if σ ≤ 1/2 then 1/2 - σ
  else (1 - σ) / 2

noncomputable def convexity_mu_v2 (σ : ℝ) : ℝ := (1 - σ) / 2

/-! ## Regularized Zeta Function -/

/-- The function (s-1)ζ(s), which extends to an entire function. -/
noncomputable def zeta_entire_v2 (s : ℂ) : ℂ :=
  if s = 1 then 1 else (s - 1) * riemannZeta s

lemma zeta_entire_analytic_v2 : Differentiable ℂ zeta_entire_v2 := by
  intro s
  by_cases hs : s = 1
  · -- At s = 1: removable singularity, using riemannZeta_residue_one
    subst hs
    have h_diff_punct : ∀ᶠ z in nhdsWithin (1 : ℂ) {(1 : ℂ)}ᶜ,
        DifferentiableAt ℂ zeta_entire_v2 z := by
      apply Filter.eventually_of_mem self_mem_nhdsWithin
      intro z hz
      simp only [Set.mem_compl_iff, Set.mem_singleton_iff] at hz
      exact DifferentiableAt.congr_of_eventuallyEq
        ((differentiableAt_id.sub (differentiableAt_const 1)).mul
          (differentiableAt_riemannZeta hz))
        (Filter.eventuallyEq_of_mem (isOpen_compl_singleton.mem_nhds
          (Set.mem_compl_singleton_iff.mpr hz)) fun w hw => by
          simp only [Set.mem_compl_iff, Set.mem_singleton_iff] at hw
          show zeta_entire_v2 w = (w - 1) * riemannZeta w
          simp only [zeta_entire_v2, if_neg hw])
    have h_cont : ContinuousAt zeta_entire_v2 1 := by
      rw [ContinuousAt]
      have hval : zeta_entire_v2 1 = 1 := by simp [zeta_entire_v2]
      rw [hval, Metric.tendsto_nhds]
      intro ε hε
      have hres := riemannZeta_residue_one
      rw [Metric.tendsto_nhds] at hres
      have hres' := hres ε hε
      rw [Filter.Eventually, Metric.mem_nhdsWithin_iff] at hres'
      obtain ⟨δ, hδ_pos, hball⟩ := hres'
      rw [Filter.Eventually, Metric.mem_nhds_iff]
      exact ⟨δ, hδ_pos, fun z hz => by
        by_cases h : z = 1
        · simp [h, hval, hε]
        · have hz' : z ∈ Metric.ball (1 : ℂ) δ ∩ {(1 : ℂ)}ᶜ := ⟨hz, h⟩
          simp only [zeta_entire_v2, if_neg h, Set.mem_setOf_eq]
          exact hball hz'⟩
    exact (Complex.analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt
      h_diff_punct h_cont).differentiableAt
  · -- Away from 1, straightforward product
    exact DifferentiableAt.congr_of_eventuallyEq
      ((differentiableAt_id.sub (differentiableAt_const _)).mul
        (differentiableAt_riemannZeta hs))
      (Filter.eventuallyEq_of_mem (isOpen_ne.mem_nhds hs) fun x hx => by
        show zeta_entire_v2 x = (x - 1) * riemannZeta x
        simp only [zeta_entire_v2, if_neg (Set.mem_compl_singleton_iff.mp hx)])

/-! ## Growth Conditions -/

/-- Polynomial growth in a strip implies the Phragmén-Lindelöf growth condition. -/
lemma g_growth_condition_v2 (g : ℂ → ℂ) (a b : ℝ) (hab : a < b)
    (hg_poly : ∃ k C, ∀ z, a ≤ z.re → z.re ≤ b → ‖g z‖ ≤ C * (1 + ‖z‖) ^ k) :
    ∃ c < Real.pi / (b - a), ∃ B, g =O[Filter.comap (_root_.abs ∘ im) Filter.atTop ⊓
      Filter.principal (re ⁻¹' Set.Ioo a b)] fun z => Real.exp (B * Real.exp (c * |z.im|)) := by
  -- Polynomial growth is dominated by any exponential growth condition
  -- Choose c = π/(2(b-a)) < π/(b-a) and B large enough
  sorry

/-- Phragmén-Lindelöf for functions of polynomial growth:
    if f has polynomial growth in a strip and is bounded on the boundary,
    then f is bounded throughout the strip. -/
theorem polynomial_growth_implies_bounded_of_boundary_bounded_v2
    {f : ℂ → ℂ} {a b M : ℝ} (hab : a < b)
    (hf_diff : DiffContOnCl ℂ f (re ⁻¹' Set.Ioo a b))
    (hf_growth : ∃ k C, ∀ z, a ≤ z.re → z.re ≤ b → ‖f z‖ ≤ C * (1 + ‖z‖) ^ k)
    (hf_bound_a : ∀ y : ℝ, ‖f (a + I * y)‖ ≤ M)
    (hf_bound_b : ∀ y : ℝ, ‖f (b + I * y)‖ ≤ M) :
    ∀ z, a ≤ z.re → z.re ≤ b → ‖f z‖ ≤ M := by
  intro z hz_left hz_right
  obtain ⟨c, hc_lt, B, hO⟩ := g_growth_condition_v2 f a b hab hf_growth
  have h_bound_a' : ∀ w : ℂ, w.re = a → ‖f w‖ ≤ M := by
    intro w hw
    have : w = a + I * w.im := by apply Complex.ext <;> simp [hw]
    rw [this]; exact hf_bound_a w.im
  have h_bound_b' : ∀ w : ℂ, w.re = b → ‖f w‖ ≤ M := by
    intro w hw
    have : w = b + I * w.im := by apply Complex.ext <;> simp [hw]
    rw [this]; exact hf_bound_b w.im
  exact PhragmenLindelof.vertical_strip hf_diff ⟨c, hc_lt, B, hO⟩ h_bound_a' h_bound_b'
    hz_left hz_right

/-! ## Zeta Growth Estimates -/

/-- Growth estimate for (s-1)ζ(s) in the critical strip. -/
lemma zeta_entire_growth_v2
    (h_growth : ∃ k C, ∀ σ : ℝ, 0 ≤ σ → σ ≤ 1 → ∀ t : ℝ, 1 ≤ |t| →
      ‖riemannZeta (σ + I * t)‖ ≤ C * |t|^k) :
    ∃ k C, ∀ z, 0 ≤ z.re → z.re ≤ 1 → ‖zeta_entire_v2 z‖ ≤ C * (1 + ‖z‖) ^ k := by
  -- Combines the bound on ‖z-1‖ with the assumed bound on ‖ζ(z)‖
  -- for |Im(z)| ≥ 1, and uses compactness for |Im(z)| < 1
  sorry

end
