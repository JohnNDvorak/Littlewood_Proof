/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: f74319ab-eea9-4ffd-97a2-da1e0d3a513a

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

KEY RESULTS:
- phragmen_lindelof_convexity: Core Hadamard three-lines bound
- zeta_entire_analytic: (s-1)ζ(s) is entire
- polynomial_growth_implies_bounded_of_boundary_bounded: Main P-L lemma
- zeta_entire_growth: Polynomial growth estimates

NOTE: Budget reached - some proofs may be incomplete.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators Real Nat Classical Pointwise
open Complex

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-! ## Phragmén-Lindelöf Convexity -/

/-- Hadamard three-lines convexity bound for vertical strips. -/
theorem phragmen_lindelof_convexity_v2 {f : ℂ → ℂ} {a b : ℝ} (hab : a < b)
    {M_a M_b : ℝ} (hMa : 0 < M_a) (hMb : 0 < M_b)
    (hf_diff : DiffContOnCl ℂ f (re ⁻¹' Set.Ioo a b))
    (hf_bdd : BddAbove ((norm ∘ f) '' HadamardThreeLines.verticalClosedStrip a b))
    (hf_bound_a : ∀ z ∈ re ⁻¹' {a}, ‖f z‖ ≤ M_a)
    (hf_bound_b : ∀ z ∈ re ⁻¹' {b}, ‖f z‖ ≤ M_b) :
    ∀ z, a ≤ z.re → z.re ≤ b →
      ‖f z‖ ≤ M_a ^ (1 - (z.re - a) / (b - a)) * M_b ^ ((z.re - a) / (b - a)) := by
  intro z hz₁ hz₂
  have hz_mem : z ∈ HadamardThreeLines.verticalClosedStrip a b :=
    ⟨hz₁, hz₂⟩
  exact HadamardThreeLines.norm_le_interp_of_mem_verticalClosedStrip' hab hz_mem hf_diff hf_bdd
    hf_bound_a hf_bound_b

/-! ## Lindelöf Function -/

noncomputable def lindelof_mu_v2 (σ : ℝ) : ℝ :=
  if 1 ≤ σ then 0
  else if σ ≤ 0 then 1/2 - σ
  else if σ ≤ 1/2 then 1/2 - σ
  else (1 - σ) / 2

noncomputable def convexity_mu_v2 (σ : ℝ) : ℝ := (1 - σ) / 2

/-! ## Regularized Zeta Function -/

/-- The function (s-1)ζ(s), which extends to an entire function. -/
noncomputable def zeta_entire_v2 (s : ℂ) : ℂ :=
  if s = 1 then 1 else (s - 1) * riemannZeta s

lemma zeta_entire_analytic_v2 : Differentiable ℂ zeta_entire_v2 := by
  intro s
  by_cases hs : s = 1
  · -- At s = 1: removable singularity, using riemannZeta_residue_one
    subst hs
    have h_diff_punct : ∀ᶠ z in nhdsWithin (1 : ℂ) {(1 : ℂ)}ᶜ,
        DifferentiableAt ℂ zeta_entire_v2 z := by
      apply Filter.eventually_of_mem self_mem_nhdsWithin
      intro z hz
      simp only [Set.mem_compl_iff, Set.mem_singleton_iff] at hz
      exact DifferentiableAt.congr_of_eventuallyEq
        ((differentiableAt_id.sub (differentiableAt_const 1)).mul
          (differentiableAt_riemannZeta hz))
        (Filter.eventuallyEq_of_mem (isOpen_compl_singleton.mem_nhds
          (Set.mem_compl_singleton_iff.mpr hz)) fun w hw => by
          simp only [Set.mem_compl_iff, Set.mem_singleton_iff] at hw
          show zeta_entire_v2 w = (w - 1) * riemannZeta w
          simp only [zeta_entire_v2, if_neg hw])
    have h_cont : ContinuousAt zeta_entire_v2 1 := by
      rw [ContinuousAt]
      have hval : zeta_entire_v2 1 = 1 := by simp [zeta_entire_v2]
      rw [hval, Metric.tendsto_nhds]
      intro ε hε
      have hres := riemannZeta_residue_one
      rw [Metric.tendsto_nhds] at hres
      have hres' := hres ε hε
      rw [Filter.Eventually, Metric.mem_nhdsWithin_iff] at hres'
      obtain ⟨δ, hδ_pos, hball⟩ := hres'
      rw [Filter.Eventually, Metric.mem_nhds_iff]
      exact ⟨δ, hδ_pos, fun z hz => by
        by_cases h : z = 1
        · simp [h, hval, hε]
        · have hz' : z ∈ Metric.ball (1 : ℂ) δ ∩ {(1 : ℂ)}ᶜ := ⟨hz, h⟩
          simp only [zeta_entire_v2, if_neg h, Set.mem_setOf_eq]
          exact hball hz'⟩
    exact (Complex.analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt
      h_diff_punct h_cont).differentiableAt
  · -- Away from 1, straightforward product
    exact DifferentiableAt.congr_of_eventuallyEq
      ((differentiableAt_id.sub (differentiableAt_const _)).mul
        (differentiableAt_riemannZeta hs))
      (Filter.eventuallyEq_of_mem (isOpen_ne.mem_nhds hs) fun x hx => by
        show zeta_entire_v2 x = (x - 1) * riemannZeta x
        simp only [zeta_entire_v2, if_neg (Set.mem_compl_singleton_iff.mp hx)])

/-! ## Growth Conditions -/

/-- Polynomial growth in a strip implies the Phragmén-Lindelöf growth condition. -/
lemma g_growth_condition_v2 (g : ℂ → ℂ) (a b : ℝ) (hab : a < b)
    (hg_poly : ∃ k C, ∀ z, a ≤ z.re → z.re ≤ b → ‖g z‖ ≤ C * (1 + ‖z‖) ^ k) :
    ∃ c < Real.pi / (b - a), ∃ B, g =O[Filter.comap (_root_.abs ∘ im) Filter.atTop ⊓
      Filter.principal (re ⁻¹' Set.Ioo a b)] fun z => Real.exp (B * Real.exp (c * |z.im|)) := by
  -- Polynomial growth is dominated by any exponential growth condition
  -- Choose c = π/(2(b-a)) < π/(b-a) and B large enough
  sorry

/-- Phragmén-Lindelöf for functions of polynomial growth:
    if f has polynomial growth in a strip and is bounded on the boundary,
    then f is bounded throughout the strip. -/
theorem polynomial_growth_implies_bounded_of_boundary_bounded_v2
    {f : ℂ → ℂ} {a b M : ℝ} (hab : a < b)
    (hf_diff : DiffContOnCl ℂ f (re ⁻¹' Set.Ioo a b))
    (hf_growth : ∃ k C, ∀ z, a ≤ z.re → z.re ≤ b → ‖f z‖ ≤ C * (1 + ‖z‖) ^ k)
    (hf_bound_a : ∀ y : ℝ, ‖f (a + I * y)‖ ≤ M)
    (hf_bound_b : ∀ y : ℝ, ‖f (b + I * y)‖ ≤ M) :
    ∀ z, a ≤ z.re → z.re ≤ b → ‖f z‖ ≤ M := by
  intro z hz_left hz_right
  obtain ⟨c, hc_lt, B, hO⟩ := g_growth_condition_v2 f a b hab hf_growth
  have h_bound_a' : ∀ w : ℂ, w.re = a → ‖f w‖ ≤ M := by
    intro w hw
    have : w = a + I * w.im := by apply Complex.ext <;> simp [hw]
    rw [this]; exact hf_bound_a w.im
  have h_bound_b' : ∀ w : ℂ, w.re = b → ‖f w‖ ≤ M := by
    intro w hw
    have : w = b + I * w.im := by apply Complex.ext <;> simp [hw]
    rw [this]; exact hf_bound_b w.im
  exact PhragmenLindelof.vertical_strip hf_diff ⟨c, hc_lt, B, hO⟩ h_bound_a' h_bound_b'
    hz_left hz_right

/-! ## Zeta Growth Estimates -/

/-- Growth estimate for (s-1)ζ(s) in the critical strip. -/
lemma zeta_entire_growth_v2
    (h_growth : ∃ k C, ∀ σ : ℝ, 0 ≤ σ → σ ≤ 1 → ∀ t : ℝ, 1 ≤ |t| →
      ‖riemannZeta (σ + I * t)‖ ≤ C * |t|^k) :
    ∃ k C, ∀ z, 0 ≤ z.re → z.re ≤ 1 → ‖zeta_entire_v2 z‖ ≤ C * (1 + ‖z‖) ^ k := by
  obtain ⟨k₀, C₀, hC₀⟩ := h_growth
  -- Bound on compact region {z : ‖z‖ ≤ 2}
  have hcont : Continuous zeta_entire_v2 := zeta_entire_analytic_v2.continuous
  obtain ⟨M₀, hM₀⟩ := (isCompact_closedBall (0 : ℂ) 2).exists_bound_of_continuousOn
    hcont.continuousOn
  -- Choose k and C (ensure C ≥ 1 for monotonicity)
  refine ⟨k₀ + 1, max 1 (max C₀ (M₀ + 1)), ?_⟩
  intro z hz_re hz_re'
  have h1p : 1 ≤ 1 + ‖z‖ := le_add_of_nonneg_right (norm_nonneg z)
  have hC_ge : 0 < max 1 (max C₀ (M₀ + 1)) := lt_of_lt_of_le one_pos (le_max_left _ _)
  by_cases him : 1 ≤ |z.im|
  · -- Case: |Im(z)| ≥ 1. Use hypothesis to bound ζ, multiply by ‖z-1‖.
    have hz_ne : z ≠ 1 := by intro heq; simp [heq] at him; linarith
    -- Apply hypothesis with σ = Re(z), t = Im(z)
    have h_zeta : ‖riemannZeta z‖ ≤ C₀ * |z.im| ^ k₀ := by
      have h := hC₀ z.re hz_re hz_re' z.im him
      have heq : (↑z.re : ℂ) + I * ↑z.im = z := by
        rw [mul_comm]; exact re_add_im z
      rwa [heq] at h
    -- Derive C₀ ≥ 0 from the bound
    have hC₀_nonneg : 0 ≤ C₀ := by
      have h1 : 0 ≤ C₀ * |z.im| ^ k₀ := le_trans (norm_nonneg _) h_zeta
      have h2 : (0 : ℝ) < |z.im| ^ k₀ := pow_pos (lt_of_lt_of_le zero_lt_one him) _
      by_contra h; push_neg at h; linarith [mul_neg_of_neg_of_pos h h2]
    -- zeta_entire_v2 z = (z - 1) * ζ(z) when z ≠ 1
    have h_val : zeta_entire_v2 z = (z - 1) * riemannZeta z := if_neg hz_ne
    rw [h_val, norm_mul]
    -- Key estimates
    have h_sub : ‖z - 1‖ ≤ 1 + ‖z‖ := by linarith [norm_sub_le z 1, norm_one (α := ℂ)]
    have h_im : |z.im| ≤ 1 + ‖z‖ := by linarith [abs_im_le_norm z]
    calc ‖z - 1‖ * ‖riemannZeta z‖
        ≤ (1 + ‖z‖) * (C₀ * |z.im| ^ k₀) :=
          mul_le_mul h_sub h_zeta (norm_nonneg _) (by linarith [norm_nonneg z])
      _ = C₀ * ((1 + ‖z‖) * |z.im| ^ k₀) := by ring
      _ ≤ C₀ * ((1 + ‖z‖) * (1 + ‖z‖) ^ k₀) := by
          apply mul_le_mul_of_nonneg_left _ hC₀_nonneg
          apply mul_le_mul_of_nonneg_left _ (by linarith [norm_nonneg z])
          exact pow_le_pow_left₀ (abs_nonneg _) h_im k₀
      _ = C₀ * (1 + ‖z‖) ^ (k₀ + 1) := by rw [← pow_succ']
      _ ≤ max 1 (max C₀ (M₀ + 1)) * (1 + ‖z‖) ^ (k₀ + 1) := by
          gcongr; exact le_max_of_le_right (le_max_left _ _)
  · -- Case: |Im(z)| < 1. Compact region: use continuity bound.
    push_neg at him
    -- z ∈ closedBall 0 2 since |Re| ≤ 1 and |Im| < 1, so ‖z‖ ≤ |Re| + |Im| < 2
    have hz_ball : z ∈ Metric.closedBall (0 : ℂ) 2 := by
      simp only [Metric.mem_closedBall, dist_zero_right]
      have hre_abs : |z.re| ≤ 1 := abs_le.mpr ⟨by linarith, by linarith⟩
      have him_abs : |z.im| ≤ 1 := le_of_lt him
      calc ‖z‖ ≤ |z.re| + |z.im| := norm_le_abs_re_add_abs_im z
        _ ≤ 1 + 1 := by linarith
        _ = 2 := by norm_num
    calc ‖zeta_entire_v2 z‖
        ≤ M₀ := hM₀ z hz_ball
      _ ≤ M₀ + 1 := le_add_of_nonneg_right one_pos.le
      _ ≤ max C₀ (M₀ + 1) := le_max_right _ _
      _ ≤ max 1 (max C₀ (M₀ + 1)) := le_max_right _ _
      _ = max 1 (max C₀ (M₀ + 1)) * 1 := (mul_one _).symm
      _ ≤ max 1 (max C₀ (M₀ + 1)) * (1 + ‖z‖) ^ (k₀ + 1) := by
          gcongr; exact one_le_pow₀ h1p

end
