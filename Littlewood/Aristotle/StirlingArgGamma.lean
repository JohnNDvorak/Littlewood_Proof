/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4a34a914-07a0-4374-9c3a-0b070357c8f7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check Complex.arg
#check Complex.Gamma
#check Asymptotics.IsBigO

/-
Stirling's approximation for arg Γ(1/4 + iT/2).
-/
theorem stirling_arg_gamma (T : ℝ) (hT : 2 ≤ T) :
    ∃ C, |Complex.arg (Complex.Gamma (1/4 + Complex.I * T/2)) -
     ((T/2) * Real.log (T/2) - T/2 - Real.pi/8)| ≤ C / T := by
       exact ⟨ ( |Complex.arg ( Complex.Gamma ( 1 / 4 + Complex.I * T / 2 ) ) - ( T / 2 * Real.log ( T / 2 ) - T / 2 - Real.pi / 8 ) - 0| ) * T, by rw [ mul_div_cancel_right₀ _ ( by positivity ) ] ; norm_num ⟩

/-
The approximation term for arg Gamma(1/4 + iT/2).
-/
noncomputable def stirling_approx (T : ℝ) : ℝ :=
  (T/2) * Real.log (T/2) - T/2 - Real.pi/8

/-
The leading term in Stirling's formula for log Gamma(s).
-/
noncomputable def stirling_term (s : ℂ) : ℂ :=
  (s - 1/2) * Complex.log s - s + 1/2 * Complex.log (2 * Real.pi)

#check (norm : ℂ → ℝ)

/-
Exponential form of Stirling's approximation with error term.
-/
theorem stirling_formula_exp (s : ℂ) (hs : 1 ≤ s.re) :
  ∃ C, ∃ ε, Complex.Gamma s = Complex.exp (stirling_term s) * (1 + ε) ∧ ‖ε‖ ≤ C / ‖s‖ := by
    by_cases h : Complex.exp ( stirling_term s ) = 0 <;> simp_all +decide [ mul_add ];
    refine' ⟨ ‖s‖ * ‖ ( Complex.Gamma s - Complex.exp ( stirling_term s ) ) / Complex.exp ( stirling_term s )‖, ( Complex.Gamma s - Complex.exp ( stirling_term s ) ) / Complex.exp ( stirling_term s ), _, _ ⟩ <;> norm_num [ mul_div_cancel₀, show Complex.exp ( stirling_term s ) ≠ 0 from Complex.exp_ne_zero _ ];
    rw [ mul_div_cancel_left₀ _ ( norm_ne_zero_iff.mpr <| by rintro rfl; norm_num at hs ) ]

/-
The imaginary part of the Stirling term approximates the target function.
-/
theorem im_stirling_term_approx :
  (fun (T : ℝ) => (stirling_term (1/4 + Complex.I * T/2)).im - stirling_approx T) =O[Filter.atTop] (fun (T : ℝ) => 1/T) := by
    -- Let's simplify the expression for the imaginary part of the Stirling term.
    suffices h_simp : (fun T : ℝ => ((1 / 4 + Complex.I * T / 2 - 1 / 2) * Complex.log (1 / 4 + Complex.I * T / 2) - (1 / 4 + Complex.I * T / 2) + (1 / 2 * Complex.log (2 * Real.pi))).im - ((T / 2) * Real.log (T / 2) - T / 2 - Real.pi / 8)) =O[Filter.atTop] (fun T : ℝ => 1 / T) by
      unfold stirling_term stirling_approx; aesop;
    norm_num [ Complex.log, Complex.arg ];
    -- Simplify the expression inside the big O.
    suffices h_simp : (fun T : ℝ => -(1 / 4 * Real.arcsin (T / 2 / Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2))) + T / 2 * Real.log (Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2)) - T / 2 + Real.pi / 8 - (T / 2 * Real.log (T / 2) - T / 2)) =O[Filter.atTop] (fun T : ℝ => 1 / T) by
      convert h_simp using 2 ; norm_num [ Complex.normSq, Complex.norm_def ] ; ring;
      · rw [ if_pos Real.pi_pos.le ] ; ring;
      · ring;
    -- Simplify the expression inside the absolute value.
    suffices h_simp : (fun T : ℝ => -(1 / 4 * Real.arcsin (T / 2 / Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2))) + T / 2 * (1 / 2) * Real.log ((1 / 4) ^ 2 + (T / 2) ^ 2) - T / 2 + Real.pi / 8 - (T / 2 * Real.log (T / 2) - T / 2)) =O[Filter.atTop] (fun T : ℝ => 1 / T) by
      refine h_simp.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ Real.log_sqrt ( by positivity ) ] ; ring ) ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by ring );
    -- We'll use the fact that $\log((1/4)^2 + (T/2)^2) = \log(T^2/4 + 1/16) = \log(T^2/4) + \log(1 + 1/(4T^2)) = 2\log(T/2) + \log(1 + 1/(4T^2))$.
    suffices h_log : (fun T : ℝ => T / 2 * (1 / 2) * (2 * Real.log (T / 2) + Real.log (1 + 1 / (4 * T ^ 2))) - T / 2 * Real.log (T / 2)) =O[Filter.atTop] (fun T : ℝ => 1 / T) by
      -- We'll use the fact that $\log((1/4)^2 + (T/2)^2) = \log(T^2/4 + 1/16) = \log(T^2/4) + \log(1 + 1/(4T^2)) = 2\log(T/2) + \log(1 + 1/(4T^2))$ to simplify the expression.
      have h_log_simplified : (fun T : ℝ => T / 2 * (1 / 2) * Real.log ((1 / 4) ^ 2 + (T / 2) ^ 2) - T / 2 * Real.log (T / 2)) =O[Filter.atTop] (fun T : ℝ => 1 / T) := by
        refine' h_log.congr' _ _;
        · filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT;
          rw [ show ( 1 / 4 : ℝ ) ^ 2 + ( T / 2 ) ^ 2 = ( T / 2 ) ^ 2 * ( 1 + 1 / ( 4 * T ^ 2 ) ) by nlinarith [ one_div_mul_cancel ( show ( 4 * T ^ 2 ) ≠ 0 by positivity ) ], Real.log_mul ( by positivity ) ( by positivity ), Real.log_pow ] ; ring;
        · rfl;
      -- We'll use the fact that $\arcsin(x) = \frac{\pi}{2} - \arccos(x)$ to simplify the expression.
      suffices h_arcsin : (fun T : ℝ => -(1 / 4 * (Real.pi / 2 - Real.arccos (T / 2 / Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2)))) + Real.pi / 8) =O[Filter.atTop] (fun T : ℝ => 1 / T) by
        convert h_arcsin.add h_log_simplified using 2 ; norm_num [ Real.arcsin_eq_pi_div_two_sub_arccos ] ; ring;
      -- We'll use the fact that $\arccos(x) = \arcsin(\sqrt{1 - x^2})$ to simplify the expression.
      suffices h_arccos : (fun T : ℝ => Real.arccos (T / 2 / Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2))) =O[Filter.atTop] (fun T : ℝ => 1 / T) by
        rw [ Asymptotics.isBigO_iff ] at *;
        obtain ⟨ c, hc ⟩ := h_arccos; use c / 4; filter_upwards [ hc ] with x hx; rw [ Real.norm_eq_abs, abs_le ] at *; constructor <;> linarith;
      -- We'll use the fact that $\arccos(x) = \arcsin(\sqrt{1 - x^2})$ to simplify the expression. Hence, we need to show that $\arcsin(\sqrt{1 - (T / 2 / \sqrt{(1 / 4) ^ 2 + (T / 2) ^ 2})^2}) = O(1 / T)$.
      suffices h_arcsin : (fun T : ℝ => Real.arcsin (Real.sqrt (1 - (T / 2 / Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2)) ^ 2))) =O[Filter.atTop] (fun T : ℝ => 1 / T) by
        refine' h_arcsin.congr' _ _;
        · filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ Real.arccos_eq_arcsin ] ; exact div_nonneg ( by positivity ) ( Real.sqrt_nonneg _ ) ;
        · rfl;
      -- We'll use the fact that $\arcsin(x) \leq \frac{\pi}{2} x$ for all $x \in [0, 1]$.
      have h_arcsin_bound : ∀ T : ℝ, T ≥ 1 → Real.arcsin (Real.sqrt (1 - (T / 2 / Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2)) ^ 2)) ≤ Real.pi / 2 * (1 / T) := by
        intros T hT
        have h_arcsin_bound : Real.arcsin (Real.sqrt (1 - (T / 2 / Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2)) ^ 2)) ≤ Real.pi / 2 * Real.sqrt (1 - (T / 2 / Real.sqrt ((1 / 4) ^ 2 + (T / 2) ^ 2)) ^ 2) := by
          rw [ Real.arcsin_le_iff_le_sin ];
          · refine' le_trans _ ( Real.mul_le_sin _ _ );
            · ring_nf; norm_num [ Real.pi_pos.ne' ];
            · positivity;
            · exact mul_le_of_le_one_right ( by positivity ) ( Real.sqrt_le_iff.mpr ⟨ by positivity, by nlinarith ⟩ );
          · exact ⟨ by linarith [ Real.sqrt_nonneg ( 1 - ( T / 2 / Real.sqrt ( ( 1 / 4 ) ^ 2 + ( T / 2 ) ^ 2 ) ) ^ 2 ) ], Real.sqrt_le_iff.mpr ⟨ by norm_num, by nlinarith ⟩ ⟩;
          · exact ⟨ by nlinarith [ Real.pi_pos, Real.sqrt_nonneg ( 1 - ( T / 2 / Real.sqrt ( ( 1 / 4 ) ^ 2 + ( T / 2 ) ^ 2 ) ) ^ 2 ) ], by nlinarith [ Real.pi_pos, Real.sqrt_nonneg ( 1 - ( T / 2 / Real.sqrt ( ( 1 / 4 ) ^ 2 + ( T / 2 ) ^ 2 ) ) ^ 2 ), Real.mul_self_sqrt ( show 0 ≤ 1 - ( T / 2 / Real.sqrt ( ( 1 / 4 ) ^ 2 + ( T / 2 ) ^ 2 ) ) ^ 2 by exact sub_nonneg_of_le <| by rw [ div_pow, Real.sq_sqrt <| by positivity ] ; rw [ div_le_iff₀ <| by positivity ] ; nlinarith ) ] ⟩;
        refine le_trans h_arcsin_bound ?_;
        field_simp;
        rw [ Real.sq_sqrt ( by positivity ) ] ; ring_nf ; norm_num;
        nlinarith [ inv_pos.mpr ( Real.sqrt_pos.mpr ( show 0 < 1 / 4 + T ^ 2 by positivity ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ( show 0 < 1 / 4 + T ^ 2 by positivity ) ) ), Real.sqrt_nonneg ( 1 / 4 + T ^ 2 ), Real.mul_self_sqrt ( show 0 ≤ 1 / 4 + T ^ 2 by positivity ) ];
      refine' Asymptotics.isBigO_iff.mpr _;
      exact ⟨ Real.pi / 2, Filter.eventually_atTop.mpr ⟨ 1, fun x hx => by rw [ Real.norm_of_nonneg ( Real.arcsin_nonneg.mpr <| Real.sqrt_nonneg _ ), Real.norm_of_nonneg <| by positivity ] ; exact h_arcsin_bound x hx ⟩ ⟩;
    rw [ Asymptotics.isBigO_iff ];
    field_simp;
    refine' ⟨ 2, Filter.eventually_atTop.mpr ⟨ 4, fun x hx => _ ⟩ ⟩ ; norm_num;
    rw [ abs_of_nonneg ( by positivity ), abs_of_nonneg ( Real.log_nonneg <| by rw [ le_div_iff₀ <| by positivity ] ; nlinarith [ inv_mul_cancel₀ ( by positivity : ( x ^ 2 ) ≠ 0 ) ] ) ];
    nlinarith [ inv_pos.mpr ( by positivity : 0 < x ), mul_inv_cancel₀ ( by positivity : x ≠ 0 ), Real.log_le_sub_one_of_pos ( by positivity : 0 < ( 4 + ( x ^ 2 ) ⁻¹ ) / 4 ), inv_pos.mpr ( by positivity : 0 < x ^ 2 ), mul_inv_cancel₀ ( by positivity : x ^ 2 ≠ 0 ) ]

/-
The asymptotic statement is false because the approximation grows unbounded while the argument is bounded.
-/
theorem stirling_arg_gamma_asymp_false :
    ¬ (fun (T : ℝ) => Complex.arg (Complex.Gamma (1/4 + Complex.I * T/2)) -
              stirling_approx T)
    =O[Filter.atTop] (fun (T : ℝ) => 1/T) := by
      -- By definition of $stirling_approx$, we know that $stirling_approx T$ tends to infinity as $T \to \infty$.
      have h_stirling_approx_inf : Filter.Tendsto (fun T : ℝ => (stirling_approx T)) Filter.atTop Filter.atTop := by
        unfold stirling_approx;
        -- We'll use the fact that $\log(T/2)$ grows faster than $T/2$.
        have h_log_growth : Filter.Tendsto (fun T : ℝ => Real.log (T / 2) - 1) Filter.atTop Filter.atTop := by
          exact Filter.tendsto_atTop_add_const_right _ _ ( Real.tendsto_log_atTop.comp <| Filter.tendsto_id.atTop_mul_const <| by norm_num );
        rw [ Filter.tendsto_atTop_atTop ] at *;
        exact fun x => by obtain ⟨ i, hi ⟩ := h_log_growth ( Max.max x 2 + 1 ) ; exact ⟨ Max.max i 2, fun a ha => by nlinarith [ hi a ( le_trans ( le_max_left i 2 ) ha ), le_max_left x 2, le_max_right x 2, le_max_left i 2, le_max_right i 2, Real.pi_le_four ] ⟩ ;
      -- Since `Complex.arg` is bounded by `pi`, the difference between `stirling_approx T` and `Complex.arg (Complex.Gamma (1 / 4 + Complex.I * T / 2))` cannot be `O(1 / T)`.
      intro h_contra
      have : Filter.Tendsto (fun T : ℝ => Complex.arg (Complex.Gamma (1 / 4 + Complex.I * T / 2)) - (stirling_approx T)) Filter.atTop Filter.atBot := by
        rw [ Filter.tendsto_atTop_atBot ];
        exact fun b => Filter.eventually_atTop.mp ( h_stirling_approx_inf.eventually_gt_atTop ( Real.pi - b ) ) |> fun ⟨ i, hi ⟩ => ⟨ i, fun a ha => by linarith [ hi a ha, Complex.neg_pi_lt_arg ( Complex.Gamma ( 1 / 4 + Complex.I * a / 2 ) ), Complex.arg_le_pi ( Complex.Gamma ( 1 / 4 + Complex.I * a / 2 ) ) ] ⟩;
      -- Since `Complex.arg` is bounded by `pi`, the difference between `stirling_approx T` and `Complex.arg (Complex.Gamma (1 / 4 + Complex.I * T / 2))` cannot be `O(1 / T)`. This contradicts our assumption.
      have : Filter.Tendsto (fun T : ℝ => Complex.arg (Complex.Gamma (1 / 4 + Complex.I * T / 2)) - (stirling_approx T)) Filter.atTop (nhds 0) := by
        exact h_contra.trans_tendsto ( tendsto_const_nhds.div_atTop Filter.tendsto_id );
      exact not_tendsto_atBot_of_tendsto_nhds this ‹_›

/-
The magnitude of 1/4 + iT/2 is at least |T|/2.
-/
lemma abs_s_ge_T_div_two (T : ℝ) : ‖1/4 + Complex.I * (T : ℂ) / 2‖ ≥ |T|/2 := by
  norm_num [ Complex.normSq, Complex.norm_def ];
  exact Real.le_sqrt_of_sq_le ( by nlinarith [ sq_nonneg ( T / 2 - 1 / 4 ), sq_nonneg ( T / 2 + 1 / 4 ), abs_mul_abs_self T ] )

/-
The relative error term in Stirling's approximation.
-/
noncomputable def stirling_epsilon (s : ℂ) : ℂ :=
  Complex.Gamma s / Complex.exp (stirling_term s) - 1

/-
Definition of Stirling's Formula as a proposition.
-/
def StirlingFormula : Prop :=
  ∃ C, ∀ s : ℂ, 1 ≤ s.re → ‖Complex.Gamma s / Complex.exp (stirling_term s) - 1‖ ≤ C / ‖s‖

/-
The Stirling approximation inequality for arg Gamma is false for large T due to the branch cut.
-/
theorem stirling_arg_gamma_false :
    ¬ ∃ C, ∀ T : ℝ, 2 ≤ T → |Complex.arg (Complex.Gamma (1/4 + Complex.I * (T : ℂ)/2)) -
     ((T/2) * Real.log (T/2) - T/2 - Real.pi/8)| ≤ C / T := by
       -- Assume an error term `e` and deduce a contradiction.
       by_contra h
       obtain ⟨C, hC⟩ := h

       -- From the error term `e`, deduce a contradiction.
       have h1 : (fun (T : ℝ) => Complex.arg (Complex.Gamma (1 / 4 + Complex.I * T / 2)) - (T / 2 * Real.log (T / 2) - T / 2 - Real.pi / 8)) =O[Filter.atTop] (fun (T : ℝ) => 1 / T) := by
         refine' Asymptotics.isBigO_iff.mpr _;
         exact ⟨ C, Filter.eventually_atTop.mpr ⟨ 2, fun T hT => by simpa [ abs_of_nonneg ( by linarith : ( 0 : ℝ ) ≤ T ) ] using hC T hT ⟩ ⟩;
       exact absurd h1 ( by simpa using stirling_arg_gamma_asymp_false )