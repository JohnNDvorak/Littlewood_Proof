/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 859116c5-e6db-41f3-9532-23c647282c20

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Partial Dirichlet sum and its squared norm expansion.

KEY RESULTS (PROVED):
- partialZetaSum: Σ_{n=1}^N n^{-s}
- normSq_partialZetaSum_eq: |partialZetaSum(N,s)|² = ΣΣ (nm)^{-σ} cos(t log(n/m))

This is the key algebraic identity for mean square estimates of ζ(s).
The proof uses:
- Complex.normSq_eq_norm_sq
- Complex.cpow_def_of_ne_zero
- Real.log_mul, Real.log_div
- Real.cos_sub, Real.sin_sub
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-- The partial Dirichlet sum for the Riemann zeta function: Σ_{n=1}^N n^{-s} -/
def partialZetaSum (N : ℕ) (s : ℂ) : ℂ := ∑ n ∈ Finset.range N, (n + 1 : ℂ) ^ (-s)

/-- The squared norm of the partial zeta sum expands as a double sum.
    This is the key algebraic identity for mean square estimates:
    |Σ n^{-s}|² = ΣΣ (nm)^{-σ} cos(t log(n/m))
    where s = σ + it. -/
lemma normSq_partialZetaSum_general (N : ℕ) (s : ℂ) :
    Complex.normSq (partialZetaSum N s) =
    ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N,
      ((n + 1 : ℝ) * (m + 1 : ℝ)) ^ (-s.re) *
      Real.cos (s.im * Real.log ((n + 1 : ℝ) / (m + 1 : ℝ))) := by
        -- By definition of $partialZetaSum$, we have
        have h_def : Complex.normSq (partialZetaSum N s) = (∑ n ∈ Finset.range N, (∑ m ∈ Finset.range N, ((n + 1) : ℂ) ^ (-s) * ((m + 1) : ℂ) ^ (-starRingEnd ℂ s))) := by
          -- By definition of $partialZetaSum$, we have $partialZetaSum N s = \sum_{n=0}^{N-1} (n+1)^{-s}$.
          have h_partialZetaSum : partialZetaSum N s = ∑ n ∈ Finset.range N, ((n + 1) : ℂ) ^ (-s) := by
            rfl;
          simp +decide [ h_partialZetaSum, Complex.normSq_eq_norm_sq, ← Finset.mul_sum _ _ _, ← Finset.sum_mul ];
          have h_conj : ∑ n ∈ Finset.range N, ((n + 1) : ℂ) ^ (-starRingEnd ℂ s) = starRingEnd ℂ (∑ n ∈ Finset.range N, ((n + 1) : ℂ) ^ (-s)) := by
            simp +decide [ Complex.cpow_def ];
            norm_cast ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ];
          rw [ h_conj, Complex.mul_conj, Complex.normSq_eq_norm_sq, Complex.ofReal_pow ];
        -- By definition of exponentiation for complex numbers, we can write $(n+1)^{-s} = e^{-s \ln(n+1)}$ and $(m+1)^{-\overline{s}} = e^{-\overline{s} \ln(m+1)}$.
        have h_exp : ∀ n m : ℕ, ((n + 1) : ℂ) ^ (-s) * ((m + 1) : ℂ) ^ (-starRingEnd ℂ s) = Real.exp (-s.re * Real.log ((n + 1) * (m + 1))) * Complex.exp (Complex.I * (-s.im * Real.log ((n + 1) / (m + 1)))) := by
          intro n m
          have h_exp : ((n + 1) : ℂ) ^ (-s) = Complex.exp (-s * Real.log (n + 1)) ∧ ((m + 1) : ℂ) ^ (-starRingEnd ℂ s) = Complex.exp (-starRingEnd ℂ s * Real.log (m + 1)) := by
            constructor <;> rw [ Complex.cpow_def_of_ne_zero ] <;> norm_cast <;> norm_num;
            · ring;
            · ring;
          simp_all +decide [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Real.log_mul ( by positivity : ( n:ℝ ) + 1 ≠ 0 ) ( by positivity : ( m:ℝ ) + 1 ≠ 0 ), Real.log_div ( by positivity : ( n:ℝ ) + 1 ≠ 0 ) ( by positivity : ( m:ℝ ) + 1 ≠ 0 ) ];
          norm_num [ ← h_def.2 ] at *;
          norm_num [ Real.cos_sub, Real.sin_sub, mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm, ← Real.exp_add ] ; ring;
          norm_num [ Real.cos_sub, Real.sin_sub, Real.exp_sub ] ; ring;
          exact ⟨ by rw [ ← Real.exp_neg ] ; ring, by rw [ ← Real.exp_neg ] ; ring ⟩;
        convert congr_arg Complex.re h_def using 1 ; simp_all +decide [ Complex.exp_re, Complex.exp_im ];
        exact Finset.sum_congr rfl fun i hi => Finset.sum_congr rfl fun j hj => by rw [ Real.rpow_def_of_pos ( by positivity ) ] ; ring;

end
