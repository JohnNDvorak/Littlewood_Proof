/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eb15349b-a271-46ef-b854-cb7c2cc401fe

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Contents:
- Gamma function growth bounds
- Cosine growth bounds for functional equation
- Harmonic sum bounds
- Partial Dirichlet sum bounds
- Euler-Maclaurin integral infrastructure
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The magnitude of cos(π(1 - it)/2) is asymptotically O(exp(π|t|/2)).
-/
lemma norm_cos_pi_div_two_sub_I_mul_t_div_two_asymp :
    (fun t : ℝ => ‖Complex.cos (Real.pi * (1 - Complex.I * t) / 2)‖) =O[Filter.cocompact ℝ] (fun t => Real.exp (Real.pi * |t| / 2)) := by
      refine' Asymptotics.isBigO_iff.mpr _;
      use 3, ?_ ; norm_num;
      constructor <;> use 0 <;> intro x hx <;> rw [ Complex.norm_def ];
      · norm_num [ Complex.normSq, Complex.exp_re, Complex.exp_im, Complex.cos ];
        field_simp;
        rw [ Real.sqrt_sq_eq_abs, abs_le ] ; constructor <;> cases abs_cases x <;> nlinarith [ Real.exp_pos ( Real.pi * x / 2 ), Real.exp_pos ( - ( Real.pi * x / 2 ) ), Real.exp_le_exp.mpr ( show Real.pi * x / 2 ≤ Real.pi * |x| / 2 by nlinarith [ Real.pi_pos ] ), Real.exp_le_exp.mpr ( show - ( Real.pi * x / 2 ) ≤ Real.pi * |x| / 2 by nlinarith [ Real.pi_pos ] ) ];
      · rw [ Real.sqrt_le_left <| by positivity ] ; norm_num [ Complex.normSq, Complex.cos, Complex.exp_re, Complex.exp_im ] ; ring_nf;
        norm_num [ ← Real.exp_add, sq, abs_of_nonneg hx ] ; ring_nf ; norm_num [ Real.pi_pos.le ];
        nlinarith [ Real.pi_pos, Real.exp_pos ( Real.pi * x ), Real.exp_pos ( - ( Real.pi * x ) ), Real.exp_le_one_iff.mpr ( show - ( Real.pi * x ) ≤ 0 by nlinarith [ Real.pi_pos ] ) ]

/-
The magnitude of Gamma(1 - it) is asymptotically O(|t|^(1/2) * exp(-π|t|/2)).
-/
lemma norm_gamma_one_sub_I_mul_t_asymp :
    (fun t : ℝ => ‖Complex.Gamma (1 - Complex.I * t)‖) =O[Filter.cocompact ℝ] (fun t => |t| ^ (1 / 2 : ℝ) * Real.exp (-Real.pi * |t| / 2)) := by
      refine' Asymptotics.isBigO_iff.mpr _;
      -- Use the fact that $|\Gamma(1-it)| \sim \sqrt{2\pi} |t|^{-1/2} e^{-\pi|t|/2}$ as $|t| \to \infty$.
      have h_gamma_asymptotic : ∃ C : ℝ, ∀ t : ℝ, |t| ≥ 1 → ‖Complex.Gamma (1 - Complex.I * t)‖ ≤ C * |t| ^ (1 / 2 : ℝ) * Real.exp (-Real.pi * |t| / 2) := by
        use 2 * Real.sqrt ( 2 * Real.pi );
        intro t ht;
        -- Use the fact that $|\Gamma(1-it)| = \sqrt{\frac{\pi |t|}{\sinh(\pi |t|)}}$.
        have h_gamma_abs : ‖Complex.Gamma (1 - Complex.I * t)‖ = Real.sqrt (Real.pi * |t| / Real.sinh (Real.pi * |t|)) := by
          have h_gamma_abs : ‖Complex.Gamma (1 - Complex.I * t)‖ ^ 2 = Real.pi * |t| / Real.sinh (Real.pi * |t|) := by
            have h_gamma_sq : ‖Complex.Gamma (1 - Complex.I * t)‖^2 = Real.pi * |t| / Real.sinh (Real.pi * |t|) := by
              have h_gamma_sq_def : Complex.Gamma (1 - Complex.I * t) * Complex.Gamma (1 + Complex.I * t) = Real.pi * |t| / Real.sinh (Real.pi * |t|) := by
                have := @Complex.Gamma_mul_Gamma_one_sub ( Complex.I * t );
                convert congr_arg ( fun x => x * ( Complex.I * t ) ) this using 1 <;> ring;
                · rw [ show 1 + Complex.I * t = Complex.I * t + 1 by ring, Complex.Gamma_add_one ] <;> ring ; norm_num [ Complex.ext_iff ];
                  rintro rfl; norm_num at ht;
                · norm_num [ Complex.sin, Complex.exp_re, Complex.exp_im, Real.sinh_eq ] ; ring;
                  cases abs_cases t <;> simp +decide [ * ] <;> ring;
                  · norm_num [ ← sub_mul, mul_assoc ];
                    norm_num [ ← mul_assoc ];
                  · norm_num [ Complex.normSq, Complex.ext_iff ] ; ring;
                    norm_num
              have h_gamma_sq_def : Complex.Gamma (1 + Complex.I * t) = starRingEnd ℂ (Complex.Gamma (1 - Complex.I * t)) := by
                convert Complex.Gamma_conj ( 1 - Complex.I * t ) using 1 ; norm_num;
              simp_all +decide [ Complex.ext_iff, sq ];
              norm_cast at *; simp_all +decide [ Complex.normSq, Complex.norm_def ] ;
              rw [ Real.mul_self_sqrt ( div_nonneg ( mul_nonneg Real.pi_pos.le ( abs_nonneg t ) ) ( Real.sinh_nonneg_iff.mpr ( mul_nonneg Real.pi_pos.le ( abs_nonneg t ) ) ) ) ];
            exact h_gamma_sq;
          rw [ ← h_gamma_abs, Real.sqrt_sq ( norm_nonneg _ ) ];
        -- Use the fact that $\sinh(\pi |t|) \geq \frac{e^{\pi |t|}}{4}$ for $|t| \geq 1$.
        have h_sinh_bound : Real.sinh (Real.pi * |t|) ≥ Real.exp (Real.pi * |t|) / 4 := by
          rw [ Real.sinh_eq ];
          nlinarith [ Real.pi_gt_three, abs_nonneg t, Real.exp_pos ( Real.pi * |t| ), Real.exp_neg ( Real.pi * |t| ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * |t| ) ) ), Real.add_one_le_exp ( Real.pi * |t| ), Real.add_one_le_exp ( - ( Real.pi * |t| ) ) ];
        -- Substitute the bound for $\sinh(\pi |t|)$ into the expression for $|\Gamma(1-it)|$.
        have h_gamma_bound : ‖Complex.Gamma (1 - Complex.I * t)‖ ≤ Real.sqrt (4 * Real.pi * |t| * Real.exp (-Real.pi * |t|)) := by
          rw [ h_gamma_abs ];
          refine Real.sqrt_le_sqrt ?_;
          rw [ div_le_iff₀ ] <;> norm_num [ Real.exp_neg ];
          · field_simp;
            linarith;
          · positivity;
        refine le_trans h_gamma_bound ?_;
        rw [ Real.sqrt_le_iff ] ; ring ; norm_num [ Real.exp_neg, Real.exp_mul, Real.exp_log, Real.pi_pos.le ];
        norm_num [ ← Real.sqrt_eq_rpow, mul_pow, Real.pi_pos.le ];
        exact ⟨ by positivity, by rw [ Real.sq_sqrt ( by positivity ) ] ; exact mul_le_mul_of_nonneg_right ( by nlinarith [ Real.pi_pos, abs_nonneg t ] ) ( by positivity ) ⟩;
      cases' h_gamma_asymptotic with C hC;
      norm_num [ abs_of_nonneg, Real.rpow_nonneg ] at *;
      exact ⟨ C, ⟨ -2, fun t ht => by convert hC t ( by cases abs_cases t <;> linarith ) using 1 ; ring ⟩, 2, fun t ht => by convert hC t ( by cases abs_cases t <;> linarith ) using 1 ; ring ⟩

/-
The magnitude of the constant factor in the functional equation is O(1).
-/
lemma norm_two_mul_two_pi_pow_sub_one_plus_I_mul_t_asymp :
    (fun t : ℝ => ‖2 * (2 * (Real.pi : ℂ)) ^ (-(1 - Complex.I * t))‖) =O[Filter.cocompact ℝ] (fun t => (1 : ℝ)) := by
      refine' Asymptotics.isBigO_iff.mpr _;
      refine' ⟨ 2 * ( 2 * Real.pi ) ^ ( -1 : ℝ ), _ ⟩;
      norm_num [ Complex.norm_cpow_of_ne_zero, Real.pi_ne_zero ];
      norm_num [ Complex.arg ];
      exact ⟨ ⟨ -1, fun x hx => by rw [ abs_of_nonneg ( by positivity ), if_pos ( by positivity ) ] ; norm_num [ abs_of_nonneg, Real.pi_pos.le ] ⟩, ⟨ 1, fun x hx => by rw [ abs_of_nonneg ( by positivity ), if_pos ( by positivity ) ] ; norm_num [ abs_of_nonneg, Real.pi_pos.le ] ⟩ ⟩

/-
The magnitude of zeta(1 - it) is equal to the magnitude of zeta(1 + it).
-/
lemma zeta_conj_eq : ∀ t : ℝ, ‖riemannZeta (1 - Complex.I * t)‖ = ‖riemannZeta (1 + Complex.I * t)‖ := by
  -- By definition of zeta, we know that for any complex number $s$, $\zeta(\overline{s}) = \overline{\zeta(s)}$.
  have h_conj : ∀ s : ℂ, riemannZeta (starRingEnd ℂ s) = starRingEnd ℂ (riemannZeta s) := by
    intro s;
    -- By definition of the Riemann zeta function, we know that it is analytic in the region $\operatorname{Re}(s) > 1$.
    have h_analytic : ∀ s : ℂ, 1 < s.re → riemannZeta s = ∑' n : ℕ, (1 : ℂ) / (n + 1 : ℂ) ^ s := by
      exact fun s hs => zeta_eq_tsum_one_div_nat_add_one_cpow hs;
    -- By definition of the Riemann zeta function, we know that it is analytic in the region $\operatorname{Re}(s) > 1$, and thus we can apply the functional equation.
    have h_analytic : ∀ s : ℂ, 1 < s.re → riemannZeta (starRingEnd ℂ s) = starRingEnd ℂ (riemannZeta s) := by
      intro s hs; rw [ h_analytic s hs, h_analytic ( starRingEnd ℂ s ) ] ; norm_num;
      · rw [ Complex.conj_tsum ];
        refine' tsum_congr fun n => _;
        rw [ Complex.cpow_def_of_ne_zero ( Nat.cast_add_one_ne_zero n ), Complex.cpow_def_of_ne_zero ( Nat.cast_add_one_ne_zero n ) ] ; norm_num;
        norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ];
        norm_cast ; norm_num [ Real.cos_add, Real.sin_add ];
      · simpa using hs;
    -- By definition of the Riemann zeta function, we know that it is analytic in the region $\operatorname{Re}(s) > 1$, and thus we can apply the functional equation to extend the result to all $s$.
    have h_analytic_ext : ∀ s : ℂ, s ≠ 1 → riemannZeta (starRingEnd ℂ s) = starRingEnd ℂ (riemannZeta s) := by
      intro s hs_ne_one
      have h_analytic_ext : AnalyticOn ℂ (fun s : ℂ => riemannZeta s - starRingEnd ℂ (riemannZeta (starRingEnd ℂ s))) (Set.univ \ {1}) := by
        apply_rules [ DifferentiableOn.analyticOn ];
        · refine' DifferentiableOn.sub _ _;
          · intro s hs_ne_one; exact (by
            refine' DifferentiableAt.differentiableWithinAt _;
            apply_rules [ differentiableAt_riemannZeta ] ; aesop);
          · intro s hs_ne_one
            have h_diff : DifferentiableAt ℂ riemannZeta (starRingEnd ℂ s) := by
              apply_rules [ differentiableAt_riemannZeta ];
              exact fun h => hs_ne_one.2 <| by simpa [ Complex.ext_iff ] using congr_arg Star.star h;
            refine' DifferentiableAt.differentiableWithinAt _;
            have h_diff : HasDerivAt (fun s : ℂ => starRingEnd ℂ (riemannZeta (starRingEnd ℂ s))) (starRingEnd ℂ (deriv riemannZeta (starRingEnd ℂ s))) s := by
              rw [ hasDerivAt_iff_tendsto_slope_zero ];
              have := h_diff.hasDerivAt.tendsto_slope_zero;
              convert Complex.continuous_conj.continuousAt.tendsto.comp ( this.comp ( show Filter.Tendsto ( fun t : ℂ => starRingEnd ℂ t ) ( nhdsWithin 0 { 0 } ᶜ ) ( nhdsWithin 0 { 0 } ᶜ ) from Filter.Tendsto.inf ( Continuous.tendsto' ( by continuity ) _ _ <| by norm_num ) <| by norm_num ) ) using 2 ; norm_num;
            exact h_diff.differentiableAt;
        · exact isOpen_univ.sdiff isClosed_singleton;
      have h_analytic_ext : ∀ s : ℂ, s ≠ 1 → riemannZeta s - starRingEnd ℂ (riemannZeta (starRingEnd ℂ s)) = 0 := by
        intro s hs_ne_one
        have h_zero : ∀ s : ℂ, 1 < s.re → riemannZeta s - starRingEnd ℂ (riemannZeta (starRingEnd ℂ s)) = 0 := by
          aesop;
        have h_zero : AnalyticOnNhd ℂ (fun s : ℂ => riemannZeta s - starRingEnd ℂ (riemannZeta (starRingEnd ℂ s))) (Set.univ \ {1}) := by
          intro s hs_ne_one; exact (by
          apply_rules [ DifferentiableOn.analyticAt, h_analytic_ext ];
          exact h_analytic_ext.differentiableOn;
          exact IsOpen.mem_nhds ( isOpen_univ.sdiff isClosed_singleton ) hs_ne_one);
        apply h_zero.eqOn_zero_of_preconnected_of_frequently_eq_zero;
        any_goals exact Complex.I + 1;
        · have h_connected : IsConnected (Set.univ \ {1} : Set ℂ) := by
            have h_connected : IsConnected (Set.univ \ {0} : Set ℂ) := by
              have h_connected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
                exact isConnected_range ( Complex.continuous_exp );
              convert h_connected using 1;
              ext; simp [Complex.exp_ne_zero];
            convert h_connected.image _ _ using 1;
            rotate_left;
            use fun s => s + 1;
            · exact continuousOn_id.add continuousOn_const;
            · ext; simp [Set.mem_image];
          exact h_connected.isPreconnected;
        · norm_num [ Complex.ext_iff ];
        · rw [ Metric.nhdsWithin_basis_ball.frequently_iff ];
          intro ε ε_pos;
          refine' ⟨ Complex.I + 1 + ε / 2, _, _ ⟩ <;> norm_num [ Complex.ext_iff, ε_pos.ne' ];
          · linarith [ abs_of_pos ε_pos ];
          · have := ‹∀ s : ℂ, 1 < s.re → riemannZeta s - ( starRingEnd ℂ ) ( riemannZeta ( starRingEnd ℂ s ) ) = 0› ( Complex.I + 1 + ε / 2 ) ( by norm_num [ Complex.ext_iff, ε_pos ] ) ; norm_num [ Complex.ext_iff ] at * ; aesop;
        · grind;
      specialize h_analytic_ext s hs_ne_one; rw [ sub_eq_zero ] at h_analytic_ext; aesop;
    by_cases hs : s = 1 <;> simp_all +decide;
    rw [ riemannZeta_one ] ; norm_num;
    norm_num [ Complex.ext_iff, Complex.log_re, Complex.log_im ];
    norm_num [ Complex.normSq, Complex.div_re, Complex.div_im, Complex.log_re, Complex.log_im, abs_of_pos Real.pi_pos ];
    norm_num [ Complex.arg ] ; ring ; norm_num [ Real.pi_pos.ne' ];
    split_ifs <;> linarith [ Real.pi_pos ];
  intro t; convert congr_arg Norm.norm ( h_conj ( 1 + Complex.I * t ) ) using 1 ; norm_num [ Complex.normSq, Complex.norm_def ] ; ring;
  norm_num [ Complex.normSq, Complex.norm_def ]

/-
The harmonic sum $\sum_{i=1}^n \frac{1}{i}$ is bounded by $1 + \log n$.
-/
lemma harmonic_le_one_plus_log (n : ℕ) (hn : n ≥ 1) :
    ∑ i ∈ Finset.Icc 1 n, (1 : ℝ) / i ≤ 1 + Real.log n := by
      induction' hn with n hn ih <;> norm_num [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] at *;
      rw [ show ( n : ℝ ) + 1 = n * ( 1 + ( n : ℝ ) ⁻¹ ) by nlinarith only [ mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ) ], Real.log_mul ( by positivity ) ( by positivity ) ];
      nlinarith [ inv_pos.mpr ( by positivity : 0 < ( n : ℝ ) * ( 1 + ( n : ℝ ) ⁻¹ ) ), mul_inv_cancel₀ ( by positivity : ( n : ℝ ) * ( 1 + ( n : ℝ ) ⁻¹ ) ≠ 0 ), Real.log_inv ( 1 + ( n : ℝ ) ⁻¹ ), Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by positivity : 0 < ( 1 + ( n : ℝ ) ⁻¹ ) ) ), mul_inv_cancel₀ ( by positivity : ( n : ℝ ) ≠ 0 ), mul_inv_cancel₀ ( by positivity : ( 1 + ( n : ℝ ) ⁻¹ ) ≠ 0 ) ]

/-
The partial sum of the Dirichlet series for zeta on the line 1 is bounded by 1 + log N.
-/
lemma partial_sum_bound (t : ℝ) (N : ℕ) (hN : N ≥ 1) :
    ‖∑ n ∈ Finset.range N, 1 / (n + 1 : ℂ) ^ (1 + Complex.I * t)‖ ≤ 1 + Real.log N := by
      refine' le_trans ( norm_sum_le _ _ ) _;
      -- Apply the bound on the norm of the sum.
      have h_norm : ∀ n : ℕ, ‖(1 : ℂ) / ((n + 1) : ℂ) ^ (1 + Complex.I * t)‖ = 1 / (n + 1 : ℝ) := by
        intro n; rw [ one_div ] ; norm_num [ Complex.norm_cpow_of_ne_zero, Nat.cast_add_one_ne_zero ] ;
        norm_cast ; norm_num [ Complex.arg ];
      convert harmonic_le_one_plus_log N hN using 1;
      erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ', h_norm ];
      exact Finset.sum_congr rfl fun _ _ => by simpa using h_norm _;

/-
The integral of the fractional part term over [n, n+1] relates to the zeta series terms.
-/
lemma integral_fract_term (s : ℂ) (n : ℕ) (hn : n ≥ 1) (hs : s ≠ 1) (hs_pos : 0 < s.re) :
    -s * ∫ x in Set.Ioc (n : ℝ) (n + 1), ((x - n : ℝ) : ℂ) / (x : ℂ) ^ (s + 1) =
    (n + 1 : ℂ) ^ (-s) - (1 / (s - 1)) * ((n : ℂ) ^ (1 - s) - (n + 1 : ℂ) ^ (1 - s)) := by
      -- Use integration by parts with $u = x - n$ and $dv = x^{-s-1} dx$.
      have h_parts : ∀ a b : ℝ, 1 ≤ a → a < b → ∫ x in a..b, (x - n) / (x : ℂ) ^ (s + 1) = ((b - n) * (b : ℂ) ^ (-s)) / (-s) - ((a - n) * (a : ℂ) ^ (-s)) / (-s) - ∫ x in a..b, (x : ℂ) ^ (-s) / (-s) := by
        intros a b ha hb
        have h_parts : ∫ x in a..b, (x - n) * (x : ℂ) ^ (-(s + 1)) = ((b - n) * (b : ℂ) ^ (-s)) / (-s) - ((a - n) * (a : ℂ) ^ (-s)) / (-s) - ∫ x in a..b, (x : ℂ) ^ (-s) / (-s) := by
          rw [ intervalIntegral.integral_mul_deriv_eq_deriv_mul ];
          any_goals intro x hx; exact HasDerivAt.sub ( HasDerivAt.ofReal_comp ( hasDerivAt_id x ) ) ( hasDerivAt_const _ _ );
          rotate_right;
          use fun x => ( x : ℂ ) ^ ( -s ) / ( -s );
          · norm_num [ mul_div_assoc ];
          · intro x hx; convert HasDerivAt.div_const ( HasDerivAt.comp x ( hasDerivAt_id _ |> HasDerivAt.cpow_const <| ?_ ) <| hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) _ using 1 <;> norm_num ; ring;
            · rw [ mul_right_comm, mul_inv_cancel₀ ( by rintro rfl; norm_num at hs_pos ), one_mul ];
            · cases Set.mem_uIcc.mp hx <;> linarith;
          · norm_num;
          · apply_rules [ ContinuousOn.intervalIntegrable ];
            exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.cpow ( Complex.continuous_ofReal.continuousAt ) continuousAt_const <| Or.inl <| by norm_cast; cases Set.mem_uIcc.mp hx <;> linarith;
        convert h_parts using 1;
        refine' intervalIntegral.integral_congr fun x hx => _;
        rw [ div_eq_mul_inv, Complex.cpow_neg ];
      convert congr_arg ( fun x : ℂ => -s * x ) ( h_parts ( n : ℝ ) ( n + 1 ) ( by norm_cast ) ( by norm_num ) ) using 1;
      · norm_num [ intervalIntegral.integral_of_le, MeasureTheory.integral_Ioc_eq_integral_Ioo ];
      · -- Evaluate the remaining integral.
        have h_eval : ∫ x in (n : ℝ)..n + 1, (x : ℂ) ^ (-s) = ((n + 1 : ℂ) ^ (1 - s) - (n : ℂ) ^ (1 - s)) / (1 - s) := by
          rw [ integral_cpow ];
          · push_cast; ring;
          · exact Or.inr ⟨ by contrapose! hs; aesop, Set.notMem_uIcc_of_lt ( by norm_num; linarith ) ( by linarith ) ⟩;
        rw [ intervalIntegral.integral_div, h_eval ] ; ring;
        rw [ show ( -1 + s ) = - ( 1 - s ) by ring, inv_neg ] ; norm_num [ mul_assoc, mul_comm s, show s ≠ 0 by rintro rfl; norm_num at hs_pos ] ; ring

/-
Summation of the integral identity.
-/
lemma sum_integral_fract_term (s : ℂ) (N M : ℕ) (hN : N ≥ 1) (hNM : N ≤ M) (hs : s ≠ 1) (hs_pos : 0 < s.re) :
    ∑ n ∈ Finset.Ico N (M + 1), (-s * ∫ x in Set.Ioc (n : ℝ) (n + 1), ((x - n : ℝ) : ℂ) / (x : ℂ) ^ (s + 1)) =
    ∑ n ∈ Finset.Ico N (M + 1), ((n + 1 : ℂ) ^ (-s) - (1 / (s - 1)) * ((n : ℂ) ^ (1 - s) - (n + 1 : ℂ) ^ (1 - s))) := by
      -- This is just summing the result of `integral_fract_term`.
      refine' Finset.sum_congr rfl fun n hn => _;
      rw [ integral_fract_term s n ( by simp at hn; linarith ) hs hs_pos ];

/-
The integral of the fractional part term over [n, n+1] is bounded.
-/
lemma integral_fract_bound (n : ℕ) (s : ℂ) (hn : n ≥ 1) (hs : 0 < s.re) :
    ‖∫ x in Set.Ioc (n : ℝ) (n + 1), ((Int.fract x : ℝ) : ℂ) / (x : ℂ) ^ (s + 1)‖ ≤ (n : ℝ) ^ (-s.re - 1) := by
      -- Increase $N$ to get better approximation. Bound the integral using the fact that $|Int.fract x| \leq 1$ for all $x$.
      have h_integral_bound : ‖∫ x in Set.Ioc (n : ℝ) (n + 1), (Int.fract x : ℝ) / (x : ℂ) ^ (s + 1)‖ ≤ ∫ x in Set.Ioc (n : ℝ) (n + 1), 1 / (x : ℝ) ^ (s.re + 1) := by
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
        · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
        · exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.div continuousAt_const ( ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hx.1, show ( n : ℝ ) ≥ 1 by norm_cast ] ) <| ne_of_gt <| Real.rpow_pos_of_pos ( by linarith [ hx.1, show ( n : ℝ ) ≥ 1 by norm_cast ] ) _ ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with x hx;
          have h_integral_bound : ‖(Int.fract x : ℝ) / (x : ℂ) ^ (s + 1)‖ ≤ ‖(Int.fract x : ℝ)‖ / ‖(x : ℂ) ^ (s + 1)‖ := by
            norm_num [ Complex.norm_exp ];
          refine le_trans h_integral_bound ?_;
          gcongr;
          · exact Real.rpow_pos_of_pos ( lt_trans ( Nat.cast_pos.mpr hn ) hx.1 ) _;
          · exact abs_le.mpr ⟨ by linarith [ Int.fract_nonneg x ], by linarith [ Int.fract_lt_one x ] ⟩;
          · have := Complex.norm_cpow_eq_rpow_re_of_pos ( show 0 < x by linarith [ hx.1, show ( n : ℝ ) ≥ 1 by norm_cast ] ) ( s + 1 ) ; aesop;
      refine' le_trans h_integral_bound ( le_trans ( MeasureTheory.setIntegral_mono_on _ _ _ _ ) _ ) <;> norm_num;
      refine' fun x => ( n : ℝ ) ^ ( -s.re - 1 );
      · exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.inv₀ ( ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by linarith [ hx.1, show ( n : ℝ ) ≥ 1 by norm_cast ] ) <| ne_of_gt <| Real.rpow_pos_of_pos ( by linarith [ hx.1, show ( n : ℝ ) ≥ 1 by norm_cast ] ) _ ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
      · norm_num;
      · intro x hx₁ hx₂; rw [ show ( -s.re - 1 : ℝ ) = - ( s.re + 1 ) by ring, Real.rpow_neg ( by positivity ) ] ; exact inv_anti₀ ( by positivity ) ( by exact Real.rpow_le_rpow ( by positivity ) hx₁.le ( by positivity ) ) ;
      · norm_num [ Real.rpow_neg ( Nat.cast_nonneg _ ) ]

end
