/-
Laurent Expansion of -ζ'/ζ - Generated by Aristotle (Harmonic)
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/
import Mathlib

set_option maxHeartbeats 400000

open scoped BigOperators Real Nat Classical Pointwise

noncomputable section

/-- ζ(s) multiplied by (s-1), with value 1 at s=1.
    This removes the pole and gives an analytic function. -/
def zetaMulSubOne (s : ℂ) : ℂ := if s = 1 then 1 else (s - 1) * riemannZeta s

/-- The residue of -ζ'/ζ at s = 1 is 1.
    This follows from ζ having a simple pole with residue 1. -/
theorem neg_zeta_logDeriv_residue_one :
    Filter.Tendsto (fun s => (s - 1) * (-deriv riemannZeta s / riemannZeta s))
                   (nhdsWithin 1 {1}ᶜ) (nhds 1) := by
  -- Near s = 1: ζ(s) ~ 1/(s-1), so log ζ(s) ~ -log(s-1)
  -- Thus ζ'/ζ ~ -1/(s-1), and -ζ'/ζ ~ 1/(s-1)
  -- So (s-1) * (-ζ'/ζ) → 1 as s → 1
  -- BLOCKED: Requires riemannZeta_residue_one and logarithmic derivative computation
  sorry

/-- Near s = 1, (s-1) * (-ζ'/ζ) - 1 is bounded. -/
theorem neg_zeta_logDeriv_principal_part :
    ∃ r > 0, ∃ M, ∀ s, s ≠ 1 → ‖s - 1‖ < r →
    ‖(s - 1) * (-deriv riemannZeta s / riemannZeta s) - 1‖ ≤ M := by
  -- This follows from neg_zeta_logDeriv_residue_one and continuity
  -- BLOCKED: Same as above
  sorry

/-- zetaMulSubOne is continuous at s = 1 -/
theorem zetaMulSubOne_continuousAt_one : ContinuousAt zetaMulSubOne 1 := by
  -- Use riemannZeta_residue_one: (s-1)*ζ(s) → 1 as s → 1
  -- Strategy: zetaMulSubOne 1 = 1, and on {1}ᶜ it equals (s-1)*ζ(s) which → 1
  rw [ContinuousAt]
  have hval : zetaMulSubOne 1 = 1 := by simp [zetaMulSubOne]
  rw [hval]
  -- Need: Tendsto zetaMulSubOne (nhds 1) (nhds 1)
  -- Key: on punctured nhds, zetaMulSubOne = (s-1)*ζ(s), which → 1
  have hres := riemannZeta_residue_one
  -- Use tendsto_nhds_iff_forall_eventually
  rw [Metric.tendsto_nhds]
  intro ε hε
  -- From riemannZeta_residue_one, we know (s-1)*ζ(s) → 1
  rw [Metric.tendsto_nhds] at hres
  specialize hres ε hε
  rw [Filter.Eventually, Metric.mem_nhdsWithin_iff] at hres
  obtain ⟨δ, hδ_pos, hball⟩ := hres
  rw [Filter.Eventually, Metric.mem_nhds_iff]
  use δ, hδ_pos
  intro s hs
  by_cases h : s = 1
  · simp [h, hval, hε]
  · have hs' : s ∈ Metric.ball (1 : ℂ) δ ∩ {(1 : ℂ)}ᶜ := ⟨hs, h⟩
    have hdist := hball hs'
    simp only [Set.mem_setOf_eq] at hdist
    simp only [zetaMulSubOne, if_neg h, Set.mem_setOf_eq]
    exact hdist

end
