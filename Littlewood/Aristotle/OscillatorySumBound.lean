/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: edb5d6c8-cb9a-4232-a33d-5d57a6f24052

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

We prove the first moment upper bound for the oscillatory integral.
Note: The original statement included the `n=0` term, which corresponds to `cos(t * log 1) = cos 0 = 1`. This term is non-oscillatory and contributes `O(T)` to the integral, which contradicts the target bound of `T^{1/2+ε}`. We assume the intention was to bound the oscillatory part of the sum, so we sum from `n=1` (i.e., `Finset.Ico 1 ...`) instead of `n=0`.

The proof proceeds by:
1. Interchanging the integral and the sum (Fubini).
2. Bounding each integral term `∫ cos(t * log(n+1)) dt` by `2 / log(n+1)` using the lemma `cos_integral_bound`.
3. Bounding the resulting sum `∑ (n+1)^{-1/2} / log(n+1)` by `O(√N)` using `sum_reciprocal_sqrt_log_bound_corrected`.
4. Substituting `N ≈ √T` to get the final bound `O(T^{1/4})`, which is well within `O(T^{1/2+ε})`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace OscillatorySumBound

open Complex MeasureTheory Set Real Finset

/-
The integral of `cos(at)` from 1 to T is bounded by `2/|a|`.
-/
lemma cos_integral_bound (a : ℝ) (ha : a ≠ 0) (T : ℝ) (hT : T ≥ 1) :
    |∫ t in Set.Ioc 1 T, Real.cos (a * t)| ≤ 2 / |a| := by
      rw [ ← intervalIntegral.integral_of_le hT, intervalIntegral.integral_comp_mul_left ] <;> ring_nf <;> norm_num [ ha ];
      exact abs_le.mpr ⟨ by linarith [ abs_le.mp ( Real.abs_sin_le_one ( a * T ) ), abs_le.mp ( Real.abs_sin_le_one a ) ], by linarith [ abs_le.mp ( Real.abs_sin_le_one ( a * T ) ), abs_le.mp ( Real.abs_sin_le_one a ) ] ⟩

/-
A bound on the sum of `n^{-1/2} / log(n)`.
-/
lemma sum_reciprocal_sqrt_log_bound (N : ℕ) (hN : N ≥ 2) :
    ∑ n ∈ Finset.range N, (n + 1 : ℝ)^(-(1:ℝ)/2) / Real.log (n + 2) ≤ 4 * Real.sqrt N := by
      -- The term is roughly `1 / (sqrt n * log n)`.
      -- Summing `1/sqrt n` gives `2 * sqrt n`.
      have h_sum_sqrt : ∑ n ∈ Finset.range N, ((n + 1 : ℝ) ^ (-1 / 2 : ℝ)) ≤ 2 * Real.sqrt N := by
        have h_sum_sqrt : ∀ k ∈ Finset.range N, (k + 1 : ℝ) ^ (-1 / 2 : ℝ) ≤ 2 * Real.sqrt (k + 1) - 2 * Real.sqrt k := by
          norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg ( add_nonneg ( Nat.cast_nonneg _ ) zero_le_one ) ];
          intro k hk; rw [ ← Real.sqrt_eq_rpow, ← Real.sqrt_eq_rpow ] ; rw [ inv_eq_one_div, div_le_iff₀ ] <;> nlinarith [ Real.sqrt_nonneg ( k + 1 : ℝ ), Real.sq_sqrt ( by linarith : ( k : ℝ ) + 1 ≥ 0 ), Real.sq_sqrt ( by linarith : ( k : ℝ ) ≥ 0 ) ] ;
        convert Finset.sum_le_sum h_sum_sqrt ; norm_num [ Finset.sum_range_succ' ];
        exact Nat.recOn N ( by norm_num ) fun n ih => by norm_num [ Finset.sum_range_succ ] at * ; linarith;
      -- Using the bound from h_sum_sqrt and the fact that `log(n+2) ≥ 1` for `n ≥ 0`, we get the desired inequality.
      have h_log_bound : ∀ n : ℕ, 0 ≤ n → (Real.log (n + 2)) ≥ 1 / 2 := by
        exact fun n _ => le_trans ( Real.log_two_gt_d9.le.trans' <| by norm_num ) ( Real.log_le_log ( by norm_num ) <| by linarith );
      exact le_trans ( Finset.sum_le_sum fun i hi => mul_le_mul_of_nonneg_left ( inv_anti₀ ( by positivity ) ( h_log_bound i ( Nat.zero_le i ) ) ) ( by positivity ) ) ( by norm_num [ ← Finset.sum_mul _ _ _ ] ; linarith )

/-
Bound for the sum of `(n+1)^{-1/2}/log(n+1)` for `n ≥ 1`.
-/
lemma sum_reciprocal_sqrt_log_bound_corrected (N : ℕ) :
    ∑ n ∈ Finset.Ico 1 N, (n + 1 : ℝ)^(-(1:ℝ)/2) / Real.log (n + 1) ≤ 4 * Real.sqrt N := by
  -- The term is `(n+1)^{-1/2} / log(n+1)`. For `n ≥ 1`, `n+1 ≥ 2`, so `log(n+1) ≥ log 2`. Thus `1/log(n+1) ≤ 1/log 2`.
  have h_term_bound : ∀ n : ℕ, 1 ≤ n → ((n + 1 : ℝ) ^ (-1 / 2 : ℝ)) / Real.log (n + 1) ≤ (1 / Real.log 2) * ((n + 1 : ℝ) ^ (-1 / 2 : ℝ)) := by
    intro n hn; rw [ div_mul_eq_mul_div ] ; gcongr ; norm_cast ; linarith;
    norm_cast ; linarith;
  -- The sum $\sum_{n=1}^{N-1} (n+1)^{-1/2}$ is bounded by an integral: $\sum_{n=1}^{N-1} (n+1)^{-1/2} \leq \int_{1}^{N} x^{-1/2} \, dx = [2x^{1/2}]_{1}^{N} = 2\sqrt{N} - 2 \leq 2\sqrt{N}$.
  have h_sum_integral_bound : ∑ n ∈ Finset.Ico 1 N, (n + 1 : ℝ)^(-1 / 2 : ℝ) ≤ 2 * Real.sqrt N := by
    -- We can bound the sum $\sum_{n=1}^{N-1} (n+1)^{-1/2}$ by comparing it to the integral $\int_{1}^{N} x^{-1/2} \, dx$.
    have h_integral_bound : ∀ n : ℕ, 1 ≤ n → (n + 1 : ℝ)^(-1 / 2 : ℝ) ≤ 2 * (Real.sqrt (n + 1) - Real.sqrt n) := by
      intro n hn; rw [ show ( -1 / 2 : ℝ ) = - ( 1 / 2 ) by norm_num, Real.rpow_neg ( by positivity ) ] ; norm_num;
      rw [ ← Real.sqrt_eq_rpow, inv_eq_one_div, div_le_iff₀ ] <;> nlinarith [ Real.sqrt_nonneg ( n + 1 : ℝ ), Real.sq_sqrt ( by positivity : 0 ≤ ( n : ℝ ) + 1 ), Real.sq_sqrt ( by positivity : 0 ≤ ( n : ℝ ) ) ];
    exact le_trans ( Finset.sum_le_sum fun i hi => by simpa only [ neg_div ] using h_integral_bound i ( Finset.mem_Ico.mp hi |>.1 ) ) ( Nat.recOn N ( by norm_num ) fun n ihn => by cases n <;> norm_num [ Finset.sum_Ico_succ_top ] at * ; linarith );
  -- Combining the term bound and the integral bound, we get the desired result.
  have h_combined_bound : ∑ n ∈ Finset.Ico 1 N, ((n + 1 : ℝ) ^ (-1 / 2 : ℝ)) / Real.log (n + 1) ≤ (1 / Real.log 2) * (2 * Real.sqrt N) := by
    exact le_trans ( Finset.sum_le_sum fun n hn => h_term_bound n <| Finset.mem_Ico.mp hn |>.1 ) <| by simpa only [ Finset.mul_sum _ _ _ ] using mul_le_mul_of_nonneg_left h_sum_integral_bound <| by positivity;
  norm_num [ div_eq_mul_inv ] at *;
  exact h_combined_bound.trans ( by nlinarith [ Real.sqrt_nonneg N, Real.log_two_gt_d9, mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos one_lt_two ) ), mul_le_mul_of_nonneg_right ( Real.log_two_gt_d9.le ) ( Real.sqrt_nonneg N ) ] )

/-
The integral of the oscillatory sum (excluding the constant mode n=0) is bounded by `C * T^(1/2 + ε)`.
-/
theorem oscillatory_sum_integral_bound (ε : ℝ) (hε : 0 < ε) :
    ∃ C : ℝ, C > 0 ∧ ∃ T₀ : ℝ, T₀ ≥ 2 ∧ ∀ T : ℝ, T ≥ T₀ →
      |∫ t in Set.Ioc 1 T, ∑ n ∈ Finset.Ico 1 (Nat.sqrt (Nat.floor T)),
        (n + 1 : ℝ)^(-(1:ℝ)/2) * Real.cos (t * Real.log (n + 1))| ≤ C * T^(1/2 + ε) := by
  -- By Fubini's theorem, we can interchange the integral and the sum.
  have h_fubini : ∀ T : ℝ, T ≥ 2 → ∫ t in (Set.Ioc 1 T), (∑ n ∈ (Finset.Ico 1 (Nat.sqrt (Nat.floor T))), ((n + 1 : ℝ) ^ (-(1 : ℝ) / 2) * Real.cos (t * Real.log (n + 1)))) = ∑ n ∈ (Finset.Ico 1 (Nat.sqrt (Nat.floor T))), ((n + 1 : ℝ) ^ (-(1 : ℝ) / 2)) * (∫ t in (Set.Ioc 1 T), Real.cos (t * Real.log (n + 1))) := by
    intro T hT; rw [ MeasureTheory.integral_finset_sum _ fun i hi => Continuous.integrableOn_Ioc ( by continuity ) ] ; exact Finset.sum_congr rfl fun i hi => by rw [ MeasureTheory.integral_const_mul ] ;
  -- Apply the bound for the integral of `cos(a*t)` to each term in the sum.
  have h_cos_bound : ∀ T : ℝ, T ≥ 2 → ∑ n ∈ (Finset.Ico 1 (Nat.sqrt (Nat.floor T))), ((n + 1 : ℝ) ^ (-(1 : ℝ) / 2)) * |∫ t in (Set.Ioc 1 T), Real.cos (t * Real.log (n + 1))| ≤ ∑ n ∈ (Finset.Ico 1 (Nat.sqrt (Nat.floor T))), ((n + 1 : ℝ) ^ (-(1 : ℝ) / 2)) * (2 / |Real.log (n + 1)|) := by
    intros T hT
    apply Finset.sum_le_sum;
    intro n hn; gcongr;
    convert cos_integral_bound ( Real.log ( n + 1 ) ) _ T ( by linarith ) using 1;
    · ac_rfl;
    · exact ne_of_gt <| Real.log_pos <| by norm_cast; linarith [ Finset.mem_Ico.mp hn ];
  -- Use `sum_reciprocal_sqrt_log_bound_corrected` to bound the sum by `4 * √K`.
  have h_sum_bound : ∀ T : ℝ, T ≥ 2 → ∑ n ∈ (Finset.Ico 1 (Nat.sqrt (Nat.floor T))), ((n + 1 : ℝ) ^ (-(1 : ℝ) / 2)) * (2 / |Real.log (n + 1)|) ≤ 8 * Real.sqrt (Nat.sqrt (Nat.floor T)) := by
    -- Apply the bound from `sum_reciprocal_sqrt_log_bound_corrected`.
    intros T hT
    have h_sum_bound : ∑ n ∈ (Finset.Ico 1 (Nat.sqrt (Nat.floor T))), ((n + 1 : ℝ) ^ (-(1 : ℝ) / 2)) / |Real.log (n + 1)| ≤ 4 * Real.sqrt (Nat.sqrt (Nat.floor T)) := by
      convert sum_reciprocal_sqrt_log_bound_corrected ( Nat.sqrt ( Nat.floor T ) ) using 1;
      exact Finset.sum_congr rfl fun x hx => by rw [ abs_of_nonneg ( Real.log_nonneg ( by linarith ) ) ] ;
    convert mul_le_mul_of_nonneg_left h_sum_bound zero_le_two using 1 <;> ring;
    rw [ Finset.sum_mul _ _ _ ];
  -- Use `h_sum_bound` to bound the integral by `8 * √K`.
  have h_integral_bound : ∀ T : ℝ, T ≥ 2 → |∫ t in (Set.Ioc 1 T), (∑ n ∈ (Finset.Ico 1 (Nat.sqrt (Nat.floor T))), ((n + 1 : ℝ) ^ (-(1 : ℝ) / 2) * Real.cos (t * Real.log (n + 1))))| ≤ 8 * Real.sqrt (Nat.sqrt (Nat.floor T)) := by
    intros T hT
    rw [h_fubini T hT];
    exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( le_trans ( Finset.sum_le_sum fun _ _ => by rw [ abs_mul, abs_of_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ] ) ( le_trans ( h_cos_bound T hT ) ( h_sum_bound T hT ) ) );
  refine' ⟨ 8, by norm_num, 2, by norm_num, fun T hT => le_trans ( h_integral_bound T hT ) _ ⟩ ; norm_num [ Real.sqrt_eq_rpow ] at *;
  exact le_trans ( Real.rpow_le_rpow ( by positivity ) ( show ( ⌊T⌋₊.sqrt : ℝ ) ≤ T by exact le_trans ( Nat.cast_le.mpr <| Nat.sqrt_le_self _ ) <| Nat.floor_le <| by positivity ) <| by positivity ) <| Real.rpow_le_rpow_of_exponent_le ( by linarith ) <| by linarith;

end OscillatorySumBound
