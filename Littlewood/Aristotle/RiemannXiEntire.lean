/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 5bfeeed3-7ffe-4290-a5ce-93c5ceac1467

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Riemann Xi function entireness proof.

KEY RESULTS:
- RiemannXiAlt: Alternative definition using completedRiemannZeta₀
- RiemannXiAlt_entire: RiemannXiAlt is entire (differentiable everywhere on ℂ)
- RiemannXiAlt_eq_formula: Agrees with standard formula for s ≠ 0, 1
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define the Riemann Xi function using the completed Riemann Zeta function without poles, to ensure it is defined everywhere.
-/
noncomputable def RiemannXiAlt (s : ℂ) : ℂ := (1/2) * (s * (s - 1) * completedRiemannZeta₀ s + 1)

/-
Prove that the Riemann Xi function is entire (differentiable everywhere on the complex plane).
-/
theorem RiemannXiAlt_entire : Differentiable ℂ RiemannXiAlt := by
  -- By definition of $RiemannXiAlt$, we know that it is a composition of differentiable functions.
  have h_comp : Differentiable ℂ (fun s : ℂ => (s * (s - 1) * completedRiemannZeta₀ s + 1) / 2) := by
    exact Differentiable.div_const ( Differentiable.add ( Differentiable.mul ( differentiable_id.mul ( differentiable_id.sub_const _ ) ) differentiable_completedZeta₀ ) ( differentiable_const _ ) ) _;
  convert h_comp using 1;
  exact funext fun s => by unfold RiemannXiAlt; ring;;

/-
Prove that the Riemann Xi function satisfies the formula `(1/2) * s * (s - 1) * completedRiemannZeta s` for `s ≠ 0, 1`.
-/
theorem RiemannXiAlt_eq_formula {s : ℂ} (h0 : s ≠ 0) (h1 : s ≠ 1) :
    RiemannXiAlt s = (1/2) * s * (s - 1) * completedRiemannZeta s := by
      have h_subst : (1 / 2 : ℂ) * s * (s - 1) * (completedRiemannZeta₀ s - 1 / s - 1 / (1 - s)) = (1 / 2 : ℂ) * (s * (s - 1) * completedRiemannZeta₀ s + 1) := by
        grind;
      have h_subst : completedRiemannZeta s = completedRiemannZeta₀ s - 1 / s - 1 / (1 - s) := by
        exact completedRiemannZeta_eq s;
      unfold RiemannXiAlt; aesop;

end
