/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6b9fc50e-8759-4c52-94ab-d14893a5b6a5

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module proves that there are finitely many zeros of the Riemann zeta function up to height T in the critical strip.
It defines the set of zeros `zetaZerosBelowSet` and proves its finiteness using the compactness of the region and the isolation of zeros.
Key lemmas include `riemannZeta_zeros_closed`, `riemannZeta_zeros_isolated`, and `riemannZeta_zeros_discrete`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ZetaZerosFiniteBelow

/-
The set of zeros of the Riemann zeta function with 0 < re(s) < 1 and 0 < im(s) <= T.
-/
def zetaZerosBelowSet (T : ℝ) : Set ℂ :=
  {s | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ 0 < s.im ∧ s.im ≤ T}

/-
The set of zeros of the Riemann zeta function is closed in the complex plane.
-/
lemma riemannZeta_zeros_closed : IsClosed {s : ℂ | riemannZeta s = 0} := by
  have h_analytic : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
    apply_rules [ DifferentiableOn.analyticOnNhd ];
    · exact fun s hs => DifferentiableAt.differentiableWithinAt ( by exact differentiableAt_riemannZeta <| by aesop );
    · exact isOpen_univ.sdiff isClosed_singleton;
  have h_closed : IsClosed {s : ℂ | riemannZeta s = 0 ∧ s ≠ 1} := by
    refine' isClosed_iff_clusterPt.mpr _;
    intro a ha
    by_cases ha1 : a = 1;
    · -- Since $a = 1$, we have a contradiction with the assumption that $a$ is a cluster point of the set of zeros of $\zeta(s)$ excluding $1$.
      have h_contra : ∀ᶠ s in nhdsWithin 1 {1}ᶜ, riemannZeta s ≠ 0 := by
        have h_contra : Filter.Tendsto (fun s : ℂ => (s - 1) * riemannZeta s) (nhdsWithin 1 {1}ᶜ) (nhds 1) := by
          exact HurwitzZeta.hurwitzZetaEven_residue_one 0;
        filter_upwards [ h_contra.eventually_ne one_ne_zero ] with s hs using by aesop;
      rw [ clusterPt_principal_iff ] at ha;
      rw [ eventually_nhdsWithin_iff ] at h_contra;
      exact absurd ( ha _ <| by simpa [ ha1 ] using h_contra ) ( by rintro ⟨ x, hx₁, hx₂ ⟩ ; aesop );
    · have := h_analytic a ( by aesop );
      have := this.continuousAt.tendsto;
      rw [ clusterPt_principal_iff ] at ha;
      contrapose! ha;
      exact ⟨ { s : ℂ | riemannZeta s ≠ 0 }, this.eventually_ne ( by aesop ), by aesop ⟩;
  have h_not_zero : riemannZeta 1 ≠ 0 := by
    exact riemannZeta_one_ne_zero;
  convert h_closed using 1 ; ext s ; by_cases hs : s = 1 <;> aesop

/-
The zeros of the Riemann zeta function are isolated points.
-/
lemma riemannZeta_zeros_isolated (z : ℂ) (hz : riemannZeta z = 0) :
    ∃ U ∈ nhds z, {w ∈ U | riemannZeta w = 0} = {z} := by
      -- By the principle of isolated zeros, either `riemannZeta` is identically zero in a neighborhood of `z`, or it is non-zero in a punctured neighborhood of `z`.
      have h_isolated : AnalyticAt ℂ riemannZeta z := by
        apply_rules [ DifferentiableOn.analyticAt, riemannZeta ];
        refine' fun s hs => DifferentiableAt.differentiableWithinAt _;
        swap;
        exact { s : ℂ | s ≠ 1 };
        · exact differentiableAt_riemannZeta hs;
        · exact IsOpen.mem_nhds ( isOpen_ne.preimage continuous_id' ) ( show z ≠ 1 from by rintro rfl; exact absurd hz <| by exact riemannZeta_one_ne_zero );
      have := h_isolated.eventually_eq_zero_or_eventually_ne_zero;
      -- If `riemannZeta` is identically zero in a neighborhood of `z`, then by the identity theorem on the connected domain `ℂ \ {1}`, it would be identically zero everywhere.
      by_cases h_id : ∀ᶠ w in nhds z, riemannZeta w = 0;
      · have h_id_zero : ∀ w : ℂ, w ≠ 1 → riemannZeta w = 0 := by
          intro w hw_ne_one
          have h_id_zero : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
            intro w hw_ne_one; exact (by
            apply_rules [ DifferentiableOn.analyticAt, riemannZeta ];
            any_goals exact { w | w ≠ 1 };
            · intro w hw_ne_one; exact (by
              exact DifferentiableAt.differentiableWithinAt ( by exact differentiableAt_riemannZeta hw_ne_one ));
            · exact isOpen_ne.mem_nhds hw_ne_one.2);
          apply h_id_zero.eqOn_zero_of_preconnected_of_eventuallyEq_zero;
          any_goals exact z;
          · -- The set of complex numbers excluding 1 is path-connected, hence preconnected.
            have h_path_connected : IsPathConnected (Set.univ \ {1} : Set ℂ) := by
              have h_path_connected : IsPathConnected (Set.univ \ {0} : Set ℂ) := by
                -- The set of nonzero complex numbers is path-connected because it is the continuous image of the path-connected space $\mathbb{R}^2 \setminus \{0\}$ under the continuous map $z \mapsto e^z$.
                have h_path_connected : IsPathConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
                  exact isPathConnected_range Complex.continuous_exp;
                convert h_path_connected using 1;
                ext; simp [Complex.exp_ne_zero];
              have h_path_connected : IsPathConnected (Set.image (fun w : ℂ => w + 1) (Set.univ \ {0})) := by
                apply_rules [ IsPathConnected.image, h_path_connected ];
                exact continuous_id.add continuous_const;
              convert h_path_connected using 1;
              ext; simp [Set.mem_image];
            exact h_path_connected.isConnected.isPreconnected;
          · simp +zetaDelta at *;
            rintro rfl; exact absurd hz ( by exact riemannZeta_one_ne_zero );
          · exact h_id;
          · aesop;
        exact absurd ( h_id_zero 2 ( by norm_num ) ) ( by norm_num [ riemannZeta_two ] );
      · simp_all +decide [ eventually_nhdsWithin_iff ];
        exact ⟨ _, this, Set.eq_singleton_iff_unique_mem.mpr ⟨ ⟨ Filter.Eventually.self_of_nhds this, hz ⟩, fun w hw => Classical.not_not.1 fun h => hw.2 |> fun hw' => hw' |> fun hw'' => by aesop ⟩ ⟩

/-
The set of zeros of the Riemann zeta function has the discrete topology.
-/
lemma riemannZeta_zeros_discrete : DiscreteTopology {s : ℂ | riemannZeta s = 0} := by
  -- We have shown that for every zero `z`, there exists a neighborhood `U` such that `U ∩ {s | riemannZeta s = 0} = {z}`.
  have h_discrete : ∀ z : ℂ, riemannZeta z = 0 → ∃ U ∈ nhds z, {w ∈ U | riemannZeta w = 0} = {z} := by
    exact fun z a => riemannZeta_zeros_isolated z a;
  rw [ discreteTopology_iff_singleton_mem_nhds ];
  simp_all +decide [ Set.eq_singleton_iff_unique_mem ];
  intro z hz; specialize h_discrete z hz; rcases h_discrete with ⟨ U, hU₁, hU₂, hU₃ ⟩ ; rw [ Metric.mem_nhds_iff ] at *; aesop;

/-
The set of zeros of the Riemann zeta function with 0 < re(s) < 1 and 0 < im(s) <= T is finite.
-/
lemma zetaZerosBelow_finite (T : ℝ) : (zetaZerosBelowSet T).Finite := by
  -- Let's choose the set K = {s : ℂ | 0 ≤ s.re ∧ s.re ≤ 1 ∧ 0 ≤ s.im ∧ s.im ≤ T}.
  set K : Set ℂ := {s : ℂ | 0 ≤ s.re ∧ s.re ≤ 1 ∧ 0 ≤ s.im ∧ s.im ≤ T} with hK_def;
  have hK_compact : IsCompact K := by
    refine' ( Metric.isCompact_iff_isClosed_bounded.mpr _ );
    exact ⟨ by exact IsClosed.inter ( isClosed_Ici.preimage Complex.continuous_re ) ( IsClosed.inter ( isClosed_Iic.preimage Complex.continuous_re ) ( IsClosed.inter ( isClosed_Ici.preimage Complex.continuous_im ) ( isClosed_Iic.preimage Complex.continuous_im ) ) ), isBounded_iff_forall_norm_le.mpr ⟨ 1 + |T|, by rintro s ⟨ h₀, h₁, h₂, h₃ ⟩ ; exact Complex.norm_le_abs_re_add_abs_im _ |> le_trans <| by cases abs_cases T <;> linarith [ abs_of_nonneg h₀, abs_of_nonneg h₂ ] ⟩ ⟩;
  have h_inter : {s : ℂ | riemannZeta s = 0 ∧ s ∈ K}.Finite := by
    have h_inter_compact : IsCompact {s : ℂ | riemannZeta s = 0 ∧ s ∈ K} := by
      exact hK_compact.of_isClosed_subset ( riemannZeta_zeros_closed.inter ( isClosed_Ici.preimage Complex.continuous_re |> IsClosed.inter <| isClosed_Iic.preimage Complex.continuous_re |> IsClosed.inter <| isClosed_Ici.preimage Complex.continuous_im |> IsClosed.inter <| isClosed_Iic.preimage Complex.continuous_im ) ) fun x hx => hx.2;
    have h_inter_discrete : DiscreteTopology {s : ℂ | riemannZeta s = 0 ∧ s ∈ K} := by
      have h_inter_discrete : DiscreteTopology {s : ℂ | riemannZeta s = 0} := by
        exact riemannZeta_zeros_discrete;
      rw [ discreteTopology_iff_singleton_mem_nhds ] at *;
      intro x; specialize h_inter_discrete ⟨ x.val, x.property.1 ⟩ ; rw [ mem_nhds_subtype ] at *; aesop;
    exact h_inter_compact.finite h_inter_discrete.isDiscrete;
  exact h_inter.subset fun x hx => ⟨ hx.1, ⟨ by linarith [ hx.2.1 ], by linarith [ hx.2.2.1 ], by linarith [ hx.2.2.2.1 ], by linarith [ hx.2.2.2.2 ] ⟩ ⟩
end ZetaZerosFiniteBelow
