/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f05462b9-a210-4ff5-91da-c0be4a6070a8

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: Hardy approximate functional equation V3 — chi factor, error term, partial sum bounds.
NOT imported by any bridge — standalone reference material.
Redefines HardyApproxFunctional.hardyZ/partial_sum locally (same as HardyApproxFunctionalEq.lean).

Contains (0 sorries, budget reached before further proofs):
- HardyApproxFunctional.chi: χ(s) factor from functional equation at s = 1/2 + it
- HardyApproxFunctional.error_term: R(t) = ζ(1/2+it) - S_N(t) - χ(s)S_N(t)*
- HardyApproxFunctional.norm_chi: |χ(1/2+it)| = 1 (PROVED)
- HardyApproxFunctional.pointwise_afe: ζ = S_N + χ·S_N* + R (PROVED, by definition)
- HardyApproxFunctional.partial_sum_bound_lemma: ‖S_N(t)‖ ≤ C·t^(1/4) (PROVED)
- HardyBounds: structure bundling error/cross-term bounds (definition only)
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.HardyApproxFunctionalEqV3

def HardyApproxFunctional.hardyZ (t : ℝ) : ℝ := ‖riemannZeta (1 / 2 + t * Complex.I)‖

def HardyApproxFunctional.partial_sum (N : ℕ) (t : ℝ) : ℂ :=
  ∑ n ∈ Finset.range N, (n + 1 : ℂ) ^ (-(1 / 2 : ℂ) - t * Complex.I)

def HardyApproxFunctional.partial_sum_approx (t : ℝ) : ℂ :=
  HardyApproxFunctional.partial_sum (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) t

/-
The factor χ(s) appearing in the functional equation ζ(s) = χ(s)ζ(1-s), evaluated at s = 1/2 + it.
-/
def HardyApproxFunctional.chi (t : ℝ) : ℂ :=
  let s : ℂ := 1 / 2 + t * Complex.I
  (Real.pi : ℂ) ^ (s - 1 / 2) * Complex.Gamma ((1 - s) / 2) / Complex.Gamma (s / 2)

/-
The error term R(t) in the approximate functional equation ζ(s) = S_N(t) + χ(s)S_N(t)* + R(t).
-/
def HardyApproxFunctional.error_term (t : ℝ) : ℂ :=
  riemannZeta (1 / 2 + t * Complex.I) -
  (HardyApproxFunctional.partial_sum_approx t +
   HardyApproxFunctional.chi t * star (HardyApproxFunctional.partial_sum_approx t))

/-
The magnitude of the factor χ(1/2 + it) is 1.
-/
lemma HardyApproxFunctional.norm_chi (t : ℝ) : ‖HardyApproxFunctional.chi t‖ = 1 := by
  unfold HardyApproxFunctional.chi;
  norm_num [ Complex.Gamma_ofReal, Complex.norm_cpow_of_ne_zero, Real.pi_ne_zero ];
  rw [ Complex.arg_ofReal_of_nonneg Real.pi_pos.le ] ; norm_num;
  rw [ div_eq_iff ] <;> norm_num [ Complex.Gamma_ne_zero ];
  · convert Complex.norm_conj ( Complex.Gamma ( ( 1 / 2 + t * Complex.I ) / 2 ) ) using 2 ; ring;
    convert Complex.Gamma_conj ( 1 / 4 + t * Complex.I * ( 1 / 2 ) ) using 2 ; norm_num ; ring;
    erw [ Complex.conj_ofReal, Complex.conj_ofReal ] ; norm_num ; ring;
  · rw [ Complex.Gamma_eq_zero_iff ] ; norm_num [ Complex.ext_iff ] ; ring ; norm_num;
    exact fun x hx => by linarith;

/-
The approximate functional equation for the Riemann Zeta function, expressed as an equality with an error term.
-/
lemma HardyApproxFunctional.pointwise_afe (t : ℝ) :
  riemannZeta (1 / 2 + t * Complex.I) =
    HardyApproxFunctional.partial_sum_approx t +
    HardyApproxFunctional.chi t * star (HardyApproxFunctional.partial_sum_approx t) +
    HardyApproxFunctional.error_term t := by
      -- By definition of $HardyApproxFunctional.error_term$, we have:
      simp [HardyApproxFunctional.error_term]

/-
The partial sum S_N(t) is bounded by O(t^(1/4)) for t ≥ 1.
-/
lemma HardyApproxFunctional.partial_sum_bound_lemma :
  ∃ C_S > 0, ∀ t ≥ 1, ‖HardyApproxFunctional.partial_sum_approx t‖ ≤ C_S * t ^ (1/4 : ℝ) := by
    -- Each term in the partial sum S_N(t) is bounded by O(t^(-1/4)), so the sum is bounded by O(t^(1/2)).
    have h_partial_sum_bound : ∃ C_S > 0, ∀ t ≥ 1, ‖HardyApproxFunctional.partial_sum_approx t‖ ≤ C_S * (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) ^ (1 / 2 : ℝ) := by
      -- Each term in the partial sum S_N(t) is bounded by O(t^(-1/4)), so the sum is bounded by O(t^(1/2)). We can choose C_S = 2.
      use 2; norm_num;
      intro t ht
      have h_partial_sum_bound : ‖HardyApproxFunctional.partial_sum_approx t‖ ≤ ∑ n ∈ Finset.range (Nat.floor (Real.sqrt (t / (2 * Real.pi)))), (n + 1 : ℝ) ^ (-1 / 2 : ℝ) := by
        convert norm_sum_le _ _ using 2;
        rotate_right;
        use fun n => ( n + 1 : ℂ ) ^ ( - ( 1 / 2 : ℂ ) - t * Complex.I );
        · unfold HardyApproxFunctional.partial_sum_approx; norm_num [ Complex.ofReal_cpow ] ;
          unfold HardyApproxFunctional.partial_sum; norm_num [ Complex.ofReal_cpow ] ;
        · rw [ Complex.norm_cpow_of_ne_zero ] <;> norm_num [ Complex.ext_iff, Nat.cast_add_one_ne_zero ];
          norm_cast ; norm_num [ Complex.arg ];
      -- We'll use the fact that $\sum_{n=1}^{N} n^{-1/2}$ is bounded above by $2\sqrt{N}$.
      have h_sum_bound : ∀ N : ℕ, ∑ n ∈ Finset.range N, (n + 1 : ℝ) ^ (-1 / 2 : ℝ) ≤ 2 * Real.sqrt N := by
        intro N; induction' N with N ih <;> norm_num [ Finset.sum_range_succ ];
        norm_num [ Real.rpow_neg ( add_nonneg ( Nat.cast_nonneg _ ) zero_le_one ) ] at *;
        rw [ ← Real.sqrt_eq_rpow ] at *;
        nlinarith [ sq_nonneg ( Real.sqrt ( N:ℝ ) - Real.sqrt ( N+1 ) ), Real.mul_self_sqrt ( show ( N:ℝ ) ≥ 0 by positivity ), Real.mul_self_sqrt ( show ( N+1:ℝ ) ≥ 0 by positivity ), inv_pos.mpr ( Real.sqrt_pos.mpr ( show ( N+1:ℝ ) > 0 by positivity ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ( show ( N+1:ℝ ) > 0 by positivity ) ) ) ];
      exact h_partial_sum_bound.trans ( le_trans ( h_sum_bound _ ) ( by rw [ ← Real.sqrt_eq_rpow ] ) );
    -- Since $\lfloor \sqrt{t/(2\pi)} \rfloor \leq \sqrt{t/(2\pi)}$, we have $(Nat.floor (Real.sqrt (t / (2 * Real.pi)))) ^ (1 / 2 : ℝ) \leq (Real.sqrt (t / (2 * Real.pi))) ^ (1 / 2 : ℝ)$.
    have h_floor_sqrt : ∀ t ≥ 1, (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) ^ (1 / 2 : ℝ) ≤ (Real.sqrt (t / (2 * Real.pi))) ^ (1 / 2 : ℝ) := by
      exact fun t ht => Real.rpow_le_rpow ( Nat.cast_nonneg _ ) ( Nat.floor_le ( Real.sqrt_nonneg _ ) ) ( by norm_num );
    -- Combining the bounds, we get that $\|S_N(t)\| \leq C_S \cdot (\sqrt{t/(2\pi)})^{1/2} = C_S \cdot t^{1/4} \cdot (1/(2\pi))^{1/4}$.
    obtain ⟨C_S, hC_S_pos, hC_S_bound⟩ := h_partial_sum_bound
    use C_S * (1 / (2 * Real.pi)) ^ (1 / 4 : ℝ);
    refine' ⟨ mul_pos hC_S_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ), fun t ht => le_trans ( hC_S_bound t ht ) _ ⟩;
    convert mul_le_mul_of_nonneg_left ( h_floor_sqrt t ht ) hC_S_pos.le using 1 ; ring;
    rw [ Real.sqrt_eq_rpow, ← Real.rpow_mul ( by positivity ) ] ; ring;
    rw [ mul_right_comm, Real.mul_rpow ( by positivity ) ( by positivity ) ] ; ring;
    rw [ Real.mul_rpow ( by positivity ) ( by positivity ), Real.mul_rpow ( by positivity ) ( by positivity ) ] ; ring

/-
A structure bundling the assumed bounds for the error term and the cross term integral.
-/
structure HardyBounds where
  C_R : ℝ
  hC_R_pos : C_R > 0
  h_error : ∀ t ≥ 1, ‖HardyApproxFunctional.error_term t‖ ≤ C_R * t ^ (-(1/4 : ℝ))
  C_cross : ℝ
  hC_cross_nonneg : C_cross ≥ 0
  h_cross : ∀ T ≥ 2, abs (∫ t in Set.Ioc 1 T, (HardyApproxFunctional.chi t * (star (HardyApproxFunctional.partial_sum_approx t))^2).re) ≤ C_cross * T

end Aristotle.HardyApproxFunctionalEqV3
