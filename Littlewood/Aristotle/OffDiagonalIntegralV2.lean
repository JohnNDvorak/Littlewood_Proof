/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 95bfe9a9-da11-498e-b972-d85db5ba1b9e

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We prove the off-diagonal integral bound for the mean square of the Riemann zeta function (or a related exponential sum).
The main result is `norm_integral_offDiagSsq_le`, which states that the integral of the off-diagonal terms is bounded by $C N^2$.
We use several helper lemmas:
- `integral_cos_bound`: bounds the integral of $\cos(\alpha t)$.
- `log_diff_bound`: bounds the difference of logarithms.
- `sum_inv_sqrt_bound`: bounds the sum of $1/\sqrt{k+1}$.
- `sum_inv_dist_bound`: bounds the double sum of $1/|n-m|$.
- `term_bound`: bounds the individual terms in the sum.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace OffDiagonalIntegralV2

/-
The magnitude of the integral of cos(αt) from 1 to T is at most 2/|α|.
-/
lemma integral_cos_bound (α : ℝ) (hα : α ≠ 0) (T : ℝ) (hT : 1 ≤ T) :
  ‖∫ t in (1:ℝ)..T, Real.cos (α * t)‖ ≤ 2 / |α| := by
    norm_num [ intervalIntegral.integral_comp_mul_left, hα ];
    rw [ inv_mul_eq_div, div_le_div_iff_of_pos_right ( abs_pos.mpr hα ) ] ; exact abs_sub_le_iff.2 ⟨ by linarith [ Real.neg_one_le_sin ( α * T ), Real.sin_le_one ( α * T ), Real.neg_one_le_sin α, Real.sin_le_one α ], by linarith [ Real.neg_one_le_sin ( α * T ), Real.sin_le_one ( α * T ), Real.neg_one_le_sin α, Real.sin_le_one α ] ⟩

/-
The difference of logs is at least the relative difference with respect to the maximum.
-/
lemma log_diff_bound (x y : ℝ) (hx : 0 < x) (hy : 0 < y) :
  |Real.log x - Real.log y| ≥ |x - y| / max x y := by
    cases le_total x y <;> simp_all +decide [ abs_sub_comm, div_le_iff₀ ];
    · rw [ abs_of_nonpos, abs_of_nonpos ] <;> try linarith;
      · -- Since $x \leq y$, we have $1 - \frac{x}{y} \leq \log y - \log x$.
        have h_log_diff : 1 - x / y ≤ Real.log y - Real.log x := by
          have := Real.log_le_sub_one_of_pos ( div_pos hx hy );
          rw [ Real.log_div ] at this <;> linarith;
        nlinarith [ mul_div_cancel₀ x hy.ne' ];
      · linarith [ Real.log_le_log hx ‹_› ];
    · rw [ abs_of_nonneg ( sub_nonneg.2 ‹_› ), abs_of_nonneg ( sub_nonneg.2 <| Real.log_le_log hy ‹_› ) ];
      have := Real.log_le_sub_one_of_pos ( div_pos hy hx );
      rw [ Real.log_div ] at this <;> nlinarith [ mul_div_cancel₀ y hx.ne' ]

/-
The sum of 1/sqrt(k+1) is bounded by 2*sqrt(N).
-/
lemma sum_inv_sqrt_bound (N : ℕ) : ∑ k ∈ Finset.range N, (1 : ℝ) / Real.sqrt (k + 1) ≤ 2 * Real.sqrt N := by
  induction' N with N ih <;> norm_num [ Finset.sum_range_succ ] at * ; nlinarith [ ( inv_nonneg.2 ( Real.sqrt_nonneg ( N + 1 ) ) ), sq_nonneg ( Real.sqrt ( N + 1 ) - Real.sqrt N ), Real.sq_sqrt ( by positivity : ( 0 :ℝ ) ≤ N + 1 ), Real.sq_sqrt ( by positivity : ( 0 :ℝ ) ≤ N ), Real.sqrt_nonneg N, Real.sqrt_nonneg ( N + 1 ), mul_inv_cancel₀ ( show Real.sqrt ( N + 1 ) ≠ 0 by positivity ) ] ;

/-
The double sum of 1/|n-m| is bounded by 4 N^(1.5).
-/
lemma sum_inv_dist_bound (N : ℕ) :
  ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (if n ≠ m then 1 / |(n : ℝ) - m| else 0) ≤ 4 * (N : ℝ) ^ (3/2 : ℝ) := by
    -- For each $n$, the inner sum $\sum_{m \neq n} \frac{1}{|n-m|}$ is bounded by $2 \sum_{k=1}^{N} \frac{1}{k}$.
    have h_inner_sum_bound : ∀ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (if n ≠ m then (abs (n - m : ℝ))⁻¹ else 0) ≤ 2 * ∑ k ∈ Finset.range N, (1 : ℝ) / (k + 1) := by
      -- Let's choose any $n$ in the range $0$ to $N-1$.
      intro n hn
      -- We can split the sum into two parts: one for $m < n$ and one for $m > n$.
      have h_split_sum : ∑ m ∈ Finset.range N, (if n ≠ m then (abs (n - m : ℝ))⁻¹ else 0) = (∑ m ∈ Finset.range n, (abs (n - m : ℝ))⁻¹) + (∑ m ∈ Finset.Ico (n + 1) N, (abs (n - m : ℝ))⁻¹) := by
        rw [ ← Finset.sum_range_add_sum_Ico _ ( by linarith [ Finset.mem_range.mp hn ] : n + 1 ≤ N ) ];
        simp +decide [ Finset.sum_range_succ, Finset.sum_Ico_eq_sum_range ];
        exact congrArg₂ ( · + · ) ( Finset.sum_congr rfl fun x hx => by rw [ if_neg ( by linarith [ Finset.mem_range.mp hx ] ) ] ) ( Finset.sum_congr rfl fun x hx => by rw [ if_neg ( by linarith [ Finset.mem_range.mp hx ] ) ] );
      -- For $m < n$, we have $|n - m| = n - m$, and for $m > n$, we have $|n - m| = m - n$.
      have h_abs_split : (∑ m ∈ Finset.range n, (abs (n - m : ℝ))⁻¹) + (∑ m ∈ Finset.Ico (n + 1) N, (abs (n - m : ℝ))⁻¹) = (∑ k ∈ Finset.range n, (1 : ℝ) / (k + 1)) + (∑ k ∈ Finset.range (N - n - 1), (1 : ℝ) / (k + 1)) := by
        refine' congrArg₂ ( · + · ) _ _ <;> norm_num [ Finset.sum_Ico_eq_sum_range ];
        · rw [ ← Finset.sum_range_reflect ];
          exact Finset.sum_congr rfl fun x hx => by rw [ Nat.cast_sub <| Nat.le_sub_one_of_lt <| Finset.mem_range.mp hx ] ; rw [ Nat.cast_sub <| by linarith [ Finset.mem_range.mp hx ] ] ; rw [ abs_of_nonneg ] <;> ring ; linarith [ Finset.mem_range.mp hx ] ;
        · exact Eq.symm ( by rw [ Nat.sub_sub ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ abs_of_nonpos ] <;> ring ; linarith );
      simp_all +decide [ two_mul ];
      exact add_le_add ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.range_mono ( by omega ) ) fun _ _ _ => by positivity ) ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.range_mono ( by omega ) ) fun _ _ _ => by positivity );
    -- Using the bound on the inner sum, we can bound the double sum.
    have h_double_sum_bound : (∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (if n ≠ m then (abs (n - m : ℝ))⁻¹ else 0)) ≤ 2 * N * (∑ k ∈ Finset.range N, (1 : ℝ) / (k + 1)) := by
      simpa [ mul_assoc, mul_comm, mul_left_comm ] using Finset.sum_le_sum h_inner_sum_bound;
    -- We'll use that $\sum_{k=1}^{N} \frac{1}{k}$ is bounded by $2\sqrt{N}$.
    have h_sum_bound : (∑ k ∈ Finset.range N, (1 : ℝ) / (k + 1)) ≤ 2 * Real.sqrt N := by
      clear h_double_sum_bound h_inner_sum_bound;
      induction' N with N ih <;> norm_num [ Finset.sum_range_succ ] at *;
      refine le_trans ( add_le_add ih (le_refl _) ) ?_;
      field_simp;
      nlinarith only [ sq_nonneg ( Real.sqrt N - Real.sqrt ( N + 1 ) ), Real.mul_self_sqrt ( show ( N:ℝ ) ≥ 0 by positivity ), Real.mul_self_sqrt ( show ( N + 1:ℝ ) ≥ 0 by positivity ), Real.sqrt_nonneg N, Real.sqrt_nonneg ( N + 1 ) ];
    norm_num at *; convert h_double_sum_bound.trans ( mul_le_mul_of_nonneg_left h_sum_bound <| by positivity ) using 1 ; ring; rw [ Real.sqrt_eq_rpow, ← Real.rpow_one_add' ] <;> norm_num;

/-
The term is bounded by 2 * sqrt(max) / sqrt(min) / |n-m|.
-/
lemma term_bound (n m : ℕ) (hnm : n ≠ m) :
  ((n+1:ℝ)*(m+1:ℝ))^(-(1:ℝ)/2) * (2 / |Real.log ((n+1)/(m+1))|) ≤
  2 * Real.sqrt (max (n+1) (m+1)) * (1 / Real.sqrt (min (n+1) (m+1))) * (1 / |(n:ℝ) - m|) := by
    -- By log_diff_bound, 1/|log((n+1)/(m+1))| ≤ max(n+1, m+1) / |(n+1)-(m+1)| = max(n+1, m+1) / |n-m|.
    have h_log_bound : 1 / |Real.log ((n + 1) / (m + 1))| ≤ (max (n + 1 : ℝ) (m + 1)) / |(n : ℝ) - m| := by
      -- Applying the logarithmic bound to our expression.
      have h_log_bound : |Real.log ((n + 1) / (m + 1))| ≥ |(n + 1 : ℝ) - (m + 1)| / max (n + 1 : ℝ) (m + 1) := by
        convert log_diff_bound ( n + 1 : ℝ ) ( m + 1 : ℝ ) ( by positivity ) ( by positivity ) using 1 ; ring;
        rw [ ← Real.log_div ( by positivity ) ( by positivity ) ] ; ring;
      simpa using inv_anti₀ ( div_pos ( abs_pos.mpr <| sub_ne_zero.mpr <| by aesop : 0 < |( n : ℝ ) + 1 - ( m + 1 )| ) <| by positivity ) h_log_bound;
    field_simp;
    convert mul_le_mul_of_nonneg_left h_log_bound ( show 0 ≤ ( ( n + 1 : ℝ ) * ( m + 1 ) ) ^ ( - ( 1 / 2 : ℝ ) ) * Real.sqrt ( Min.min ( n + 1 : ℝ ) ( m + 1 ) ) by positivity ) using 1 ; ring;
    rw [ Real.rpow_neg ( by positivity ) ] ; cases le_total ( n + 1 : ℝ ) ( m + 1 ) <;> simp +decide [ *, Real.sqrt_eq_rpow, mul_comm, mul_assoc, mul_left_comm ] ; ring;
    · rw [ show ( 1 + m + m * n + n : ℝ ) = ( 1 + m ) * ( 1 + n ) by ring, Real.mul_rpow ( by positivity ) ( by positivity ) ] ; ring;
      -- Combine like terms and simplify the expression.
      field_simp
      ring;
      rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ) ] ; norm_num ; ring;
    · rw [ Real.mul_rpow ( by positivity ) ( by positivity ) ] ; ring;
      -- Combine like terms and simplify the expression.
      field_simp
      ring;
      rw [ ← Real.sqrt_eq_rpow, Real.sq_sqrt ] <;> linarith

/-
The off-diagonal integral is bounded by C * N^2.
-/
theorem norm_integral_offDiagSsq_le : ∃ C, ∀ (N : ℕ) (T : ℝ) (hT : 1 ≤ T),
    ‖∫ t in (1:ℝ)..T, ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N,
      (if n ≠ m then ((n+1:ℝ)*(m+1:ℝ))^(-(1:ℝ)/2) * Real.cos (t * Real.log ((n+1:ℝ)/(m+1:ℝ))) else 0)‖
    ≤ C * (N:ℝ)^2 := by
      use 8;
      intro N T hT
      have h_integral_bound : ∀ n m : ℕ, n ≠ m → ‖∫ t in (1:ℝ)..T, (Real.cos (t * (Real.log ((n + 1) / (m + 1)))))‖ ≤ 2 / |Real.log ((n + 1) / (m + 1))| := by
        intro n m hnm
        by_cases h_log : Real.log ((n + 1) / (m + 1)) = 0;
        · simp_all +decide [ add_eq_zero_iff_of_nonneg ];
          cases h_log <;> rw [ div_eq_iff ] at * <;> norm_cast at * ; aesop;
        · convert integral_cos_bound ( Real.log ( ( n + 1 ) / ( m + 1 ) ) ) h_log T hT using 1;
          ac_rfl;
      -- Applying the bound from h_integral_bound, we can sum over all pairs $(n, m)$ with $n \neq m$.
      have h_sum_integral_bound : ‖∫ t in (1:ℝ)..T, ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, if n ≠ m then (((n + 1 : ℝ) * (m + 1)) ^ (-1 / 2 : ℝ)) * (Real.cos (t * (Real.log ((n + 1) / (m + 1))))) else 0‖ ≤ ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, if n ≠ m then (((n + 1 : ℝ) * (m + 1)) ^ (-1 / 2 : ℝ)) * (2 / |Real.log ((n + 1) / (m + 1))|) else 0 := by
        have h_integral_le : ∀ n ∈ Finset.range N, ∀ m ∈ Finset.range N, ‖∫ t in (1:ℝ)..T, (if n ≠ m then (((n + 1) * (m + 1) : ℝ) ^ (-1 / 2 : ℝ)) * (Real.cos (t * (Real.log ((n + 1) / (m + 1))))) else 0)‖ ≤ (if n ≠ m then (((n + 1) * (m + 1) : ℝ) ^ (-1 / 2 : ℝ)) * (2 / |Real.log ((n + 1) / (m + 1))|) else 0) := by
          intro n hn m hm; split_ifs <;> simp_all +decide [ intervalIntegral.integral_const_mul ] ;
          rw [ abs_of_nonneg ( by positivity ) ] ; exact mul_le_mul_of_nonneg_left ( h_integral_bound n m ‹_› ) ( by positivity );
        have h_integral_le_sum : ‖∫ t in (1:ℝ)..T, ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, if n ≠ m then (((n + 1) * (m + 1) : ℝ) ^ (-1 / 2 : ℝ)) * (Real.cos (t * (Real.log ((n + 1) / (m + 1))))) else 0‖ ≤ ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, ‖∫ t in (1:ℝ)..T, (if n ≠ m then (((n + 1) * (m + 1) : ℝ) ^ (-1 / 2 : ℝ)) * (Real.cos (t * (Real.log ((n + 1) / (m + 1))))) else 0)‖ := by
          rw [ intervalIntegral.integral_finset_sum ];
          · refine' le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun i hi => _ );
            rw [ intervalIntegral.integral_finset_sum ];
            · exact norm_sum_le _ _;
            · intro j hj; split_ifs <;> norm_num;
              exact Continuous.intervalIntegrable ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) _ _;
          · exact fun i hi => Continuous.intervalIntegrable ( by exact continuous_finset_sum _ fun j hj => by split_ifs <;> continuity ) _ _;
        exact h_integral_le_sum.trans ( Finset.sum_le_sum fun n hn => Finset.sum_le_sum fun m hm => h_integral_le n hn m hm );
      -- Applying the bound from term_bound, we can sum over all pairs $(n, m)$ with $n \neq m$.
      have h_sum_term_bound : ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (if n ≠ m then (((n + 1 : ℝ) * (m + 1)) ^ (-1 / 2 : ℝ)) * (2 / |Real.log ((n + 1) / (m + 1))|) else 0) ≤ ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (if n ≠ m then (2 * Real.sqrt (max (n + 1) (m + 1)) * (1 / Real.sqrt (min (n + 1) (m + 1))) * (1 / |(n : ℝ) - m|)) else 0) := by
        apply Finset.sum_le_sum;
        intro i hi; apply Finset.sum_le_sum; intro m hm; split_ifs <;> norm_num;
        convert term_bound i m ‹_› using 1 ; ring;
        ring;
      -- Since $\sqrt{\max(n+1, m+1)} \leq \sqrt{N}$ and $\frac{1}{\sqrt{\min(n+1, m+1)}} \leq 1$, we can further bound the sum.
      have h_sum_bound : ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (if n ≠ m then (2 * Real.sqrt (max (n + 1) (m + 1)) * (1 / Real.sqrt (min (n + 1) (m + 1))) * (1 / |(n : ℝ) - m|)) else 0) ≤ ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (if n ≠ m then (2 * Real.sqrt N * (1 / 1) * (1 / |(n : ℝ) - m|)) else 0) := by
        refine Finset.sum_le_sum fun i hi => Finset.sum_le_sum fun j hj => ?_;
        split_ifs <;> norm_num;
        field_simp;
        gcongr;
        rw [ ← Real.sqrt_mul <| by positivity ] ; exact Real.sqrt_le_sqrt <| by cases max_cases ( ( i : ℝ ) + 1 ) ( ( j : ℝ ) + 1 ) <;> cases min_cases ( ( i : ℝ ) + 1 ) ( ( j : ℝ ) + 1 ) <;> nlinarith [ show ( i : ℝ ) + 1 ≤ N by norm_cast; linarith [ Finset.mem_range.mp hi ], show ( j : ℝ ) + 1 ≤ N by norm_cast; linarith [ Finset.mem_range.mp hj ] ] ;
      -- By sum_inv_dist_bound, we know that $\sum_{n \neq m} \frac{1}{|n-m|} \leq 4N^{1.5}$.
      have h_sum_inv_dist_bound : ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (if n ≠ m then (1 / |(n : ℝ) - m|) else 0) ≤ 4 * (N : ℝ) ^ (3 / 2 : ℝ) := by
        convert sum_inv_dist_bound N using 1;
      refine le_trans h_sum_integral_bound <| le_trans h_sum_term_bound <| le_trans h_sum_bound ?_;
      convert mul_le_mul_of_nonneg_left h_sum_inv_dist_bound ( show ( 0 : ℝ ) ≤ 2 * Real.sqrt N by positivity ) using 1 <;> norm_num [ Finset.sum_ite ] ; ring;
      · simp +decide only [mul_comm, mul_left_comm, Finset.mul_sum _ _ _];
      · rw [ show ( N : ℝ ) ^ ( 3 / 2 : ℝ ) = N * Real.sqrt N by rw [ Real.sqrt_eq_rpow, ← Real.rpow_one_add' ] <;> norm_num ] ; ring;
        rw [ Real.sq_sqrt ( Nat.cast_nonneg _ ) ] ; ring
end OffDiagonalIntegralV2
