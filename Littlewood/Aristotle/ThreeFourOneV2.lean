/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 091f7c75-9f6b-446c-8e2e-20be29214c6f

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

KEY RESULTS:
- trig_ineq: 3 + 4cos(θ) + cos(2θ) ≥ 0 (the fundamental identity)
- three_four_one: |ζ(σ)|³|ζ(σ+it)|⁴|ζ(σ+2it)| ≥ 1
- zeta_ne_zero_re_one: ζ(1+it) ≠ 0 for t ≠ 0 (MAJOR RESULT!)
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators Real Nat Classical Pointwise
open Complex

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-! ## The Fundamental Trigonometric Identity -/

/-- The key identity: 3 + 4cos(θ) + cos(2θ) = 2(1 + cos(θ))² ≥ 0. -/
lemma trig_ineq_v2 (θ : ℝ) : 3 + 4 * Real.cos θ + Real.cos (2 * θ) ≥ 0 := by
  nlinarith [sq_nonneg (Real.cos θ + 1), Real.cos_sq_le_one θ, Real.cos_two_mul θ]

/-! ## Logarithmic Identities -/

/-- The Euler product gives: log‖ζ(s)‖ = Σ_p log‖(1-p^{-s})⁻¹‖ -/
lemma log_norm_zeta_eq_tsum_v2 (s : ℂ) (hs : 1 < s.re) :
    Real.log ‖riemannZeta s‖ = ∑' p : Nat.Primes, Real.log ‖(1 - (p : ℂ) ^ (-s))⁻¹‖ := by
  have h_prod := riemannZeta_eulerProduct_exp_log hs
  rw [← h_prod, Complex.norm_exp, Real.log_exp]
  -- Goal: (∑' p, -log (1 - ↑↑p ^ (-s))).re = ∑' p, Real.log ‖(1 - ↑↑p ^ (-s))⁻¹‖
  -- Summability of the Euler factor logarithms
  have h_summ : Summable (fun p : Nat.Primes => -log (1 - (p : ℂ) ^ (-s))) := by
    have h := DirichletCharacter.summable_neg_log_one_sub_mul_prime_cpow
      (1 : DirichletCharacter ℂ 1) hs
    simp only [MulChar.one_apply (isUnit_of_subsingleton _), one_mul] at h
    exact h
  -- Commute Re with tsum via the continuous linear map reCLM
  rw [show (∑' p : Nat.Primes, -log (1 - (p : ℂ) ^ (-s))).re =
      ∑' p : Nat.Primes, (-log (1 - (p : ℂ) ^ (-s))).re from
    Complex.reCLM.map_tsum h_summ]
  -- Pointwise equality: (-log(1-p^{-s})).re = log ‖(1-p^{-s})⁻¹‖
  congr 1; ext ⟨p, hp⟩
  rw [neg_re, log_re, norm_inv, Real.log_inv]

/-! ## Term-by-Term Analysis -/

/-- Each term in the 3-4-1 combination is non-negative. -/
lemma term_nonneg_v2 (r : ℝ) (hr : 0 ≤ r) (θ : ℝ) :
    3 + 4 * Real.cos θ + Real.cos (2 * θ) ≥ 0 :=
  trig_ineq_v2 θ

/-! ## The 3-4-1 Inequality -/

/-- The 3-4-1 log combination: 3 log‖ζ(σ)‖ + 4 log‖ζ(σ+it)‖ + log‖ζ(σ+2it)‖ ≥ 0. -/
lemma log_zeta_combination_nonneg_v2 (σ : ℝ) (hσ : 1 < σ) (t : ℝ) :
    3 * Real.log ‖riemannZeta σ‖ + 4 * Real.log ‖riemannZeta (σ + I * t)‖ +
      Real.log ‖riemannZeta (σ + 2 * I * t)‖ ≥ 0 := by
  -- Use Mathlib's LFunction product inequality for trivial character mod 1
  have hx : 0 < σ - 1 := by linarith
  have h := DirichletCharacter.norm_LFunction_product_ge_one (1 : DirichletCharacter ℂ 1) hx t
  -- Convert LFunction to riemannZeta (LFunction_modOne_eq : LFunction χ = riemannZeta for level 1)
  simp only [DirichletCharacter.LFunction_modOne_eq, one_pow] at h
  -- Simplify arguments: 1 + ↑(σ - 1) = ↑σ
  rw [show (1 : ℂ) + ↑(σ - 1) = (σ : ℂ) from by push_cast; ring] at h
  -- Distribute norms over products and powers
  rw [norm_mul, norm_mul, norm_pow, norm_pow] at h
  -- h : ‖riemannZeta ↑σ‖ ^ 3 * ‖riemannZeta (↑σ + I * ↑t)‖ ^ 4 * ‖riemannZeta (↑σ + 2 * I * ↑t)‖ ≥ 1
  -- All zeta values nonzero for Re > 1
  have hne1 : riemannZeta (σ : ℂ) ≠ 0 :=
    riemannZeta_ne_zero_of_one_lt_re (by simpa using hσ)
  have hne2 : riemannZeta (↑σ + I * ↑t) ≠ 0 :=
    riemannZeta_ne_zero_of_one_lt_re (by simp [add_re, mul_re, I_re, I_im]; linarith)
  have hne3 : riemannZeta (↑σ + 2 * I * ↑t) ≠ 0 :=
    riemannZeta_ne_zero_of_one_lt_re (by simp [add_re, mul_re, I_re, I_im]; linarith)
  have hp1 := norm_pos_iff.mpr hne1
  have hp2 := norm_pos_iff.mpr hne2
  have hp3 := norm_pos_iff.mpr hne3
  -- Take log: product ≥ 1 implies log(product) ≥ 0
  have h_log := Real.log_nonneg h
  -- Expand log(a^3 * b^4 * c) = 3*log(a) + 4*log(b) + log(c)
  rw [Real.log_mul (ne_of_gt (mul_pos (pow_pos hp1 3) (pow_pos hp2 4))) (ne_of_gt hp3)] at h_log
  rw [Real.log_mul (ne_of_gt (pow_pos hp1 3)) (ne_of_gt (pow_pos hp2 4))] at h_log
  rw [Real.log_pow, Real.log_pow] at h_log
  push_cast at h_log ⊢
  linarith

/-- **The 3-4-1 inequality**: |ζ(σ)|³ · |ζ(σ+it)|⁴ · |ζ(σ+2it)| ≥ 1 for σ > 1. -/
theorem three_four_one_v2 (σ : ℝ) (hσ : 1 < σ) (t : ℝ) :
    ‖riemannZeta σ‖ ^ 3 * ‖riemannZeta (σ + I * t)‖ ^ 4 *
      ‖riemannZeta (σ + 2 * I * t)‖ ≥ 1 := by
  have h_zeta_ne_zero_sigma : riemannZeta (σ : ℂ) ≠ 0 :=
    riemannZeta_ne_zero_of_one_lt_re (by simpa using hσ)
  have h_zeta_ne_zero_sigma_it : riemannZeta (σ + I * t) ≠ 0 :=
    riemannZeta_ne_zero_of_one_lt_re (by simp [add_re, ofReal_re, mul_re, I_re, I_im]; linarith)
  have h_zeta_ne_zero_sigma_2it : riemannZeta (σ + 2 * I * t) ≠ 0 :=
    riemannZeta_ne_zero_of_one_lt_re (by simp [add_re, ofReal_re, mul_re, I_re, I_im]; linarith)
  have h_norm_pos_sigma : 0 < ‖riemannZeta (σ : ℂ)‖ := norm_pos_iff.mpr h_zeta_ne_zero_sigma
  have h_norm_pos_sigma_it : 0 < ‖riemannZeta (σ + I * t)‖ := norm_pos_iff.mpr h_zeta_ne_zero_sigma_it
  have h_norm_pos_sigma_2it : 0 < ‖riemannZeta (σ + 2 * I * t)‖ := norm_pos_iff.mpr h_zeta_ne_zero_sigma_2it
  rw [ge_iff_le, ← Real.log_le_log_iff (by positivity) (by positivity)]
  simp only [Real.log_one]
  rw [Real.log_mul (ne_of_gt (by positivity)) (ne_of_gt h_norm_pos_sigma_2it)]
  rw [Real.log_mul (ne_of_gt (by positivity)) (ne_of_gt (by positivity))]
  rw [Real.log_pow, Real.log_pow]
  have h := log_zeta_combination_nonneg_v2 σ hσ t
  push_cast at *
  linarith

/-! ## Non-Vanishing on Re(s) = 1 -/

/-- **ζ(1+it) ≠ 0 for t ≠ 0**: The Riemann zeta function has no zeros on the line Re(s) = 1.
This is a key ingredient in the Prime Number Theorem. The proof uses the 3-4-1 inequality. -/
theorem zeta_ne_zero_re_one_v2 (t : ℝ) (ht : t ≠ 0) : riemannZeta (1 + I * t) ≠ 0 :=
  riemannZeta_ne_zero_of_one_le_re (by simp [add_re, mul_re, I_re, I_im, ofReal_re, ofReal_im])

end
