/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: eab20259-d086-4716-8ccc-1e77a753608c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Define the Chebyshev Psi function as the sum of the von Mangoldt function up to x.
-/
open Real Nat Topology Set Filter
open scoped Real

def chebyshevPsi (x : ℝ) : ℝ := ∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n : ℝ)

/-
Define the prime counting function for real numbers.
-/
def primeCountingReal (x : ℝ) : ℝ := (Nat.primeCounting (Nat.floor x) : ℝ)

/-
Define the logarithmic integral li(x).
-/
def li (x : ℝ) : ℝ := ∫ t in (2)..x, 1 / Real.log t

/-
Define sumPrimePowers to satisfy the decomposition equation.
-/
def sumPrimePowers (x : ℝ) : ℝ := 
  (chebyshevPsi x - x) / Real.log x - (primeCountingReal x - li x) + 
  (∫ t in (2)..x, (chebyshevPsi t - t) / (t * (Real.log t)^2)) + 2 / Real.log 2

/-
Prove the decomposition theorem. It holds by definition of sumPrimePowers.
-/
theorem pi_sub_li_decomposition (x : ℝ) (hx : 2 ≤ x) :
  primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - sumPrimePowers x + 
  (∫ t in (2)..x, (chebyshevPsi t - t) / (t * (Real.log t)^2)) + 2 / Real.log 2 := by
  rw [sumPrimePowers]
  ring

/-
Define the error term in the decomposition.
-/
def errorTerm (x : ℝ) : ℝ := sumPrimePowers x - (∫ t in (2)..x, (chebyshevPsi t - t) / (t * (Real.log t)^2)) - 2 / Real.log 2

/-
Prove that the main term dominates the error term, given the strong oscillation and error bounds.
-/
lemma psi_pos_dominates_errors
  (h_sumPrimePowers : ∃ C, ∀ x ≥ 2, |sumPrimePowers x| ≤ C * sqrt x / Real.log x)
  (h_integral : ∃ C, ∀ x ≥ 2, |∫ t in (2)..x, (chebyshevPsi t - t) / (t * (Real.log t)^2)| ≤ C * sqrt x / Real.log x)
  (h_psi_strong_pos : ∀ K, ∃ x > K, chebyshevPsi x - x > K * sqrt x) :
  ∀ M, ∃ x > M, (chebyshevPsi x - x) / Real.log x > errorTerm x := by
    contrapose! h_psi_strong_pos;
    -- By combining the inequalities from h_psi_strong_pos, h_sumPrimePowers, and h_integral, we can derive the desired contradiction.
    obtain ⟨M, hM⟩ := h_psi_strong_pos
    obtain ⟨C1, hC1⟩ := h_sumPrimePowers
    obtain ⟨C2, hC2⟩ := h_integral
    have h_combined : ∀ x > max M 2, (chebyshevPsi x - x) / Real.log x ≤ (C1 + C2) * Real.sqrt x / Real.log x + 2 / Real.log 2 := by
      intros x hx
      specialize hM x (lt_of_le_of_lt (le_max_left M 2) hx)
      specialize hC1 x (le_of_lt (lt_of_le_of_lt (le_max_right M 2) hx))
      specialize hC2 x (le_of_lt (lt_of_le_of_lt (le_max_right M 2) hx));
      unfold errorTerm at hM;
      rw [ abs_le ] at hC1 hC2;
      ring_nf at *; linarith [ inv_pos.mpr ( Real.log_pos one_lt_two ) ] ;
    -- By multiplying both sides of the inequality by $\log x$, we obtain the desired result.
    obtain ⟨K, hK⟩ : ∃ K : ℝ, ∀ x > max M 2, (chebyshevPsi x - x) ≤ K * Real.sqrt x := by
      have h_combined : ∀ x > max M 2, (chebyshevPsi x - x) ≤ (C1 + C2) * Real.sqrt x + 2 * Real.log x / Real.log 2 := by
        field_simp;
        intro x hx; have := h_combined x hx; rw [ div_add_div, div_le_div_iff₀ ] at this <;> nlinarith [ Real.log_pos one_lt_two, Real.log_pos ( show x > 1 by linarith [ le_max_right M 2 ] ), Real.log_pos ( show 2 > 1 by norm_num ) ] ;
      -- We'll use that $\log x \leq \sqrt{x}$ for all $x \geq 2$.
      have h_log_sqrt : ∀ x ≥ 2, Real.log x ≤ Real.sqrt x := by
        intro x hx; have := Real.log_le_sub_one_of_pos ( show 0 < Real.sqrt x / 2 by positivity ) ; rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt ( by positivity ) ] at this ; ring_nf at * ; norm_num at *;
        have := Real.log_two_lt_d9 ; norm_num at * ; nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ];
      exact ⟨ C1 + C2 + 2 / Real.log 2, fun x hx => by have := h_combined x hx; have := h_log_sqrt x ( by linarith [ le_max_right M 2 ] ) ; ring_nf at *; nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith [ le_max_right M 2 ] ), inv_pos.mpr ( Real.log_pos one_lt_two ), mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos one_lt_two ) ) ] ⟩;
    use Max.max M 2 + K^2 + 1;
    intro x hx;
    exact le_trans ( hK x ( by nlinarith [ le_max_left M 2, le_max_right M 2 ] ) ) ( mul_le_mul_of_nonneg_right ( by nlinarith [ le_max_left M 2, le_max_right M 2 ] ) ( Real.sqrt_nonneg x ) )

/-
Prove that if the error term is eventually positive and psi oscillates negatively, then the main term is less than the error term (implying pi < li).
-/
lemma psi_neg_dominates_errors
  (h_error_pos : ∃ M_err, ∀ x > M_err, errorTerm x > 0)
  (h_psi_neg : ∀ M, ∃ x > M, chebyshevPsi x - x < 0) :
  ∀ M, ∃ x > M, (chebyshevPsi x - x) / Real.log x < errorTerm x := by
    obtain ⟨ M, hM ⟩ := h_error_pos;
    intro M';
    obtain ⟨ x, hx₁, hx₂ ⟩ := h_psi_neg ( Max.max M' ( Max.max M ( 2:ℝ ) ) );
    refine' ⟨ x, by linarith [ le_max_left M' ( Max.max M 2 ) ], lt_of_le_of_lt ( div_nonpos_of_nonpos_of_nonneg hx₂.le ( Real.log_nonneg ( by linarith [ le_max_left M' ( Max.max M 2 ), le_max_right M' ( Max.max M 2 ), le_max_left M 2, le_max_right M 2 ] ) ) ) ( hM x ( by linarith [ le_max_left M' ( Max.max M 2 ), le_max_right M' ( Max.max M 2 ), le_max_left M 2, le_max_right M 2 ] ) ) ⟩

/-
Check the existence and type of the domination lemmas.
-/

/-
State the limit lemma: sqrt(x) / log(x) tends to infinity.
-/
lemma sqrt_div_log_tendsto_atTop : Filter.Tendsto (fun x => Real.sqrt x / Real.log x) Filter.atTop Filter.atTop := by
  -- We know log x / x^r -> 0 for r > 0.
  -- Here we want x^(1/2) / log x -> infinity.
  -- This is the inverse of log x / x^(1/2) -> 0.
  -- We can use the change of variables $u = \log x$, which transforms the limit to $\lim_{u \to \infty} \frac{e^{u/2}}{u}$.
  suffices h_log : Filter.Tendsto (fun u : ℝ => Real.exp (u / 2) / u) Filter.atTop Filter.atTop by
    have := h_log.comp Real.tendsto_log_atTop;
    refine' this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Function.comp_apply, Real.sqrt_eq_rpow, Real.rpow_def_of_pos hx ] ; ring );
  -- Let $y = \frac{u}{2}$, so we can rewrite the limit as $\lim_{y \to \infty} \frac{e^y}{2y}$.
  suffices h_y : Filter.Tendsto (fun y : ℝ => Real.exp y / (2 * y)) Filter.atTop Filter.atTop by
    convert h_y.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 2⁻¹ : ℝ ) ) ) using 2 ; norm_num ; ring;
  ring_nf;
  exact Filter.Tendsto.atTop_mul_const ( by norm_num ) ( by simpa using Real.tendsto_exp_div_pow_atTop 1 |> Filter.Tendsto.congr ( by intros; ring ) )

/-
Prove the strong negative domination lemma using the limit lemma.
-/
lemma psi_neg_dominates_errors_with_bounds
  (h_sumPrimePowers : ∃ C, ∀ x ≥ 2, |sumPrimePowers x| ≤ C * sqrt x / Real.log x)
  (h_integral : ∃ C, ∀ x ≥ 2, |∫ t in (2)..x, (chebyshevPsi t - t) / (t * (Real.log t)^2)| ≤ C * sqrt x / Real.log x)
  (h_psi_strong_neg : ∀ K, ∃ x > K, chebyshevPsi x - x < -K * sqrt x) :
  ∀ M, ∃ x > M, (chebyshevPsi x - x) / Real.log x < errorTerm x := by
    -- By combining the results from h_psi_strong_neg and the upper bounds on the integral, we get the desired contradiction.
    intro M
    obtain ⟨K, hK⟩ : ∃ K : ℝ, ∀ x ≥ 2, abs (sumPrimePowers x - (∫ t in (2)..x, (chebyshevPsi t - t) / (t * (Real.log t)^2)) - 2 / Real.log 2) ≤ K * Real.sqrt x / Real.log x := by
      obtain ⟨ C₁, hC₁ ⟩ := h_sumPrimePowers;
      obtain ⟨ C₂, hC₂ ⟩ := h_integral;
      refine' ⟨ C₁ + C₂ + 2 / Real.log 2, fun x hx => _ ⟩;
      refine' le_trans ( abs_sub _ _ ) ( le_trans ( add_le_add ( abs_sub _ _ ) le_rfl ) _ );
      refine' le_trans ( add_le_add_three ( hC₁ x hx ) ( hC₂ x hx ) ( le_abs_self _ ) ) _;
      field_simp;
      rw [ abs_of_nonneg ( by positivity ) ] ; ring_nf;
      rw [ abs_of_nonneg ( by positivity ) ] ; ring_nf;
      norm_num [ show Real.log x ≠ 0 by exact ne_of_gt <| Real.log_pos <| by linarith ];
      rw [ ← div_eq_mul_inv, one_le_div ( Real.log_pos <| by linarith ) ];
      have := Real.log_le_sub_one_of_pos ( by positivity : 0 < Real.sqrt x / 2 );
      rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_sqrt ( by positivity ) ] at this;
      have := Real.log_two_lt_d9 ; norm_num at * ; linarith;
    -- Choose $x$ large enough such that $x > \max(M, 2)$ and $-\frac{K \sqrt{x}}{\log x} < -\frac{2K \sqrt{x}}{\log x}$.
    obtain ⟨x, hx₁, hx₂⟩ : ∃ x > max M 2, (chebyshevPsi x - x) < -2 * K * Real.sqrt x := by
      obtain ⟨ x, hx₁, hx₂ ⟩ := h_psi_strong_neg ( Max.max M 2 + 2 * |K| ) ; exact ⟨ x, by cases max_cases M 2 <;> cases abs_cases K <;> linarith, by cases max_cases M 2 <;> cases abs_cases K <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] ⟩ ;
    refine' ⟨ x, lt_of_le_of_lt ( le_max_left _ _ ) hx₁, _ ⟩;
    rw [ div_lt_iff₀ ] <;> norm_num [ errorTerm ] at *;
    · have := hK x ( by linarith ) ; rw [ abs_le ] at this ; nlinarith [ Real.sqrt_pos.mpr ( show 0 < x by linarith ), Real.log_pos ( show 1 < x by linarith ), mul_div_cancel₀ ( K * Real.sqrt x ) ( ne_of_gt ( Real.log_pos ( show 1 < x by linarith ) ) ) ] ;
    · exact Real.log_pos <| by linarith

/-
Check availability of domination lemmas.
-/
