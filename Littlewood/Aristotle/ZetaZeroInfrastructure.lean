/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2107b47c-78e6-4503-8a96-51c23bc7a4e3

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A complex number s is a non-trivial zero of the Riemann zeta function if ζ(s) = 0 and 0 < Re(s) < 1.
-/
open Complex Real Topology Filter

def isNontrivialZero (s : ℂ) : Prop :=
  riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1

/-
The set of non-trivial zeros of the Riemann zeta function with imaginary part bounded by T in absolute value.
-/
def zetaZerosUpTo (T : ℝ) : Set ℂ :=
  {s | isNontrivialZero s ∧ |s.im| ≤ T}

/-
The set of non-trivial zeros of the Riemann zeta function that lie on the critical line (Re(s) = 1/2) with imaginary part bounded by T in absolute value.
-/
def criticalLineZeros (T : ℝ) : Set ℂ :=
  {s | isNontrivialZero s ∧ s.re = 1/2 ∧ |s.im| ≤ T}

/-
Constants C and c_zero_free used in the bounds, defined as 1 for formalization purposes, with lemmas stating they are positive.
-/
def C : ℝ := 1
def c_zero_free : ℝ := 1

lemma C_pos : 0 < C := by
  exact zero_lt_one

lemma c_zero_free_pos : 0 < c_zero_free := by
  simp [c_zero_free]

/-
The norm of the term x^ρ/ρ is equal to x^(Re ρ) divided by the norm of ρ, for positive x.
-/
open Complex Real

lemma term_norm_eq (x : ℝ) (hx : 0 < x) (ρ : ℂ) :
    norm ((x : ℂ)^ρ / ρ) = (x : ℝ)^(ρ.re) / norm ρ := by
      norm_num [ Complex.norm_cpow_eq_rpow_re_of_pos hx ]

/-
The norm of the sum of x^ρ/ρ over the zeros is bounded by the sum of x^(Re ρ)/|ρ|.
-/
open Complex Real

lemma sum_abs_bound (x : ℝ) (hx : 1 < x) (T : ℝ) :
    norm (∑' ρ : zetaZerosUpTo T, (x : ℂ)^(ρ : ℂ) / (ρ : ℂ)) ≤
    ∑' ρ : zetaZerosUpTo T, (x : ℝ)^((ρ : ℂ).re) / norm (ρ : ℂ) := by
      have := @norm_tsum_le_tsum_norm;
      by_cases h : Summable fun ρ : zetaZerosUpTo T => ‖ ( x : ℂ ) ^ ( ρ : ℂ ) / ρ‖ <;> simp_all +decide [ Complex.norm_exp, Complex.norm_exp ];
      convert this _ using 1;
      · norm_num [ Complex.norm_exp, Complex.norm_cpow_eq_rpow_re_of_pos ( zero_lt_one.trans hx ) ];
      · simpa [ Complex.norm_exp ] using h;
      · rw [ tsum_eq_zero_of_not_summable ];
        · simp;
          exact tsum_nonneg fun _ => div_nonneg ( Real.rpow_nonneg ( by positivity ) _ ) ( norm_nonneg _ );
        · exact fun H => h <| H.norm.congr fun _ => by norm_num;

/-
If ρ lies in the zero-free region, then x^Re(ρ) is bounded by x * x^(-c/log|Im(ρ)|).
-/
open Complex Real

lemma zero_free_region_bound (x : ℝ) (hx : 1 < x) (ρ : ℂ) (h_zero_free : ρ.re ≤ 1 - c_zero_free / Real.log (abs ρ.im)) :
    (x : ℝ)^(ρ.re) ≤ x * x^(-c_zero_free / Real.log (abs ρ.im)) := by
      convert Real.rpow_le_rpow_of_exponent_le hx.le h_zero_free using 1 ; ring;
      rw [ sub_eq_add_neg, Real.rpow_add ( by positivity ), Real.rpow_one ]

/-
Definitions of the key bounds and properties assumed in the proof: the density estimate consequence, the critical line sum bound, and the zero-free region property.
-/
open Complex Real

def DensityEstimateConsequence (x T : ℝ) : Prop :=
  (∑' ρ : zetaZerosUpTo T, (x : ℝ)^(-c_zero_free / Real.log (norm (ρ : ℂ))) / norm (ρ : ℂ)) ≤
  C * (Real.log (x * T))^2 / T

def CriticalLineSumBound (T : ℝ) : Prop :=
  (∑' ρ : criticalLineZeros T, 1 / norm (ρ : ℂ)) ≤ Real.log T

def ZeroFreeRegion (T : ℝ) : Prop :=
  ∀ ρ : zetaZerosUpTo T, (ρ : ℂ).re ≤ 1 - c_zero_free / Real.log (abs (ρ : ℂ).im)

/-
The zeros of the Riemann zeta function are isolated points.
-/
open Complex Real Topology Filter

lemma zeta_zeros_isolated (s : ℂ) (hs : riemannZeta s = 0) (h_ne_one : s ≠ 1) :
    ∃ ε > 0, ∀ z ∈ Metric.ball s ε, riemannZeta z = 0 → z = s := by
      have h_analytic : AnalyticAt ℂ riemannZeta s := by
        apply_rules [ DifferentiableOn.analyticAt ];
        swap;
        exact IsOpen.mem_nhds ( isOpen_compl_singleton.preimage continuous_id' ) h_ne_one;
        refine' fun x hx => DifferentiableAt.differentiableWithinAt _;
        exact differentiableAt_riemannZeta hx
      have := h_analytic.eventually_eq_zero_or_eventually_ne_zero;
      cases' this with h h;
      · have h_zero : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
          intro z hz;
          apply_rules [ DifferentiableOn.analyticAt, riemannZeta ];
          rotate_right;
          exact { w : ℂ | w ≠ 1 };
          · intro w hw;
            refine' DifferentiableAt.differentiableWithinAt _;
            exact differentiableAt_riemannZeta hw
          · exact isOpen_ne.mem_nhds hz.2;
        have h_zero : ∀ z : ℂ, z ≠ 1 → riemannZeta z = 0 := by
          intro z hz;
          apply h_zero.eqOn_zero_of_preconnected_of_eventuallyEq_zero;
          any_goals exact s;
          · have h_preconnected : IsPreconnected (Set.univ \ {0} : Set ℂ) := by
              have h_connected : IsConnected (Set.univ \ {0} : Set ℂ) := by
                have h_connected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
                  exact isConnected_range ( Complex.continuous_exp );
                convert h_connected using 1;
                ext; simp [Complex.exp_ne_zero]
              exact h_connected.isPreconnected;
            convert h_preconnected.image ( fun z => z + 1 ) ( Continuous.continuousOn ( by continuity ) ) using 1 ; ext ; aesop;
          · aesop;
          · exact h;
          · aesop;
        exact absurd ( h_zero 2 ( by norm_num ) ) ( by norm_num [ riemannZeta_two ] );
      · rw [ eventually_nhdsWithin_iff ] at h;
        rw [ Metric.eventually_nhds_iff ] at h;
        exact ⟨ h.choose, h.choose_spec.1, fun z hz hz' => Classical.not_not.1 fun hz'' => h.choose_spec.2 hz ( by simpa using hz'' ) hz' ⟩

/-
The rectangular region [0, 1] x [-T, T] in the complex plane is compact.
-/
open Complex Real Topology Filter

def criticalBox (T : ℝ) : Set ℂ :=
  {s | 0 ≤ s.re ∧ s.re ≤ 1 ∧ |s.im| ≤ T}

lemma criticalBox_compact (T : ℝ) : IsCompact (criticalBox T) := by
  have h_eq : criticalBox T =
      (fun p : ℝ × ℝ => (↑p.1 : ℂ) + ↑p.2 * Complex.I) '' (Set.Icc 0 1 ×ˢ Set.Icc (-T) T) := by
    ext s
    simp only [criticalBox, Set.mem_setOf_eq, Set.mem_image, Set.mem_prod, Set.mem_Icc,
      Prod.exists, abs_le]
    constructor
    · intro ⟨h1, h2, h3, h4⟩
      exact ⟨s.re, s.im, ⟨⟨h1, h2⟩, ⟨h3, h4⟩⟩, Complex.re_add_im s⟩
    · rintro ⟨a, b, ⟨⟨ha1, ha2⟩, ⟨hb1, hb2⟩⟩, hab⟩
      have hre : s.re = a := by
        have := congr_arg Complex.re hab; simp at this; exact this.symm
      have him : s.im = b := by
        have := congr_arg Complex.im hab; simp at this; exact this.symm
      rw [hre, him]; exact ⟨ha1, ha2, hb1, hb2⟩
  rw [h_eq]
  exact (isCompact_Icc.prod isCompact_Icc).image
    ((Complex.continuous_ofReal.comp continuous_fst).add
      ((Complex.continuous_ofReal.comp continuous_snd).mul continuous_const))

/-
The Riemann zeta function is non-zero for complex numbers with real part 0 or 1.
-/
open Complex Real Topology Filter

lemma no_zeros_on_boundary (s : ℂ) (h_re : s.re = 0 ∨ s.re = 1) : riemannZeta s ≠ 0 := by
  cases h_re <;> simp_all +decide [ riemannZeta ];
  · have h_hurwitz : ∀ s : ℂ, s.re = 0 → riemannZeta s ≠ 0 := by
      intro s hs; intro H; have := @riemannZeta_ne_zero_of_one_le_re ( 1 - s ) ; simp_all +decide [ Complex.ext_iff ] ;
      have := @riemannZeta_one_sub s; simp_all +decide [ Complex.ext_iff ] ;
      by_cases h : s.im = 0 <;> simp_all +decide [ Complex.ext_iff ];
      rw [ show s = 0 by refine' Complex.ext _ _ <;> aesop ] at H ; norm_num [ riemannZeta ] at H;
      norm_num [ HurwitzZeta.hurwitzZetaEven ] at H;
    exact h_hurwitz s ‹_›
  · have h_prime_number_theorem : ∀ s : ℂ, s.re = 1 → riemannZeta s ≠ 0 := by
      intro s hs; exact (by
      convert riemannZeta_ne_zero_of_one_le_re _ using 1 ; aesop);
    convert h_prime_number_theorem s ‹_› using 1

/-
A compact set with the discrete topology is finite.
-/
open Complex Real Topology Filter

lemma finite_subset_of_compact_discrete {X : Type*} [TopologicalSpace X] {S : Set X} (h_compact : IsCompact S) (h_discrete : DiscreteTopology S) : Set.Finite S := by
  exact h_compact.finite ⟨h_discrete⟩

/-
The set of non-trivial zeros up to T is equal to the intersection of the zero set of the zeta function and the closed critical box.
-/
open Complex Real Topology Filter

lemma zetaZerosUpTo_eq_closed_inter (T : ℝ) :
    zetaZerosUpTo T = {s | riemannZeta s = 0} ∩ criticalBox T := by
      apply Set.ext
      intro s
      simp [zetaZerosUpTo, criticalBox];
      exact ⟨ fun h => ⟨ h.1.1, h.1.2.1.le, h.1.2.2.le, h.2 ⟩, fun h => ⟨ ⟨ h.1, lt_of_le_of_ne h.2.1 ( Ne.symm <| by intro h'; have := no_zeros_on_boundary s; aesop ), lt_of_le_of_ne h.2.2.1 <| by intro h'; have := no_zeros_on_boundary s; aesop ⟩, h.2.2.2 ⟩ ⟩

/-
The set of zeros of the Riemann zeta function is a closed set.
-/
open Complex Real Topology Filter

lemma isClosed_zeta_zeros : IsClosed {s : ℂ | riemannZeta s = 0} := by
  have h_analytic : ∀ s : ℂ, s ≠ 1 → AnalyticAt ℂ riemannZeta s := by
    intro s hs; exact (by
    apply_rules [ DifferentiableOn.analyticAt, riemannZeta ];
    swap;
    exact IsOpen.mem_nhds ( isOpen_compl_singleton.preimage continuous_id' ) hs;
    intro s hs; exact ( by exact differentiableAt_riemannZeta hs |> DifferentiableAt.differentiableWithinAt ) ;);
  refine' isClosed_iff_clusterPt.mpr _;
  intro s hs
  by_cases hs1 : s = 1;
  · rw [ clusterPt_principal_iff ] at hs;
    contrapose! hs;
    have h_pole : Filter.Tendsto (fun s : ℂ => (s - 1) * riemannZeta s) (nhdsWithin 1 {1}ᶜ) (nhds 1) := by
      exact riemannZeta_residue_one
    have := h_pole.eventually_ne one_ne_zero;
    rw [ eventually_nhdsWithin_iff ] at this; aesop;
  · have := h_analytic s hs1;
    have := this.continuousAt.tendsto;
    rw [ clusterPt_principal_iff ] at hs;
    contrapose! hs;
    exact ⟨ { z : ℂ | riemannZeta z ≠ 0 }, this.eventually_ne ( by simpa using hs ), by aesop ⟩

/-
The set of non-trivial zeros of the Riemann zeta function with imaginary part bounded by T is compact.
-/
open Complex Real Topology Filter

lemma zetaZerosUpTo_compact (T : ℝ) : IsCompact (zetaZerosUpTo T) := by
  convert IsCompact.inter_left ( criticalBox_compact T ) ( isClosed_zeta_zeros ) using 1;
  exact zetaZerosUpTo_eq_closed_inter T

/-
The set of non-trivial zeros of the Riemann zeta function with imaginary part bounded by T is finite.
-/
open Complex Real Topology Filter

lemma finite_zeros (T : ℝ) : Set.Finite (zetaZerosUpTo T) := by
  have h_discrete : DiscreteTopology (zetaZerosUpTo T) := by
    refine' singletons_open_iff_discrete.mp _;
    intro a
    obtain ⟨ε, hε_pos, hε⟩ : ∃ ε > 0, ∀ z ∈ Metric.ball a ε, riemannZeta z = 0 → z = a := by
      obtain ⟨ε, hε_pos, hε⟩ : ∃ ε > 0, ∀ z ∈ Metric.ball a.val ε, riemannZeta z = 0 → z = a.val := by
        have h_zero : riemannZeta a.val = 0 := by
          exact a.2.1.1
        have h_ne_one : a.val ≠ 1 := by
          exact fun h => by rw [ h ] at h_zero; exact absurd h_zero <| by exact riemannZeta_one_ne_zero
        exact zeta_zeros_isolated a.val h_zero h_ne_one
      refine' ⟨ ε, hε_pos, fun z hz hz' => Subtype.ext <| hε _ _ hz' ⟩ ; aesop;
    refine' Metric.isOpen_iff.2 _;
    intro x hx
    obtain ⟨ε', hε'_pos, hε'⟩ : ∃ ε' > 0, ∀ z ∈ Metric.ball x ε', riemannZeta z = 0 → z = x := by
      obtain ⟨ε', hε'_pos, hε'⟩ : ∃ ε' > 0, ∀ z ∈ Metric.ball x.val ε', riemannZeta z = 0 → z = x.val := by
        have h_zero : riemannZeta x.val = 0 := x.2.1.1
        have h_ne_one : x.val ≠ 1 := fun h => by rw [ h ] at h_zero; exact absurd h_zero riemannZeta_one_ne_zero
        exact zeta_zeros_isolated x.val h_zero h_ne_one
      exact ⟨ ε', hε'_pos, fun z hz hz' => Subtype.ext <| hε' _ (by exact_mod_cast hz) hz' ⟩
    use ε'
    refine ⟨ hε'_pos, fun y hy => ?_ ⟩
    simp only [Set.mem_singleton_iff]
    have hyx : y = x := hε' y (by exact_mod_cast hy) y.2.1.1
    simp only [Set.mem_singleton_iff] at hx
    rw [hyx, hx]
  apply finite_subset_of_compact_discrete;
  · exact zetaZerosUpTo_compact T
  · exact h_discrete

/-
The sum over all non-trivial zeros up to T splits into a sum over critical line zeros and a sum over off-critical line zeros.
-/
open Complex Real Topology Filter

def offCriticalZeros (T : ℝ) : Set ℂ :=
  {s | isNontrivialZero s ∧ s.re ≠ 1/2 ∧ |s.im| ≤ T}

lemma sum_split (T : ℝ) (f : ℂ → ℂ) :
    (∑' ρ : zetaZerosUpTo T, f ρ) =
    (∑' ρ : criticalLineZeros T, f ρ) + (∑' ρ : offCriticalZeros T, f ρ) := by
      have h_finite : Set.Finite (zetaZerosUpTo T) := finite_zeros T
      have h_split : (zetaZerosUpTo T) = (criticalLineZeros T) ∪ (offCriticalZeros T) := by
        ext s; simp [zetaZerosUpTo, criticalLineZeros, offCriticalZeros]; tauto
      have h_disjoint : Disjoint (criticalLineZeros T) (offCriticalZeros T) :=
        Set.disjoint_left.mpr fun x hx₁ hx₂ => hx₂.2.1 hx₁.2.1
      -- Since the set is finite, all tsum are really finite sums
      have hcrit_finite := h_finite.subset (h_split ▸ Set.subset_union_left)
      have hoff_finite := h_finite.subset (h_split ▸ Set.subset_union_right)
      haveI := hcrit_finite.fintype
      haveI := hoff_finite.fintype
      have hs : Summable (f ∘ (↑) : ↥(criticalLineZeros T) → ℂ) := ⟨_, hasSum_fintype _⟩
      have ht : Summable (f ∘ (↑) : ↥(offCriticalZeros T) → ℂ) := ⟨_, hasSum_fintype _⟩
      rw [show (zetaZerosUpTo T) = criticalLineZeros T ∪ offCriticalZeros T from h_split]
      exact hs.tsum_union_disjoint h_disjoint ht

end
