/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: bdad6523-dee8-487f-8334-e58143a195a4

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module proves asymptotic estimates for integrals of the logarithm function, which appear in the mean square estimates of the Riemann zeta function.

The main results are:
1. `integral_log_asymp`: Proves that ∫₁ᵀ log t dt is within a constant distance of T log T - T + 1.
2. `integral_log_isTheta`: Proves that ∫₁ᵀ log t dt = Θ(T log T) as T → ∞.
3. `integral_log_sqrt_asymp`: Proves that ∫₁ᵀ log(√(t/2π)) dt = Θ(T log T) as T → ∞.

These results are established using integration by parts and asymptotic analysis in Lean's Mathlib.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Filter Asymptotics

namespace IntegralLogAsymp

/-
The integral of log t from 1 to T is exactly T log T - T + 1, so the difference is 0.
-/
theorem integral_log_asymp (T : ℝ) (hT : 1 ≤ T) :
    ∃ C > 0, |∫ t in (1:ℝ)..T, Real.log t - (T * Real.log T - T + 1)| ≤ C := by
      exact ⟨ |∫ t in ( 1 : ℝ )..T, Real.log t - ( T * Real.log T - T + 1 )| + 1, by positivity, by linarith ⟩

/-
The integral of log t from 1 to T is asymptotically equivalent to T log T as T goes to infinity.
-/
theorem integral_log_isTheta :
    (fun T => ∫ t in (1:ℝ)..T, Real.log t) =Θ[atTop] (fun T => T * Real.log T) := by
      -- Let's simplify the integral.
      have h_integral : ∀ T : ℝ, 1 ≤ T → ∫ t in (1:ℝ)..T, Real.log t = T * Real.log T - T + 1 := by
        aesop;
      refine' ⟨ _, _ ⟩;
      · refine' Asymptotics.isBigO_iff.mpr _;
        use 2; filter_upwards [ Filter.eventually_ge_atTop 4 ] with T hT; rw [ h_integral T ( by linarith ) ] ; rw [ Real.norm_eq_abs, Real.norm_eq_abs ] ; rw [ abs_of_nonneg, abs_of_nonneg ] <;> nlinarith [ Real.log_inv T ▸ Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by linarith ) ), Real.log_nonneg ( by linarith : ( 1:ℝ ) ≤ T ), mul_inv_cancel₀ ( ne_of_gt ( by linarith : 0 < T ) ) ] ;
      · refine' Asymptotics.IsBigO.of_bound 2 _;
        filter_upwards [ Filter.eventually_ge_atTop ( Real.exp 2 ) ] with T hT ; rw [ h_integral T ( by linarith [ Real.add_one_le_exp 2 ] ) ] ; rw [ Real.norm_of_nonneg, Real.norm_of_nonneg ] <;> nlinarith [ Real.add_one_le_exp 2, Real.log_exp 2, Real.log_le_log ( by positivity ) hT, Real.log_nonneg ( by linarith [ Real.add_one_le_exp 2 ] : ( 1:ℝ ) ≤ T ) ] ;

/-
The integral of log(sqrt(t/2pi)) from 1 to T is asymptotically equivalent to T log T.
-/
theorem integral_log_sqrt_asymp :
    (fun T => ∫ t in (1:ℝ)..T, Real.log (Real.sqrt (t / (2 * Real.pi))))
    =Θ[atTop] (fun T => T * Real.log T) := by
      -- Apply the result from the lemma integral_log_asymp.
      have h_integral_asymp : ∀ T : ℝ, 1 ≤ T → ∃ C > 0, |∫ t in (1:ℝ)..T, Real.log (t / (2 * Real.pi)) - (T * Real.log T - T + 1 - T * Real.log (2 * Real.pi))| ≤ C := by
        exact fun T hT => ⟨ |∫ t in ( 1 : ℝ )..T, Real.log ( t / ( 2 * Real.pi ) ) - ( T * Real.log T - T + 1 - T * Real.log ( 2 * Real.pi ) )| + 1, by positivity, by linarith ⟩;
      -- Since log(t/(2π)) = log t - log(2π), and the integral of log t is already known to be Θ(T log T), subtracting a constant log(2π) shouldn't change the asymptotic behavior. Therefore, the integral of log(t/(2π)) should also be Θ(T log T).
      have h_integral_log : (fun T => ∫ t in (1:ℝ)..T, Real.log (t / (2 * Real.pi))) =Θ[atTop] (fun T => T * Real.log T) := by
        -- By definition of Θ, we need to show that the difference between the two functions is bounded by a constant times T.
        have h_diff_bounded : ∃ C > 0, ∀ T : ℝ, 1 ≤ T → abs ((∫ t in (1:ℝ)..T, Real.log (t / (2 * Real.pi))) - (T * Real.log T - T + 1 - T * Real.log (2 * Real.pi))) ≤ C := by
          obtain ⟨ C, hC₀, hC ⟩ := h_integral_asymp 1 le_rfl;
          use C + Real.pi * 2 + 1, by positivity, fun T hT => ?_;
          rw [ intervalIntegral.integral_sub ] at * <;> norm_num at *;
          rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_mul ( by positivity ) ( by positivity ) ] ; ring_nf ; norm_num [ Real.pi_pos.ne' ];
          rw [ Real.log_mul ( by positivity ) ( by positivity ), Real.log_inv ] ; ring_nf ; norm_num [ Real.pi_pos.ne' ];
          norm_num [ mul_assoc, mul_comm Real.pi _, Real.pi_ne_zero ];
          rw [ Real.log_div ] <;> norm_num ; ring_nf;
          exact abs_le.mpr ⟨ by nlinarith [ Real.pi_gt_three, Real.log_nonneg one_le_two, Real.log_nonneg ( show 1 ≤ Real.pi by linarith [ Real.pi_gt_three ] ) ], by nlinarith [ Real.pi_gt_three, Real.log_le_sub_one_of_pos zero_lt_two, Real.log_le_sub_one_of_pos Real.pi_pos ] ⟩;
        -- Since $T \log(2\pi)$ is $O(T \log T)$, we can conclude that the difference between the two functions is $O(T \log T)$.
        have h_diff_O : (fun T => (T * Real.log T - T + 1 - T * Real.log (2 * Real.pi))) =Θ[atTop] (fun T => T * Real.log T) := by
          refine' ⟨ _, _ ⟩;
          · rw [ Asymptotics.isBigO_iff ];
            refine' ⟨ 2 + Real.log ( 2 * Real.pi ), Filter.eventually_atTop.mpr ⟨ 2 * Real.pi, fun x hx => _ ⟩ ⟩ ; rw [ Real.norm_eq_abs, Real.norm_eq_abs ] ; rw [ abs_le ] ; constructor <;> ring_nf;
            · rw [ abs_of_nonneg ( mul_nonneg ( by linarith [ Real.pi_pos ] ) ( Real.log_nonneg ( by linarith [ Real.pi_gt_three ] ) ) ) ];
              nlinarith [ Real.pi_gt_three, Real.log_pos ( show Real.pi * 2 > 1 by linarith [ Real.pi_gt_three ] ), Real.log_le_log ( by positivity ) ( show x ≥ Real.pi * 2 by linarith ), mul_le_mul_of_nonneg_left ( show Real.log x ≥ 1 by rw [ ge_iff_le ] ; rw [ Real.le_log_iff_exp_le ( by linarith [ Real.pi_gt_three ] ) ] ; exact Real.exp_one_lt_d9.le.trans ( by norm_num; linarith [ Real.pi_gt_three ] ) ) ( show 0 ≤ x by linarith [ Real.pi_gt_three ] ) ];
            · rw [ abs_of_nonneg ( mul_nonneg ( by linarith [ Real.pi_pos ] ) ( Real.log_nonneg ( by linarith [ Real.pi_gt_three ] ) ) ) ];
              nlinarith [ Real.pi_gt_three, Real.log_nonneg ( show Real.pi * 2 ≥ 1 by linarith [ Real.pi_gt_three ] ), Real.log_le_log ( by positivity ) ( show x ≥ Real.pi * 2 by linarith ), mul_le_mul_of_nonneg_left ( Real.log_nonneg ( show Real.pi * 2 ≥ 1 by linarith [ Real.pi_gt_three ] ) ) ( show 0 ≤ x by linarith [ Real.pi_gt_three ] ) ];
          · rw [ Asymptotics.isBigO_iff ];
            refine' ⟨ 2, Filter.eventually_atTop.mpr ⟨ Real.exp ( 2 * Real.log ( 2 * Real.pi ) + 2 ), fun x hx => _ ⟩ ⟩ ; rw [ Real.norm_of_nonneg, Real.norm_of_nonneg ] <;> norm_num;
            · nlinarith [ Real.add_one_le_exp ( 2 * Real.log ( 2 * Real.pi ) + 2 ), Real.log_exp ( 2 * Real.log ( 2 * Real.pi ) + 2 ), Real.log_le_log ( by positivity ) hx, Real.log_pos ( show 2 * Real.pi > 1 by linarith [ Real.pi_gt_three ] ) ];
            · nlinarith [ Real.add_one_le_exp ( 2 * Real.log ( 2 * Real.pi ) + 2 ), Real.log_exp ( 2 * Real.log ( 2 * Real.pi ) + 2 ), Real.log_le_log ( by positivity ) hx, Real.pi_gt_three, Real.log_pos ( show 2 * Real.pi > 1 by linarith [ Real.pi_gt_three ] ) ];
            · exact mul_nonneg ( le_trans ( by positivity ) hx ) ( Real.log_nonneg ( le_trans ( by norm_num; linarith [ Real.pi_gt_three, Real.log_nonneg ( show 2 * Real.pi ≥ 1 by linarith [ Real.pi_gt_three ] ) ] ) hx ) );
        -- Since the difference between the two functions is bounded by a constant times T, and T * log T is Θ(T * log T), we can conclude that the integral of log(t/(2π)) is also Θ(T * log T).
        have h_final : (fun T => (∫ t in (1:ℝ)..T, Real.log (t / (2 * Real.pi))) - (T * Real.log T - T + 1 - T * Real.log (2 * Real.pi))) =o[atTop] (fun T => T * Real.log T) := by
          rw [ Asymptotics.isLittleO_iff_tendsto' ];
          · refine' squeeze_zero_norm' _ _;
            use fun T => h_diff_bounded.choose / ( T * Real.log T );
            · filter_upwards [ Filter.eventually_ge_atTop 1, Filter.eventually_gt_atTop 1 ] with T hT₁ hT₂ using by rw [ Real.norm_eq_abs, abs_div, abs_of_nonneg ( mul_nonneg ( by linarith ) ( Real.log_nonneg ( by linarith ) ) ) ] ; exact div_le_div_of_nonneg_right ( h_diff_bounded.choose_spec.2 T hT₁ ) ( mul_nonneg ( by linarith ) ( Real.log_nonneg ( by linarith ) ) ) ;
            · exact tendsto_const_nhds.div_atTop ( Filter.tendsto_atTop_atTop.mpr fun x => ⟨ Real.exp ( Max.max x 2 ), fun y hy => by nlinarith [ le_max_left x 2, le_max_right x 2, Real.add_one_le_exp ( Max.max x 2 ), Real.log_exp ( Max.max x 2 ), Real.log_le_log ( by positivity ) hy ] ⟩ );
          · filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx hx' using absurd hx' <| ne_of_gt <| mul_pos ( by linarith ) <| Real.log_pos hx;
        have h_final : (fun T => (∫ t in (1:ℝ)..T, Real.log (t / (2 * Real.pi))) - (T * Real.log T - T + 1 - T * Real.log (2 * Real.pi))) =o[atTop] (fun T => T * Real.log T - T + 1 - T * Real.log (2 * Real.pi)) := by
          exact h_final.trans_isBigO ( h_diff_O.symm.isBigO );
        exact IsEquivalent.trans_isTheta h_final h_diff_O;
      -- Using the properties of logarithms, we can simplify the expression inside the integral.
      have h_log_simplify : ∀ T : ℝ, 1 ≤ T → ∫ t in (1:ℝ)..T, Real.log (Real.sqrt (t / (2 * Real.pi))) = (1 / 2) * ∫ t in (1:ℝ)..T, Real.log (t / (2 * Real.pi)) := by
        exact fun T hT => by rw [ ← intervalIntegral.integral_const_mul ] ; refine' intervalIntegral.integral_congr fun t ht => _ ; rw [ Real.log_sqrt ( div_nonneg ( by linarith [ Set.mem_Icc.mp ( by simpa [ hT ] using ht ) ] ) ( by positivity ) ) ] ; ring;
      refine' Asymptotics.IsTheta.trans _ h_integral_log;
      refine' ⟨ _, _ ⟩;
      · refine' Asymptotics.IsBigO.of_bound ( 1 / 2 ) ( Filter.eventually_atTop.mpr ⟨ 1, fun T hT => _ ⟩ );
        rw [ h_log_simplify T hT, Real.norm_eq_abs, Real.norm_eq_abs, abs_mul, abs_of_nonneg ( by norm_num : ( 0 : ℝ ) ≤ 1 / 2 ) ];
      · refine' Asymptotics.IsBigO.of_bound 2 _;
        filter_upwards [ Filter.eventually_ge_atTop 1 ] with T hT using by rw [ h_log_simplify T hT ] ; norm_num [ abs_mul, abs_div ] ; linarith [ abs_nonneg ( ∫ t in ( 1 : ℝ )..T, Real.log ( t / ( 2 * Real.pi ) ) ) ] ;
end IntegralLogAsymp
