/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1df2e6a3-2fb6-49db-bfa0-41483395951c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The cosine function grows exponentially in vertical strips.
-/
lemma complex_cos_bound_vertical_strip (a b : ℝ) :
    ∃ C : ℝ, ∀ s : ℂ, a ≤ s.re → s.re ≤ b →
    ‖Complex.cos (Real.pi * s / 2)‖ ≤ C * Real.exp (Real.pi * |s.im| / 2) := by
      -- Set $C$ to be $\left(\exp\left(\frac{\pi}{2}\left(a^2 + b^2\right)\right) + \exp\left(\frac{\pi}{2}\left(a^2 + b^2\right)\right)\right) / \exp\left(\frac{\pi}{2}\cdot 0^2\right)$.
      use Real.exp ((Real.pi * (b - a)) / 2) + Real.exp ((Real.pi * (b - a)) / 2);
      -- Use the exponential representation of the cosine function: $\cos(z) = \frac{e^{iz} + e^{-iz}}{2}$.
      intro s ha hb
      have h_cos_exp : Complex.cos (Real.pi * s / 2) = (Complex.exp (Complex.I * Real.pi * s / 2) + Complex.exp (-Complex.I * Real.pi * s / 2)) / 2 := by
        simpa only [ Complex.cos ] using by ring;
      -- Use the triangle inequality to bound the norm: $\| \cos(z) \| \leq \frac{ \|e^{iz}\| + \|e^{-iz}\| }{2}$.
      have h_cos_norm : ‖Complex.cos (Real.pi * s / 2)‖ ≤ (Real.exp (-Real.pi * s.im / 2) + Real.exp (Real.pi * s.im / 2)) / 2 := by
        rw [ h_cos_exp ];
        convert norm_add_le ( Complex.exp ( Complex.I * Real.pi * s / 2 ) / 2 ) ( Complex.exp ( -Complex.I * Real.pi * s / 2 ) / 2 ) using 1 <;> norm_num [ Complex.norm_exp ] ; ring;
        · rw [ ← add_mul ] ; norm_num [ mul_div ] ;
        · ring;
      refine le_trans h_cos_norm ?_;
      ring_nf;
      cases abs_cases s.im <;> simp +decide [ *, ← Real.exp_add ] <;> ring_nf at * <;> norm_num at *;
      · nlinarith [ Real.pi_pos, Real.exp_pos ( - ( Real.pi * s.im * ( 1 / 2 ) ) ), Real.exp_le_exp.2 ( show - ( Real.pi * s.im * ( 1 / 2 ) ) ≤ Real.pi * s.im * ( 1 / 2 ) + Real.pi * b * ( 1 / 2 ) + - ( Real.pi * a * ( 1 / 2 ) ) by nlinarith [ Real.pi_pos ] ), Real.exp_pos ( Real.pi * s.im * ( 1 / 2 ) ), Real.exp_le_exp.2 ( show Real.pi * s.im * ( 1 / 2 ) ≤ Real.pi * s.im * ( 1 / 2 ) + Real.pi * b * ( 1 / 2 ) + - ( Real.pi * a * ( 1 / 2 ) ) by nlinarith [ Real.pi_pos ] ) ];
      · nlinarith [ Real.pi_pos, Real.exp_pos ( - ( Real.pi * s.im * ( 1 / 2 ) ) ), Real.exp_pos ( Real.pi * s.im * ( 1 / 2 ) ), Real.exp_le_exp.mpr ( show - ( Real.pi * s.im * ( 1 / 2 ) ) ≤ - ( Real.pi * s.im * ( 1 / 2 ) ) + Real.pi * b * ( 1 / 2 ) + - ( Real.pi * a * ( 1 / 2 ) ) by nlinarith [ Real.pi_pos ] ), Real.exp_le_exp.mpr ( show Real.pi * s.im * ( 1 / 2 ) ≤ - ( Real.pi * s.im * ( 1 / 2 ) ) + Real.pi * b * ( 1 / 2 ) + - ( Real.pi * a * ( 1 / 2 ) ) by nlinarith [ Real.pi_pos ] ) ]