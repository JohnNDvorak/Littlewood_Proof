/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 44316ca8-ff37-4ca8-9d32-eccbb136af32

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Perron formula contour integral bounds.

KEY RESULTS:
- perron_horizontal_bound_pointwise: |y^{x+iT}/(x+iT)| ‚â§ y^x/T
- integral_norm_bound_large_y: ‚à´ ‚Äñy^z/z‚Äñ ‚â§ (y^c - y^{-R})/(T log y) for y > 1
- integral_boundary_rect_perron_pos: ‚àÆ y^z/z = 2œÄi for y > 1
- integral_boundary_rect_perron_neg: ‚àÆ y^z/z = 0 for y < 1
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Pointwise bound for the integrand in the Perron formula.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma perron_horizontal_bound_pointwise (y : ‚Ñù) (hy : 0 < y) (x : ‚Ñù) (T : ‚Ñù) (hT : 0 < T) :
    ‚Äñ(y : ‚ÑÇ)^(x + I * T) / (x + I * T)‚Äñ ‚â§ y^x / T := by
      norm_num [ Complex.norm_exp, Complex.norm_cpow_eq_rpow_re_of_pos hy ];
      field_simp;
      exact div_le_one_of_le‚ÇÄ ( Real.le_sqrt_of_sq_le ( by norm_num [ Complex.normSq ] ; nlinarith ) ) ( Real.sqrt_nonneg _ )

/-
Integral of y^x.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_rpow_on_interval (y : ‚Ñù) (hy : 0 < y) (hy1 : y ‚â† 1) (a b : ‚Ñù) :
    ‚à´ x in a..b, y^x = (y^b - y^a) / Real.log y := by
      norm_num [ Real.rpow_def_of_pos hy, mul_comm, div_eq_mul_inv ];
      rw [ intervalIntegral.integral_comp_mul_right ] <;> norm_num [ hy1, hy.ne' ];
      linarith

/-
Integral of y^x / T.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_y_pow_div_T (y : ‚Ñù) (hy : 0 < y) (hy1 : y ‚â† 1) (T : ‚Ñù) (hT : T ‚â† 0) (a b : ‚Ñù) :
    ‚à´ x in a..b, y^x / T = (y^b - y^a) / (T * Real.log y) := by
      norm_num [ Real.rpow_def_of_pos hy, div_eq_mul_inv ];
      rw [ intervalIntegral.integral_comp_mul_left ] <;> ring ; norm_num [ hT, hy.ne', Real.log_pow ];
      ¬∑ ring;
      ¬∑ exact fun h => hy1 <| Real.eq_one_of_pos_of_log_eq_zero hy h

/-
Bound for the integral of the norm of the integrand for y > 1.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_norm_bound_large_y (y : ‚Ñù) (hy : 1 < y) (c : ‚Ñù) (T : ‚Ñù) (hT : 0 < T) (R : ‚Ñù) (hR : -R ‚â§ c) :
    ‚à´ x in -R..c, ‚Äñ(y : ‚ÑÇ)^(x + I * T) / (x + I * T)‚Äñ ‚â§ (y^c - y^(-R)) / (T * Real.log y) := by
      -- Let's choose any $x \in [-R, c]$.
      have h_integral_bound : ‚à´ x in -R..c, ‚Äñ(y : ‚ÑÇ) ^ (x + Complex.I * T) / (x + Complex.I * T)‚Äñ ‚â§ ‚à´ x in -R..c, y^x / T := by
        apply_rules [ intervalIntegral.integral_mono_on ];
        ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
          exact continuousOn_of_forall_continuousAt fun u hu => ContinuousAt.norm <| ContinuousAt.div ( ContinuousAt.cpow ( continuousAt_const ) ( Continuous.continuousAt <| by continuity ) <| Or.inl <| by norm_num; linarith ) ( Continuous.continuousAt <| by continuity ) <| by norm_num [ Complex.ext_iff ] ; intros; nlinarith;
        ¬∑ exact Continuous.intervalIntegrable ( by exact Continuous.div_const ( by exact Continuous.rpow continuous_const continuous_id' <| by intro u; exact Or.inl <| by linarith ) _ ) _ _;
        ¬∑ intro x hx;
          convert perron_horizontal_bound_pointwise y ( by positivity ) x T hT using 1;
      refine le_trans h_integral_bound ?_;
      norm_num [ intervalIntegral.integral_comp_mul_left, Real.rpow_def_of_pos ( zero_lt_one.trans hy ), div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, ne_of_gt ( Real.log_pos hy ) ]

/-
Bound for the integral of the norm of the integrand for y < 1.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_norm_bound_small_y (y : ‚Ñù) (hy : 0 < y) (hy1 : y < 1) (c : ‚Ñù) (T : ‚Ñù) (hT : 0 < T) (R : ‚Ñù) (hR : c ‚â§ R) :
    ‚à´ x in c..R, ‚Äñ(y : ‚ÑÇ)^(x + I * T) / (x + I * T)‚Äñ ‚â§ (y^c - y^R) / (T * |Real.log y|) := by
      -- Use `intervalIntegral.integral_mono_on` to bound the integral of the norm by the integral of `fun x => y^x / T`.
      have h_bound : ‚à´ x in c..R, ‚Äñ(y : ‚ÑÇ)^(x + Complex.I * T) / (x + Complex.I * T)‚Äñ ‚â§ ‚à´ x in c..R, y^x / T := by
        apply_rules [ intervalIntegral.integral_mono_on ];
        ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
          norm_num [ Complex.norm_def, Complex.normSq ];
          norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def_of_ne_zero ( Complex.ofReal_ne_zero.mpr hy.ne' ) ];
          norm_num [ Complex.arg_ofReal_of_nonneg hy.le ];
          exact ContinuousOn.div ( ContinuousOn.sqrt <| ContinuousOn.add ( ContinuousOn.mul ( ContinuousOn.mul ( ContinuousOn.rexp <| continuousOn_const.mul continuousOn_id ) <| continuousOn_const ) <| ContinuousOn.mul ( ContinuousOn.rexp <| continuousOn_const.mul continuousOn_id ) <| continuousOn_const ) <| ContinuousOn.mul ( ContinuousOn.mul ( ContinuousOn.rexp <| continuousOn_const.mul continuousOn_id ) <| continuousOn_const ) <| ContinuousOn.mul ( ContinuousOn.rexp <| continuousOn_const.mul continuousOn_id ) <| continuousOn_const ) ( ContinuousOn.sqrt <| ContinuousOn.add ( continuousOn_id.mul continuousOn_id ) <| continuousOn_const.mul continuousOn_const ) fun x hx => ne_of_gt <| Real.sqrt_pos.mpr <| by nlinarith [ Set.mem_Icc.mp <| by simpa [ hR ] using hx ] ;
        ¬∑ exact Continuous.intervalIntegrable ( by exact Continuous.div_const ( by exact Continuous.rpow continuous_const continuous_id' <| by continuity ) _ ) _ _;
        ¬∑ intro x hx; convert perron_horizontal_bound_pointwise y hy x T hT using 1;
      field_simp;
      convert mul_le_mul_of_nonneg_right h_bound hT.le using 1 ; norm_num [ Real.rpow_def_of_pos hy ] ; ring;
      rw [ intervalIntegral.integral_comp_mul_left ] <;> norm_num [ hT.ne', hy.ne' ];
      ¬∑ rw [ abs_of_neg ( Real.log_neg hy hy1 ) ] ; ring;
      ¬∑ exact ‚ü® by linarith, by linarith ‚ü©

/-
Bound for the integral on the far left vertical segment.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma vertical_integral_bound_far_left (y : ‚Ñù) (hy : 0 < y) (R : ‚Ñù) (hR : 0 < R) (T : ‚Ñù) (hT : 0 < T) :
    ‚Äñ‚à´ t in -T..T, (y : ‚ÑÇ)^(-R + I * t) / (-R + I * t)‚Äñ ‚â§ 2 * T * y^(-R) / R := by
      -- The absolute value of the integrand is \( \left| \frac{y^{-R + it}}{-R + it} \right| = \frac{y^{-R}}{|-R + it|} \leq \frac{y^{-R}}{R} \).
      have h_abs_left : ‚àÄ t ‚àà Set.Icc (-T : ‚Ñù) T, ‚Äñ(y : ‚ÑÇ)^(-R + Complex.I * t) / (-R + Complex.I * t)‚Äñ ‚â§ y^(-R : ‚Ñù) / R := by
        norm_num [ Complex.norm_exp, Complex.norm_exp, Complex.norm_cpow_eq_rpow_re_of_pos hy ];
        exact fun t _ _ => by gcongr ; norm_num [ Complex.normSq, Complex.norm_def ] ; exact Real.le_sqrt_of_sq_le <| by nlinarith; ;
      rw [ intervalIntegral.integral_of_le ( by linarith ) ];
      refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
      refine' fun t => y ^ ( -R ) / R;
      ¬∑ exact Filter.Eventually.of_forall fun x => norm_nonneg _;
      ¬∑ fun_prop (disch := norm_num);
      ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using h_abs_left t <| Set.Ioc_subset_Icc_self ht;
      ¬∑ norm_num [ le_of_lt hT ] ; ring_nf ; norm_num [ hT.le ]

/-
Bound for the integral on the far right vertical segment.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma vertical_integral_bound_far_right (y : ‚Ñù) (hy : 0 < y) (R : ‚Ñù) (hR : 0 < R) (T : ‚Ñù) (hT : 0 < T) :
    ‚Äñ‚à´ t in -T..T, (y : ‚ÑÇ)^(R + I * t) / (R + I * t)‚Äñ ‚â§ 2 * T * y^R / R := by
      -- The norm of the integrand is $|\frac{y^{R+it}}{R+it}| = \frac{y^R}{|R+it|}$.
      have h_integrand_norm : ‚àÄ t : ‚Ñù, ‚Äñ(y : ‚ÑÇ)^(R + Complex.I * t) / (R + Complex.I * t)‚Äñ = y^R / Real.sqrt (R^2 + t^2) := by
        norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ];
        field_simp;
        norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, hy.ne' ];
        norm_num [ Complex.arg_ofReal_of_nonneg hy.le, mul_pow, Real.exp_add, Real.exp_sub, Real.exp_log hy ];
        norm_num [ ‚Üê mul_add, Real.exp_mul, Real.exp_log hy ];
        rw [ Real.sqrt_sq ( by positivity ), ‚Üê Real.exp_mul, mul_comm, Real.exp_mul, Real.exp_log hy ];
      -- Since $|R + it| \geq R$, we have $\frac{y^R}{|R + it|} \leq \frac{y^R}{R}$.
      have h_integrand_bound : ‚àÄ t : ‚Ñù, y^R / Real.sqrt (R^2 + t^2) ‚â§ y^R / R := by
        exact fun t => by gcongr ; exact Real.le_sqrt_of_sq_le <| by nlinarith ;
      refine' le_trans ( intervalIntegral.norm_integral_le_of_norm_le_const _ ) _;
      exacts [ y ^ R / R, fun t ht => h_integrand_norm t ‚ñ∏ h_integrand_bound t, by ring_nf; norm_num [ abs_of_pos, hT ] ; nlinarith [ Real.rpow_pos_of_pos hy R, mul_inv_cancel‚ÇÄ ( ne_of_gt hR ) ] ]

/-
Bound for the improper integral of the norm of the integrand for y > 1.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_norm_bound_large_y_improper (y : ‚Ñù) (hy : 1 < y) (c : ‚Ñù) (T : ‚Ñù) (hT : 0 < T) :
    ‚à´ x in Iic c, ‚Äñ(y : ‚ÑÇ)^(x + I * T) / (x + I * T)‚Äñ ‚â§ y^c / (T * Real.log y) := by
      -- We use the fact that $\int_{-\infty}^{c} y^x / T \, dx = \frac{y^c}{T \log(y)}$.
      have h_integral : ‚à´ x in Set.Iic c, (y : ‚Ñù) ^ x / T = (y ^ c) / (T * Real.log y) := by
        have h_integrable_large_y : ‚à´ x in Set.Iic c, y^x = (y^c) / Real.log y := by
          norm_num [ Real.rpow_def_of_pos ( zero_lt_one.trans hy ) ];
          have h_integrable_large_y : ‚à´ x in Set.Iic c, Real.exp (Real.log y * x) = Real.exp (Real.log y * c) * ‚à´ x in Set.Iic 0, Real.exp (Real.log y * x) := by
            rw [ ‚Üê MeasureTheory.integral_const_mul ];
            rw [ ‚Üê MeasureTheory.integral_indicator, ‚Üê MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
            rw [ ‚Üê MeasureTheory.integral_add_right_eq_self _ c ] ; congr ; ext x ; split_ifs <;> simp_all +decide [ ‚Üê Real.exp_add ] ; ring;
          have := integral_exp_neg_mul_rpow zero_lt_one ( Real.log_pos hy );
          simp_all +decide [ div_eq_mul_inv, Real.rpow_neg_one, Real.Gamma_add_one, MeasureTheory.integral_Iic_eq_integral_Iio ];
          rw [ ‚Üê this, ‚Üê MeasureTheory.integral_Iic_eq_integral_Iio ] ; rw [ ‚Üê neg_zero, ‚Üê integral_comp_neg_Iic ] ; norm_num;
        rw [ MeasureTheory.integral_div, h_integrable_large_y, div_div, mul_comm ];
      refine' h_integral ‚ñ∏ MeasureTheory.integral_mono_of_nonneg _ _ _;
      ¬∑ exact Filter.Eventually.of_forall fun x => norm_nonneg _;
      ¬∑ exact ( by contrapose! h_integral; rw [ MeasureTheory.integral_undef h_integral ] ; exact ne_of_lt ( div_pos ( Real.rpow_pos_of_pos ( zero_lt_one.trans hy ) _ ) ( mul_pos hT ( Real.log_pos hy ) ) ) );
      ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Iic ] with x hx;
        convert perron_horizontal_bound_pointwise y ( by positivity ) x T hT using 1

/-
The integral of (y^z - 1)/z over the rectangle is 0.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_y_pow_sub_one_div_z_rect_eq_zero (y : ‚Ñù) (hy : 0 < y) (c : ‚Ñù) (hc : 0 < c) (T : ‚Ñù) (hT : 0 < T) (R : ‚Ñù) (hR : 0 < R) :
    let f := fun z : ‚ÑÇ => (y^z - 1) / z
    (‚à´ t in -T..T, f (c + I * t) * I) +
    (‚à´ x in c..(-R), f (x + I * T)) +
    (‚à´ t in T..(-T), f (-R + I * t) * I) +
    (‚à´ x in -R..c, f (x - I * T)) = 0 := by
      -- Define `g(z)` to be `(y^z - 1)/z` for `z ‚â† 0` and `log y` for `z = 0`.
      set g : ‚ÑÇ ‚Üí ‚ÑÇ := fun z =>
        if z = 0 then Complex.log y else ((y : ‚ÑÇ) ^ z - 1) / z;
      -- Show that `g` is holomorphic on $\mathbb{C}$.
      have hg_holomorphic : DifferentiableOn ‚ÑÇ g Set.univ := by
        -- Show that `g` is differentiable at `z = 0`.
        have hg_diff_zero : HasDerivAt g ((Complex.log y)^2 / 2) 0 := by
          -- To prove the differentiability at 0, we use the fact that the limit of the difference quotient is the derivative.
          have h_lim : Filter.Tendsto (fun z : ‚ÑÇ => ((y : ‚ÑÇ) ^ z - 1 - z * Complex.log y) / z ^ 2) (nhdsWithin 0 {0}·∂ú) (nhds ((Complex.log y) ^ 2 / 2)) := by
            -- We'll use the fact that $e^{z \log y} = \sum_{n=0}^{\infty} \frac{(z \log y)^n}{n!}$ to expand $y^z$.
            have h_expansion : ‚àÄ z : ‚ÑÇ, (y : ‚ÑÇ) ^ z = ‚àë' n : ‚Ñï, (z * Complex.log y) ^ n / Nat.factorial n := by
              intro z; rw [ Complex.cpow_def_of_ne_zero ( Complex.ofReal_ne_zero.mpr hy.ne' ) ] ; rw [ Complex.exp_eq_exp_‚ÑÇ ] ; rw [ NormedSpace.exp_eq_tsum_div ] ; ring;
            -- Substitute the expansion into the limit expression.
            suffices h_subst : Filter.Tendsto (fun z : ‚ÑÇ => (‚àë' n : ‚Ñï, (z * Complex.log y) ^ (n + 2) / Nat.factorial (n + 2)) / z ^ 2) (ùìù[‚â†] 0) (nhds ((Complex.log y) ^ 2 / 2)) by
              convert h_subst using 2;
              rw [ h_expansion, Summable.tsum_eq_zero_add ];
              ¬∑ rw [ Summable.tsum_eq_zero_add ] ; norm_num;
                exact Summable.of_norm <| by simpa using summable_nat_add_iff 1 |>.2 <| Real.summable_pow_div_factorial _;
              ¬∑ exact Summable.of_norm <| by simpa using Real.summable_pow_div_factorial _;
            -- Factor out $z^2$ from the numerator.
            suffices h_factor : Filter.Tendsto (fun z : ‚ÑÇ => (‚àë' n : ‚Ñï, (Complex.log y) ^ (n + 2) * z ^ n / Nat.factorial (n + 2))) (ùìù[‚â†] 0) (nhds ((Complex.log y) ^ 2 / 2)) by
              refine' h_factor.congr' _;
              filter_upwards [ self_mem_nhdsWithin ] with z hz using by rw [ eq_div_iff ( pow_ne_zero 2 hz ) ] ; rw [ ‚Üê tsum_mul_right ] ; exact tsum_congr fun n => by ring;
            -- The series $\sum_{n=0}^{\infty} \frac{(z \log y)^n}{(n+2)!}$ converges uniformly to $\frac{e^{z \log y} - 1 - z \log y}{z^2}$ on any compact subset of $\mathbb{C}$.
            have h_uniform : ContinuousOn (fun z : ‚ÑÇ => ‚àë' n : ‚Ñï, (Complex.log y) ^ (n + 2) * z ^ n / Nat.factorial (n + 2)) (Metric.closedBall 0 1) := by
              refine' continuousOn_tsum _ _ _;
              use fun n => ‚ÄñComplex.log y‚Äñ ^ ( n + 2 ) / Nat.factorial ( n + 2 );
              ¬∑ exact fun n => Continuous.continuousOn ( by continuity );
              ¬∑ exact Real.summable_pow_div_factorial _ |> Summable.comp_injective <| Nat.succ_injective.comp <| Nat.succ_injective;
              ¬∑ norm_num;
                bound;
            convert h_uniform.continuousAt ( Metric.closedBall_mem_nhds _ zero_lt_one ) |> fun h => h.tendsto.mono_left inf_le_left using 2;
            rw [ tsum_eq_single 0 ] <;> aesop;
          rw [ hasDerivAt_iff_tendsto_slope_zero ];
          refine' h_lim.congr' _;
          filter_upwards [ self_mem_nhdsWithin ] with z hz ; by_cases h : z = 0 <;> simp_all +decide [ div_eq_inv_mul, sq, mul_assoc, mul_comm, mul_left_comm ];
          grind;
        intro z hz; by_cases h : z = 0 <;> simp_all +decide [ hasDerivAt_iff_tendsto_slope_zero ] ;
        ¬∑ refine' ‚ü® _, hasDerivWithinAt_iff_tendsto_slope.mpr _ ‚ü©;
          exact Complex.log y ^ 2 / 2;
          convert hg_diff_zero.mono_left <| nhdsWithin_mono _ _ using 2 <;> norm_num [ div_eq_inv_mul, slope_def_field ];
        ¬∑ refine' DifferentiableAt.differentiableWithinAt _;
          exact DifferentiableAt.congr_of_eventuallyEq ( show DifferentiableAt ‚ÑÇ ( fun z => ( ( y : ‚ÑÇ ) ^ z - 1 ) / z ) z from DifferentiableAt.div ( DifferentiableAt.sub ( DifferentiableAt.cpow ( differentiableAt_const _ ) differentiableAt_id <| by aesop ) <| differentiableAt_const _ ) differentiableAt_id <| by aesop ) <| Filter.eventuallyEq_of_mem ( isOpen_compl_singleton.mem_nhds h ) fun x hx => if_neg hx;
      -- Apply Cauchy's Integral Theorem for rectangles to `g`.
      have h_cauchy_integral : (‚à´ t in (-T)..T, g (c + Complex.I * t) * Complex.I) + (‚à´ x in (c)..(-R), g (x + Complex.I * T)) + (‚à´ t in (T)..(-T), g (-R + Complex.I * t) * Complex.I) + (‚à´ x in (-R)..c, g (x - Complex.I * T)) = 0 := by
        have h_cauchy_integral : ‚àÄ (a b c d : ‚Ñù), a ‚â§ b ‚Üí c ‚â§ d ‚Üí (‚à´ t in (c)..d, g (a + Complex.I * t) * Complex.I) + (‚à´ x in (a)..b, g (x + Complex.I * d)) + (‚à´ t in (d)..c, g (b + Complex.I * t) * Complex.I) + (‚à´ x in (b)..a, g (x + Complex.I * c)) = 0 := by
          intros a b c d hab hcd;
          convert Complex.integral_boundary_rect_eq_zero_of_differentiable_on_off_countable _ _ _ using 1;
          any_goals exact g;
          any_goals try infer_instance;
          rotate_left;
          exact a + Complex.I * c;
          exact b + Complex.I * d;
          norm_num [ intervalIntegral.integral_of_ge, hab, hcd ];
          norm_num [ mul_comm Complex.I, ‚Üê intervalIntegral.integral_of_le hcd, ‚Üê intervalIntegral.integral_of_le hab ];
          exact ‚ü® fun h s hs hs' hs'' => by linear_combination -h, fun h => by linear_combination -h ‚àÖ ( by norm_num ) ( by exact ContinuousOn.mono hg_holomorphic.continuousOn fun x hx => by simpa ) ( by intros; exact hg_holomorphic.differentiableAt ( by simpa ) ) ‚ü©;
        by_cases h : c ‚â§ -R <;> simp_all +decide [ intervalIntegral ];
        ¬∑ linarith;
        ¬∑ have := h_cauchy_integral ( -R ) c ( -T ) T ( by linarith ) ( by linarith ) ; simp_all +decide [ le_of_lt, MeasureTheory.integral_Ioc_eq_integral_Ioo ] ;
          grind;
      convert h_cauchy_integral using 1;
      refine' congrArg‚ÇÇ _ ( congrArg‚ÇÇ _ ( congrArg‚ÇÇ _ _ _ ) _ ) _ <;> refine' intervalIntegral.integral_congr fun x hx => _ <;> norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ] at *;
      ¬∑ simp +zetaDelta at *;
        split_ifs <;> simp_all +decide [ Complex.exp_ne_zero, Complex.cpow_def_of_ne_zero, Complex.log_re, Complex.log_im ];
        norm_num [ Complex.ext_iff ] at * ; linarith;
      ¬∑ simp +zetaDelta at *;
        split_ifs <;> simp_all +decide [ Complex.exp_ne_zero, Complex.cpow_def_of_ne_zero, Complex.log_re, Complex.log_im ];
        norm_num [ Complex.ext_iff ] at * ; linarith;
      ¬∑ simp +zetaDelta at *;
        split_ifs <;> simp_all +decide [ Complex.exp_ne_zero, Complex.cpow_def_of_ne_zero, Complex.log_re, Complex.log_im ];
        norm_num [ Complex.ext_iff ] at * ; linarith;
      ¬∑ simp +zetaDelta at *;
        split_ifs <;> simp_all +decide [ Complex.exp_ne_zero, Complex.log_re, Complex.log_im, Complex.cpow_def_of_ne_zero, Complex.exp_ne_zero ];
        simp_all +decide [ Complex.ext_iff ]

/-
Value of the integral of 1/z on the left vertical segment.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_one_div_z_left_side_value (R T : ‚Ñù) (hR : 0 < R) (hT : 0 < T) :
    ‚à´ t in T..(-T), 1 / (-R + I * t) * I = 2 * I * Real.arctan (T / R) := by
      -- We can simplify the integral $\int_{T}^{-T} \frac{i}{-R + it} dt$ by multiplying the numerator and denominator by the conjugate of the denominator.
      have h_simplify : ‚àÄ t : ‚Ñù, 1 / (-(R : ‚ÑÇ) + Complex.I * t) * Complex.I = (t - R * Complex.I) / (R^2 + t^2) := by
        intro t; rw [ div_mul_eq_mul_div, div_eq_div_iff ] <;> ring <;> norm_num [ Complex.ext_iff, sq, hR.ne', hT.ne' ] ;
        nlinarith;
      -- We can split the integral into two separate integrals: one for the real part and one for the imaginary part.
      suffices h_split : (‚à´ t in T..(-T), t / (R^2 + t^2) : ‚Ñù) - Complex.I * (‚à´ t in T..(-T), R / (R^2 + t^2) : ‚Ñù) = 2 * Complex.I * Real.arctan (T / R) by
        convert h_split using 1;
        convert intervalIntegral.integral_congr fun x _ => h_simplify x using 1;
        norm_num [ sub_div, mul_div_assoc ];
        rw [ intervalIntegral.integral_sub ];
        ¬∑ norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, ‚Üê intervalIntegral.integral_ofReal ];
        ¬∑ exact Continuous.intervalIntegrable ( by exact Continuous.div ( by continuity ) ( by continuity ) fun x => by norm_cast; positivity ) _ _;
        ¬∑ exact Continuous.intervalIntegrable ( by exact Continuous.mul continuous_const <| Continuous.div continuous_const ( by continuity ) fun x => by norm_cast; positivity ) _ _;
      -- The integral of $t/(R^2 + t^2)$ is $(1/2) \ln(R^2 + t^2)$, and the integral of $R/(R^2 + t^2)$ is $\arctan(t/R)$.
      have h_integrals : ‚àÄ a b : ‚Ñù, ‚à´ t in a..b, t / (R^2 + t^2) = (1 / 2) * Real.log (R^2 + b^2) - (1 / 2) * Real.log (R^2 + a^2) ‚àß ‚à´ t in a..b, R / (R^2 + t^2) = Real.arctan (b / R) - Real.arctan (a / R) := by
        intros a b; constructor <;> rw [ intervalIntegral.integral_deriv_eq_sub' ] <;> norm_num [ div_eq_mul_inv ];
        ¬∑ exact funext fun x => by norm_num [ Real.differentiableAt_log, show R ^ 2 + x ^ 2 ‚â† 0 by positivity ] ; ring;
        ¬∑ exact fun x hx => DifferentiableAt.mul ( differentiableAt_const _ ) ( DifferentiableAt.log ( by norm_num ) ( by positivity ) );
        ¬∑ exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.mul continuousAt_id <| ContinuousAt.inv‚ÇÄ ( continuousAt_const.add <| continuousAt_id.pow 2 ) <| by positivity;
        ¬∑ -- By simplifying, we can see that the derivatives are equal.
          funext t;
          field_simp [hR];
          ring;
          -- By simplifying, we can see that the derivatives are equal, thus proving the equality.
          field_simp [hR]
          ring
          field_simp [hR]
          ring_nf
          norm_num [ hR.ne', hT.ne' ];
          field_simp;
        ¬∑ exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.mul continuousAt_const <| ContinuousAt.inv‚ÇÄ ( continuousAt_const.add <| continuousAt_id.pow 2 ) <| by positivity;
      norm_num [ h_integrals ] ; ring;
      norm_cast ; norm_num ; ring

/-
Value of the integral of 1/z on the right vertical segment.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_one_div_z_right_side_value (c T : ‚Ñù) (hc : 0 < c) (hT : 0 < T) :
    ‚à´ t in -T..T, 1 / (c + I * t) * I = 2 * I * Real.arctan (T / c) := by
      rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
      rotate_right;
      use fun x => Complex.I * Complex.log ( c + Complex.I * x ) / Complex.I;
      ¬∑ norm_num [ Complex.ext_iff, Complex.log_re, Complex.log_im ];
        norm_num [ Complex.normSq, Complex.norm_def, Complex.div_re, Complex.div_im, Complex.arg ];
        norm_cast ; norm_num [ neg_div, hc.le ];
        rw [ Real.arctan_eq_arcsin ] ; ring;
        field_simp;
        rw [ show ( c ^ 2 + T ^ 2 ) / c ^ 2 = ( ( c ^ 2 + T ^ 2 ) / c ^ 2 ) by ring, Real.sqrt_div ( by positivity ), Real.sqrt_sq ( by positivity ) ] ; ring;
        norm_num [ hc.ne' ];
      ¬∑ intro x hx; convert HasDerivAt.div_const ( HasDerivAt.const_mul Complex.I <| HasDerivAt.comp x ( Complex.hasDerivAt_log ?_ ) <| HasDerivAt.add ( hasDerivAt_const _ _ ) <| HasDerivAt.const_mul Complex.I <| hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) Complex.I using 1 <;> norm_num [ Complex.ext_iff ] ; ring;
        exact Or.inl <| by simpa [ Complex.ext_iff ] using hc;
      ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
        exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.mul ( continuousAt_const.div ( Continuous.continuousAt <| by continuity ) <| by norm_num [ Complex.ext_iff, hc.ne', hT.ne' ] ) continuousAt_const

/-
Value of the integral of 1/z on the top horizontal segment.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_one_div_z_top_value (c T R : ‚Ñù) (hT : 0 < T) :
    ‚à´ x in c..(-R), 1 / (x + I * T) = log (-R + I * T) - log (c + I * T) := by
      rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
      rotate_right;
      use fun x => Complex.log ( x + Complex.I * T );
      ¬∑ norm_num;
      ¬∑ intro x hx;
        convert HasDerivAt.comp x ( Complex.hasDerivAt_log _ ) ( HasDerivAt.add ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) using 1 <;> norm_num [ Complex.ext_iff, hT.ne' ];
        norm_num [ Complex.slitPlane, Complex.ext_iff ] ; aesop;
      ¬∑ apply_rules [ ContinuousOn.intervalIntegrable ];
        exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div continuousAt_const ( Continuous.continuousAt ( by continuity ) ) ( by norm_num [ Complex.ext_iff, hT.ne' ] )

/-
Value of the integral of 1/z on the bottom horizontal segment.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_one_div_z_bottom_value (c T R : ‚Ñù) (hT : 0 < T) :
    ‚à´ x in -R..c, 1 / (x - I * T) = log (c - I * T) - log (-R - I * T) := by
      rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
      rotate_right;
      use fun x => Complex.log ( x - Complex.I * T );
      ¬∑ norm_num;
      ¬∑ intro x hx;
        convert HasDerivAt.comp x ( Complex.hasDerivAt_log _ ) ( HasDerivAt.sub ( hasDerivAt_id' x |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) using 1 <;> norm_num;
        norm_num [ Complex.slitPlane, Complex.ext_iff ];
        exact Or.inr hT.ne';
      ¬∑ exact Continuous.intervalIntegrable ( continuous_const.div ( by continuity ) fun x => by norm_num [ Complex.ext_iff ] ; intros; nlinarith ) _ _

/-
The integral of 1/z over the rectangle containing 0 is 2œÄi.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_one_div_z_rect_eq_two_pi_I (c : ‚Ñù) (hc : 0 < c) (T : ‚Ñù) (hT : 0 < T) (R : ‚Ñù) (hR : 0 < R) :
    (‚à´ t in -T..T, 1 / (c + I * t) * I) +
    (‚à´ x in c..(-R), 1 / (x + I * T)) +
    (‚à´ t in T..(-T), 1 / (-R + I * t) * I) +
    (‚à´ x in -R..c, 1 / (x - I * T)) = 2 * œÄ * I := by
      -- Use the four helper lemmas to replace the integrals with their values.
      have h_integrals : (‚à´ t in (-T)..T, 1 / (c + Complex.I * t) * Complex.I) = 2 * Complex.I * Real.arctan (T / c) ‚àß
                         (‚à´ x in c..(-R), 1 / (x + Complex.I * T)) = Complex.log (-R + Complex.I * T) - Complex.log (c + Complex.I * T) ‚àß
                         (‚à´ t in T..(-T), 1 / (-R + Complex.I * t) * Complex.I) = 2 * Complex.I * Real.arctan (T / R) ‚àß
                         (‚à´ x in (-R)..c, 1 / (x - Complex.I * T)) = Complex.log (c - Complex.I * T) - Complex.log (-R - Complex.I * T) := by
                           refine' ‚ü® _, _, _, _ ‚ü©;
                           ¬∑ convert integral_one_div_z_right_side_value c T hc hT using 1;
                           ¬∑ convert integral_one_div_z_top_value c T R hT using 1;
                           ¬∑ convert integral_one_div_z_left_side_value R T hR hT using 1;
                           ¬∑ convert integral_one_div_z_bottom_value c T R hT using 1;
      convert congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) ( congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) ( congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) h_integrals.1 h_integrals.2.1 ) h_integrals.2.2.1 ) h_integrals.2.2.2 using 1 ; ring;
      norm_num [ Complex.ext_iff, Complex.log_re, Complex.log_im ];
      norm_cast ; norm_num [ Complex.normSq, Complex.norm_def, Complex.arg ] ; ring;
      rw [ Real.arctan_eq_arcsin, Real.arctan_eq_arcsin ] ; ring;
      field_simp;
      norm_num [ add_comm, add_left_comm, add_assoc, hc.le, hT.le, hR.le, ne_of_gt hc, ne_of_gt hT, ne_of_gt hR ] ; ring;
      grind

/-
The integral of y^z/z over the rectangle is 2œÄi for y > 1.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_boundary_rect_perron_pos (y : ‚Ñù) (hy : 1 < y) (c : ‚Ñù) (hc : 0 < c) (T : ‚Ñù) (hT : 0 < T) (R : ‚Ñù) (hR : 0 < R) :
    let f := fun z : ‚ÑÇ => y^z / z
    (‚à´ t in -T..T, f (c + I * t) * I) +
    (‚à´ x in c..(-R), f (x + I * T)) +
    (‚à´ t in T..(-T), f (-R + I * t) * I) +
    (‚à´ x in -R..c, f (x - I * T)) = 2 * œÄ * I := by
      convert congr_arg‚ÇÇ ( ¬∑ + ¬∑ ) ( integral_one_div_z_rect_eq_two_pi_I c hc T hT R hR ) ( integral_y_pow_sub_one_div_z_rect_eq_zero y ( by positivity ) c hc T hT R hR ) using 1;
      ¬∑ norm_num [ sub_div ];
        rw [ intervalIntegral.integral_sub, intervalIntegral.integral_sub, intervalIntegral.integral_sub, intervalIntegral.integral_sub ];
        any_goals apply_rules [ Continuous.intervalIntegrable ];
        any_goals refine' Continuous.inv‚ÇÄ _ _ ; continuity;
        any_goals intro x; norm_num [ Complex.ext_iff ] ; aesop;
        ¬∑ norm_num [ div_eq_mul_inv ] ; ring;
        ¬∑ exact Continuous.div ( by exact Continuous.cpow ( by continuity ) ( by continuity ) <| by intro x; exact Or.inl <| by norm_num; linarith ) ( by continuity ) fun x => by norm_num [ Complex.ext_iff ] ; aesop;
        ¬∑ exact Continuous.div ( Continuous.cpow ( continuous_const ) ( by continuity ) <| by intro x; exact Or.inl <| by norm_num; linarith ) ( by continuity ) fun x => by norm_num [ Complex.ext_iff ] ; intros; nlinarith;
        ¬∑ refine' Continuous.div _ _ _;
          ¬∑ exact Continuous.cpow ( by continuity ) ( by continuity ) ( by intro x; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ] ; linarith );
          ¬∑ continuity;
          ¬∑ norm_num [ Complex.ext_iff ] ; aesop;
        ¬∑ exact Continuous.div ( Continuous.cpow ( continuous_const ) ( by continuity ) <| by intro x; exact Or.inl <| by norm_num; linarith ) ( by continuity ) fun x => by norm_num [ Complex.ext_iff ] ; intros; nlinarith;
      ¬∑ ring

/-
The integral of y^z/z over the rectangle is 0 for y < 1.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_boundary_rect_perron_neg (y : ‚Ñù) (hy : 0 < y) (hy1 : y < 1) (c : ‚Ñù) (hc : 0 < c) (T : ‚Ñù) (hT : 0 < T) (R : ‚Ñù) (hR : c < R) :
    let f := fun z : ‚ÑÇ => y^z / z
    (‚à´ t in -T..T, f (c + I * t) * I) +
    (‚à´ x in c..R, f (x + I * T)) +
    (‚à´ t in T..(-T), f (R + I * t) * I) +
    (‚à´ x in R..c, f (x - I * T)) = 0 := by
      -- Apply the fact that the integral of a differentiable function over a closed contour is zero.
      have h_int_zero : (‚à´ t in (-T)..T, (y : ‚ÑÇ)^(c + Complex.I * t) / (c + Complex.I * t) * Complex.I) +
                         (‚à´ x in (c)..R, (y : ‚ÑÇ)^(x + Complex.I * T) / (x + Complex.I * T)) +
                         (‚à´ t in (T)..(-T), (y : ‚ÑÇ)^(R + Complex.I * t) / (R + Complex.I * t) * Complex.I) +
                         (‚à´ x in (R)..c, (y : ‚ÑÇ)^(x - Complex.I * T) / (x - Complex.I * T)) = 0 := by
        have h_diff : ‚àÄ z : ‚ÑÇ, Complex.re z > 0 ‚Üí DifferentiableAt ‚ÑÇ (fun z : ‚ÑÇ => (y : ‚ÑÇ) ^ z / z) z := by
          intro z hz;
          exact DifferentiableAt.div ( DifferentiableAt.cpow ( differentiableAt_const _ ) differentiableAt_id ( by norm_num; linarith ) ) differentiableAt_id ( by norm_num; exact ne_of_apply_ne Complex.re hz.ne' )
        have hNT : (-T : ‚Ñù) < T := by linarith
        -- Apply Cauchy-Goursat for the rectangle [c,R] √ó [-T,T]
        have hCG : (‚à´ x in c..R, (y : ‚ÑÇ) ^ (‚Üëx + ‚Üë(-T : ‚Ñù) * I) / (‚Üëx + ‚Üë(-T : ‚Ñù) * I)) -
                   (‚à´ x in c..R, (y : ‚ÑÇ) ^ (‚Üëx + ‚ÜëT * I) / (‚Üëx + ‚ÜëT * I)) +
                   I * (‚à´ t in (-T)..T, (y : ‚ÑÇ) ^ (‚ÜëR + ‚Üët * I) / (‚ÜëR + ‚Üët * I)) -
                   I * (‚à´ t in (-T)..T, (y : ‚ÑÇ) ^ (‚Üëc + ‚Üët * I) / (‚Üëc + ‚Üët * I)) = 0 := by
          have := @Complex.integral_boundary_rect_eq_zero_of_differentiable_on_off_countable
          convert this (fun z => (y : ‚ÑÇ) ^ z / z) (‚Üëc + ‚Üë(-T : ‚Ñù) * I) (‚ÜëR + ‚ÜëT * I) ‚àÖ (by norm_num) ?_ ?_ using 1 <;> norm_num
          ¬∑ intro z hz
            simp only [Complex.reProdIm, Set.uIcc_of_le hR.le, Set.uIcc_of_le hNT.le,
              Set.mem_prod, Set.mem_Icc] at hz
            exact (h_diff z (by linarith [hz.1.1])).continuousAt.continuousWithinAt
          ¬∑ simp only [min_eq_left hR.le, max_eq_right hR.le,
              min_eq_left hNT.le, max_eq_right hNT.le]
            intro z hz
            simp only [Set.mem_diff, Set.mem_empty_iff_false, not_false_eq_true, and_true,
              Complex.reProdIm, Set.mem_setOf_eq, Set.mem_Ioo] at hz
            exact h_diff z (by linarith [hz.1.1])
        -- Rewrite goal integrands to canonical form: I*t ‚Üí t*I, x-I*T ‚Üí x+(-T)*I
        simp_rw [show ‚àÄ (a : ‚ÑÇ) (b : ‚Ñù), a + Complex.I * (‚Üëb : ‚ÑÇ) = a + (‚Üëb : ‚ÑÇ) * Complex.I from fun a b => by ring,
                 show ‚àÄ (a : ‚ÑÇ) (b : ‚Ñù), a - Complex.I * (‚Üëb : ‚ÑÇ) = a + ‚Üë(-b : ‚Ñù) * Complex.I from fun a b => by push_cast; ring]
        -- Factor * I out of integrals 1 and 3
        simp_rw [intervalIntegral.integral_mul_const]
        -- Relate reversed-bound integrals to forward-bound integrals
        -- integral_symm a b : ‚à´ x in b..a = -(‚à´ x in a..b)
        have hS1 : ‚à´ t in (-T)..T, (‚Üëy : ‚ÑÇ) ^ ((‚ÜëR : ‚ÑÇ) + ‚Üët * I) / ((‚ÜëR : ‚ÑÇ) + ‚Üët * I) =
            -(‚à´ t in T..(-T), (‚Üëy : ‚ÑÇ) ^ ((‚ÜëR : ‚ÑÇ) + ‚Üët * I) / ((‚ÜëR : ‚ÑÇ) + ‚Üët * I)) :=
          intervalIntegral.integral_symm T (-T)
        have hS2 : ‚à´ x in c..R, (‚Üëy : ‚ÑÇ) ^ ((‚Üëx : ‚ÑÇ) + ‚Üë(-T : ‚Ñù) * I) / ((‚Üëx : ‚ÑÇ) + ‚Üë(-T : ‚Ñù) * I) =
            -(‚à´ x in R..c, (‚Üëy : ‚ÑÇ) ^ ((‚Üëx : ‚ÑÇ) + ‚Üë(-T : ‚Ñù) * I) / ((‚Üëx : ‚ÑÇ) + ‚Üë(-T : ‚Ñù) * I)) :=
          intervalIntegral.integral_symm R c
        -- Combine: goal = -hCG + I * hS1 + hS2
        linear_combination -hCG + I * hS1 + hS2
      convert h_int_zero using 1

/-
Bound for the improper integral of the norm of the integrand for y < 1.
-/
open Real Complex Set MeasureTheory intervalIntegral Filter Topology

lemma integral_norm_bound_small_y_improper (y : ‚Ñù) (hy : 0 < y) (hy1 : y < 1) (c : ‚Ñù) (T : ‚Ñù) (hT : 0 < T) :
    ‚à´ x in Ioi c, ‚Äñ(y : ‚ÑÇ)^(x + I * T) / (x + I * T)‚Äñ ‚â§ y^c / (T * |Real.log y|) := by
      -- Use `MeasureTheory.integral_mono_of_nonneg` to bound the integral of the norm by the integral of `fun x => y^x / T`.
      have h_integral_mono : ‚à´ x in Set.Ioi c, ‚Äñ(y : ‚ÑÇ) ^ (x + Complex.I * T) / (x + Complex.I * T)‚Äñ ‚â§ ‚à´ x in Set.Ioi c, y ^ x / T := by
        refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
        ¬∑ exact Filter.Eventually.of_forall fun x => norm_nonneg _;
        ¬∑ -- The integral of $y^x / T$ over $(c, \infty)$ is convergent.
          have h_integrable : MeasureTheory.IntegrableOn (fun x => y^x) (Set.Ioi c) := by
            norm_num [ Real.rpow_def_of_pos hy ];
            have h_integrable : ‚à´ x in Set.Ioi c, Real.exp (Real.log y * x) = (1 / (-Real.log y)) * Real.exp (Real.log y * c) := by
              have := integral_exp_neg_mul_rpow zero_lt_one ( neg_pos.mpr <| Real.log_neg hy hy1 );
              convert congr_arg ( fun x => x * Real.exp ( Real.log y * c ) ) this using 1 <;> norm_num [ Real.rpow_neg_one, Real.Gamma_add_one ];
              rw [ ‚Üê MeasureTheory.integral_mul_const ];
              rw [ ‚Üê MeasureTheory.integral_indicator ( measurableSet_Ioi ), ‚Üê MeasureTheory.integral_indicator ( measurableSet_Ioi ) ];
              simp +decide [ Set.indicator ];
              rw [ ‚Üê MeasureTheory.integral_add_right_eq_self _ c ] ; congr ; ext x ; split_ifs <;> simp_all +decide [ ‚Üê Real.exp_add ] ; ring;
            exact ( by contrapose! h_integrable; rw [ MeasureTheory.integral_undef h_integrable ] ; exact ne_of_lt ( mul_pos ( one_div_pos.mpr ( neg_pos.mpr ( Real.log_neg hy hy1 ) ) ) ( Real.exp_pos _ ) ) );
          exact h_integrable.div_const T;
        ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx;
          convert perron_horizontal_bound_pointwise y hy x T hT using 1;
      -- Compute `‚à´ x in Ioi c, y^x`.
      have h_integral_y_pow : ‚à´ x in Set.Ioi c, y^x = y^c / (-Real.log y) := by
        simp +decide [ Real.rpow_def_of_pos hy, mul_comm ];
        have := integral_exp_neg_mul_rpow zero_lt_one ( neg_pos.mpr ( Real.log_neg hy hy1 ) );
        convert congr_arg ( fun x : ‚Ñù => Real.exp ( c * Real.log y ) * x ) ( this ) using 1;
        ¬∑ rw [ ‚Üê MeasureTheory.integral_const_mul ] ; rw [ ‚Üê MeasureTheory.integral_indicator ( measurableSet_Ioi ), ‚Üê MeasureTheory.integral_indicator ( measurableSet_Ioi ) ] ; norm_num [ Set.indicator ] ;
          rw [ ‚Üê MeasureTheory.integral_add_right_eq_self _ c ] ; congr ; ext x ; split_ifs <;> simp_all +decide [ ‚Üê Real.exp_add ] ; ring;
        ¬∑ norm_num [ div_eq_mul_inv, Real.rpow_neg_one ];
      simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, MeasureTheory.integral_const_mul ];
      convert h_integral_mono using 1 ; rw [ MeasureTheory.integral_mul_const ] ; rw [ h_integral_y_pow ] ; rw [ abs_of_neg ( Real.log_neg hy hy1 ) ] ; ring

end
