/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 78c1f822-7de9-42ed-853a-0dee39ac2ca8

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module defines the Chebyshev functions theta and psi and proves key relationships between them.
It includes:
- `theta`: Chebyshev's theta function, sum of log p for primes p <= n.
- `psi`: Chebyshev's psi function, sum of von Mangoldt function for k <= n.
- `sum_vonMangoldt_eq_sum_prime_powers_nat`: Proof that sum of von Mangoldt equals sum over prime powers.
- `psi_nat_eq_sum_theta_nat`: Decomposition of psi(n) as sum of theta(n^(1/k)).
- `theta_diff_le_log_choose`: Upper bound for theta(2n) - theta(n) using binomial coefficients.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ChebyshevThetaV2

/-
Chebyshev's theta function theta(n) = sum_{p <= n} log p
-/
noncomputable def theta (n : ℕ) : ℝ :=
  ∑ p ∈ (Finset.range (n + 1)).filter Nat.Prime, Real.log p

/-
Chebyshev's psi function psi(n) = sum_{k <= n} Lambda(k)
-/
noncomputable def psi (n : ℕ) : ℝ :=
  ∑ k ∈ Finset.range (n + 1), ArithmeticFunction.vonMangoldt k

/-
Von Mangoldt sum equals sum over prime powers (corrected)
-/
theorem sum_vonMangoldt_eq_sum_prime_powers_nat (n : ℕ) :
    ∑ k ∈ Finset.range (n + 1), ArithmeticFunction.vonMangoldt k =
    ∑ p ∈ (Finset.range (n + 1)).filter Nat.Prime,
      ∑ j ∈ Finset.range (Nat.log p n), Real.log p := by
        -- We'll use the fact that $\Lambda(m) = \log p$ if $m = p^k$ for some prime $p$ and integer $k$, and $\Lambda(m) = 0$ otherwise.
        have h_lambda : ∀ m ∈ Finset.range (n + 1), ArithmeticFunction.vonMangoldt m = if ∃ p k : ℕ, Nat.Prime p ∧ m = p^k ∧ k > 0 then Real.log (Nat.minFac m) else 0 := by
          intros m hm;
          rw [ ArithmeticFunction.vonMangoldt_apply ];
          congr! 2;
          rw [ isPrimePow_nat_iff ] ; aesop;
        have h_split_sum : ∑ m ∈ Finset.range (n + 1), (if ∃ p k : ℕ, Nat.Prime p ∧ m = p^k ∧ k > 0 then Real.log (Nat.minFac m) else 0) = ∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), ∑ k ∈ Finset.filter (fun k => p^k ≤ n ∧ k > 0) (Finset.range (Nat.log p n + 1)), Real.log p := by
          have h_split_sum : ∑ m ∈ Finset.range (n + 1), (if ∃ p k : ℕ, Nat.Prime p ∧ m = p^k ∧ k > 0 then Real.log (Nat.minFac m) else 0) = ∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), ∑ k ∈ Finset.filter (fun k => p^k ≤ n ∧ k > 0) (Finset.range (Nat.log p n + 1)), Real.log (Nat.minFac (p^k)) := by
            have : Finset.filter (fun m => ∃ p k : ℕ, Nat.Prime p ∧ m = p^k ∧ k > 0) (Finset.range (n + 1)) = Finset.biUnion (Finset.filter Nat.Prime (Finset.range (n + 1))) (fun p => Finset.image (fun k => p^k) (Finset.filter (fun k => p^k ≤ n ∧ k > 0) (Finset.range (Nat.log p n + 1)))) := by
              ext m aesop;
              simp +zetaDelta at *;
              constructor;
              · rintro ⟨ hm₁, p, hp₁, x, rfl, hx₁ ⟩ ; refine' ⟨ p, ⟨ _, hp₁ ⟩, x, ⟨ _, _, hx₁ ⟩, rfl ⟩ <;> try linarith;
                · exact le_trans ( Nat.le_self_pow hx₁.ne' _ ) hm₁;
                · exact Nat.le_log_of_pow_le hp₁.one_lt hm₁;
              · rintro ⟨ p, hp, k, hk, rfl ⟩ ; exact ⟨ by linarith, p, hp.2, k, rfl, hk.2.2 ⟩
            rw [ ← Finset.sum_filter, this, Finset.sum_biUnion ];
            · exact Finset.sum_congr rfl fun p hp => by rw [ Finset.sum_image <| by intros a ha b hb hab; exact Nat.pow_right_injective ( Nat.Prime.one_lt <| Finset.mem_filter.mp hp |>.2 ) hab ] ;
            · intros p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ] ;
              intro a x hx₁ hx₂ hx₃ hx₄ y hy₁ hy₂ hy₃ hy₄; subst_vars; have := Nat.Prime.dvd_of_dvd_pow hp.2 ( hy₄.symm ▸ dvd_pow_self _ ( by linarith ) ) ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
          rw [h_split_sum];
          refine' Finset.sum_congr rfl fun p hp => Finset.sum_congr rfl fun k hk => _;
          rcases k with ( _ | k ) <;> simp_all +decide [ Nat.pow_minFac ];
        convert h_split_sum using 2;
        · exact h_lambda _ ‹_›;
        · rw [ Finset.sum_filter ] ; norm_num [ Finset.sum_range_succ' ];
          rw [ Finset.sum_congr rfl fun i hi => if_pos <| Nat.pow_le_of_le_log ( by aesop ) <| by linarith [ Finset.mem_range.mp hi ] ] ; norm_num

/-
Nat.log p n as a sum of indicators
-/
lemma nat_log_eq_sum_ite (p n : ℕ) (hp : Nat.Prime p) :
    Nat.log p n = ∑ k ∈ Finset.range (Nat.log 2 n), if p ^ (k + 1) ≤ n then 1 else 0 := by
      -- Let's split the sum into two parts: one up to the maximum $k$ such that $p^{k+1} \leq n$, and one with the rest, which are all zeros.
      set k := Nat.log p n with hk
      have h_split : (∑ k ∈ Finset.range (Nat.log 2 n), if p ^ (k + 1) ≤ n then 1 else 0) = (∑ k ∈ Finset.range k, if p ^ (k + 1) ≤ n then 1 else 0) + (∑ k ∈ Finset.Ico k (Nat.log 2 n), if p ^ (k + 1) ≤ n then 1 else 0) := by
        rw [ Finset.range_eq_Ico, Finset.sum_Ico_consecutive ] <;> norm_num;
        rcases p with ( _ | _ | _ | p ) <;> rcases n with ( _ | _ | _ | n ) <;> simp_all +arith +decide [ Nat.log_of_lt ];
        gcongr ; norm_num;
        linarith;
      -- In the first part, each term is 1 because $p^{k+1} \leq n$ for all $k < k$, and in the second part, each term is 0 because $p^{k+1} > n$ for all $k \geq k$.
      have h_first_part : ∑ k ∈ Finset.range k, (if p ^ (k + 1) ≤ n then 1 else 0) = k := by
        rw [ Finset.sum_congr rfl fun x hx => if_pos <| Nat.pow_le_of_le_log ( by aesop ) <| by linarith [ Finset.mem_range.mp hx ] ] ; norm_num;
      simp_all +decide [ Finset.sum_ite ];
      exact fun x hx₁ hx₂ => Nat.lt_pow_of_log_lt hp.one_lt ( by linarith )

/-
Sum of log p over prime powers equals sum of theta at roots
-/
lemma sum_prime_powers_eq_sum_theta (n : ℕ) :
    ∑ p ∈ (Finset.range (n + 1)).filter Nat.Prime, (Nat.log p n : ℝ) * Real.log p =
    ∑ k ∈ Finset.range (Nat.log 2 n), theta (Nat.floor ((n : ℝ) ^ (1 / (k + 1 : ℝ)))) := by
      -- By Fubini's theorem, we can interchange the order of summation.
      have h_fubini : ∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), (∑ k ∈ Finset.range (Nat.log 2 n), if p ^ (k + 1) ≤ n then Real.log p else 0) = ∑ k ∈ Finset.range (Nat.log 2 n), ∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), if p ^ (k + 1) ≤ n then Real.log p else 0 := by
        exact Finset.sum_comm;
      convert h_fubini using 2 <;> norm_num;
      · rename_i p hp;
        convert congr_arg ( fun x : ℕ => x * Real.log p ) ( nat_log_eq_sum_ite p n ( Finset.mem_filter.mp hp |>.2 ) ) using 1;
        norm_num [ Finset.sum_ite ];
      · rename_i k hk;
        -- By definition of $theta$, we know that
        have h_theta_def : theta ⌊(n : ℝ) ^ (1 / (k + 1 : ℝ))⌋₊ = ∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), if p ≤ ⌊(n : ℝ) ^ (1 / (k + 1 : ℝ))⌋₊ then Real.log p else 0 := by
          unfold theta;
          simp +decide [ Finset.sum_filter, Finset.sum_range_succ' ];
          rw [ ← Finset.sum_subset ( Finset.range_mono <| show ⌊ ( n : ℝ ) ^ ( ( k : ℝ ) + 1 ) ⁻¹⌋₊ ≤ n from Nat.floor_le_of_le <| le_trans ( Real.rpow_le_rpow_of_exponent_le ( mod_cast Nat.one_le_iff_ne_zero.mpr <| by aesop_cat ) <| inv_le_one_of_one_le₀ <| mod_cast Nat.succ_pos _ ) <| by norm_num ) ];
          · exact Finset.sum_congr rfl fun x hx => by split_ifs <;> linarith [ Finset.mem_range.mp hx ] ;
          · grind;
        convert h_theta_def using 3 <;> norm_num;
        rw [ Nat.le_floor_iff ( by positivity ), Real.le_rpow_inv_iff_of_pos ] <;> norm_cast <;> aesop

/-
psi as sum of theta at roots
-/
theorem psi_nat_eq_sum_theta_nat (n : ℕ) :
    psi n = ∑ k ∈ Finset.range (Nat.log 2 n + 1), theta (Nat.floor ((n : ℝ) ^ (1 / (k + 1 : ℝ)))) := by
      -- From Theorem 1, psi n = sum_{p <= n} (Nat.log p n) * log p.
      have h1 : psi n = ∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), Nat.log p n * Real.log p := by
        convert sum_vonMangoldt_eq_sum_prime_powers_nat n using 1;
        norm_num [ Finset.sum_mul _ _ _ ];
      -- From sum_prime_powers_eq_sum_theta, this equals sum_{k < log 2 n} theta(n^{1/(k+1)}).
      have h2 : psi n = ∑ k ∈ Finset.range (Nat.log 2 n), theta (Nat.floor ((n : ℝ) ^ (1 / (k + 1 : ℝ)))) := by
        convert sum_prime_powers_eq_sum_theta n using 1;
      -- The term for $k = \log_2(n)$ is $\theta(n^{1/(\log_2(n)+1)})$.
      -- Since $n < 2^{\log_2(n)+1}$, we have $n^{1/(\log_2(n)+1)} < 2$, so $\theta$ is $0$.
      have h_term_zero : theta (Nat.floor ((n : ℝ) ^ (1 / (Nat.log 2 n + 1 : ℝ)))) = 0 := by
        -- Since $n < 2^{\log_2(n)+1}$, we have $n^{1/(\log_2(n)+1)} < 2$, so $\theta$ is $0$.
        have h_floor_lt_two : Nat.floor ((n : ℝ) ^ (1 / (Nat.log 2 n + 1 : ℝ))) < 2 := by
          rcases n with ( _ | _ | n ) <;> norm_num at *;
          rw [ Nat.floor_lt', Real.rpow_lt_iff_lt_log ] <;> norm_num <;> try positivity;
          rw [ inv_mul_lt_iff₀ ( by positivity ) ] ; erw [ ← Real.log_rpow ( by positivity ) ] ; gcongr ; norm_cast ; linarith [ Nat.lt_pow_of_log_lt one_lt_two ( by linarith : Nat.log 2 ( n + 1 + 1 ) < Nat.log 2 ( n + 1 + 1 ) + 1 ) ] ;
        interval_cases ⌊ ( n : ℝ ) ^ ( 1 / ( ( Nat.log 2 n : ℝ ) + 1 ) ) ⌋₊ <;> norm_num [ theta ];
        · norm_num [ Finset.sum_filter ];
        · norm_num [ Finset.sum_filter, Finset.sum_range_succ ];
      rw [ Finset.sum_range_succ, h2, h_term_zero, add_zero ]

/-
Binomial bound for theta
-/
theorem theta_diff_le_log_choose (n : ℕ) (hn : 0 < n) :
    theta (2 * n) - theta n ≤ Real.log (Nat.choose (2 * n) n) := by
      -- By definition of theta, we have $\theta(2n) - \theta(n) = \sum_{n < p \le 2n} \log p$.
      have h_theta_diff : (theta (2 * n) - theta n) = ∑ p ∈ Finset.Icc (n + 1) (2 * n), if Nat.Prime p then Real.log p else 0 := by
        unfold theta;
        erw [ Finset.sum_filter, Finset.sum_filter, Finset.sum_Ico_eq_sub _ ] ; norm_num [ Finset.sum_range_succ ];
        linarith;
      -- Since these primes are distinct, their product divides $C(2n, n)$.
      have h_prod_divides : (∏ p ∈ Finset.Icc (n + 1) (2 * n), if Nat.Prime p then p else 1) ∣ Nat.choose (2 * n) n := by
        -- Every prime $p$ with $n < p \le 2n$ divides $C(2n, n)$.
        have h_prime_divides : ∀ p ∈ Finset.Icc (n + 1) (2 * n), Nat.Prime p → p ∣ Nat.choose (2 * n) n := by
          intro p hp hp_prime
          have h_prime_factor : p ∣ Nat.factorial (2 * n) := by
            exact Nat.dvd_factorial hp_prime.pos <| by linarith [ Finset.mem_Icc.mp hp ] ;
          have h_prime_factor : p ∣ Nat.factorial n * Nat.factorial n * Nat.choose (2 * n) n := by
            convert h_prime_factor using 1 ; rw [ ← Nat.choose_mul_factorial_mul_factorial ( show n ≤ 2 * n by linarith ) ] ; ring;
            rw [ show n * 2 - n = n by rw [ Nat.sub_eq_of_eq_add ] ; ring ] ; ring;
          simp_all +decide [ Nat.Prime.dvd_mul ];
          exact h_prime_factor.resolve_left fun h => absurd ( hp_prime.dvd_factorial.mp h ) ( by linarith );
        norm_num +zetaDelta at *;
        rw [ Finset.prod_ite ];
        convert Nat.dvd_trans _ ( Nat.prod_primeFactors_dvd _ ) using 1;
        rw [ ← Finset.prod_sdiff <| show Finset.filter Nat.Prime ( Finset.Icc ( n + 1 ) ( 2 * n ) ) ⊆ ( Nat.primeFactors ( Nat.choose ( 2 * n ) n ) ) from fun p hp => Nat.mem_primeFactors.mpr ⟨ Finset.mem_filter.mp hp |>.2, h_prime_divides p ( Finset.mem_Icc.mp ( Finset.mem_filter.mp hp |>.1 ) |>.1 ) ( Finset.mem_Icc.mp ( Finset.mem_filter.mp hp |>.1 ) |>.2 ) ( Finset.mem_filter.mp hp |>.2 ), by linarith [ Nat.choose_pos ( show n ≤ 2 * n by linarith ) ] ⟩ ] ; aesop;
      -- Taking logs: $\sum_{n < p \le 2n} \log p \le \log \prod_{n < p \le 2n} p \le \log C(2n, n)$.
      have h_log_prod_le_log_choose : (∑ p ∈ Finset.Icc (n + 1) (2 * n), if Nat.Prime p then Real.log p else 0) ≤ Real.log (∏ p ∈ Finset.Icc (n + 1) (2 * n), if Nat.Prime p then p else 1) := by
        rw [ Real.log_prod (fun x hx => by split_ifs <;> aesop) ] ; exact Finset.sum_le_sum fun x hx => by split_ifs <;> aesop;
      refine le_trans h_theta_diff.le <| h_log_prod_le_log_choose.trans ?_;
      exact Real.log_le_log ( Finset.prod_pos fun x hx => by split_ifs <;> norm_cast ; linarith [ Finset.mem_Icc.mp hx ] ) ( mod_cast Nat.le_of_dvd ( Nat.choose_pos ( by linarith ) ) h_prod_divides )

end ChebyshevThetaV2