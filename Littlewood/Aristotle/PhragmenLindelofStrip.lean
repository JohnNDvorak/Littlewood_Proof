/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: c8d6107a-ee17-4def-acee-0d612e655132

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Phragmén-Lindelöf bounds for zeta in vertical strips.

KEY RESULTS (PROVED):
- mu: Order of growth μ(σ) of ζ(σ+it) as t→∞
- zeta_bound_ge_two: |ζ(s)| ≤ 40 for Re(s) ≥ 2
- abs_exp_eps_sq_le: Bound for exp(εz²) factor
- is_bounded_exp_eps_sq_mul: f(z)exp(εz²) is bounded when f has polynomial growth
- is_bounded_exp_eps_sq_mul_closed: Extension to closed strip with boundary conditions
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the order of growth μ(σ) of the Riemann zeta function as the infimum of exponents α such that ζ(σ+it) = O(|t|^α).
-/
noncomputable def mu (σ : ℝ) : ℝ := sInf {α : ℝ | Asymptotics.IsBigO Filter.atTop (fun t : ℝ ↦ riemannZeta (↑σ + ↑t * Complex.I)) (fun t ↦ |t| ^ α)}

/-
The Riemann zeta function is bounded for σ ≥ 2.
-/
theorem zeta_bound_ge_two : ∃ C, ∀ s : ℂ, 2 ≤ s.re → ‖riemannZeta s‖ ≤ C := by
  use 40;
  intro s hs
  have h_bound : ‖riemannZeta s‖ ≤ ∑' n : ℕ, (1 : ℝ) / (n + 1 : ℝ) ^ s.re := by
    have h_sum_bound : ∀ s : ℂ, 2 ≤ s.re → ‖riemannZeta s‖ ≤ ∑' n : ℕ, (1 : ℝ) / (n + 1) ^ s.re := by
      intro s hs
      have h_sum : riemannZeta s = ∑' n : ℕ, (1 : ℂ) / (n + 1) ^ s := by
        convert zeta_eq_tsum_one_div_nat_add_one_cpow _ using 1;
        linarith
      convert norm_tsum_le_tsum_norm _ <;> norm_num;
      · rw [ ← Complex.norm_cpow_eq_rpow_re_of_pos ] <;> norm_cast ; norm_num;
      · have h_summable : Summable (fun n : ℕ => (1 : ℝ) / (n + 1) ^ s.re) := by
          exact_mod_cast summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_rpow.2 <| by linarith;
        convert h_summable using 1;
        ext; rw [ ← Complex.norm_cpow_eq_rpow_re_of_pos ( by positivity ) ] ; norm_num;
    exact h_sum_bound s hs;
  refine le_trans h_bound ?_;
  refine' le_trans ( Summable.tsum_le_tsum _ _ _ ) _;
  use fun n => 1 / ( n + 1 ) ^ 2;
  · exact fun n => one_div_le_one_div_of_le ( by positivity ) ( by exact le_trans ( by norm_num ) ( Real.rpow_le_rpow_of_exponent_le ( by linarith ) hs ) );
  · exact_mod_cast summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_rpow.2 <| by linarith;
  · simpa using summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two;
  · have := HasSum.tsum_eq ( hasSum_nat_add_iff' 1 |>.2 <| hasSum_zeta_two ) ; norm_num at *;
    nlinarith [ Real.pi_gt_three, Real.pi_le_four ]

/-
Checking definitions of vertical strips.
-/
#check Complex.HadamardThreeLines.verticalStrip
#check Complex.HadamardThreeLines.verticalClosedStrip

/-
Bound for the auxiliary function factor exp(εz²).
-/
theorem abs_exp_eps_sq_le {a b ε : ℝ} (hε : 0 < ε) {z : ℂ} (hz : a ≤ z.re ∧ z.re ≤ b) :
    ‖Complex.exp (↑ε * z ^ 2)‖ ≤ Real.exp (ε * (max (|a|) (|b|)) ^ 2) * Real.exp (-ε * z.im ^ 2) := by
      norm_num [ Complex.norm_exp, sq ];
      rw [ ← Real.exp_add ];
      exact Real.exp_le_exp.mpr ( by nlinarith [ show z.re * z.re ≤ Max.max |a| |b| * Max.max |a| |b| by cases max_cases |a| |b| <;> cases abs_cases a <;> cases abs_cases b <;> nlinarith ] )

/-
If f has polynomial growth in a vertical strip, then f(z) * exp(εz²) is bounded in the strip for ε > 0.
-/
theorem is_bounded_exp_eps_sq_mul {f : ℂ → ℂ} {a b ε : ℝ} (hab : a < b) (hε : 0 < ε)
    (h_poly : ∃ k, ∀ z ∈ Complex.HadamardThreeLines.verticalStrip a b, ‖f z‖ ≤ (1 + ‖z‖) ^ k) :
    BddAbove (norm ∘ (fun z ↦ f z * Complex.exp (ε * z ^ 2)) '' Complex.HadamardThreeLines.verticalStrip a b) := by
      -- Let's choose any $z$ in the vertical strip $a \leq \Re(z) \leq b$ and derive a bound for $\|f(z) \exp(\varepsilon z^2)\|$.
      obtain ⟨k, hk⟩ : ∃ k : ℕ, ∀ z ∈ Complex.HadamardThreeLines.verticalStrip a b, ‖f z‖ ≤ (1 + ‖z‖) ^ k := h_poly
      have h_bound : ∀ z ∈ Complex.HadamardThreeLines.verticalStrip a b, ‖f z * Complex.exp (ε * z ^ 2)‖ ≤ (1 + ‖z‖) ^ k * Real.exp (ε * (max (|a|) (|b|)) ^ 2) * Real.exp (-ε * z.im ^ 2) := by
        intro z hz
        have h_exp_bound : ‖Complex.exp (ε * z ^ 2)‖ ≤ Real.exp (ε * (max (|a|) (|b|)) ^ 2) * Real.exp (-ε * z.im ^ 2) := by
          have := abs_exp_eps_sq_le hε ⟨ le_of_lt hz.1, le_of_lt hz.2 ⟩;
          exact this;
        simpa only [ mul_assoc, norm_mul ] using mul_le_mul ( hk z hz ) h_exp_bound ( by positivity ) ( by positivity );
      -- Since $|z| \le \sqrt{(\Re z)^2 + (\Im z)^2} \le \sqrt{(max(|a|, |b|))^2 + (\Im z)^2}$, we have $(1 + |z|)^k \le (1 + \sqrt{(max(|a|, |b|))^2 + (\Im z)^2})^k$.
      have h_bound' : ∀ z : ℂ, z ∈ Complex.HadamardThreeLines.verticalStrip a b → ‖f z * Complex.exp (ε * z ^ 2)‖ ≤ (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z.im ^ 2)) ^ k * Real.exp (ε * (max (|a|) (|b|)) ^ 2) * Real.exp (-ε * z.im ^ 2) := by
        intros z hz
        -- The key is that ‖z‖ ≤ √(max|a||b|² + z.im²) when z.re ∈ (a,b)
        -- Then (1+‖z‖)^k ≤ (1+√...)^k by monotonicity
        have h_norm_le : ‖z‖ ≤ Real.sqrt ((max (|a|) (|b|)) ^ 2 + z.im ^ 2) := by
          -- ‖z‖ = √(z.re² + z.im²) and z.re² ≤ max(|a|,|b|)² when a < z.re < b
          have hre_bound : z.re ^ 2 ≤ (max (|a|) (|b|)) ^ 2 := by
            have h1 : |z.re| ≤ max (|a|) (|b|) := by
              rw [abs_le]
              constructor
              · nlinarith [le_max_left (|a|) (|b|), neg_abs_le a, le_of_lt hz.1]
              · nlinarith [le_max_right (|a|) (|b|), le_abs_self b, le_of_lt hz.2]
            nlinarith [sq_abs z.re, abs_nonneg z.re, abs_nonneg (max |a| |b|)]
          calc ‖z‖ = Real.sqrt (z.re ^ 2 + z.im ^ 2) := by
                rw [Complex.norm_def, Complex.normSq_apply]; ring_nf
            _ ≤ Real.sqrt ((max |a| |b|) ^ 2 + z.im ^ 2) := by
                apply Real.sqrt_le_sqrt; linarith
        have h_mono : (1 + ‖z‖) ^ k ≤ (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z.im ^ 2)) ^ k := by
          gcongr
        calc ‖f z * Complex.exp (ε * z ^ 2)‖
            ≤ (1 + ‖z‖) ^ k * Real.exp (ε * (max (|a|) (|b|)) ^ 2) * Real.exp (-ε * z.im ^ 2) := h_bound z hz
          _ ≤ (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z.im ^ 2)) ^ k * Real.exp (ε * (max (|a|) (|b|)) ^ 2) * Real.exp (-ε * z.im ^ 2) := by
              apply mul_le_mul_of_nonneg_right
              apply mul_le_mul_of_nonneg_right h_mono
              exact Real.exp_nonneg _
              exact Real.exp_nonneg _
      -- Since $(1 + \sqrt{(max(|a|, |b|))^2 + (\Im z)^2})^k \exp(-ε (\Im z)^2)$ is bounded, we can conclude that $\|f(z) \exp(\varepsilon z^2)\|$ is bounded.
      have h_bounded : ∃ C : ℝ, ∀ z : ℝ, (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z ^ 2)) ^ k * Real.exp (-ε * z ^ 2) ≤ C := by
        -- We'll use the fact that $(1 + \sqrt{(max(|a|, |b|))^2 + z^2})^k \exp(-ε z^2)$ is bounded.
        have h_bounded : ∃ C : ℝ, ∀ z : ℝ, (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z ^ 2)) ^ k * Real.exp (-ε * z ^ 2) ≤ C := by
          have h_lim : Filter.Tendsto (fun z : ℝ => (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z ^ 2)) ^ k * Real.exp (-ε * z ^ 2)) Filter.atTop (nhds 0) := by
            -- We can factor out $(1 + \sqrt{(max(|a|, |b|))^2 + z^2})^k$ and use the fact that $\exp(-ε z^2)$ tends to $0$ as $z$ tends to infinity.
            have h_factor : Filter.Tendsto (fun z : ℝ => (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z ^ 2)) ^ k * Real.exp (-ε * z ^ 2 / 2)) Filter.atTop (nhds 0) := by
              -- We can bound $(1 + \sqrt{(max(|a|, |b|))^2 + z^2})^k$ by $(2z)^k$ for large $z$.
              have h_bound : ∀ z : ℝ, z ≥ max (|a|) (|b|) + 1 → (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z ^ 2)) ^ k ≤ (2 * z) ^ k := by
                intro z hz; gcongr ; nlinarith [ le_max_left |a| |b|, le_max_right |a| |b|, abs_le.mp ( le_max_left |a| |b| ), abs_le.mp ( le_max_right |a| |b| ), Real.sqrt_nonneg ( Max.max |a| |b| ^ 2 + z ^ 2 ), Real.mul_self_sqrt ( by positivity : 0 ≤ Max.max |a| |b| ^ 2 + z ^ 2 ) ] ;
              -- Using the bound, we can show that $(2z)^k \exp(-ε z^2 / 2)$ tends to $0$ as $z$ tends to infinity.
              have h_tendsto_zero : Filter.Tendsto (fun z : ℝ => (2 * z) ^ k * Real.exp (-ε * z ^ 2 / 2)) Filter.atTop (nhds 0) := by
                have h_tendsto_zero : Filter.Tendsto (fun z : ℝ => z ^ k * Real.exp (-ε * z ^ 2 / 2)) Filter.atTop (nhds 0) := by
                  have := Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero k;
                  refine' squeeze_zero_norm' _ this;
                  norm_num;
                  exact ⟨ 2 * ε⁻¹ + 1, fun x hx => by rw [ abs_of_nonneg ( by linarith [ inv_pos.2 hε ] ) ] ; exact mul_le_mul_of_nonneg_left ( Real.exp_le_exp.2 <| by nlinarith [ inv_pos.2 hε, mul_inv_cancel₀ hε.ne', sq_nonneg ( x - 1 ) ] ) ( by exact pow_nonneg ( by linarith [ inv_pos.2 hε ] ) _ ) ⟩;
                convert h_tendsto_zero.const_mul ( 2 ^ k ) using 2 <;> ring;
              refine' squeeze_zero_norm' _ h_tendsto_zero;
              filter_upwards [ Filter.eventually_ge_atTop ( Max.max |a| |b| + 1 ) ] with z hz using by rw [ Real.norm_of_nonneg ( by positivity ) ] ; exact mul_le_mul_of_nonneg_right ( h_bound z hz ) ( by positivity ) ;
            refine' squeeze_zero_norm' _ h_factor;
            filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Real.norm_of_nonneg ( by positivity ) ] ; exact mul_le_mul_of_nonneg_left ( Real.exp_le_exp.mpr <| by nlinarith [ show 0 ≤ ε * x ^ 2 by positivity ] ) <| by positivity;
          have h_bounded : ∃ C : ℝ, ∀ z : ℝ, z ≥ 0 → (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z ^ 2)) ^ k * Real.exp (-ε * z ^ 2) ≤ C := by
            obtain ⟨ C, hC ⟩ := Metric.tendsto_atTop.mp h_lim 1 zero_lt_one;
            -- Let $M$ be the maximum value of the function on the interval $[0, C]$.
            obtain ⟨M, hM⟩ : ∃ M : ℝ, ∀ z ∈ Set.Icc 0 C, (1 + Real.sqrt ((max (|a|) (|b|)) ^ 2 + z ^ 2)) ^ k * Real.exp (-ε * z ^ 2) ≤ M := by
              exact ⟨ _, fun z hz => le_csSup ( IsCompact.bddAbove ( isCompact_Icc.image ( show Continuous fun z : ℝ => ( 1 + Real.sqrt ( Max.max |a| |b| ^ 2 + z ^ 2 ) ) ^ k * Real.exp ( -ε * z ^ 2 ) from by continuity ) ) ) ( Set.mem_image_of_mem _ hz ) ⟩;
            exact ⟨ Max.max M 1, fun z hz => if hz' : z ≤ C then le_trans ( by simpa [ mul_comm ] using hM z ⟨ hz, hz' ⟩ ) ( le_max_left _ _ ) else le_trans ( by simpa [ mul_comm ] using le_of_lt ( show ( 1 + Real.sqrt ( Max.max |a| |b| ^ 2 + z ^ 2 ) ) ^ k * Real.exp ( -ε * z ^ 2 ) < 1 from by simpa [ mul_comm ] using lt_of_abs_lt ( hC z ( le_of_not_ge hz' ) ) ) ) ( le_max_right _ _ ) ⟩;
          exact ⟨ h_bounded.choose, fun z => if hz : 0 ≤ z then h_bounded.choose_spec z hz else by simpa [ abs_of_neg ( not_le.mp hz ) ] using h_bounded.choose_spec ( -z ) ( by linarith ) ⟩ ;
        simpa only [ neg_mul, mul_comm ] using h_bounded;
      obtain ⟨ C, hC ⟩ := h_bounded; use C * Real.exp ( ε * Max.max |a| |b| ^ 2 ) ; rintro _ ⟨ z, hz, rfl ⟩ ; specialize h_bound' z hz; specialize hC z.im; simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ] ;
      nlinarith [ Real.exp_pos ( ε * Max.max |a| |b| ^ 2 ) ]

/-
If the modified function is bounded on the open strip and the original function is bounded on the boundary, then the modified function is bounded on the closed strip.
-/
open Complex

theorem is_bounded_exp_eps_sq_mul_closed {f : ℂ → ℂ} {a b M : ℝ} (hab : a < b)
    (hf : ContinuousOn f (Complex.HadamardThreeLines.verticalClosedStrip a b))
    (ε : ℝ) (hε : 0 < ε)
    (h_int_bound : BddAbove (norm ∘ (fun z ↦ f z * Complex.exp (ε * z ^ 2)) '' Complex.HadamardThreeLines.verticalStrip a b))
    (ha : ∀ z ∈ re ⁻¹' {a}, ‖f z‖ ≤ M)
    (hb : ∀ z ∈ re ⁻¹' {b}, ‖f z‖ ≤ M) :
    BddAbove (norm ∘ (fun z ↦ f z * Complex.exp (ε * z ^ 2)) '' Complex.HadamardThreeLines.verticalClosedStrip a b) := by
      -- Since the function is bounded on the open strip and the boundary, we can find an upper bound for the absolute value of the function on the closed strip.
      have h_closed_bound : ∀ z ∈ Complex.HadamardThreeLines.verticalClosedStrip a b, ‖f z * Complex.exp (ε * z ^ 2)‖ ≤ max (h_int_bound.choose) (max (M * Real.exp (ε * a ^ 2)) (M * Real.exp (ε * b ^ 2))) := by
        intro z hz
        by_cases hz_open : z ∈ Complex.HadamardThreeLines.verticalStrip a b;
        · exact le_trans ( h_int_bound.choose_spec ⟨ z, hz_open, rfl ⟩ ) ( le_max_left _ _ );
        · -- Since $z$ is not in the open strip, it must be on the boundary of the strip.
          have hz_boundary : z.re = a ∨ z.re = b := by
            exact Classical.or_iff_not_imp_left.2 fun h => le_antisymm ( hz.2 ) ( le_of_not_gt fun h' => hz_open ⟨ lt_of_le_of_ne hz.1 ( Ne.symm h ), h' ⟩ );
          cases hz_boundary <;> simp_all +decide [ Complex.norm_exp ];
          · simp_all +decide [ sq, Complex.normSq, Complex.exp_re, Complex.exp_im ];
            exact Or.inr <| Or.inl <| mul_le_mul ( ha z ‹_› ) ( Real.exp_le_exp.mpr <| by nlinarith [ sq_nonneg ( z.im - a ), sq_nonneg ( z.im + a ) ] ) ( by positivity ) ( by linarith [ norm_nonneg ( f z ), ha z ‹_› ] );
          · simp_all +decide [ sq, Complex.normSq, Complex.exp_re, Complex.exp_im ];
            exact Or.inr <| Or.inr <| mul_le_mul ( hb z ‹_› ) ( Real.exp_le_exp.mpr <| by nlinarith [ sq_nonneg ( z.im - b ), sq_nonneg ( z.im + b ) ] ) ( by positivity ) ( by linarith [ norm_nonneg ( f z ), show 0 ≤ M by exact le_trans ( norm_nonneg _ ) ( hb ⟨ b, 0 ⟩ rfl ) ] );
      exact ⟨ _, Set.forall_mem_image.2 h_closed_bound ⟩

end
