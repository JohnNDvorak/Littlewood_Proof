/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1fd7502f-63a6-412c-bb59-03482dbea266

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This file contains a formal proof of Schmidt's oscillation theorem for trigonometric polynomials.
It establishes that a non-trivial trigonometric polynomial with positive frequencies changes sign infinitely often.
The proof proceeds by contradiction, showing that if the function were eventually non-negative, it would be identically zero.
Key lemmas include `trigPoly_zero_iff_coeffs_zero`, `trigPoly_mean_square`, and `trigPoly_eventually_nonneg_implies_zero`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
A trigonometric polynomial is zero everywhere if and only if all its coefficients are zero, given positive frequencies.
-/
open Real Finset

/-- The key lemma: a trigonometric polynomial is zero everywhere iff all coefficients are zero. -/
theorem trigPoly_zero_iff_coeffs_zero (Œ≥s : Finset ‚Ñù) (hŒ≥s : ‚àÄ Œ≥ ‚àà Œ≥s, Œ≥ > 0)
    (c : ‚Ñù ‚Üí ‚Ñù) (phi : ‚Ñù ‚Üí ‚Ñù) :
    (‚àÄ t, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * cos (Œ≥ * t + phi Œ≥) = 0) ‚Üî (‚àÄ Œ≥ ‚àà Œ≥s, c Œ≥ = 0) := by
      refine' ‚ü® fun h Œ≥ hŒ≥ => _, _ ‚ü©;
      ¬∑ -- By taking the limit as $T \to \infty$, we can show that each coefficient $c_\gamma$ must be zero.
        have h_lim : ‚àÄ Œ≥ ‚àà Œ≥s, Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥)) * Real.cos (Œ≥ * t + phi Œ≥)) Filter.atTop (nhds (c Œ≥ / 2)) := by
          -- We'll use the fact that the integral of $\cos^2(\gamma t + \phi)$ over $[0, T]$ is $\frac{T}{2} + \frac{\sin(2\gamma T + 2\phi)}{4\gamma}$.
          have h_cos_sq : ‚àÄ Œ≥ ‚àà Œ≥s, Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) ^ 2) Filter.atTop (nhds (1 / 2)) := by
            -- We'll use the fact that the integral of $\cos^2(\gamma t + \phi)$ over $[0, T]$ is $\frac{T}{2} + \frac{\sin(2\gamma T + 2\phi)}{4\gamma}$ and that $\frac{\sin(2\gamma T + 2\phi)}{4\gamma}$ tends to $0$ as $T \to \infty$.
            have h_cos_sq_integral : ‚àÄ Œ≥ ‚àà Œ≥s, ‚àÄ T > 0, ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) ^ 2 = T / 2 + (Real.sin (2 * Œ≥ * T + 2 * phi Œ≥) - Real.sin (2 * phi Œ≥)) / (4 * Œ≥) := by
              intro Œ≥ hŒ≥ T hT; rw [ intervalIntegral.integral_comp_mul_add ( fun t => Real.cos t ^ 2 ) ] <;> norm_num [ hŒ≥s Œ≥ hŒ≥ |> ne_of_gt ] ; ring;
              rw [ show Œ≥ * T * 2 + phi Œ≥ * 2 = 2 * ( Œ≥ * T + phi Œ≥ ) by ring, show phi Œ≥ * 2 = 2 * phi Œ≥ by ring ] ; rw [ Real.sin_two_mul, Real.sin_two_mul ] ; rw [ mul_inv_cancel‚ÇÄ ( ne_of_gt ( hŒ≥s Œ≥ hŒ≥ ) ) ] ; ring;
            -- We'll use the fact that $\frac{\sin(2\gamma T + 2\phi)}{4\gamma}$ tends to $0$ as $T \to \infty$.
            have h_sin_term : ‚àÄ Œ≥ ‚àà Œ≥s, Filter.Tendsto (fun T => (Real.sin (2 * Œ≥ * T + 2 * phi Œ≥) - Real.sin (2 * phi Œ≥)) / (4 * Œ≥ * T)) Filter.atTop (nhds 0) := by
              intro Œ≥ hŒ≥; refine' squeeze_zero_norm' _ _;
              use fun T => 2 / ( 4 * Œ≥ * |T| );
              ¬∑ norm_num [ abs_mul, abs_div ];
                exact ‚ü® 1, fun T hT => by rw [ abs_of_pos ( hŒ≥s Œ≥ hŒ≥ ) ] ; exact div_le_div_of_nonneg_right ( abs_le.mpr ‚ü® by linarith [ abs_le.mp ( Real.abs_sin_le_one ( 2 * Œ≥ * T + 2 * phi Œ≥ ) ), abs_le.mp ( Real.abs_sin_le_one ( 2 * phi Œ≥ ) ) ], by linarith [ abs_le.mp ( Real.abs_sin_le_one ( 2 * Œ≥ * T + 2 * phi Œ≥ ) ), abs_le.mp ( Real.abs_sin_le_one ( 2 * phi Œ≥ ) ) ] ‚ü© ) ( by exact mul_nonneg ( mul_nonneg zero_le_four ( le_of_lt ( hŒ≥s Œ≥ hŒ≥ ) ) ) ( abs_nonneg _ ) ) ‚ü©;
              ¬∑ exact tendsto_const_nhds.div_atTop ( Filter.Tendsto.const_mul_atTop ( by linarith [ hŒ≥s Œ≥ hŒ≥ ] ) ( tendsto_norm_atTop_atTop ) );
            intro Œ≥ hŒ≥; specialize h_sin_term Œ≥ hŒ≥; refine' Filter.Tendsto.congr' _ ( by simpa using h_sin_term.const_add ( 1 / 2 : ‚Ñù ) ) ; filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT; rw [ h_cos_sq_integral Œ≥ hŒ≥ T hT ] ; ring_nf; norm_num [ hT.ne' ] ;
          -- We'll use the fact that the integral of $\cos(\gamma t + \phi)\cos(\gamma' t + \phi')$ over $[0, T]$ is $\frac{T}{2}\delta_{\gamma\gamma'} + \frac{\sin((\gamma - \gamma')T + (\phi - \phi'))}{2(\gamma - \gamma')}$.
          have h_cos_prod : ‚àÄ Œ≥ Œ≥' : ‚Ñù, Œ≥ ‚àà Œ≥s ‚Üí Œ≥' ‚àà Œ≥s ‚Üí Œ≥ ‚â† Œ≥' ‚Üí Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥')) Filter.atTop (nhds 0) := by
            -- Using the product-to-sum formula, we have $\cos(\gamma t + \phi)\cos(\gamma' t + \phi') = \frac{1}{2}[\cos((\gamma - \gamma')t + (\phi - \phi')) + \cos((\gamma + \gamma')t + (\phi + \phi'))]$.
            have h_prod_to_sum : ‚àÄ Œ≥ Œ≥' : ‚Ñù, Œ≥ ‚àà Œ≥s ‚Üí Œ≥' ‚àà Œ≥s ‚Üí Œ≥ ‚â† Œ≥' ‚Üí ‚àÄ T, ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥') = (1 / 2) * (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ - Œ≥') * t + (phi Œ≥ - phi Œ≥'))) + (1 / 2) * (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ + Œ≥') * t + (phi Œ≥ + phi Œ≥'))) := by
              intro Œ≥ Œ≥' hŒ≥ hŒ≥' hne T; rw [ ‚Üê mul_add, ‚Üê intervalIntegral.integral_add ];
              ¬∑ rw [ ‚Üê intervalIntegral.integral_const_mul ] ; congr ; ext t ; rw [ Real.cos_add_cos ] ; ring;
                norm_num [ Real.cos_add, Real.cos_sub ];
                exact Or.inl <| by ring;
              ¬∑ exact Continuous.intervalIntegrable ( Real.continuous_cos.comp <| by continuity ) _ _;
              ¬∑ exact Continuous.intervalIntegrable ( Real.continuous_cos.comp <| by continuity ) _ _;
            -- Using the fact that the integral of $\cos((\gamma - \gamma')t + (\phi - \phi'))$ over $[0, T]$ is $\frac{\sin((\gamma - \gamma')T + (\phi - \phi'))}{\gamma - \gamma'}$, we can show that the limit is zero.
            have h_cos_diff : ‚àÄ Œ≥ Œ≥' : ‚Ñù, Œ≥ ‚àà Œ≥s ‚Üí Œ≥' ‚àà Œ≥s ‚Üí Œ≥ ‚â† Œ≥' ‚Üí Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ - Œ≥') * t + (phi Œ≥ - phi Œ≥'))) Filter.atTop (nhds 0) := by
              intros Œ≥ Œ≥' hŒ≥ hŒ≥' hne
              have h_cos_diff : ‚àÄ T, ‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ - Œ≥') * t + (phi Œ≥ - phi Œ≥')) = (Real.sin ((Œ≥ - Œ≥') * T + (phi Œ≥ - phi Œ≥')) - Real.sin (phi Œ≥ - phi Œ≥')) / (Œ≥ - Œ≥') := by
                intro T; rw [ intervalIntegral.integral_comp_mul_add ] <;> norm_num ; ring ; contrapose! hne ; linarith [ hŒ≥s Œ≥ hŒ≥, hŒ≥s Œ≥' hŒ≥' ] ;
              simp_all +decide [ div_eq_inv_mul ];
              exact squeeze_zero_norm ( fun T => by simpa [ abs_mul, abs_inv ] using mul_le_mul_of_nonneg_left ( mul_le_mul_of_nonneg_left ( show |Real.sin ( ( Œ≥ - Œ≥' ) * T + ( phi Œ≥ - phi Œ≥' ) ) - Real.sin ( phi Œ≥ - phi Œ≥' )| ‚â§ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( ( Œ≥ - Œ≥' ) * T + ( phi Œ≥ - phi Œ≥' ) ), Real.abs_sin_le_one ( phi Œ≥ - phi Œ≥' ) ] ) ) ( by positivity ) ) ( by positivity ) ) ( by simpa using tendsto_inv_atTop_zero.comp tendsto_norm_atTop_atTop |> Filter.Tendsto.mul_const ( |Œ≥ - Œ≥'|‚Åª¬π * 2 ) );
            -- Using the fact that the integral of $\cos((\gamma + \gamma')t + (\phi + \phi'))$ over $[0, T]$ is $\frac{\sin((\gamma + \gamma')T + (\phi + \phi'))}{\gamma + \gamma'}$, we can show that the limit is zero.
            have h_cos_sum : ‚àÄ Œ≥ Œ≥' : ‚Ñù, Œ≥ ‚àà Œ≥s ‚Üí Œ≥' ‚àà Œ≥s ‚Üí Œ≥ ‚â† Œ≥' ‚Üí Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ + Œ≥') * t + (phi Œ≥ + phi Œ≥'))) Filter.atTop (nhds 0) := by
              intros Œ≥ Œ≥' hŒ≥ hŒ≥' hne
              have h_cos_sum : ‚àÄ T, ‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ + Œ≥') * t + (phi Œ≥ + phi Œ≥')) = (Real.sin ((Œ≥ + Œ≥') * T + (phi Œ≥ + phi Œ≥')) - Real.sin (phi Œ≥ + phi Œ≥')) / (Œ≥ + Œ≥') := by
                intro T; rw [ intervalIntegral.integral_comp_mul_add ] <;> norm_num ; ring ; linarith [ hŒ≥s Œ≥ hŒ≥, hŒ≥s Œ≥' hŒ≥' ] ;
              simp_all +decide [ div_eq_inv_mul ];
              field_simp;
              refine' squeeze_zero_norm' _ _;
              use fun T => 2 / |T * ( Œ≥ + Œ≥' )|;
              ¬∑ norm_num +zetaDelta at *;
                exact ‚ü® 1, fun T hT => by gcongr ; exact abs_le.mpr ‚ü® by linarith [ abs_le.mp ( Real.abs_sin_le_one ( T * ( Œ≥ + Œ≥' ) + ( phi Œ≥ + phi Œ≥' ) ) ), abs_le.mp ( Real.abs_sin_le_one ( phi Œ≥ + phi Œ≥' ) ) ], by linarith [ abs_le.mp ( Real.abs_sin_le_one ( T * ( Œ≥ + Œ≥' ) + ( phi Œ≥ + phi Œ≥' ) ) ), abs_le.mp ( Real.abs_sin_le_one ( phi Œ≥ + phi Œ≥' ) ) ] ‚ü© ‚ü©;
              ¬∑ exact tendsto_const_nhds.div_atTop ( Filter.tendsto_abs_atTop_atTop.comp <| Filter.tendsto_id.atTop_mul_const <| add_pos ( hŒ≥s Œ≥ hŒ≥ ) ( hŒ≥s Œ≥' hŒ≥' ) );
            intro Œ≥ Œ≥' hŒ≥ hŒ≥' hne; convert Filter.Tendsto.add ( h_cos_diff Œ≥ Œ≥' hŒ≥ hŒ≥' hne |> Filter.Tendsto.const_mul ( 1 / 2 ) ) ( h_cos_sum Œ≥ Œ≥' hŒ≥ hŒ≥' hne |> Filter.Tendsto.const_mul ( 1 / 2 ) ) using 2 <;> push_cast [ h_prod_to_sum Œ≥ Œ≥' hŒ≥ hŒ≥' hne ] <;> ring;
          -- By linearity of the integral, we can split the integral into the sum of integrals.
          have h_split : ‚àÄ Œ≥ ‚àà Œ≥s, Filter.Tendsto (fun T => (1 / T) * ‚àë Œ≥' ‚àà Œ≥s, c Œ≥' * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥')) Filter.atTop (nhds (c Œ≥ / 2)) := by
            intro Œ≥ hŒ≥
            have h_split : Filter.Tendsto (fun T => (1 / T) * ‚àë Œ≥' ‚àà Œ≥s \ {Œ≥}, c Œ≥' * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥')) Filter.atTop (nhds 0) := by
              simp_all +decide [ ‚Üê sq, Finset.sum_mul _ _ _ ];
              have h_split : Filter.Tendsto (fun T => (1 / T) * ‚àë Œ≥' ‚àà Œ≥s \ {Œ≥}, c Œ≥' * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥')) Filter.atTop (nhds 0) := by
                simpa [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] using tendsto_finset_sum _ fun x hx => h_cos_prod Œ≥ x hŒ≥ ( by aesop ) ( by aesop ) |> Filter.Tendsto.const_mul ( c x );
              convert h_split using 2 ; simp +decide [ Finset.sum_eq_sum_diff_singleton_add hŒ≥ ] ; ring;
              norm_num;
            convert h_split.add ( h_cos_sq Œ≥ hŒ≥ |> Filter.Tendsto.const_mul ( c Œ≥ ) ) using 2 <;> norm_num [ Finset.sum_eq_add_sum_diff_singleton hŒ≥ ] ; ring;
            ring;
          convert h_split using 3;
          ext T; simp +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, ‚Üê intervalIntegral.integral_const_mul ] ;
          field_simp;
          rw [ intervalIntegral.integral_finset_sum ] ; exact fun _ _ => by exact Continuous.intervalIntegrable ( by exact Continuous.div_const ( by exact Continuous.mul ( Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) ( Real.continuous_cos.comp ( by continuity ) ) ) _ ) _ _;
        simp_all +decide [ div_eq_inv_mul ];
      ¬∑ aesop

/-
The mean value of a trigonometric polynomial with positive frequencies is zero.
-/
open Real Finset Filter Topology

/-- The mean value of a trigonometric polynomial with positive frequencies is zero. -/
theorem trigPoly_mean_zero (Œ≥s : Finset ‚Ñù) (hŒ≥s : ‚àÄ Œ≥ ‚àà Œ≥s, Œ≥ > 0)
    (c : ‚Ñù ‚Üí ‚Ñù) (phi : ‚Ñù ‚Üí ‚Ñù) :
    Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * cos (Œ≥ * t + phi Œ≥)) atTop (nhds 0) := by
      -- Each integral of the form $\int_0^T \cos(\gamma t + \varphi) dt$ tends to zero as $T \to \infty$.
      have h_cos_int : ‚àÄ Œ≥ > 0, Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0)..T, Real.cos (Œ≥ * t + phi Œ≥)) Filter.atTop (ùìù 0) := by
        intro Œ≥ hŒ≥_pos
        have : ‚àÄ T > 0, (1 / T) * ‚à´ t in (0)..T, Real.cos (Œ≥ * t + phi Œ≥) = (1 / T) * ((1 / Œ≥) * (Real.sin (Œ≥ * T + phi Œ≥) - Real.sin (phi Œ≥))) := by
          intro T hT_pos; simp +decide [ intervalIntegral.integral_comp_mul_add, hŒ≥_pos.ne.symm ] ;
        rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop ( 0 : ‚Ñù ) ] with T hT using this T hT ) ];
        norm_num [ mul_assoc, mul_comm, mul_left_comm ];
        exact squeeze_zero_norm ( fun T => by simpa using mul_le_mul_of_nonneg_left ( mul_le_mul_of_nonneg_left ( show |Real.sin ( Œ≥ * T + phi Œ≥ ) - Real.sin ( phi Œ≥ )| ‚â§ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( Œ≥ * T + phi Œ≥ ), Real.abs_sin_le_one ( phi Œ≥ ) ] ) ) ( by positivity ) ) ( by positivity ) ) ( by simpa using tendsto_const_nhds.mul ( tendsto_inv_atTop_zero.comp ( tendsto_norm_atTop_atTop ) |> Filter.Tendsto.mul_const ( 2 : ‚Ñù ) ) );
      -- By linearity of the integral, we can split the integral into a sum of integrals.
      have h_split : ‚àÄ T : ‚Ñù, ‚à´ t in (0)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥) = ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * ‚à´ t in (0)..T, Real.cos (Œ≥ * t + phi Œ≥) := by
        intro T; rw [ intervalIntegral.integral_finset_sum ] ; aesop;
        exact fun Œ≥ hŒ≥ => Continuous.intervalIntegrable ( by continuity ) _ _;
      simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
      simpa using tendsto_finset_sum _ fun x hx => Filter.Tendsto.const_mul ( c x ) ( h_cos_int x ( hŒ≥s x hx ) )

/-
The integral of a trigonometric polynomial with positive frequencies is bounded.
-/
open Real Finset Filter Topology

/-- The integral of a trigonometric polynomial with positive frequencies is bounded. -/
theorem trigPoly_integral_bounded (Œ≥s : Finset ‚Ñù) (hŒ≥s : ‚àÄ Œ≥ ‚àà Œ≥s, Œ≥ > 0)
    (c : ‚Ñù ‚Üí ‚Ñù) (phi : ‚Ñù ‚Üí ‚Ñù) :
    ‚àÉ C, ‚àÄ T > 0, |‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * cos (Œ≥ * t + phi Œ≥)| ‚â§ C := by
      -- The integral is explicitly $\sum (c_\gamma / \gamma) (\sin(\gamma T + \phi_\gamma) - \sin(\phi_\gamma))$.
      have h_integral : ‚àÄ T > 0, ‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * (Real.cos (Œ≥ * t + (phi Œ≥))) = ‚àë Œ≥ ‚àà Œ≥s, (c Œ≥ / Œ≥) * (Real.sin (Œ≥ * T + (phi Œ≥)) - Real.sin (phi Œ≥)) := by
        intro T hT;
        rw [ intervalIntegral.integral_finset_sum ];
        ¬∑ refine' Finset.sum_congr rfl fun Œ≥ hŒ≥ => _;
          rw [ intervalIntegral.integral_const_mul, intervalIntegral.integral_comp_mul_left ( fun x => Real.cos ( x + phi Œ≥ ) ) ] <;> norm_num [ div_eq_inv_mul, hŒ≥s Œ≥ hŒ≥, ne_of_gt ];
          ring;
        ¬∑ exact fun Œ≥ hŒ≥ => Continuous.intervalIntegrable ( by continuity ) _ _;
      exact ‚ü® ‚àë Œ≥ ‚àà Œ≥s, |c Œ≥ / Œ≥| * 2, fun T hT => by rw [ h_integral T hT ] ; exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun Œ≥ hŒ≥ => by rw [ abs_mul ] ; exact mul_le_mul_of_nonneg_left ( abs_le.mpr ‚ü® by linarith [ sin_le_one ( Œ≥ * T + phi Œ≥ ), Real.neg_one_le_sin ( Œ≥ * T + phi Œ≥ ), sin_le_one ( phi Œ≥ ), Real.neg_one_le_sin ( phi Œ≥ ) ], by linarith [ sin_le_one ( Œ≥ * T + phi Œ≥ ), Real.neg_one_le_sin ( Œ≥ * T + phi Œ≥ ), sin_le_one ( phi Œ≥ ), Real.neg_one_le_sin ( phi Œ≥ ) ] ‚ü© ) ( by positivity ) ) ‚ü©

/-
The mean square value of a trigonometric polynomial with positive frequencies is the sum of half the squares of the coefficients.
-/
open Real Finset Filter Topology

/-- The mean square value of a trigonometric polynomial with positive frequencies. -/
theorem trigPoly_mean_square (Œ≥s : Finset ‚Ñù) (hŒ≥s : ‚àÄ Œ≥ ‚àà Œ≥s, Œ≥ > 0)
    (c : ‚Ñù ‚Üí ‚Ñù) (phi : ‚Ñù ‚Üí ‚Ñù) :
    Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * cos (Œ≥ * t + phi Œ≥))^2) atTop (nhds (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ ^ 2 / 2)) := by
      -- Expanding the square: $(\sum c_\gamma \cos(\gamma t + \phi_\gamma))^2 = \sum_\gamma \sum_{\gamma'} c_\gamma c_{\gamma'} \cos(\gamma t + \phi_\gamma) \cos(\gamma' t + \phi_{\gamma'})$.
      have h_expansion : ‚àÄ T > 0, ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2 = ‚àë Œ≥ ‚àà Œ≥s, ‚àë Œ≥' ‚àà Œ≥s, c Œ≥ * c Œ≥' * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥') := by
        norm_num [ sq, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul, ‚Üê intervalIntegral.integral_const_mul ];
        field_simp;
        field_simp;
        intro T hT; rw [ intervalIntegral.integral_finset_sum ] ; refine' Finset.sum_congr rfl fun _ _ => _ ; rw [ intervalIntegral.integral_finset_sum ] ; refine' Finset.sum_congr rfl fun _ _ => _ ; norm_num [ mul_assoc, mul_comm, mul_left_comm ] ;
        ¬∑ exact fun _ _ => Continuous.intervalIntegrable ( by exact Continuous.mul ( Continuous.mul ( Continuous.mul continuous_const ( Real.continuous_cos.comp ( by continuity ) ) ) continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) _ _;
        ¬∑ exact fun _ _ => Continuous.intervalIntegrable ( by continuity ) _ _;
      -- For each pair of $\gamma$ and $\gamma'$, the integral $\int_0^T \cos(\gamma t + \phi_\gamma) \cos(\gamma' t + \phi_{\gamma'}) \, dt$ is $O(1)$ if $\gamma \neq \gamma'$ and $\frac{T}{2} + O(1)$ if $\gamma = \gamma'$.
      have h_integral_pairwise : ‚àÄ Œ≥ Œ≥' : ‚Ñù, Œ≥ > 0 ‚Üí Œ≥' > 0 ‚Üí Œ≥ ‚â† Œ≥' ‚Üí Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥')) Filter.atTop (nhds 0) := by
        -- Use the trigonometric identity $\cos A \cos B = \frac{1}{2} (\cos(A-B) + \cos(A+B))$ to simplify the integral.
        intro Œ≥ Œ≥' hŒ≥ hŒ≥' hneq
        have h_trig : ‚àÄ T : ‚Ñù, ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥') = (1 / 2) * (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ - Œ≥') * t + (phi Œ≥ - phi Œ≥'))) + (1 / 2) * (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ + Œ≥') * t + (phi Œ≥ + phi Œ≥'))) := by
          intro T; rw [ ‚Üê mul_add, ‚Üê intervalIntegral.integral_add ];
          ¬∑ rw [ ‚Üê intervalIntegral.integral_const_mul ] ; congr ; ext t ; rw [ Real.cos_add_cos ] ; ring;
            norm_num [ Real.cos_add, Real.cos_sub ];
            exact Or.inl <| by ring;
          ¬∑ exact Continuous.intervalIntegrable ( Real.continuous_cos.comp <| by continuity ) _ _;
          ¬∑ exact Continuous.intervalIntegrable ( Real.continuous_cos.comp <| by continuity ) _ _;
        -- The integral of $\cos((Œ≥ - Œ≥')t + (phi Œ≥ - phi Œ≥'))$ over $[0, T]$ is $\frac{1}{Œ≥ - Œ≥'} \sin((Œ≥ - Œ≥')T + (phi Œ≥ - phi Œ≥')) - \frac{1}{Œ≥ - Œ≥'} \sin((phi Œ≥ - phi Œ≥'))$.
        have h_integral_sin : ‚àÄ T : ‚Ñù, ‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ - Œ≥') * t + (phi Œ≥ - phi Œ≥')) = (1 / (Œ≥ - Œ≥')) * (Real.sin ((Œ≥ - Œ≥') * T + (phi Œ≥ - phi Œ≥')) - Real.sin ((phi Œ≥ - phi Œ≥'))) := by
          intro T; rw [ intervalIntegral.integral_comp_mul_add ] ; norm_num [ sub_ne_zero.mpr hneq ] ;
          exact sub_ne_zero_of_ne hneq;
        -- The integral of $\cos((Œ≥ + Œ≥')t + (phi Œ≥ + phi Œ≥'))$ over $[0, T]$ is $\frac{1}{Œ≥ + Œ≥'} \sin((Œ≥ + Œ≥')T + (phi Œ≥ + phi Œ≥')) - \frac{1}{Œ≥ + Œ≥'} \sin((phi Œ≥ + phi Œ≥'))$.
        have h_integral_sin2 : ‚àÄ T : ‚Ñù, ‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ + Œ≥') * t + (phi Œ≥ + phi Œ≥')) = (1 / (Œ≥ + Œ≥')) * (Real.sin ((Œ≥ + Œ≥') * T + (phi Œ≥ + phi Œ≥')) - Real.sin ((phi Œ≥ + phi Œ≥'))) := by
          intro T; rw [ intervalIntegral.integral_comp_mul_add ] <;> norm_num ; ring ; positivity;
        -- Substitute the integral results into the expression.
        simp [h_trig, h_integral_sin, h_integral_sin2];
        -- The terms involving $\sin((Œ≥ - Œ≥')T + (phi Œ≥ - phi Œ≥'))$ and $\sin((Œ≥ + Œ≥')T + (phi Œ≥ + phi Œ≥'))$ tend to zero as $T \to \infty$.
        have h_sin_zero : Filter.Tendsto (fun T => T‚Åª¬π * Real.sin ((Œ≥ - Œ≥') * T + (phi Œ≥ - phi Œ≥'))) Filter.atTop (nhds 0) ‚àß Filter.Tendsto (fun T => T‚Åª¬π * Real.sin ((Œ≥ + Œ≥') * T + (phi Œ≥ + phi Œ≥'))) Filter.atTop (nhds 0) := by
          exact ‚ü® squeeze_zero_norm ( fun T => by simpa using mul_le_of_le_one_right ( by positivity ) ( Real.abs_sin_le_one _ ) ) ( tendsto_inv_atTop_zero.comp tendsto_norm_atTop_atTop ), squeeze_zero_norm ( fun T => by simpa using mul_le_of_le_one_right ( by positivity ) ( Real.abs_sin_le_one _ ) ) ( tendsto_inv_atTop_zero.comp tendsto_norm_atTop_atTop ) ‚ü©;
        convert Filter.Tendsto.add ( h_sin_zero.1.const_mul ( ( Œ≥ - Œ≥' ) ‚Åª¬π * ( 1 / 2 ) ) ) ( h_sin_zero.2.const_mul ( ( Œ≥ + Œ≥' ) ‚Åª¬π * ( 1 / 2 ) ) ) |> Filter.Tendsto.sub <| Filter.Tendsto.const_mul ( ( Œ≥ - Œ≥' ) ‚Åª¬π * ( 1 / 2 ) ) ( tendsto_inv_atTop_zero.const_mul ( Real.sin ( phi Œ≥ - phi Œ≥' ) ) ) |> Filter.Tendsto.add <| Filter.Tendsto.const_mul ( ( Œ≥ + Œ≥' ) ‚Åª¬π * ( 1 / 2 ) ) ( tendsto_inv_atTop_zero.const_mul ( Real.sin ( phi Œ≥ + phi Œ≥' ) ) ) using 2 <;> ring;
      -- For each $\gamma$, the integral $\int_0^T \cos^2(\gamma t + \phi_\gamma) \, dt$ is $\frac{T}{2} + O(1)$.
      have h_integral_self : ‚àÄ Œ≥ : ‚Ñù, Œ≥ > 0 ‚Üí Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) ^ 2) Filter.atTop (nhds (1 / 2)) := by
        -- Use the identity $\cos^2(x) = \frac{1 + \cos(2x)}{2}$ to rewrite the integral.
        have h_integral_self_identity : ‚àÄ Œ≥ : ‚Ñù, Œ≥ > 0 ‚Üí ‚àÄ T : ‚Ñù, T > 0 ‚Üí ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) ^ 2 = (T / 2) + (Real.sin (2 * Œ≥ * T + 2 * phi Œ≥) - Real.sin (2 * phi Œ≥)) / (4 * Œ≥) := by
          intro Œ≥ hŒ≥ T hT; rw [ intervalIntegral.integral_comp_mul_add ( fun t => Real.cos t ^ 2 ) ] <;> norm_num [ hŒ≥.ne' ] ; ring;
          rw [ show Œ≥ * T * 2 + phi Œ≥ * 2 = 2 * ( Œ≥ * T + phi Œ≥ ) by ring, show phi Œ≥ * 2 = 2 * phi Œ≥ by ring ] ; rw [ Real.sin_two_mul, Real.sin_two_mul ] ; norm_num [ hŒ≥.ne' ] ; ring;
        -- Use the fact that $\frac{\sin(2\gamma T + 2\phi_\gamma) - \sin(2\phi_\gamma)}{4\gamma T}$ tends to $0$ as $T \to \infty$.
        have h_sin_term : ‚àÄ Œ≥ : ‚Ñù, Œ≥ > 0 ‚Üí Filter.Tendsto (fun T => (Real.sin (2 * Œ≥ * T + 2 * phi Œ≥) - Real.sin (2 * phi Œ≥)) / (4 * Œ≥ * T)) Filter.atTop (nhds 0) := by
          intro Œ≥ hŒ≥;
          refine' ( squeeze_zero_norm _ _ );
          exacts [ fun T => 2 / ( 4 * Œ≥ * |T| ), fun T => by simpa [ abs_div, abs_mul, abs_of_pos hŒ≥ ] using div_le_div_of_nonneg_right ( show |Real.sin ( 2 * Œ≥ * T + 2 * phi Œ≥) - Real.sin ( 2 * phi Œ≥)| ‚â§ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( 2 * Œ≥ * T + 2 * phi Œ≥ ), Real.abs_sin_le_one ( 2 * phi Œ≥ ) ] ) ) ( by positivity ), tendsto_const_nhds.div_atTop <| Filter.Tendsto.const_mul_atTop ( by positivity ) <| Filter.tendsto_abs_atTop_atTop ];
        intro Œ≥ hŒ≥; specialize h_sin_term Œ≥ hŒ≥; rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ h_integral_self_identity Œ≥ hŒ≥ T hT ] ) ] ; convert h_sin_term.const_add ( 1 / 2 ) |> Filter.Tendsto.congr' _ using 2 <;> norm_num ; ring;
        filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ mul_inv_cancel‚ÇÄ hT.ne' ] ; ring;
      -- Using the results of the pairwise and self integrals, we can simplify the limit expression.
      have h_simplify : Filter.Tendsto (fun T => ‚àë Œ≥ ‚àà Œ≥s, ‚àë Œ≥' ‚àà Œ≥s, c Œ≥ * c Œ≥' * (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥')) Filter.atTop (nhds (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ ^ 2 / 2)) := by
        have h_simplify : ‚àÄ Œ≥ Œ≥' : ‚Ñù, Œ≥ > 0 ‚Üí Œ≥' > 0 ‚Üí Filter.Tendsto (fun T => c Œ≥ * c Œ≥' * (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + phi Œ≥) * Real.cos (Œ≥' * t + phi Œ≥')) Filter.atTop (nhds (if Œ≥ = Œ≥' then c Œ≥ ^ 2 / 2 else 0)) := by
          intro Œ≥ Œ≥' hŒ≥ hŒ≥'; split_ifs <;> simp_all +decide [ mul_assoc, sq ] ;
          ¬∑ convert Filter.Tendsto.const_mul ( c Œ≥' * c Œ≥' ) ( h_integral_self Œ≥' hŒ≥' ) using 2 ; ring;
          ¬∑ simpa [ mul_assoc ] using Filter.Tendsto.const_mul ( c Œ≥ * c Œ≥' ) ( h_integral_pairwise Œ≥ Œ≥' hŒ≥ hŒ≥' ‚Äπ_‚Ä∫ );
        exact le_trans ( tendsto_finset_sum _ fun Œ≥ hŒ≥ => tendsto_finset_sum _ fun Œ≥' hŒ≥' => h_simplify Œ≥ Œ≥' ( hŒ≥s Œ≥ hŒ≥ ) ( hŒ≥s Œ≥' hŒ≥' ) ) ( by aesop );
      refine h_simplify.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ h_expansion T hT ] ; simp +decide [ div_eq_inv_mul, mul_assoc, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul ] )

/-
If a trigonometric polynomial tends to zero at infinity, then all its coefficients are zero.
-/
open Real Finset Filter Topology

/-- If a trigonometric polynomial tends to zero at infinity, then all its coefficients are zero. -/
theorem trigPoly_tendsto_zero_implies_zero (Œ≥s : Finset ‚Ñù) (hŒ≥s : ‚àÄ Œ≥ ‚àà Œ≥s, Œ≥ > 0)
    (c : ‚Ñù ‚Üí ‚Ñù) (phi : ‚Ñù ‚Üí ‚Ñù)
    (h_lim : Tendsto (fun t => ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * cos (Œ≥ * t + phi Œ≥)) atTop (nhds 0)) :
    ‚àÄ Œ≥ ‚àà Œ≥s, c Œ≥ = 0 := by
      -- By `trigPoly_mean_square`, (1/T) ‚à´_0^T f(t)^2 dt ‚Üí ‚àë c_Œ≥^2 / 2.
      have h_lim_integral : Filter.Tendsto (fun T => (1 / T) * (‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2)) Filter.atTop (nhds (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ ^ 2 / 2)) := by
        convert trigPoly_mean_square Œ≥s hŒ≥s c phi using 1;
      -- By `trigPoly_mean_square`, (1/T) ‚à´_0^T f(t)^2 dt ‚Üí 0.
      have h_lim_zero_integral : Filter.Tendsto (fun T => (1 / T) * (‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2)) Filter.atTop (nhds 0) := by
        -- Since $f(t) \to 0$ as $t \to \infty$, we have $f(t)^2 \to 0$ as $t \to \infty$.
        have h_f_sq_zero : Filter.Tendsto (fun t => (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2) Filter.atTop (nhds 0) := by
          simpa using h_lim.pow 2;
        -- Using the fact that the integral of a function that tends to zero over $[0, T]$ also tends to zero, we can apply the squeeze theorem.
        have h_integral_zero : ‚àÄ Œµ > 0, ‚àÉ T‚ÇÄ : ‚Ñù, ‚àÄ T ‚â• T‚ÇÄ, ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2 ‚â§ Œµ * T := by
          intro Œµ hŒµ_pos
          obtain ‚ü®T‚ÇÄ, hT‚ÇÄ‚ü© : ‚àÉ T‚ÇÄ : ‚Ñù, ‚àÄ t ‚â• T‚ÇÄ, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2 ‚â§ Œµ / 2 := by
            simpa using h_f_sq_zero.eventually ( ge_mem_nhds <| half_pos hŒµ_pos );
          -- Using the fact that the integral of a function that tends to zero over $[0, T]$ also tends to zero, we can bound the integral.
          have h_integral_bound : ‚àÄ T ‚â• max T‚ÇÄ 1, ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2 ‚â§ (‚à´ t in (0 : ‚Ñù)..max T‚ÇÄ 1, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2) + (T - max T‚ÇÄ 1) * (Œµ / 2) := by
            intro T hT
            have h_integral_bound : ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2 = (‚à´ t in (0 : ‚Ñù)..max T‚ÇÄ 1, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2) + (‚à´ t in (max T‚ÇÄ 1)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2) := by
              rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ Continuous.intervalIntegrable ] <;> exact Continuous.pow ( by exact continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp <| by continuity ) ) _;
            rw [h_integral_bound];
            -- The integral from max T‚ÇÄ 1 to T is bounded by (T - max T‚ÇÄ 1) * (Œµ/2)
            have hle : ‚à´ t in (max T‚ÇÄ 1)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2 ‚â§ (T - max T‚ÇÄ 1) * (Œµ / 2) := by
              calc ‚à´ t in (max T‚ÇÄ 1)..T, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))^2
                  ‚â§ ‚à´ t in (max T‚ÇÄ 1)..T, (Œµ / 2) := by
                    apply intervalIntegral.integral_mono_on (by linarith)
                    ¬∑ exact Continuous.intervalIntegrable (Continuous.pow (continuous_finset_sum _ fun _ _ => Continuous.mul continuous_const (Real.continuous_cos.comp (by continuity))) _) _ _
                    ¬∑ exact continuous_const.intervalIntegrable _ _
                    ¬∑ intro x hx; exact hT‚ÇÄ x (le_trans (le_max_left _ _) hx.1)
                _ = (T - max T‚ÇÄ 1) * (Œµ / 2) := by simp [intervalIntegral.integral_const]; ring
            linarith;
          exact ‚ü® Max.max T‚ÇÄ 1 + ‚åà ( ‚à´ t in ( 0 : ‚Ñù )..Max.max T‚ÇÄ 1, ( ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos ( Œ≥ * t + phi Œ≥ ) ) ^ 2 ) / ( Œµ / 2 ) ‚åâ‚Çä + 1, fun T hT => by nlinarith [ Nat.le_ceil ( ( ‚à´ t in ( 0 : ‚Ñù )..Max.max T‚ÇÄ 1, ( ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos ( Œ≥ * t + phi Œ≥ ) ) ^ 2 ) / ( Œµ / 2 ) ), h_integral_bound T ( by linarith [ le_max_left T‚ÇÄ 1, le_max_right T‚ÇÄ 1 ] ), mul_div_cancel‚ÇÄ ( ‚à´ t in ( 0 : ‚Ñù )..Max.max T‚ÇÄ 1, ( ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos ( Œ≥ * t + phi Œ≥ ) ) ^ 2 ) ( by linarith : ( Œµ / 2 ) ‚â† 0 ), le_max_left T‚ÇÄ 1, le_max_right T‚ÇÄ 1 ] ‚ü©;
        rw [ Metric.tendsto_nhds ];
        field_simp;
        intro Œµ hŒµ; rcases h_integral_zero ( Œµ / 2 ) ( half_pos hŒµ ) with ‚ü® T‚ÇÄ, hT‚ÇÄ ‚ü© ; filter_upwards [ Filter.eventually_ge_atTop T‚ÇÄ, Filter.eventually_gt_atTop 0 ] with T hT‚ÇÅ hT‚ÇÇ using abs_lt.mpr ‚ü® by rw [ lt_sub_iff_add_lt ] ; rw [ lt_div_iff‚ÇÄ hT‚ÇÇ ] ; nlinarith [ hT‚ÇÄ T hT‚ÇÅ, show 0 ‚â§ ‚à´ t in ( 0 : ‚Ñù )..T, ( ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos ( Œ≥ * t + phi Œ≥ ) ) ^ 2 from intervalIntegral.integral_nonneg ( by linarith ) fun _ _ => sq_nonneg _ ], by rw [ sub_lt_iff_lt_add' ] ; rw [ div_lt_iff‚ÇÄ hT‚ÇÇ ] ; nlinarith [ hT‚ÇÄ T hT‚ÇÅ, show 0 ‚â§ ‚à´ t in ( 0 : ‚Ñù )..T, ( ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos ( Œ≥ * t + phi Œ≥ ) ) ^ 2 from intervalIntegral.integral_nonneg ( by linarith ) fun _ _ => sq_nonneg _ ] ‚ü© ;
      intros Œ≥ hŒ≥; have := tendsto_nhds_unique h_lim_integral h_lim_zero_integral; simp_all +decide [ Finset.sum_eq_zero_iff_of_nonneg, sq_nonneg ] ;
      rw [ Finset.sum_eq_zero_iff_of_nonneg fun _ _ => div_nonneg ( sq_nonneg _ ) zero_le_two ] at this; aesop;

/-
If a non-negative uniformly continuous function has a convergent integral, it tends to zero at infinity.
-/
open Real Finset Filter Topology

/-- If a non-negative uniformly continuous function has a convergent integral, it tends to zero at infinity. -/
theorem tendsto_zero_of_nonneg_integrable_uniformContinuous {f : ‚Ñù ‚Üí ‚Ñù}
    (hf_nonneg : ‚àÄ x, 0 ‚â§ f x)
    (hf_unif : UniformContinuous f)
    (hf_int : ‚àÉ L, Tendsto (fun T => ‚à´ t in (0 : ‚Ñù)..T, f t) atTop (nhds L)) :
    Tendsto f atTop (nhds 0) := by
      -- We need to show that for every Œµ > 0, there exists an M such that for all x ‚â• M, |f(x)| < Œµ.
      have h_forall_eps (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) : ‚àÉ M, ‚àÄ x ‚â• M, f x < Œµ := by
        -- By uniform continuity, there exists Œ¥ > 0 such that |x - y| < Œ¥ implies |f(x) - f(y)| < Œµ/2.
        obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ x y, |x - y| < Œ¥ ‚Üí |f x - f y| < Œµ / 2 := by
          exact Metric.uniformContinuous_iff.mp hf_unif ( Œµ / 2 ) ( half_pos hŒµ );
        -- Suppose f does not tend to 0. Then there exists Œµ > 0 and a sequence x_n ‚Üí ‚àû such that f(x_n) ‚â• Œµ.
        by_contra h_contra
        obtain ‚ü®M, hM‚ü© : ‚àÉ M, ‚àÄ x ‚â• M, ‚à´ t in x..x + Œ¥, f t < Œ¥ * Œµ / 4 := by
          -- By the properties of integrals, we can write
          have h_integral_split : ‚àÄ x ‚â• 0, ‚à´ t in x..x + Œ¥, f t = (‚à´ t in (0 : ‚Ñù)..x + Œ¥, f t) - (‚à´ t in (0 : ‚Ñù)..x, f t) := by
            intro x hx; rw [ eq_sub_iff_add_eq', intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ Continuous.intervalIntegrable, hf_unif.continuous ] ;
          -- By the properties of integrals, we can write the difference as
          have h_integral_diff : Filter.Tendsto (fun x => (‚à´ t in (0 : ‚Ñù)..x + Œ¥, f t) - (‚à´ t in (0 : ‚Ñù)..x, f t)) Filter.atTop (nhds 0) := by
            simpa using Filter.Tendsto.sub ( hf_int.choose_spec.comp ( Filter.tendsto_id.atTop_add tendsto_const_nhds ) ) hf_int.choose_spec;
          exact Filter.eventually_atTop.mp ( h_integral_diff.eventually ( gt_mem_nhds <| show 0 < Œ¥ * Œµ / 4 by positivity ) ) |> fun ‚ü® M, hM ‚ü© ‚Ü¶ ‚ü® Max.max M 0, fun x hx ‚Ü¶ by linarith [ hM x ( le_trans ( le_max_left _ _ ) hx ), h_integral_split x ( le_trans ( le_max_right _ _ ) hx ) ] ‚ü©;
        -- Choose x_n such that x_n ‚Üí ‚àû and f(x_n) ‚â• Œµ.
        obtain ‚ü®xn, hxn‚ü© : ‚àÉ xn : ‚Ñï ‚Üí ‚Ñù, Filter.Tendsto xn Filter.atTop Filter.atTop ‚àß ‚àÄ n, f (xn n) ‚â• Œµ := by
          push_neg at h_contra;
          exact ‚ü® fun n => Classical.choose ( h_contra n ), Filter.tendsto_atTop_mono ( fun n => Classical.choose_spec ( h_contra n ) |>.1 ) tendsto_natCast_atTop_atTop, fun n => Classical.choose_spec ( h_contra n ) |>.2 ‚ü©;
        -- Choose N such that for all n ‚â• N, xn n ‚â• M.
        obtain ‚ü®N, hN‚ü© : ‚àÉ N, ‚àÄ n ‚â• N, xn n ‚â• M := by
          exact Filter.eventually_atTop.mp ( hxn.1.eventually_ge_atTop M );
        -- By the properties of integrals, we have $\int_{xn n}^{xn n + Œ¥} f(t) dt \geq \int_{xn n}^{xn n + Œ¥} (Œµ / 2) dt = Œ¥ * (Œµ / 2)$.
        have h_integral_bound : ‚àÄ n ‚â• N, ‚à´ t in xn n..xn n + Œ¥, f t ‚â• Œ¥ * (Œµ / 2) := by
          intros n hn
          have h_integral_bound : ‚àÄ t ‚àà Set.Icc (xn n) (xn n + Œ¥), f t ‚â• Œµ / 2 := by
            intros t ht
            by_cases h_case : t = xn n + Œ¥;
            ¬∑ have h_lim : Filter.Tendsto (fun y => f y) (nhdsWithin (xn n + Œ¥) (Set.Iio (xn n + Œ¥))) (nhds (f (xn n + Œ¥))) := by
                exact hf_unif.continuous.continuousWithinAt;
              have h_lim_ge : ‚àÄ·∂† y in nhdsWithin (xn n + Œ¥) (Set.Iio (xn n + Œ¥)), f y ‚â• Œµ / 2 := by
                filter_upwards [ Ioo_mem_nhdsLT ( show xn n < xn n + Œ¥ by linarith ) ] with y hy using by linarith [ abs_lt.mp ( hŒ¥ y ( xn n ) ( abs_lt.mpr ‚ü® by linarith [ hy.1, hy.2 ], by linarith [ hy.1, hy.2 ] ‚ü© ) ), hxn.2 n ] ;
              exact h_case.symm ‚ñ∏ le_of_tendsto_of_tendsto tendsto_const_nhds h_lim ( Filter.eventually_of_mem h_lim_ge fun x hx => hx );
            ¬∑ linarith [ abs_lt.mp ( hŒ¥ t ( xn n ) ( abs_lt.mpr ‚ü® by linarith [ ht.1, ht.2, lt_of_le_of_ne ht.2 h_case ], by linarith [ ht.1, ht.2, lt_of_le_of_ne ht.2 h_case ] ‚ü© ) ), hxn.2 n ];
          refine' le_trans _ ( intervalIntegral.integral_mono_on _ _ _ h_integral_bound ) <;> norm_num [ hŒ¥_pos.le ];
          ¬∑ linarith;
          ¬∑ exact hf_unif.continuous.intervalIntegrable _ _;
        exact absurd ( h_integral_bound N le_rfl ) ( by nlinarith [ hM ( xn N ) ( hN N le_rfl ) ] );
      exact Metric.tendsto_atTop.mpr fun Œµ hŒµ => by obtain ‚ü® M, hM ‚ü© := h_forall_eps Œµ hŒµ; exact ‚ü® M, fun x hx => abs_lt.mpr ‚ü® by linarith [ hf_nonneg x, hM x hx ], by linarith [ hf_nonneg x, hM x hx ] ‚ü© ‚ü© ;

/-
If a trigonometric polynomial with positive frequencies is non-negative everywhere, then it is identically zero.
-/
open Real Finset Filter Topology

/-- If a trigonometric polynomial with positive frequencies is non-negative everywhere, then it is identically zero. -/
theorem trigPoly_nonneg_implies_zero (Œ≥s : Finset ‚Ñù) (hŒ≥s : ‚àÄ Œ≥ ‚àà Œ≥s, Œ≥ > 0)
    (c : ‚Ñù ‚Üí ‚Ñù) (phi : ‚Ñù ‚Üí ‚Ñù) (h_nonneg : ‚àÄ t, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * cos (Œ≥ * t + phi Œ≥) ‚â• 0) :
    ‚àÄ Œ≥ ‚àà Œ≥s, c Œ≥ = 0 := by
      -- By Lemma 2, the integral $F(T) = \int_0^T f(t) dt$ converges to a limit $L$ as $T \to \infty$.
      have hF_conv : ‚àÉ L, Filter.Tendsto (fun T => ‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥)) Filter.atTop (nhds L) := by
        -- By Lemma 2, the integral $F(T) = \int_0^T f(t) dt$ is bounded.
        have hF_bounded : ‚àÉ C, ‚àÄ T > 0, |‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥)| ‚â§ C := by
          exact trigPoly_integral_bounded Œ≥s hŒ≥s c phi;
        -- Since $F(T)$ is bounded and non-decreasing, it converges to a limit $L$ as $T \to \infty$.
        have hF_monotone : Monotone (fun T => ‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥)) := by
          intro T‚ÇÅ T‚ÇÇ hT; cases le_total T‚ÇÅ 0 <;> cases le_total T‚ÇÇ 0 <;> simp_all +decide [ intervalIntegral ] ;
          ¬∑ refine' MeasureTheory.setIntegral_mono_set _ _ _;
            ¬∑ exact Continuous.integrableOn_Ioc ( continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) );
            ¬∑ exact Filter.Eventually.of_forall h_nonneg;
            ¬∑ exact MeasureTheory.ae_of_all _ fun x hx => ‚ü® by linarith [ hx.1 ], by linarith [ hx.2 ] ‚ü©;
          ¬∑ exact le_trans ( neg_nonpos_of_nonneg ( MeasureTheory.setIntegral_nonneg measurableSet_Ioc fun x hx => h_nonneg x ) ) ( MeasureTheory.setIntegral_nonneg measurableSet_Ioc fun x hx => h_nonneg x );
          ¬∑ norm_num [ show T‚ÇÅ = 0 by linarith, show T‚ÇÇ = 0 by linarith ];
          ¬∑ refine' MeasureTheory.setIntegral_mono_set _ _ _;
            ¬∑ exact Continuous.integrableOn_Ioc ( continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) );
            ¬∑ exact Filter.Eventually.of_forall h_nonneg;
            ¬∑ exact MeasureTheory.ae_of_all _ fun x hx => ‚ü® hx.1, hx.2.trans hT ‚ü©;
        have hF_bounded : BddAbove (Set.range (fun T => ‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥))) := by
          obtain ‚ü® C, hC ‚ü© := hF_bounded;
          refine' ‚ü® C, Set.forall_mem_range.2 fun T => _ ‚ü©;
          by_cases hT : 0 < T;
          ¬∑ linarith [ abs_le.mp ( hC T hT ) ];
          ¬∑ rw [ intervalIntegral.integral_of_ge ( le_of_not_gt hT ) ];
            exact le_trans ( neg_nonpos_of_nonneg ( MeasureTheory.setIntegral_nonneg measurableSet_Ioc fun x hx => h_nonneg x ) ) ( le_trans ( abs_nonneg _ ) ( hC 1 zero_lt_one ) );
        exact ‚ü® _, tendsto_atTop_isLUB hF_monotone ( isLUB_ciSup hF_bounded ) ‚ü©;
      -- By Lemma 1, we know that $f(t)$ is uniformly continuous.
      have h_unif_cont : UniformContinuous (fun t => ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥)) := by
        refine' ( Metric.uniformContinuous_iff.mpr _ );
        -- Since the derivative of $f(t)$ is bounded, $f(t)$ is uniformly continuous.
        have h_deriv_bounded : ‚àÉ M, ‚àÄ t, |deriv (fun t => ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥)) t| ‚â§ M := by
          norm_num [ mul_comm ];
          norm_num [ deriv_sum ];
          exact ‚ü® ‚àë Œ≥ ‚àà Œ≥s, |c Œ≥| * |Œ≥|, fun t => le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum fun x hx => by simpa [ abs_mul ] using mul_le_mul_of_nonneg_left ( mul_le_of_le_one_left ( abs_nonneg _ ) ( Real.abs_sin_le_one _ ) ) ( abs_nonneg _ ) ) ‚ü©;
        -- By the Mean Value Theorem, if the derivative of $f(t)$ is bounded, then $f(t)$ is Lipschitz continuous.
        have h_lipschitz : ‚àÉ M, ‚àÄ a b, |‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * a + phi Œ≥) - ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * b + phi Œ≥)| ‚â§ M * |a - b| := by
          obtain ‚ü® M, hM ‚ü© := h_deriv_bounded;
          use M;
          intro a b; cases eq_or_ne a b <;> simp_all +decide [ mul_comm ];
          cases' lt_or_gt_of_ne ‚Äπ_‚Ä∫ with h h;
          ¬∑ have := exists_deriv_eq_slope ( f := fun t => ‚àë x ‚àà Œ≥s, c x * Real.cos ( t * x + phi x ) ) h;
            exact this ( Continuous.continuousOn <| continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) <| Real.continuous_cos.comp <| by continuity ) ( Differentiable.differentiableOn <| by norm_num ) |> fun ‚ü® x, hx‚ÇÅ, hx‚ÇÇ ‚ü© => by rw [ abs_le ] ; constructor <;> cases abs_cases ( a - b ) <;> nlinarith [ abs_le.mp ( hM x ), mul_div_cancel‚ÇÄ ( ‚àë x ‚àà Œ≥s, c x * Real.cos ( b * x + phi x ) - ‚àë x ‚àà Œ≥s, c x * Real.cos ( a * x + phi x ) ) ( sub_ne_zero_of_ne <| by linarith : ( b - a ) ‚â† 0 ) ] ;
          ¬∑ have := exists_deriv_eq_slope ( f := fun t => ‚àë x ‚àà Œ≥s, c x * Real.cos ( t * x + phi x ) ) h;
            exact this ( Continuous.continuousOn <| continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) <| Real.continuous_cos.comp <| by continuity ) ( Differentiable.differentiableOn <| by norm_num ) |> fun ‚ü® x, hx‚ÇÅ, hx‚ÇÇ ‚ü© => by rw [ eq_div_iff ] at hx‚ÇÇ <;> cases abs_cases ( a - b ) <;> cases abs_cases ( ‚àë x ‚àà Œ≥s, c x * Real.cos ( a * x + phi x ) - ‚àë x ‚àà Œ≥s, c x * Real.cos ( b * x + phi x ) ) <;> nlinarith [ abs_le.mp ( hM x ) ] ;
        exact fun Œµ Œµ_pos => by rcases h_lipschitz with ‚ü® M, HM ‚ü© ; exact ‚ü® Œµ / ( Max.max M 1 ), div_pos Œµ_pos ( by positivity ), fun a b hab => by rw [ Real.dist_eq ] at *; exact lt_of_le_of_lt ( HM a b ) ( by nlinarith [ abs_nonneg ( a - b ), le_max_left M 1, le_max_right M 1, mul_div_cancel‚ÇÄ Œµ ( by positivity : ( Max.max M 1 ) ‚â† 0 ) ] ) ‚ü© ;
      have := tendsto_zero_of_nonneg_integrable_uniformContinuous h_nonneg h_unif_cont hF_conv;
      exact trigPoly_tendsto_zero_implies_zero Œ≥s hŒ≥s c phi this

/-
If a uniformly continuous function is non-negative on [0, ‚àû) and has a convergent integral, it tends to zero at infinity.
-/
open Real Finset Filter Topology

/-- If a uniformly continuous function is non-negative on [0, ‚àû) and has a convergent integral, it tends to zero at infinity. -/
theorem tendsto_zero_of_nonneg_on_Ici_integrable_uniformContinuous {f : ‚Ñù ‚Üí ‚Ñù}
    (hf_nonneg : ‚àÄ x ‚â• 0, 0 ‚â§ f x)
    (hf_unif : UniformContinuous f)
    (hf_int : ‚àÉ L, Tendsto (fun T => ‚à´ t in (0 : ‚Ñù)..T, f t) atTop (nhds L)) :
    Tendsto f atTop (nhds 0) := by
      have h_limit_zero : ‚àÄ {g : ‚Ñù ‚Üí ‚Ñù}, (‚àÄ x, 0 ‚â§ g x) ‚Üí UniformContinuous g ‚Üí (‚àÉ L, Filter.Tendsto (fun T => ‚à´ t in (0 : ‚Ñù)..T, g t) Filter.atTop (nhds L)) ‚Üí Filter.Tendsto g Filter.atTop (nhds 0) := by
        exact fun {g} a a_1 a_2 => tendsto_zero_of_nonneg_integrable_uniformContinuous a a_1 a_2;
      contrapose! h_limit_zero;
      refine' ‚ü® fun x => f ( |x| ), _, _, _, _ ‚ü© <;> norm_num;
      ¬∑ exact fun x => hf_nonneg _ ( abs_nonneg x );
      ¬∑ refine' Metric.uniformContinuous_iff.2 fun Œµ Œµpos => _;
        rcases Metric.uniformContinuous_iff.1 hf_unif Œµ Œµpos with ‚ü® Œ¥, Œ¥pos, hŒ¥ ‚ü© ; exact ‚ü® Œ¥, Œ¥pos, fun { a b } hab => hŒ¥ <| by simpa using abs_lt.2 ‚ü® by cases abs_cases a <;> cases abs_cases b <;> linarith [ abs_lt.mp hab ], by cases abs_cases a <;> cases abs_cases b <;> linarith [ abs_lt.mp hab ] ‚ü© ‚ü©;
      ¬∑ refine' ‚ü® hf_int.choose, hf_int.choose_spec.congr' _ ‚ü©;
        filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by refine' intervalIntegral.integral_congr fun t ht => _ ; rw [ abs_of_nonneg ] ; linarith [ Set.mem_Icc.mp ( by simpa [ hT.le ] using ht ) ] ;
      ¬∑ exact fun h => h_limit_zero <| h.congr' <| by filter_upwards [ Filter.eventually_ge_atTop 0 ] with x hx using by rw [ abs_of_nonneg hx ] ;

/-
If a trigonometric polynomial with positive frequencies is eventually non-negative, then it is identically zero.
-/
open Real Finset Filter Topology

/-- If a trigonometric polynomial with positive frequencies is eventually non-negative, then it is identically zero. -/
theorem trigPoly_eventually_nonneg_implies_zero (Œ≥s : Finset ‚Ñù) (hŒ≥s : ‚àÄ Œ≥ ‚àà Œ≥s, Œ≥ > 0)
    (c : ‚Ñù ‚Üí ‚Ñù) (phi : ‚Ñù ‚Üí ‚Ñù) (M : ‚Ñù)
    (h_nonneg : ‚àÄ t > M, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * cos (Œ≥ * t + phi Œ≥) ‚â• 0) :
    ‚àÄ Œ≥ ‚àà Œ≥s, c Œ≥ = 0 := by
      -- Let $f(t) = \sum_{Œ≥ \in Œ≥s} c_Œ≥ \cos(Œ≥ t + phi_Œ≥)$.
      set f : ‚Ñù ‚Üí ‚Ñù := fun t => ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥);
      -- Define $g(t) = f(t + M)$. Then $g(t) = \sum_{Œ≥ \in Œ≥s} c_Œ≥ \cos(Œ≥(t + M) + phi_Œ≥) = \sum_{Œ≥ \in Œ≥s} c_Œ≥ \cos(Œ≥t + (Œ≥M + phi_Œ≥))$.
      set g : ‚Ñù ‚Üí ‚Ñù := fun t => f (t + M);
      -- Since $g(t)$ is a trigonometric polynomial with the same coefficients $c_Œ≥$ and shifted phases, by `tendsto_zero_of_nonneg_on_Ici_integrable_uniformContinuous`, $g(t) \to 0$ as $t \to \infty$.
      have h_g_zero : Filter.Tendsto g Filter.atTop (nhds 0) := by
        have h_g_nonneg : ‚àÄ t ‚â• 0, 0 ‚â§ g t := by
          intro t ht;
          by_cases h : t = 0;
          ¬∑ -- Since $g$ is continuous, we have $\lim_{t \to 0^+} g(t) = g(0)$.
            have hg_cont : Filter.Tendsto g (nhdsWithin 0 (Set.Ioi 0)) (nhds (g 0)) := by
              exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by exact continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp <| by continuity ) ) _ _ <| by aesop );
            exact h.symm ‚ñ∏ le_of_tendsto_of_tendsto tendsto_const_nhds hg_cont ( Filter.eventually_of_mem self_mem_nhdsWithin fun x hx => by simpa using h_nonneg ( x + M ) ( by linarith [ hx.out ] ) );
          ¬∑ exact h_nonneg _ ( lt_add_of_pos_left _ ( lt_of_le_of_ne ht ( Ne.symm h ) ) )
        have h_g_uniformContinuous : UniformContinuous g := by
          -- The function $g(t)$ is a trigonometric polynomial with the same coefficients $c_Œ≥$ and shifted phases.
          have h_g_trigPoly : ‚àÄ t, g t = ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + (Œ≥ * M + phi Œ≥)) := by
            exact fun t => Finset.sum_congr rfl fun _ _ => by ring;
          -- The function $g(t)$ is a trigonometric polynomial with the same coefficients $c_Œ≥$ and shifted phases, hence it is uniformly continuous.
          have h_g_unif : ‚àÄ Œµ > 0, ‚àÉ Œ¥ > 0, ‚àÄ t1 t2, |t1 - t2| < Œ¥ ‚Üí |g t1 - g t2| < Œµ := by
            -- The function $g(t)$ is a trigonometric polynomial with the same coefficients $c_Œ≥$ and shifted phases, hence it is Lipschitz continuous.
            have h_g_lipschitz : ‚àÉ L, ‚àÄ t1 t2, |g t1 - g t2| ‚â§ L * |t1 - t2| := by
              -- The function $g(t)$ is a trigonometric polynomial with the same coefficients $c_Œ≥$ and shifted phases, hence it is Lipschitz continuous with constant $L = \sum_{Œ≥ \in Œ≥s} |c_Œ≥| * Œ≥$.
              use ‚àë Œ≥ ‚àà Œ≥s, |c Œ≥| * Œ≥;
              -- By the properties of the cosine function and the triangle inequality, we can bound the difference $|g(t1) - g(t2)|$.
              intros t1 t2
              have h_cos_diff : ‚àÄ Œ≥ ‚àà Œ≥s, |Real.cos (Œ≥ * t1 + (Œ≥ * M + phi Œ≥)) - Real.cos (Œ≥ * t2 + (Œ≥ * M + phi Œ≥))| ‚â§ Œ≥ * |t1 - t2| := by
                -- Using the fact that the cosine function is Lipschitz continuous with constant 1, we can bound the difference.
                have h_cos_lip : ‚àÄ x y : ‚Ñù, |Real.cos x - Real.cos y| ‚â§ |x - y| := by
                  -- Using the mean value theorem, we can bound the difference $|\cos(x) - \cos(y)|$ by $|x - y|$.
                  have h_cos_diff_bound : ‚àÄ x y : ‚Ñù, x < y ‚Üí |Real.cos x - Real.cos y| ‚â§ |x - y| := by
                    intros x y hxy;
                    have := exists_deriv_eq_slope ( Real.cos ) hxy;
                    exact this ( Real.continuousOn_cos ) ( Differentiable.differentiableOn ( Real.differentiable_cos ) ) |> fun ‚ü® c, hc1, hc2 ‚ü© => by rw [ eq_div_iff ] at hc2 <;> norm_num at * <;> cases abs_cases ( x - y ) <;> cases abs_cases ( Real.cos x - Real.cos y ) <;> nlinarith [ Real.neg_one_le_sin c, Real.sin_le_one c ] ;
                  exact fun x y => if hxy : x < y then h_cos_diff_bound x y hxy else if hyx : y < x then by simpa only [ abs_sub_comm ] using h_cos_diff_bound y x hyx else by rw [ show x = y by linarith ] ; norm_num;
                exact fun Œ≥ hŒ≥ => le_trans ( h_cos_lip _ _ ) ( by rw [ show Œ≥ * t1 + ( Œ≥ * M + phi Œ≥ ) - ( Œ≥ * t2 + ( Œ≥ * M + phi Œ≥ ) ) = Œ≥ * ( t1 - t2 ) by ring ] ; rw [ abs_mul, abs_of_nonneg ( le_of_lt ( hŒ≥s Œ≥ hŒ≥ ) ) ] );
              rw [ h_g_trigPoly t1, h_g_trigPoly t2, ‚Üê Finset.sum_sub_distrib ];
              exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( by rw [ Finset.sum_mul _ _ _ ] ; exact Finset.sum_le_sum fun x hx => by rw [ ‚Üê mul_sub ] ; exact abs_le.mpr ‚ü® by cases abs_cases ( c x ) <;> cases abs_cases ( t1 - t2 ) <;> nlinarith [ abs_le.mp ( h_cos_diff x hx ), hŒ≥s x hx ], by cases abs_cases ( c x ) <;> cases abs_cases ( t1 - t2 ) <;> nlinarith [ abs_le.mp ( h_cos_diff x hx ), hŒ≥s x hx ] ‚ü© );
            exact fun Œµ Œµ_pos => by obtain ‚ü® L, hL ‚ü© := h_g_lipschitz; exact ‚ü® Œµ / ( Max.max L 1 ), div_pos Œµ_pos ( by positivity ), fun t1 t2 h => by rw [ lt_div_iff‚ÇÄ ( by positivity ) ] at h; nlinarith [ hL t1 t2, le_max_left L 1, le_max_right L 1, abs_nonneg ( t1 - t2 ) ] ‚ü© ;
          exact Metric.uniformContinuous_iff.mpr fun Œµ hŒµ => by simpa using h_g_unif Œµ hŒµ;
        have h_g_integrable : ‚àÉ L, Filter.Tendsto (fun T => ‚à´ t in (0 : ‚Ñù)..T, g t) Filter.atTop (nhds L) := by
          -- By `trigPoly_integral_bounded`, the integral of $g$ is bounded.
          have h_g_integral_bounded : ‚àÉ C, ‚àÄ T > 0, |‚à´ t in (0 : ‚Ñù)..T, g t| ‚â§ C := by
            have h_g_integral_bounded : ‚àÉ C, ‚àÄ T > 0, |‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * (t + M) + phi Œ≥)| ‚â§ C := by
              have h_g_integral_bounded : ‚àÉ C, ‚àÄ T > 0, |‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + (Œ≥ * M + phi Œ≥))| ‚â§ C := by
                convert trigPoly_integral_bounded Œ≥s hŒ≥s ( fun Œ≥ => c Œ≥ ) ( fun Œ≥ => Œ≥ * M + phi Œ≥ ) using 1
              convert h_g_integral_bounded using 6 ; ring;
              exact intervalIntegral.integral_congr fun _ _ => Finset.sum_congr rfl fun _ _ => by ring;
            aesop;
          have h_g_integral_converges : Filter.Tendsto (fun T => ‚à´ t in (0 : ‚Ñù)..T, g t) Filter.atTop (nhds (sSup {‚à´ t in (0 : ‚Ñù)..T, g t | T > 0})) := by
            have h_monotone : MonotoneOn (fun T => ‚à´ t in (0 : ‚Ñù)..T, g t) (Set.Ioi 0) := by
              intros T hT U hU hTUTT';
              apply_rules [ intervalIntegral.integral_mono_interval, hT.out.le, hU.out.le ];
              ¬∑ norm_num;
              ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using h_g_nonneg t ht.1.le;
              ¬∑ exact h_g_uniformContinuous.continuous.intervalIntegrable _ _
            refine' ( tendsto_order.2 ‚ü® _, _ ‚ü© );
            ¬∑ intro a' ha'; rcases exists_lt_of_lt_csSup ( show { x : ‚Ñù | ‚àÉ T > 0, ‚à´ t in ( 0 : ‚Ñù )..T, g t = x }.Nonempty from ‚ü® _, ‚ü® 1, zero_lt_one, rfl ‚ü© ‚ü© ) ha' with ‚ü® x, ‚ü® T, hT, rfl ‚ü©, hx ‚ü© ; filter_upwards [ Filter.eventually_gt_atTop T ] with t ht using hx.trans_le ( h_monotone ( show 0 < T by linarith ) ( show 0 < t by linarith ) ht.le ) ;
            ¬∑ exact fun x hx => Filter.eventually_atTop.mpr ‚ü® 1, fun t ht => lt_of_le_of_lt ( le_csSup ( show BddAbove { x : ‚Ñù | ‚àÉ T > 0, ‚à´ t in ( 0 : ‚Ñù )..T, g t = x } from ‚ü® h_g_integral_bounded.choose, by rintro x ‚ü® T, hT, rfl ‚ü© ; exact le_of_abs_le ( h_g_integral_bounded.choose_spec T hT ) ‚ü© ) ‚ü® t, by linarith, rfl ‚ü© ) hx ‚ü©;
          exact ‚ü® _, h_g_integral_converges ‚ü©
        convert tendsto_zero_of_nonneg_on_Ici_integrable_uniformContinuous h_g_nonneg h_g_uniformContinuous h_g_integrable using 1;
      convert trigPoly_tendsto_zero_implies_zero Œ≥s hŒ≥s c phi _ using 1;
      convert h_g_zero.comp ( show Filter.Tendsto ( fun t => t - M ) Filter.atTop Filter.atTop from Filter.tendsto_id.atTop_add tendsto_const_nhds ) using 2 ; aesop

/-
Schmidt's oscillation theorem: A non-trivial trigonometric polynomial with positive frequencies oscillates infinitely often.
-/
open Real Finset Filter Topology

/-- Schmidt's oscillation theorem: A non-trivial trigonometric polynomial with positive frequencies oscillates infinitely often. -/
theorem schmidt_oscillation (Œ≥s : Finset ‚Ñù) (hŒ≥s : ‚àÄ Œ≥ ‚àà Œ≥s, Œ≥ > 0)
    (c : ‚Ñù ‚Üí ‚Ñù) (phi : ‚Ñù ‚Üí ‚Ñù) (hc : ‚àÉ Œ≥ ‚àà Œ≥s, c Œ≥ ‚â† 0) :
    ‚àÄ M, ‚àÉ t‚ÇÅ t‚ÇÇ, t‚ÇÅ > M ‚àß t‚ÇÇ > M ‚àß
    (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t‚ÇÅ + phi Œ≥)) > 0 ‚àß
    (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t‚ÇÇ + phi Œ≥)) < 0 := by
      intro M;
      -- By contradiction, assume there exists $M$ such that $f(t)$ does not change sign for $t > M$.
      by_contra h_contra
      obtain ‚ü®M, hM‚ü© : ‚àÉ M : ‚Ñù, (‚àÄ t > M, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥)) ‚â• 0) ‚à® (‚àÄ t > M, (‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥)) ‚â§ 0) := by
        simp +zetaDelta at *;
        by_cases h_pos : ‚àÉ t > M, ‚àë Œ≥ ‚àà Œ≥s, c Œ≥ * Real.cos (Œ≥ * t + phi Œ≥) > 0;
        ¬∑ exact ‚ü® M, Or.inl fun t ht => h_contra _ h_pos.choose_spec.1 _ ht h_pos.choose_spec.2 ‚ü©;
        ¬∑ exact ‚ü® M, Or.inr fun t ht => le_of_not_gt fun h => h_pos ‚ü® t, ht, h ‚ü© ‚ü©;
      rcases hM with hM | hM;
      ¬∑ exact hc.elim fun Œ≥ hŒ≥ => hŒ≥.2 <| trigPoly_eventually_nonneg_implies_zero Œ≥s hŒ≥s c phi M hM Œ≥ hŒ≥.1;
      ¬∑ -- Applying `trigPoly_eventually_nonneg_implies_zero` to $-f(t)$.
        have := trigPoly_eventually_nonneg_implies_zero Œ≥s hŒ≥s (fun Œ≥ => -c Œ≥) (fun Œ≥ => phi Œ≥) M (fun t ht => by
          simpa only [ neg_mul, Finset.sum_neg_distrib ] using neg_nonneg_of_nonpos ( hM t ht ));
        exact hc.elim fun Œ≥ hŒ≥ => hŒ≥.2 <| neg_eq_zero.mp <| this Œ≥ hŒ≥.1