/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9bcd5d61-a059-4746-8b75-bf6b787885ff

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Given a finite set of real numbers γs and a tolerance ε, there exists a time t > 0 such that for all γ in γs, t*γ is close to an integer multiple of 2π.
-/
lemma align_phases (γs : Finset ℝ) (ε : ℝ) (hε : ε > 0) :
    ∃ t > 0, ∀ γ ∈ γs, ∃ k : ℤ, |t * γ / (2 * Real.pi) - k| < ε := by
      have h_dirichlet : ∀ {γs : Finset ℝ} {ε : ℝ}, ε > 0 → ∃ t > 0, ∀ γ ∈ γs, ∃ k : ℤ, |t * γ / (2 * Real.pi) - k| < ε := by
        intros γs ε hε_pos
        obtain ⟨t, ht_pos, ht_approx⟩ : ∃ t > 0, ∀ γ ∈ γs, ∃ (k : ℤ), |t * γ / (2 * Real.pi) - k| < ε := by
          have h_dirichlet : ∀ {γs : Finset ℝ} {ε : ℝ}, ε > 0 → ∃ t ∈ Set.Ioo 0 ε, ∀ γ ∈ γs, ∃ k : ℤ, |t * γ / (2 * Real.pi) - k| < ε := by
            intros γs ε hε_pos
            obtain ⟨t, ht⟩ : ∃ t ∈ Set.Ioo 0 ε, ∀ γ ∈ γs, |t * γ / (2 * Real.pi)| < ε := by
              obtain ⟨t, ht⟩ : ∃ t ∈ Set.Ioo 0 ε, ∀ γ ∈ γs, |t * γ| < ε * (2 * Real.pi) := by
                have h_bounded : ∃ M > 0, ∀ γ ∈ γs, |γ| ≤ M := by
                  exact ⟨ ∑ x ∈ γs, |x| + 1, add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => abs_nonneg _ ) zero_lt_one, fun x hx => by linarith [ Finset.single_le_sum ( fun x _ => abs_nonneg x ) hx ] ⟩
                obtain ⟨ M, hM_pos, hM ⟩ := h_bounded;
                exact ⟨ Min.min ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ) / 2, ⟨ by positivity, by linarith [ show 0 < Min.min ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ) by positivity, min_le_left ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ), min_le_right ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ) ] ⟩, fun γ hγ => by rw [ abs_lt ] ; constructor <;> nlinarith [ show 0 < Min.min ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ) by positivity, min_le_left ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ), min_le_right ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ), abs_le.mp ( hM γ hγ ), Real.pi_gt_three, mul_div_cancel₀ ( ε * ( 2 * Real.pi ) ) ( by positivity : ( M + 1 ) ≠ 0 ) ] ⟩;
              exact ⟨ t, ht.1, fun γ hγ => by rw [ abs_div, abs_of_nonneg ( by positivity : ( 0 : ℝ ) ≤ 2 * Real.pi ) ] ; rw [ div_lt_iff₀ ( by positivity ) ] ; linarith [ ht.2 γ hγ ] ⟩;
            exact ⟨ t, ht.1, fun γ hγ => ⟨ 0, by simpa using ht.2 γ hγ ⟩ ⟩
          exact Exists.elim ( h_dirichlet hε_pos ) fun t ht => ⟨ t, ht.1.1, ht.2 ⟩;
        use t;
      exact h_dirichlet hε

/-
Given a finite set of frequencies γs and tolerance ε, we can find arbitrarily large x
such that cos(γ * log x) is close to 1 for all γ in γs simultaneously.
-/
lemma cos_alignment (γs : Finset ℝ) (ε : ℝ) (hε : ε > 0) (M : ℝ) :
    ∃ x > M, ∀ γ ∈ γs, |Real.cos (γ * Real.log x) - 1| < ε := by
  -- Phase alignment gives t > 0 with all phases near integers mod 2π
  -- Then x = exp(2πN/t) for large N gives the result
  sorry

end
