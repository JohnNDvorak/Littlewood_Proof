/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9bcd5d61-a059-4746-8b75-bf6b787885ff

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib
import Littlewood.Aristotle.DirichletApprox

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Given a finite set of real numbers γs and a tolerance ε, there exists a time t > 0 such that for all γ in γs, t*γ is close to an integer multiple of 2π.
-/
lemma align_phases (γs : Finset ℝ) (ε : ℝ) (hε : ε > 0) :
    ∃ t > 0, ∀ γ ∈ γs, ∃ k : ℤ, |t * γ / (2 * Real.pi) - k| < ε := by
      have h_dirichlet : ∀ {γs : Finset ℝ} {ε : ℝ}, ε > 0 → ∃ t > 0, ∀ γ ∈ γs, ∃ k : ℤ, |t * γ / (2 * Real.pi) - k| < ε := by
        intros γs ε hε_pos
        obtain ⟨t, ht_pos, ht_approx⟩ : ∃ t > 0, ∀ γ ∈ γs, ∃ (k : ℤ), |t * γ / (2 * Real.pi) - k| < ε := by
          have h_dirichlet : ∀ {γs : Finset ℝ} {ε : ℝ}, ε > 0 → ∃ t ∈ Set.Ioo 0 ε, ∀ γ ∈ γs, ∃ k : ℤ, |t * γ / (2 * Real.pi) - k| < ε := by
            intros γs ε hε_pos
            obtain ⟨t, ht⟩ : ∃ t ∈ Set.Ioo 0 ε, ∀ γ ∈ γs, |t * γ / (2 * Real.pi)| < ε := by
              obtain ⟨t, ht⟩ : ∃ t ∈ Set.Ioo 0 ε, ∀ γ ∈ γs, |t * γ| < ε * (2 * Real.pi) := by
                have h_bounded : ∃ M > 0, ∀ γ ∈ γs, |γ| ≤ M := by
                  exact ⟨ ∑ x ∈ γs, |x| + 1, add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => abs_nonneg _ ) zero_lt_one, fun x hx => by linarith [ Finset.single_le_sum ( fun x _ => abs_nonneg x ) hx ] ⟩
                obtain ⟨ M, hM_pos, hM ⟩ := h_bounded;
                exact ⟨ Min.min ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ) / 2, ⟨ by positivity, by linarith [ show 0 < Min.min ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ) by positivity, min_le_left ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ), min_le_right ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ) ] ⟩, fun γ hγ => by rw [ abs_lt ] ; constructor <;> nlinarith [ show 0 < Min.min ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ) by positivity, min_le_left ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ), min_le_right ε ( ε * ( 2 * Real.pi ) / ( M + 1 ) ), abs_le.mp ( hM γ hγ ), Real.pi_gt_three, mul_div_cancel₀ ( ε * ( 2 * Real.pi ) ) ( by positivity : ( M + 1 ) ≠ 0 ) ] ⟩;
              exact ⟨ t, ht.1, fun γ hγ => by rw [ abs_div, abs_of_nonneg ( by positivity : ( 0 : ℝ ) ≤ 2 * Real.pi ) ] ; rw [ div_lt_iff₀ ( by positivity ) ] ; linarith [ ht.2 γ hγ ] ⟩;
            exact ⟨ t, ht.1, fun γ hγ => ⟨ 0, by simpa using ht.2 γ hγ ⟩ ⟩
          exact Exists.elim ( h_dirichlet hε_pos ) fun t ht => ⟨ t, ht.1.1, ht.2 ⟩;
        use t;
      exact h_dirichlet hε

/-
Given a finite set of frequencies γs and tolerance ε, we can find arbitrarily large x
such that cos(γ * log x) is close to 1 for all γ in γs simultaneously.
-/
lemma cos_alignment (γs : Finset ℝ) (ε : ℝ) (hε : ε > 0) (M : ℝ) :
    ∃ x > M, ∀ γ ∈ γs, |Real.cos (γ * Real.log x) - 1| < ε := by
  -- Strategy: use double-angle formula cos(2θ) = 2cos²(θ) - 1
  -- If |cos(θ)| > 1 - δ, then cos²(θ) > (1-δ)², so
  -- cos(2θ) > 2(1-δ)² - 1 = 1 - 4δ + 2δ², hence |cos(2θ) - 1| < 4δ
  -- Apply oscillation_alignment with half-frequencies and δ = min(ε/4, 1/2)
  set δ := min (ε / 4) (1 / 2) with hδ_def
  have hδ_pos : 0 < δ := by positivity
  -- Convert Finset to indexed form
  set l := γs.toList with hl_def
  -- Apply oscillation_alignment with half-frequencies
  obtain ⟨x, hxM, hx_cos⟩ := oscillation_alignment l.length
    (fun i => l.get i / 2) δ hδ_pos M
  refine ⟨x, hxM, ?_⟩
  intro γ hγ
  -- Find the index of γ in l
  have hγl : γ ∈ l := Finset.mem_toList.mpr hγ
  obtain ⟨j, hj⟩ : ∃ j : Fin l.length, l.get j = γ := List.mem_iff_get.mp hγl
  -- From oscillation_alignment: |cos(γ/2 * log x)| > 1 - δ
  have hcos_half := hx_cos j
  simp only at hcos_half
  rw [hj] at hcos_half
  -- cos(γ * log x) = 2cos²(γ/2 * log x) - 1
  set θ := γ / 2 * Real.log x with hθ_def
  have h_double : γ * Real.log x = 2 * θ := by rw [hθ_def]; ring
  rw [h_double, Real.cos_two_mul]
  -- Now goal: |2 * cos(θ)² - 1 - 1| < ε, i.e., |2cos²(θ) - 2| < ε
  -- = 2|cos²(θ) - 1| = 2(1 - cos²(θ)) since cos²(θ) ≤ 1
  -- = 2(1 - cos(θ))(1 + cos(θ))
  -- Since |cos(θ)| > 1 - δ, we have cos²(θ) > (1-δ)²
  -- So 1 - cos²(θ) < 1 - (1-δ)² = 2δ - δ²
  -- Hence |2cos²(θ) - 2| = 2(1-cos²(θ)) < 2(2δ - δ²) = 4δ - 2δ² ≤ 4δ ≤ ε
  have hcos_sq : Real.cos θ ^ 2 > (1 - δ) ^ 2 := by
    -- |cos θ| > 1-δ ≥ 0, so cos²(θ) = |cos θ|² > (1-δ)²
    nlinarith [sq_abs (Real.cos θ), abs_nonneg (Real.cos θ),
               min_le_right (ε / 4) (1 / 2 : ℝ)]
  have h1 : (2 * Real.cos θ ^ 2 - 1) ≤ 1 := by nlinarith [Real.cos_sq_le_one θ]
  have h2 : (2 * Real.cos θ ^ 2 - 1) > 1 - ε := by nlinarith [min_le_left (ε / 4) (1 / 2 : ℝ)]
  rw [abs_lt]
  constructor <;> linarith

end
