/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 69e4a976-09ce-4c0e-b20e-e115db5285e7

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Xi function differentiability analysis.

KEY RESULTS:
- xi_Literal is NOT differentiable (discontinuous at s=1)
- xi_Corrected IS entire (using completedRiemannZeta₀)
- xi_Literal_eq_xi_Corrected: They agree for s ≠ 0, 1

IMPORTANT: This file explains WHY the naive product s(s-1)Λ(s) is not entire:
completedRiemannZeta takes a finite value at the pole s=1, so
xi_Literal(1) = 0, but lim_{s→1} xi_Literal(s) = 1.
The corrected version uses completedRiemannZeta₀ and adds +1 to fix this.

NOTE: We use xi_Literal instead of xi_Mathlib to avoid conflict with
ZeroCounting.lean which defines xi_Mathlib with a factor of 1/2.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of xi function using the raw product (without 1/2 factor).
This is the "literal" interpretation of s(s-1)Λ(s).
-/
noncomputable def xi_Literal (s : ℂ) := s * (s - 1) * completedRiemannZeta s

/-
The corrected xi function (using the smooth formula) is entire.
-/
noncomputable def xi_LiteralCorrected (s : ℂ) := s * (s - 1) * completedRiemannZeta₀ s + 1

theorem xi_LiteralCorrected_entire : Differentiable ℂ xi_LiteralCorrected := by
  -- The completed Riemann zeta function is entire, so its derivative is also entire.
  have h_completedRiemannZeta₀_diff : Differentiable ℂ completedRiemannZeta₀ := by
    exact?;
  exact Differentiable.add ( Differentiable.mul ( differentiable_id.mul ( differentiable_id.sub_const _ ) ) h_completedRiemannZeta₀_diff ) ( differentiable_const _ )

/-
xi_Literal agrees with xi_LiteralCorrected for s ≠ 0, 1.
-/
theorem xi_Literal_eq_xi_LiteralCorrected (s : ℂ) (h0 : s ≠ 0) (h1 : s ≠ 1) : xi_Literal s = xi_LiteralCorrected s := by
  -- Using the definition of completedRiemannZeta, we can expand xi_Literal.
  have h_expand : xi_Literal s = s * (s - 1) * (completedRiemannZeta₀ s - 1 / s - 1 / (1 - s)) := by
    convert congr_arg _ ( completedRiemannZeta_eq _ ) using 1;
  -- Simplify the expression to get rid of the extra terms.
  have h_simplify : s * (s - 1) * (completedRiemannZeta₀ s - 1 / s - 1 / (1 - s)) = s * (s - 1) * completedRiemannZeta₀ s + 1 := by
    grind;
  exact h_expand.trans h_simplify

/-
The value of xi_Literal at 1 is 0.
-/
theorem xi_Literal_value_one : xi_Literal 1 = 0 := by
  exact mul_eq_zero_of_left ( by norm_num ) _

/-
The value of xi_LiteralCorrected at 1 is 1.
-/
theorem xi_LiteralCorrected_one : xi_LiteralCorrected 1 = 1 := by
  -- By definition of xi_LiteralCorrected, we have xi_LiteralCorrected 1 = 1 * (1 - 1) * completedRiemannZeta₀ 1 + 1.
  simp [xi_LiteralCorrected]

/-
The limit of xi_Literal as s approaches 1 (excluding 1) is 1.
-/
theorem xi_Literal_tendsto_one : Filter.Tendsto xi_Literal (nhdsWithin 1 {1}ᶜ) (nhds 1) := by
  -- By definition of xi_LiteralCorrected, we know that it is continuous at 1.
  have h_cont : ContinuousAt xi_LiteralCorrected 1 := by
    exact ( xi_LiteralCorrected_entire.differentiableAt.continuousAt );
  -- Since xi_Literal and xi_LiteralCorrected are equal for all s ≠ 0, 1, their limits at 1 are the same.
  have h_eq : ∀ᶠ s in nhdsWithin 1 {1}ᶜ, xi_Literal s = xi_LiteralCorrected s := by
    refine' eventually_nhdsWithin_iff.mpr _;
    filter_upwards [ ( isOpen_ne.mem_nhds one_ne_zero ) ] with x hx hx' using xi_Literal_eq_xi_LiteralCorrected x hx hx' ▸ rfl;
  rw [ Filter.tendsto_congr' h_eq ] ; exact h_cont.mono_left inf_le_left |> fun h => h.trans ( by rw [ xi_LiteralCorrected_one ] ) ;

/-
xi_Literal is not continuous at 1.
-/
theorem xi_Literal_not_continuousAt_one : ¬ ContinuousAt xi_Literal 1 := by
  -- By contradiction, assume xi_Literal is continuous at 1.
  by_contra h_cont_at_one;
  -- Apply the fact that if the limit of a function at a point exists and is equal to the function value at that point, then the function is continuous at that point.
  have := tendsto_nhds_unique (xi_Literal_tendsto_one) (h_cont_at_one.mono_left inf_le_left);
  norm_num at this; (
  exact absurd this ( by rw [ xi_Literal_value_one ] ; norm_num ));

/-
xi_Literal is not differentiable (because it is not continuous at 1).
-/
theorem xi_Literal_not_differentiable : ¬ Differentiable ℂ xi_Literal := by
  exact fun h => xi_Literal_not_continuousAt_one <| h.continuous.continuousAt

end
