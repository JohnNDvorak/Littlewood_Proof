/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 27192048-9ee2-4b5b-90c3-27b620d61af6

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib
import Littlewood.Basic.ChebyshevFunctions

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the prime counting function π(x) for real arguments.
-/
noncomputable def primeCountingReal (x : ℝ) : ℝ :=
  Nat.primeCounting (Nat.floor x)

/-
Definition of the logarithmic integral function li(x).
-/
noncomputable def li (x : ℝ) : ℝ := ∫ t in (2 : ℝ)..x, 1 / Real.log t

/-
Definitions of oscillation predicates: IsOmegaPlus, IsOmegaMinus, and IsOmegaOscillation.
-/
def IsOmegaPlusFilter (f g : ℝ → ℝ) (l : Filter ℝ) : Prop :=
  Filter.limsup (fun x => f x / g x) l > 0

def IsOmegaMinusFilter (f g : ℝ → ℝ) (l : Filter ℝ) : Prop :=
  Filter.liminf (fun x => f x / g x) l < 0

def IsOmegaOscillationFilter (f g : ℝ → ℝ) (l : Filter ℝ) : Prop :=
  IsOmegaPlusFilter f g l ∧ IsOmegaMinusFilter f g l

/-
Definition of sumLambdaDivLog(x) as the sum of Λ(n)/log(n) for n ≤ x.
-/
noncomputable def sumLambdaDivLog (x : ℝ) : ℝ :=
  ∑ n ∈ Finset.range (Nat.floor x + 1), ArithmeticFunction.vonMangoldt n / Real.log n

/-
Helper: chebyshevPsi can be written as a sum over Finset.range.
This bridges between the Mathlib definition (using Ioc) and the range-based form.
-/
private lemma chebyshevPsi_eq_range_sum (t : ℝ) :
    chebyshevPsi t = ∑ n ∈ Finset.range (Nat.floor t + 1), ArithmeticFunction.vonMangoldt n := by
  unfold chebyshevPsi Chebyshev.psi
  conv_rhs => rw [← Finset.sum_filter_add_sum_filter_not (Finset.range (Nat.floor t + 1)) (· ∈ Finset.Ioc 0 (Nat.floor t))]
  have h1 : (Finset.range (Nat.floor t + 1)).filter (· ∈ Finset.Ioc 0 (Nat.floor t)) = Finset.Ioc 0 (Nat.floor t) := by
    ext n; simp only [Finset.mem_filter, Finset.mem_range, Finset.mem_Ioc]; omega
  rw [h1]
  suffices h : ∑ x ∈ (Finset.range (Nat.floor t + 1)).filter (fun x => x ∉ Finset.Ioc 0 (Nat.floor t)), ArithmeticFunction.vonMangoldt x = 0 by
    linarith
  apply Finset.sum_eq_zero
  intro n hn
  simp [Finset.mem_filter, Finset.mem_range, Finset.mem_Ioc] at hn
  have : n = 0 := by omega
  subst this
  exact ArithmeticFunction.vonMangoldt.map_zero'

/-
Partial summation identity relating sumLambdaDivLog(x) to ψ(x).
-/
lemma sumLambdaDivLog_eq_psi_div_log_add_integral (x : ℝ) (hx : x ≥ 2) :
    sumLambdaDivLog x = chebyshevPsi x / Real.log x + ∫ t in (2 : ℝ)..x, chebyshevPsi t / (t * Real.log t ^ 2) := by
      have h_integral : ∫ t in (2 : ℝ)..x, (chebyshevPsi t) / (t * (Real.log t)^2) = (∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n) / (Real.log n)) - (chebyshevPsi x) / (Real.log x) := by
        have h_psi : ∀ t ∈ Set.Icc (2 : ℝ) x, chebyshevPsi t = ∑ n ∈ Finset.range (Nat.floor t + 1), (ArithmeticFunction.vonMangoldt n) := by
          intro t ht
          exact chebyshevPsi_eq_range_sum t
        have h_integral_def : ∫ t in (2 : ℝ)..x, (chebyshevPsi t) / (t * (Real.log t)^2) = ∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n) * (∫ t in (2 : ℝ)..x, (if t ≥ n then 1 / (t * (Real.log t)^2) else 0)) := by
          have h_integral_def : ∫ t in (2 : ℝ)..x, (chebyshevPsi t) / (t * (Real.log t)^2) = ∫ t in (2 : ℝ)..x, (∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n) * (if t ≥ n then 1 / (t * (Real.log t)^2) else 0)) := by
            rw [ intervalIntegral.integral_of_le hx, intervalIntegral.integral_of_le hx ];
            refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun t ht => _;
            rw [ h_psi t ⟨ by linarith [ ht.1 ], by linarith [ ht.2 ] ⟩, Finset.sum_div _ _ _ ];
            rw [ ← Finset.sum_subset ( Finset.range_mono ( Nat.succ_le_succ ( Nat.floor_mono ht.2 ) ) ) ];
            · exact Finset.sum_congr rfl fun i hi => by rw [ if_pos ( Nat.floor_le ( by linarith [ ht.1 ] ) |> le_trans ( Nat.cast_le.mpr ( Finset.mem_range_succ_iff.mp hi ) ) ) ] ; ring;
            · intro n hn hn'; rw [ if_neg ] <;> norm_num;
              exact not_le.mp fun h => hn' <| Finset.mem_range.mpr <| Nat.lt_succ_of_le <| Nat.le_floor <| by linarith;
          rw [ h_integral_def, intervalIntegral.integral_finset_sum ];
          · norm_num [ intervalIntegral.integral_of_le hx ];
            exact Finset.sum_congr rfl fun _ _ => by rw [ ← MeasureTheory.integral_const_mul ] ; congr; ext; split_ifs <;> ring;
          · intro i hi;
            rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le hx ];
            refine' MeasureTheory.Integrable.mono' _ _ _;
            refine' fun t => |ArithmeticFunction.vonMangoldt i| * ( 1 / ( t * Real.log t ^ 2 ) );
            · exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.mul ( continuousAt_const ) <| ContinuousAt.div continuousAt_const ( ContinuousAt.mul continuousAt_id <| ContinuousAt.pow ( Real.continuousAt_log <| by linarith [ ht.1 ] ) _ ) <| ne_of_gt <| mul_pos ( by linarith [ ht.1 ] ) <| sq_pos_of_pos <| Real.log_pos <| by linarith [ ht.1 ] ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
            · exact Measurable.aestronglyMeasurable ( by exact Measurable.mul ( measurable_const ) ( Measurable.ite ( measurableSet_Ici ) ( measurable_one.div ( measurable_id'.mul ( Real.measurable_log.pow_const 2 ) ) ) measurable_const ) );
            · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht;
              split_ifs <;> norm_num;
              · rw [ abs_of_nonneg ( by linarith [ ht.1 ] : 0 ≤ t ) ];
              · exact mul_nonneg ( abs_nonneg _ ) ( mul_nonneg ( inv_nonneg.2 ( sq_nonneg _ ) ) ( inv_nonneg.2 ( by linarith [ ht.1 ] ) ) );
        have h_inner_integral : ∀ n ∈ Finset.range (Nat.floor x + 1), n ≥ 2 → ∫ t in (2 : ℝ)..x, (if t ≥ n then 1 / (t * (Real.log t)^2) else 0) = (1 / Real.log n) - (1 / Real.log x) := by
          intros n hn hn_ge_2
          have h_inner_integral_eval : ∫ t in (n : ℝ)..x, (1 / (t * (Real.log t)^2)) = (1 / Real.log n) - (1 / Real.log x) := by
            rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
            rotate_right;
            use fun t => -1 / Real.log t;
            · ring;
            · intro t ht; convert HasDerivAt.div ( hasDerivAt_const _ _ ) ( Real.hasDerivAt_log ( show t ≠ 0 by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) ) ( ne_of_gt <| Real.log_pos <| show t > 1 by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) using 1 ; ring;
            · apply_rules [ ContinuousOn.intervalIntegrable ];
              exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const ( ContinuousAt.mul continuousAt_id <| ContinuousAt.pow ( Real.continuousAt_log <| by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) _ ) <| ne_of_gt <| mul_pos ( by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) <| sq_pos_of_pos <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ;
          rw [ ← h_inner_integral_eval, intervalIntegral.integral_of_le ];
          · rw [ intervalIntegral.integral_of_le ( show ( n : ℝ ) ≤ x from le_trans ( Nat.cast_le.mpr ( Finset.mem_range_succ_iff.mp hn ) ) ( Nat.floor_le ( by positivity ) ) ), ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
            rw [ ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
            rw [ MeasureTheory.integral_congr_ae ];
            filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( n : ℝ ) ) ] with t ht;
            split_ifs <;> norm_num at *;
            · exact absurd ( ‹ ( n : ℝ ) < t → x < t › ( lt_of_le_of_ne ‹_› ( Ne.symm ht ) ) ) ( by linarith );
            · linarith;
            · linarith [ ‹2 < t → x < t› ( by linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) ];
          · linarith;
        have h_sum_inner_integral : ∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n) * (∫ t in (2 : ℝ)..x, (if t ≥ n then 1 / (t * (Real.log t)^2) else 0)) = ∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n) * (1 / Real.log n) - ∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n) * (1 / Real.log x) := by
          rw [ ← Finset.sum_sub_distrib ] ; refine' Finset.sum_congr rfl fun n hn => _ ; rcases n with ( _ | _ | n ) <;> simp_all +decide [ div_eq_mul_inv ] ;
          have := h_inner_integral ( n + 2 ) ( by linarith ) ( by linarith ) ; norm_num [ add_assoc ] at * ; rw [ this ] ; ring;
        simp_all +decide [ div_eq_mul_inv, Finset.sum_mul _ _ _ ];
      unfold sumLambdaDivLog; linarith;

/-
Identity relating sumLambdaDivLog - π(x) to the sum over prime powers.
-/
lemma sumLambdaDivLog_sub_primeCounting_eq_sum_prime_powers (x : ℝ) :
    sumLambdaDivLog x - primeCountingReal x = ∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n / Real.log n - (if Nat.Prime n then 1 else 0)) := by
      unfold sumLambdaDivLog primeCountingReal;
      simp +decide [ Finset.sum_sub_distrib, Nat.primeCounting ];
      rw [ Nat.primeCounting', Nat.count_eq_card_filter_range ]

/-
Definition of sumPrimePowers(x).
-/
noncomputable def sumPrimePowers (x : ℝ) : ℝ :=
  ∑ n ∈ Finset.range (Nat.floor x + 1), (ArithmeticFunction.vonMangoldt n / Real.log n - (if Nat.Prime n then 1 else 0))

/-
Decomposition of π(x) - li(x) into main terms and error terms.
-/
lemma pi_sub_li_decomposition (x : ℝ) (hx : x ≥ 2) :
    primeCountingReal x - li x =
    (chebyshevPsi x - x) / Real.log x
    - sumPrimePowers x
    + (∫ t in (2 : ℝ)..x, (chebyshevPsi t - t) / (t * Real.log t ^ 2))
    + (2 / Real.log 2) := by
      have h_T : primeCountingReal x = chebyshevPsi x / Real.log x - sumPrimePowers x + ∫ t in (2 : ℝ)..x, chebyshevPsi t / (t * (Real.log t) ^ 2) := by
        have h_T : sumLambdaDivLog x = chebyshevPsi x / Real.log x + ∫ t in (2 : ℝ)..x, chebyshevPsi t / (t * (Real.log t) ^ 2) := by
          exact sumLambdaDivLog_eq_psi_div_log_add_integral x hx
        have h_T : sumLambdaDivLog x - primeCountingReal x = sumPrimePowers x := by
          convert sumLambdaDivLog_sub_primeCounting_eq_sum_prime_powers x using 1;
        linarith;
      have h_li : li x = x / Real.log x - 2 / Real.log 2 + ∫ t in (2 : ℝ)..x, t / (t * (Real.log t) ^ 2) := by
        have h_li_integral : ∫ t in (2 : ℝ)..x, 1 / Real.log t = x / Real.log x - 2 / Real.log 2 + ∫ t in (2 : ℝ)..x, t / (t * (Real.log t) ^ 2) := by
          rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
          rotate_right;
          use fun t => t / Real.log t + ∫ u in ( 2 : ℝ )..t, u / ( u * Real.log u ^ 2 );
          · norm_num ; ring;
          · intro t ht;
            have h_ftc : HasDerivAt (fun t => ∫ u in (2 : ℝ)..t, u / (u * (Real.log u) ^ 2)) (t / (t * (Real.log t) ^ 2)) t := by
              apply_rules [ intervalIntegral.integral_hasDerivAt_right ];
              · apply_rules [ ContinuousOn.intervalIntegrable ];
                exact continuousOn_of_forall_continuousAt fun u hu => ContinuousAt.div continuousAt_id ( ContinuousAt.mul continuousAt_id <| ContinuousAt.pow ( Real.continuousAt_log <| by cases Set.mem_uIcc.mp hu <;> linarith [ Set.mem_Icc.mp <| by simpa [ hx ] using ht ] ) _ ) <| ne_of_gt <| mul_pos ( by cases Set.mem_uIcc.mp hu <;> linarith [ Set.mem_Icc.mp <| by simpa [ hx ] using ht ] ) <| sq_pos_of_pos <| Real.log_pos <| by cases Set.mem_uIcc.mp hu <;> linarith [ Set.mem_Icc.mp <| by simpa [ hx ] using ht ];
              · exact Measurable.stronglyMeasurable ( by exact Measurable.mul ( measurable_id' ) ( Measurable.inv ( measurable_id'.mul ( Real.measurable_log.pow_const 2 ) ) ) ) |> fun h => h.stronglyMeasurableAtFilter;
              · exact ContinuousAt.div continuousAt_id ( ContinuousAt.mul continuousAt_id <| ContinuousAt.pow ( Real.continuousAt_log <| by cases Set.mem_uIcc.mp ht <;> linarith ) _ ) <| ne_of_gt <| mul_pos ( by cases Set.mem_uIcc.mp ht <;> linarith ) <| sq_pos_of_pos <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> linarith;
            convert HasDerivAt.add ( HasDerivAt.div ( hasDerivAt_id t ) ( Real.hasDerivAt_log ( show t ≠ 0 by cases Set.mem_uIcc.mp ht <;> linarith ) ) ( ne_of_gt ( Real.log_pos ( show t > 1 by cases Set.mem_uIcc.mp ht <;> linarith ) ) ) ) h_ftc using 1 ; ring;
            simp only [id]; field_simp [ne_of_gt (Real.log_pos (show t > 1 by cases Set.mem_uIcc.mp ht <;> linarith)), show t ≠ 0 by cases Set.mem_uIcc.mp ht <;> linarith]; ring;
          · apply_rules [ ContinuousOn.intervalIntegrable ];
            exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp ht <;> linarith ) ) ( ne_of_gt ( Real.log_pos ( by cases Set.mem_uIcc.mp ht <;> linarith ) ) );
        convert h_li_integral using 1;
      simp_all +decide [ sub_div ];
      rw [ intervalIntegral.integral_sub ] <;> ring;
      · rw [ intervalIntegrable_iff_integrableOn_Ioc_of_le ( by linarith ) ];
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun t => ( ∑ n ∈ Finset.range ( Nat.floor x + 1 ), |ArithmeticFunction.vonMangoldt n| ) * t⁻¹ * ( Real.log t ) ⁻¹ ^ 2;
        · exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun t ht => by exact ContinuousAt.mul ( ContinuousAt.mul continuousAt_const ( ContinuousAt.inv₀ continuousAt_id ( by linarith [ ht.1 ] ) ) ) ( ContinuousAt.pow ( ContinuousAt.inv₀ ( Real.continuousAt_log ( by linarith [ ht.1 ] ) ) ( ne_of_gt ( Real.log_pos ( by linarith [ ht.1 ] ) ) ) ) 2 ) ) |> fun h => h.mono_set ( Set.Ioc_subset_Icc_self );
        · field_simp;
          refine' Measurable.aestronglyMeasurable _;
          refine' Measurable.mul _ _;
          · refine' measurable_of_tendsto_metrizable _ _;
            use fun n t => ∑ i ∈ Finset.range ( Nat.floor t + 1 ), ArithmeticFunction.vonMangoldt i * ( if i ≤ n then 1 else 0 );
            · intro i;
              have h_floor_measurable : Measurable (fun t : ℝ => Nat.floor t) := by
                exact measurable_id.nat_floor;
              have h_sum_measurable : Measurable (fun n : ℕ => ∑ i_1 ∈ Finset.range (n + 1), (ArithmeticFunction.vonMangoldt : ℕ → ℝ) i_1 * if i_1 ≤ i then 1 else 0) := by
                exact measurable_from_nat
              exact h_sum_measurable.comp h_floor_measurable;
            · refine' tendsto_pi_nhds.mpr _;
              intro x; refine' tendsto_const_nhds.congr' _; filter_upwards [ Filter.eventually_gt_atTop ( ⌊x⌋₊ ) ] with i hi; rw [ Finset.sum_congr rfl fun j hj => by rw [ if_pos ( by linarith [ Finset.mem_range.mp hj ] ) ] ] ; simp [chebyshevPsi_eq_range_sum];
          · exact Measurable.inv ( measurable_id.mul ( Measurable.pow_const ( Real.measurable_log ) _ ) );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht;
          rw [chebyshevPsi_eq_range_sum]; norm_num;
          gcongr;
          · exact le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.range_mono ( Nat.succ_le_succ ( Nat.floor_mono ht.2 ) ) ) fun _ _ _ => abs_nonneg _ );
          · linarith [ ht.1 ];
          · exact le_abs_self _;
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        exact ContinuousOn.mul ( ContinuousOn.mul continuousOn_id ( ContinuousOn.inv₀ continuousOn_id fun t ht => by cases Set.mem_uIcc.mp ht <;> linarith ) ) ( ContinuousOn.pow ( ContinuousOn.inv₀ ( Real.continuousOn_log.mono <| by intro t ht ; cases Set.mem_uIcc.mp ht <;> norm_num <;> linarith ) fun t ht => ne_of_gt <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> linarith ) _ )

/-
The key theorem: oscillation of ψ(x) - x implies oscillation of π(x) - li(x).

This follows from the decomposition:
  π(x) - li(x) = (ψ(x) - x)/log(x) - T(x) + ∫₂ˣ (ψ(t) - t)/(t log²t) dt + 2/log(2)

Since T(x) = O(x^{1/2}/log(x)) and the integral term is dominated by the main term,
if ψ(x) - x oscillates with amplitude Ω(x^{1/2}), then π(x) - li(x) oscillates too.
-/
theorem psi_oscillation_implies_pi_li_oscillation
    (h_psi_pos : ∀ M : ℝ, ∃ x > M, chebyshevPsi x - x > 0)
    (h_psi_neg : ∀ M : ℝ, ∃ x > M, chebyshevPsi x - x < 0) :
    (∀ M : ℝ, ∃ x > M, primeCountingReal x - li x > 0) ∧
    (∀ M : ℝ, ∃ x > M, primeCountingReal x - li x < 0) := by
  -- The decomposition shows that the dominant term is (ψ(x) - x)/log(x)
  -- When ψ(x) - x is large positive/negative, so is π(x) - li(x)
  -- The error terms T(x) and the integral are smaller order
  constructor
  · intro M
    -- Get x where ψ(x) - x is large and positive
    obtain ⟨x, hx_large, hx_pos⟩ := h_psi_pos (max M 2)
    -- For large enough x, the main term dominates
    sorry
  · intro M
    obtain ⟨x, hx_large, hx_neg⟩ := h_psi_neg (max M 2)
    sorry

end
