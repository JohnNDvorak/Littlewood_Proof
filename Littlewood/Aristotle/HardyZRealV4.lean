/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 5a40644b-8341-4b82-8b0e-53cebebfe968

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

KEY RESULTS:
- gamma_duplication_hardyV4: Γ(1/4+it/2)Γ(3/4+it/2) = Γ(1/2+it)·2^(1/2-it)·√π
- gamma_reflection_hardyV4: Γ(1/4-it/2)Γ(3/4+it/2) = π/sin(π(1/4-it/2))
- hardyZV4_real: Im(Z(t)) = 0

Relies on HardyZReal.lean for:
- riemannZeta_conj (ζ conjugation)
- completedRiemannZeta_real_on_critical_line
-/

import Mathlib
import Littlewood.Aristotle.HardyZReal

set_option linter.mathlibStandardSet false

open scoped BigOperators Real Nat Classical Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-! ## Definitions -/

noncomputable def hardyThetaV4 (t : ℝ) : ℝ :=
  Complex.arg (Complex.Gamma (1/4 + Complex.I * t / 2)) - (t / 2) * Real.log Real.pi

noncomputable def hardyZV4 (t : ℝ) : ℂ :=
  Complex.exp (Complex.I * hardyThetaV4 t) * riemannZeta (1/2 + Complex.I * t)

/-! ## Gamma Function Identities -/

/-- Legendre duplication formula at Hardy Z arguments. -/
theorem gamma_duplication_hardyV4 (t : ℝ) :
    Complex.Gamma (1/4 + Complex.I * t / 2) * Complex.Gamma (3/4 + Complex.I * t / 2) =
    Complex.Gamma (1/2 + Complex.I * t) * (2 : ℂ) ^ (1/2 - Complex.I * t) * Real.sqrt Real.pi := by
  have h := Complex.Gamma_mul_Gamma_add_half (1/4 + Complex.I * (t : ℂ) / 2)
  rw [show (1/4 : ℂ) + Complex.I * ↑t / 2 + 1/2 = 3/4 + Complex.I * ↑t / 2 from by ring] at h
  rw [show 2 * ((1/4 : ℂ) + Complex.I * ↑t / 2) = 1/2 + Complex.I * ↑t from by ring] at h
  rw [show (1 : ℂ) - (1/2 + Complex.I * ↑t) = 1/2 - Complex.I * ↑t from by ring] at h
  exact h

/-- Reflection formula at Hardy Z arguments. -/
theorem gamma_reflection_hardyV4 (t : ℝ) :
    Complex.Gamma (1/4 - Complex.I * t / 2) * Complex.Gamma (3/4 + Complex.I * t / 2) =
    Real.pi / Complex.sin (Real.pi * (1/4 - Complex.I * t / 2)) := by
  convert Complex.Gamma_mul_Gamma_one_sub _ using 2; ring

/-! ## Hardy Z is Real-Valued

The proof follows the same strategy as hardyZ'_real in HardyZReal.lean:
Z(t) = completedRiemannZeta(s) / ‖Gammaℝ(s)‖ where s = 1/2 + it.
completedRiemannZeta is real on the critical line, so Z(t) is real. -/

theorem hardyZV4_real (t : ℝ) : (hardyZV4 t).im = 0 := by
  set s : ℂ := 1/2 + Complex.I * ↑t with hs_def
  set w : ℂ := 1/4 + Complex.I * ↑t / 2 with hw_def
  -- Basic facts
  have hw_eq : s / 2 = w := by simp only [hs_def, hw_def]; push_cast; ring
  have hs_re : s.re = 1/2 := by
    simp only [hs_def, Complex.add_re, Complex.mul_re, Complex.I_re, Complex.I_im,
                Complex.ofReal_re, Complex.ofReal_im]; norm_num
  have hs_ne : s ≠ 0 := by
    intro h; rw [h, Complex.zero_re] at hs_re; norm_num at hs_re
  have hs_re_pos : 0 < s.re := by rw [hs_re]; norm_num
  have hw_re_pos : 0 < w.re := by
    simp only [hw_def, Complex.add_re, Complex.mul_re, Complex.I_re, Complex.I_im,
                Complex.ofReal_re, Complex.ofReal_im]; norm_num
  have hπ_pos : (0 : ℝ) < Real.pi := Real.pi_pos
  have hπ_ne : (↑Real.pi : ℂ) ≠ 0 := Complex.ofReal_ne_zero.mpr (ne_of_gt hπ_pos)
  have hΓw_ne : Complex.Gamma w ≠ 0 := Complex.Gamma_ne_zero_of_re_pos hw_re_pos
  have hΓ_ne : Complex.Gammaℝ s ≠ 0 := Complex.Gammaℝ_ne_zero_of_re_pos hs_re_pos
  have h_norm_w_ne : (↑‖Complex.Gamma w‖ : ℂ) ≠ 0 :=
    Complex.ofReal_ne_zero.mpr (norm_ne_zero_iff.mpr hΓw_ne)
  have hπ_cpow_ne : (↑Real.pi : ℂ) ^ (-s / 2) ≠ 0 := by
    intro h; rw [Complex.cpow_eq_zero_iff] at h; exact hπ_ne h.1
  have h_norm_π_ne : (↑‖(↑Real.pi : ℂ) ^ (-s / 2)‖ : ℂ) ≠ 0 :=
    Complex.ofReal_ne_zero.mpr (norm_ne_zero_iff.mpr hπ_cpow_ne)
  -- Step 1: Suffices to show Z(t) = Λ(s) / ↑‖Gammaℝ s‖
  suffices h_eq : hardyZV4 t = completedRiemannZeta s / ↑‖Complex.Gammaℝ s‖ by
    rw [h_eq, hs_def, Complex.div_ofReal_im,
        completedRiemannZeta_real_on_critical_line t, zero_div]
  -- Step 2: Unfold Z(t) = exp(I*θ(t)) * ζ(s) and use ζ(s) = Λ(s)/Gammaℝ(s)
  unfold hardyZV4
  change Complex.exp (Complex.I * ↑(hardyThetaV4 t)) * riemannZeta s =
    completedRiemannZeta s / ↑‖Complex.Gammaℝ s‖
  rw [riemannZeta_def_of_ne_zero hs_ne]
  -- Key: exp(I*θ(t)) = Gammaℝ(s)/↑‖Gammaℝ(s)‖
  suffices h_phase : Complex.exp (Complex.I * ↑(hardyThetaV4 t)) =
      Complex.Gammaℝ s / ↑‖Complex.Gammaℝ s‖ by
    rw [h_phase]; field_simp
  -- Step 3: Prove the phase identity
  unfold hardyThetaV4
  change Complex.exp (Complex.I * ↑(Complex.arg (Complex.Gamma w) - t / 2 * Real.log Real.pi)) =
    Complex.Gammaℝ s / ↑‖Complex.Gammaℝ s‖
  rw [show Complex.I * ↑(Complex.arg (Complex.Gamma w) - t / 2 * Real.log Real.pi) =
    Complex.I * ↑(Complex.arg (Complex.Gamma w)) +
    (-(Complex.I * ↑(t / 2 * Real.log Real.pi))) from by push_cast; ring]
  rw [Complex.exp_add]
  -- Sub-step 3a: exp(I*arg(Γ(w))) = Γ(w) / ↑‖Γ(w)‖
  have h_gamma_phase : Complex.exp (Complex.I * ↑(Complex.arg (Complex.Gamma w))) =
      Complex.Gamma w / ↑‖Complex.Gamma w‖ := by
    rw [eq_div_iff h_norm_w_ne, mul_comm]
    have := Complex.norm_mul_exp_arg_mul_I (Complex.Gamma w)
    rwa [show ↑(Complex.arg (Complex.Gamma w)) * Complex.I =
      Complex.I * ↑(Complex.arg (Complex.Gamma w)) from mul_comm _ _] at this
  -- Sub-step 3b: exp(-I*(t/2)*log(π)) = (↑π)^(-s/2) / ↑‖(↑π)^(-s/2)‖
  have h_cpow : (↑Real.pi : ℂ) ^ (-s / 2) =
      Complex.exp (↑(-Real.log Real.pi / 4 : ℝ)) *
      Complex.exp (-(Complex.I * ↑(t / 2 * Real.log Real.pi))) := by
    rw [Complex.cpow_def_of_ne_zero hπ_ne, ← Complex.ofReal_log (le_of_lt hπ_pos)]
    rw [show ↑(Real.log Real.pi) * (-s / 2) =
      ↑(-Real.log Real.pi / 4 : ℝ) + (-(Complex.I * ↑(t / 2 * Real.log Real.pi))) from by
      simp only [hs_def]; push_cast; ring]
    exact Complex.exp_add _ _
  have h_norm_pi : (↑‖(↑Real.pi : ℂ) ^ (-s / 2)‖ : ℂ) =
      Complex.exp (↑(-Real.log Real.pi / 4 : ℝ)) := by
    rw [Complex.norm_cpow_eq_rpow_re_of_pos hπ_pos, Real.rpow_def_of_pos hπ_pos,
        Complex.ofReal_exp]
    congr 1; push_cast
    have hre : (-s / 2).re = -1/4 := by
      simp only [hs_def, Complex.neg_re, Complex.add_re, Complex.mul_re,
                  Complex.I_re, Complex.I_im, Complex.ofReal_re, Complex.ofReal_im,
                  Complex.div_ofReal_re]
      norm_num
    rw [hre]; push_cast; ring
  have h_pi_phase : Complex.exp (-(Complex.I * ↑(t / 2 * Real.log Real.pi))) =
      (↑Real.pi : ℂ) ^ (-s / 2) / ↑‖(↑Real.pi : ℂ) ^ (-s / 2)‖ := by
    rw [eq_div_iff h_norm_π_ne, h_norm_pi, h_cpow, mul_comm]
  -- Sub-step 3c: Combine to get Gammaℝ(s)/↑‖Gammaℝ(s)‖
  rw [h_gamma_phase, h_pi_phase]
  have h_GammaR : Complex.Gammaℝ s = (↑Real.pi : ℂ) ^ (-s / 2) * Complex.Gamma w := by
    rw [Complex.Gammaℝ_def, hw_eq]
  rw [h_GammaR, norm_mul, Complex.ofReal_mul]
  field_simp

end
