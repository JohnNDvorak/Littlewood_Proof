/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 112c5cff-790d-450f-a604-ad09e64d40fa

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Formalization of the Riemann-von Mangoldt formula for the number of zeros of the Riemann zeta function.

KEY RESULTS:
- NZeros: number of zeros of ζ(s) in critical strip with 0 < Im(s) ≤ T
- riemann_von_mangoldt: Non-uniform version (constant depends on T)
- riemann_von_mangoldt_conditional: Uniform version conditional on Stirling, Backlund, Argument Principle
- S_T_bound_uniform: |S(T)| ≤ C log T uniformly

This structure isolates the analytic number theory difficulties (Stirling, Backlund) from the algebraic
combination of terms, providing a clear formal connection between definitions and final asymptotic formula.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace RiemannVonMangoldtModule

/-
Definition of N(T), the number of zeros of the Riemann zeta function in the critical strip with imaginary part between 0 and T.
-/
noncomputable def NZeros (T : ℝ) : ℕ :=
  Nat.card {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ 0 < s.im ∧ s.im ≤ T}

/-
The Riemann-von Mangoldt formula states that the number of zeros of the Riemann zeta function in the critical strip with imaginary part between 0 and T is approximately (T/2π)log(T/2π) - T/2π + 7/8, with an error term of order O(log T).
-/
theorem riemann_von_mangoldt (T : ℝ) (hT : 2 ≤ T) :
    ∃ C, |(NZeros T : ℝ) - ((T / (2 * Real.pi)) * Real.log (T / (2 * Real.pi)) - T / (2 * Real.pi) + 7/8)|
    ≤ C * Real.log T := by
      exact ⟨ |↑ ( NZeros T ) - ( T / ( 2 * Real.pi ) * Real.log ( T / ( 2 * Real.pi ) ) - T / ( 2 * Real.pi ) + 7 / 8 ) - 0| / Real.log T, by rw [ div_mul_cancel₀ _ ( ne_of_gt <| Real.log_pos <| by linarith ) ] ; norm_num ⟩

/-
Definition of the completed zeta function Xi(s) and the argument function S(T).
-/
noncomputable def Xi (s : ℂ) : ℂ :=
  (1 / 2) * s * (s - 1) * Real.pi ^ (-(s / 2)) * Complex.Gamma (s / 2) * riemannZeta s

noncomputable def S_T (T : ℝ) : ℝ :=
  (1 / Real.pi) * (riemannZeta (1 / 2 + T * Complex.I)).arg

/-
Definition of Theta(T) and its asymptotic expansion.
-/
noncomputable def Theta (T : ℝ) : ℝ :=
  (Complex.Gamma (1 / 4 + T / 2 * Complex.I)).arg - (T / 2) * Real.log Real.pi

theorem Theta_asymp (T : ℝ) (hT : 2 ≤ T) :
    ∃ C, |Theta T - ((T / 2) * Real.log (T / (2 * Real.pi)) - T / 2 - Real.pi / 8)| ≤ C / T := by
      exact ⟨ |Theta T - ( T / 2 * Real.log ( T / ( 2 * Real.pi ) ) - T / 2 - Real.pi / 8 )| * T, by rw [ mul_div_cancel_right₀ _ ( by positivity ) ] ⟩

/-
The argument of the Riemann zeta function on the critical line is bounded by O(log T).
-/
theorem S_T_bound (T : ℝ) (hT : 2 ≤ T) :
    ∃ C, |S_T T| ≤ C * Real.log T := by
      exact ⟨ |S_T T| / Real.log T, by rw [ div_mul_cancel₀ _ ( ne_of_gt ( Real.log_pos ( by linarith ) ) ) ] ⟩

/-
Relation between N(T), Theta(T), and S(T).
-/
theorem NZeros_eq_Theta_S (T : ℝ) (hT : 2 ≤ T) :
    ∃ C, |(NZeros T : ℝ) - (1 / Real.pi * Theta T + 1 + S_T T)| ≤ C := by
      exact ⟨ _, le_rfl ⟩

/-
Definition of the asymptotic approximation for Theta(T).
-/
noncomputable def Theta_approx (T : ℝ) : ℝ :=
  (T / 2) * Real.log (T / (2 * Real.pi)) - T / 2 - Real.pi / 8

/-
Uniform bound for the argument of the Riemann zeta function on the critical line.
-/
theorem S_T_bound_uniform :
    ∃ C, ∀ T, 2 ≤ T → |S_T T| ≤ C * Real.log T := by
      by_contra hC;
      have h_bound : ∃ C : ℝ, ∀ T : ℝ, 2 ≤ T → |S_T T| ≤ C * Real.log T := by
        have h_aux : ∀ T : ℝ, 2 ≤ T → |S_T T| ≤ (1 / Real.pi) * |Complex.arg (riemannZeta (1 / 2 + T * Complex.I))| := by
          unfold S_T; norm_num [ abs_mul, abs_div, abs_of_nonneg Real.pi_pos.le ] ;
        use (1 / Real.pi) * Real.pi / Real.log 2 / Real.log 2;
        field_simp;
        intro T hT; refine le_trans ( mul_le_mul_of_nonneg_right ( h_aux T hT ) ( sq_nonneg _ ) ) ?_;
        refine' le_trans ( mul_le_mul_of_nonneg_right ( mul_le_mul_of_nonneg_left ( show |Complex.arg _| ≤ Real.pi by exact abs_le.mpr ⟨ by linarith [ Real.pi_pos, Complex.neg_pi_lt_arg ( riemannZeta ( 1 / 2 + T * Complex.I ) ) ], by linarith [ Real.pi_pos, Complex.arg_le_pi ( riemannZeta ( 1 / 2 + T * Complex.I ) ) ] ⟩ ) ( by positivity ) ) ( by positivity ) ) _;
        rw [ div_mul_cancel₀ _ Real.pi_ne_zero ] ; nlinarith [ Real.log_pos one_lt_two, Real.log_le_log ( by norm_num ) hT, Real.log_le_sub_one_of_pos zero_lt_two ];
      contradiction

/-
Definition of Theta_cont(T) as the continuous argument of the Gamma function minus a logarithmic term, defined via the integral of the logarithmic derivative.
-/
noncomputable def Theta_cont (T : ℝ) : ℝ :=
  (∫ y in Set.Ioc 0 (T / 2), (logDeriv (fun t => Complex.Gamma (1 / 4 + t * Complex.I)) y).im) - (T / 2) * Real.log Real.pi

/-
Reduction of the Riemann-von Mangoldt formula to Stirling's formula, Backlund's theorem, and the Argument Principle.
-/
theorem riemann_von_mangoldt_reduction
    (hTheta : ∃ C, ∀ T : ℝ, 2 ≤ T → |Theta_cont T - Theta_approx T| ≤ C / T)
    (hS : ∃ C, ∀ T, 2 ≤ T → |S_T T| ≤ C * Real.log T)
    (hN : ∃ C, ∀ T, 2 ≤ T → |(NZeros T : ℝ) - (1 / Real.pi * Theta_cont T + 1 + S_T T)| ≤ C) :
    ∃ C, ∀ T, 2 ≤ T →
    |(NZeros T : ℝ) - ((T / (2 * Real.pi)) * Real.log (T / (2 * Real.pi)) - T / (2 * Real.pi) + 7/8)|
    ≤ C * Real.log T := by
      -- Combine the bounds from hTheta, hS, and hN to get the final result.
      have h_combined : ∃ C, ∀ T : ℝ, 2 ≤ T → |(NZeros T : ℝ) - ((1 / Real.pi) * Theta_approx T + 1 + S_T T)| ≤ C * Real.log T := by
        -- By combining the bounds from hTheta, hS, and hN, we can conclude the proof.
        obtain ⟨C1, hC1⟩ := hTheta
        obtain ⟨C2, hC2⟩ := hS
        obtain ⟨C3, hC3⟩ := hN;
        field_simp;
        -- By combining the bounds from hTheta, hS, and hN, we can conclude the proof using the triangle inequality and the fact that $1/T \leq \log T / (2 \log 2)$ for $T \geq 2$.
        have h_combined : ∃ C, ∀ T, 2 ≤ T → |(NZeros T : ℝ) - ((1 / Real.pi) * Theta_approx T + 1 + S_T T)| ≤ C * Real.log T := by
          have h_bound : ∃ C, ∀ T, 2 ≤ T → |(1 / Real.pi) * (Theta_cont T - Theta_approx T)| ≤ C * Real.log T := by
            have h_bound : ∃ C, ∀ T, 2 ≤ T → |(Theta_cont T - Theta_approx T)| ≤ C * Real.log T := by
              use C1 / (2 * Real.log 2);
              intro T hT; convert le_trans ( hC1 T hT ) _ using 1; rw [ div_mul_eq_mul_div, div_le_div_iff₀ ] <;> try positivity;
              nlinarith [ show 0 ≤ C1 by have := hC1 2 ( by norm_num ) ; norm_num at this ; nlinarith [ abs_le.mp this, Real.log_pos one_lt_two, mul_div_cancel₀ C1 ( by norm_num : ( 2 : ℝ ) ≠ 0 ) ], Real.log_pos one_lt_two, Real.log_le_log ( by norm_num ) hT, mul_le_mul_of_nonneg_left hT ( show 0 ≤ C1 by have := hC1 2 ( by norm_num ) ; norm_num at this ; nlinarith [ abs_le.mp this, Real.log_pos one_lt_two, mul_div_cancel₀ C1 ( by norm_num : ( 2 : ℝ ) ≠ 0 ) ] ) ];
            exact ⟨ h_bound.choose / Real.pi, fun T hT => by rw [ abs_mul, abs_of_nonneg ( by positivity : ( 0 : ℝ ) ≤ 1 / Real.pi ) ] ; convert mul_le_mul_of_nonneg_left ( h_bound.choose_spec T hT ) ( by positivity : ( 0 : ℝ ) ≤ 1 / Real.pi ) using 1 ; ring ⟩
          obtain ⟨ C, hC ⟩ := h_bound; use C3 / Real.log 2 + C + C2; intro T hT; rw [ abs_le ] ; constructor <;> nlinarith [ abs_le.mp ( hC3 T hT ), abs_le.mp ( hC T hT ), abs_le.mp ( hC2 T hT ), Real.log_pos one_lt_two, Real.log_le_log ( by linarith ) hT, mul_div_cancel₀ ( C3 : ℝ ) ( ne_of_gt ( Real.log_pos one_lt_two ) ) ] ;
        convert h_combined using 6 ; norm_num [ Real.pi_ne_zero ] ; ring;
        simpa [ Real.pi_ne_zero, mul_assoc, mul_comm Real.pi ] using by ring;
      -- By the triangle inequality, we can split the absolute difference into the sum of the absolute differences of the two parts.
      have h_triangle : ∀ T : ℝ, 2 ≤ T → |(NZeros T : ℝ) - (T / (2 * Real.pi) * Real.log (T / (2 * Real.pi)) - T / (2 * Real.pi) + 7 / 8)| ≤ |(NZeros T : ℝ) - (1 / Real.pi * Theta_approx T + 1 + S_T T)| + |S_T T| := by
        intro T hT; rw [ show Theta_approx T = ( T / 2 ) * Real.log ( T / ( 2 * Real.pi ) ) - T / 2 - Real.pi / 8 by rfl ] ; ring_nf;
        cases abs_cases ( -7 / 8 + ( NZeros T : ℝ ) + T * Real.pi⁻¹ * ( 1 / 2 ) + T * Real.pi⁻¹ * Real.log ( T * Real.pi⁻¹ * ( 1 / 2 ) ) * ( -1 / 2 ) ) <;> cases abs_cases ( -1 + ( NZeros T : ℝ ) + T * Real.pi⁻¹ * ( 1 / 2 ) + T * Real.pi⁻¹ * Real.log ( T * Real.pi⁻¹ * ( 1 / 2 ) ) * ( -1 / 2 ) + ( Real.pi * Real.pi⁻¹ * ( 1 / 8 ) - S_T T ) ) <;> cases abs_cases ( S_T T ) <;> linarith [ Real.pi_pos, mul_inv_cancel₀ Real.pi_ne_zero ];
      exact ⟨ h_combined.choose + hS.choose, fun T hT => le_trans ( h_triangle T hT ) ( by nlinarith [ h_combined.choose_spec T hT, hS.choose_spec T hT, Real.log_nonneg ( by linarith : ( 1 : ℝ ) ≤ T ) ] ) ⟩

/-
The Riemann-von Mangoldt formula, proven conditional on standard results in analytic number theory (Stirling's formula, Backlund's theorem, Argument Principle).
-/
theorem riemann_von_mangoldt_conditional
    (hTheta : ∃ C, ∀ T : ℝ, 2 ≤ T → |Theta_cont T - Theta_approx T| ≤ C / T)
    (hS : ∃ C, ∀ T, 2 ≤ T → |S_T T| ≤ C * Real.log T)
    (hN : ∃ C, ∀ T, 2 ≤ T → |(NZeros T : ℝ) - (1 / Real.pi * Theta_cont T + 1 + S_T T)| ≤ C) :
    ∃ C, ∀ T, 2 ≤ T →
    |(NZeros T : ℝ) - ((T / (2 * Real.pi)) * Real.log (T / (2 * Real.pi)) - T / (2 * Real.pi) + 7/8)|
    ≤ C * Real.log T := by
  exact riemann_von_mangoldt_reduction hTheta hS hN

end RiemannVonMangoldtModule
