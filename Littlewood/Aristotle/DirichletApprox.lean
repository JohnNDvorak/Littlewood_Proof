/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 6f02ef10-105e-463b-a6f3-849c6eb1d7da

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We proved Dirichlet's simultaneous approximation theorem and its corollary regarding the simultaneous large values of oscillating terms `cos(γ_j log x)`.

The main theorem `dirichlet_simultaneous_approximation` states that for any `N ≥ 1` and real numbers `α₁, ..., α_n`, there exists an integer `q` with `1 ≤ q ≤ N^n` such that `|q α_j - round(q α_j)| < 1/N` for all `j`. This was proven using the pigeonhole principle on the fractional parts of `q α_j`.

The corollary `oscillation_alignment` shows that for any frequencies `γ₁, ..., γ_n` and `ε > 0`, there exist arbitrarily large `x` such that `cos(γ_j log x) > 1 - ε` for all `j`. This follows from the approximation theorem by aligning the phases `γ_j log x` close to multiples of `2π`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Given `N^n + 1` points in `[0, 1)^n`, two of them must be within distance `1/N` in each coordinate (conceptually, they fall in the same `1/N`-sized box).
-/
lemma exists_approx_pair (n N : ℕ) (hN : 0 < N) (f : Fin (N ^ n + 1) → Fin n → ℝ)
    (hf : ∀ q j, 0 ≤ f q j ∧ f q j < 1) :
    ∃ q₁ q₂, q₁ ≠ q₂ ∧ ∀ j, |f q₁ j - f q₂ j| < 1 / (N : ℝ) := by
      set g : (Fin (N ^ n + 1)) → (Fin n → Fin N) := fun q j => ⟨⌊N * (f q j)⌋₊, by
        rw [ Nat.floor_lt ] <;> nlinarith [ hf q j, show ( N : ℝ ) ≥ 1 by norm_cast ]⟩
      generalize_proofs at *;
      field_simp;
      obtain ⟨q₁, q₂, hne, h_eq⟩ : ∃ q₁ q₂ : (Fin (N ^ n + 1)), q₁ ≠ q₂ ∧ g q₁ = g q₂ := by
        by_contra! h;
        exact absurd ( Fintype.card_le_of_injective g fun x y hxy => not_imp_not.mp ( h x y ) hxy ) ( by norm_num );
      use q₁, q₂, hne; intro j; rw [ mul_comm ] ; simp_all +decide [ funext_iff, Fin.ext_iff ] ;
      cases abs_cases ( f q₁ j - f q₂ j ) <;> nlinarith [ Nat.floor_le ( show ( N : ℝ ) * f q₁ j ≥ 0 by exact mul_nonneg ( Nat.cast_nonneg _ ) ( hf q₁ j |>.1 ) ), Nat.lt_floor_add_one ( ( N : ℝ ) * f q₁ j ), Nat.floor_le ( show ( N : ℝ ) * f q₂ j ≥ 0 by exact mul_nonneg ( Nat.cast_nonneg _ ) ( hf q₂ j |>.1 ) ), Nat.lt_floor_add_one ( ( N : ℝ ) * f q₂ j ), show ( ⌊ ( N : ℝ ) * f q₁ j⌋₊ : ℝ ) = ⌊ ( N : ℝ ) * f q₂ j⌋₊ by exact mod_cast h_eq j ]

/-
Dirichlet's simultaneous approximation theorem: Given real numbers α₁, ..., α_n and N ≥ 1, there exists an integer q with 1 ≤ q ≤ N^n such that |q·α_j - round(q·α_j)| < 1/N for all j.
-/
theorem dirichlet_simultaneous_approximation (n : ℕ) (α : Fin n → ℝ) (N : ℕ) (hN : 0 < N) :
    ∃ q : ℕ, 1 ≤ q ∧ q ≤ N ^ n ∧ ∀ j, |(q : ℝ) * α j - round ((q : ℝ) * α j)| < 1 / (N : ℝ) := by
      let f := fun q : ℕ => fun j => Int.fract (q * α j);
      obtain ⟨q₁, q₂, hq₁q₂, hf⟩ : ∃ q₁ q₂ : ℕ, q₁ ≠ q₂ ∧ 0 ≤ q₁ ∧ q₁ ≤ N^n ∧ 0 ≤ q₂ ∧ q₂ ≤ N^n ∧ ∀ j : Fin n, |f q₁ j - f q₂ j| < 1 / N := by
        set f' : Fin (N^n + 1) → Fin n → ℝ := fun q j => Int.fract ((q : ℕ) * α j);
        obtain ⟨q₁, q₂, hq₁q₂, hf'⟩ : ∃ q₁ q₂ : Fin (N^n + 1), q₁ ≠ q₂ ∧ ∀ j : Fin n, |f' q₁ j - f' q₂ j| < 1 / N := by
          convert exists_approx_pair n N hN f' _ using 1;
          exact fun q j => ⟨ Int.fract_nonneg _, Int.fract_lt_one _ ⟩;
        exact ⟨ q₁, q₂, by simpa [ Fin.ext_iff ] using hq₁q₂, Nat.zero_le _, Fin.is_le _, Nat.zero_le _, Fin.is_le _, fun j => by have := hf' j; rw [ lt_div_iff₀ ( by positivity ) ] at this; aesop ⟩;
      wlog hq₁q₂_gt : q₁ > q₂ generalizing q₁ q₂;
      · convert this q₂ q₁ ( Ne.symm hq₁q₂ ) ⟨ hf.2.2.1, hf.2.2.2.1, hf.1, hf.2.1, fun j => by simpa only [ abs_sub_comm ] using hf.2.2.2.2 j ⟩ ( lt_of_le_of_ne ( le_of_not_gt hq₁q₂_gt ) hq₁q₂ ) using 1;
      · field_simp;
        refine' ⟨ q₁ - q₂, Nat.sub_pos_of_lt hq₁q₂_gt, _, _ ⟩;
        · exact Nat.sub_le_of_le_add <| by linarith;
        · intro j; rw [ Nat.cast_sub hq₁q₂_gt.le ] ; specialize hf; have := hf.2.2.2.2 j; simp_all +decide [ abs_lt, round_eq ] ;
          set k_j := ⌊q₁ * α j⌋ - ⌊q₂ * α j⌋
          have hk_j : |(q₁ - q₂) * α j - k_j| < 1 / (N : ℝ) := by
            simp +zetaDelta at *;
            exact abs_lt.mpr ⟨ by linarith [ Int.fract_add_floor ( ( q₁ : ℝ ) * α j ), Int.fract_add_floor ( ( q₂ : ℝ ) * α j ), hf.2.2 j ], by linarith [ Int.fract_add_floor ( ( q₁ : ℝ ) * α j ), Int.fract_add_floor ( ( q₂ : ℝ ) * α j ), hf.2.2 j ] ⟩;
          have h_opt := round_le ((↑q₁ - ↑q₂ : ℝ) * α j) k_j
          rw [round_eq] at h_opt
          simp only [one_div] at h_opt
          have h1 := lt_of_le_of_lt h_opt hk_j
          have hN_pos : (0 : ℝ) < ↑N := Nat.cast_pos.mpr hN
          exact lt_of_lt_of_le (mul_lt_mul_of_pos_right h1 hN_pos)
            (le_of_eq (one_div_mul_cancel (Nat.cast_ne_zero.mpr (Nat.pos_iff_ne_zero.mp hN))))

/-
Given frequencies γ_j, we can find x arbitrarily large such that cos(γ_j log x) is close to ±1 (simultaneously for all j). This corresponds to the phases being close to integers (modulo π).
-/
theorem oscillation_alignment (n : ℕ) (γ : Fin n → ℝ) (ε : ℝ) (hε : 0 < ε) :
    ∀ M, ∃ x > M, ∀ j, |Real.cos (γ j * Real.log x)| > 1 - ε := by
      intro M;
      obtain ⟨δ, hδ_pos, hδ⟩ : ∃ δ > 0, ∀ y : ℝ, ∀ k : ℤ, |y - 2 * Real.pi * k| < δ → |Real.cos y| > 1 - ε := by
        have h_cos_cont : ∃ δ > 0, ∀ y : ℝ, |y| < δ → |Real.cos y - 1| < ε := by
          simpa using Metric.continuous_iff.mp Real.continuous_cos 0 ε hε;
        obtain ⟨ δ, hδ_pos, hδ ⟩ := h_cos_cont; use δ, hδ_pos; intros y k hy; have := hδ ( y - 2 * Real.pi * k ) ( by simpa [ mul_comm ( 2 * Real.pi ) ] using hy ) ; simp_all +decide [ mul_comm ( 2 * Real.pi ), Real.cos_sub ] ;
        norm_num [ show Real.sin ( k * ( 2 * Real.pi ) ) = 0 from Real.sin_eq_zero_iff.mpr ⟨ k * 2, by push_cast; ring ⟩ ] at this ⊢ ; cases abs_cases ( Real.cos y ) <;> linarith [ abs_lt.mp this ];
      obtain ⟨q, hq₁, hq₂⟩ : ∃ q : ℕ, q > Real.log (Max.max M 1) ∧ ∀ j, ∃ k_j : ℤ, |(q : ℝ) * (γ j / (2 * Real.pi)) - k_j| < δ / (2 * Real.pi) := by
        have h_dirichlet : ∀ (α : Fin n → ℝ), ∀ (δ : ℝ), 0 < δ → ∃ q : ℕ, 1 ≤ q ∧ ∀ j, ∃ k_j : ℤ, |(q : ℝ) * α j - k_j| < δ := by
          intros α δ hδ_pos
          obtain ⟨q, hq₁, hq₂⟩ : ∃ q : ℕ, 1 ≤ q ∧ ∀ j, |(q : ℝ) * α j - round ((q : ℝ) * α j)| < δ := by
            have := dirichlet_simultaneous_approximation n α ( ⌊δ⁻¹⌋₊ + 1 ) ( Nat.succ_pos _ );
            exact ⟨ this.choose, this.choose_spec.1, fun j => lt_of_lt_of_le ( this.choose_spec.2.2 j ) ( by simpa using inv_le_of_inv_le₀ hδ_pos <| by linarith [ Nat.lt_floor_add_one δ⁻¹ ] ) ⟩;
          exact ⟨ q, hq₁, fun j => ⟨ _, hq₂ j ⟩ ⟩;
        obtain ⟨ q, hq₁, hq₂ ⟩ := h_dirichlet ( fun j => γ j / ( 2 * Real.pi ) ) ( δ / ( 2 * Real.pi ) ) ( div_pos hδ_pos ( by positivity ) );
        obtain ⟨ q', hq'_pos, hq'_large ⟩ : ∃ q' : ℕ, 1 ≤ q' ∧ q' > Real.log (Max.max M 1) ∧ ∀ j, ∃ k_j : ℤ, |(q' : ℝ) * (γ j / (2 * Real.pi)) - k_j| < δ / (2 * Real.pi) := by
          obtain ⟨ q', hq'₁, hq'₂ ⟩ := h_dirichlet ( fun j => γ j / ( 2 * Real.pi ) ) ( δ / ( 2 * Real.pi ) / ( q + ⌈Real.log ( Max.max M 1 ) ⌉₊ + 1 ) ) ( div_pos ( div_pos hδ_pos ( by positivity ) ) ( by positivity ) );
          refine' ⟨ q' * ( q + ⌈Real.log ( Max.max M 1 ) ⌉₊ + 1 ), _, _, _ ⟩ <;> norm_num <;> try nlinarith [ Nat.le_ceil ( Real.log ( Max.max M 1 ) ) ] ;
          · nlinarith [ Nat.le_ceil ( Real.log ( Max.max M 1 ) ), show ( q' : ℝ ) ≥ 1 by norm_cast ];
          · intro j; obtain ⟨ k_j, hk_j ⟩ := hq'₂ j; use k_j * ( q + ⌈Real.log ( Max.max M 1 ) ⌉₊ + 1 ) ; rw [ abs_lt ] ; constructor <;> push_cast <;> nlinarith [ abs_lt.mp hk_j, show ( 0 : ℝ ) < δ / ( 2 * Real.pi ) by positivity, mul_div_cancel₀ ( δ / ( 2 * Real.pi ) ) ( by positivity : ( q : ℝ ) + ⌈Real.log ( Max.max M 1 ) ⌉₊ + 1 ≠ 0 ) ] ;
        use q';
      refine' ⟨ Real.exp q, _, _ ⟩;
      · exact lt_of_le_of_lt ( le_max_left _ _ ) ( by rw [ gt_iff_lt ] at hq₁; rw [ Real.log_lt_iff_lt_exp ( by positivity ) ] at hq₁; linarith );
      · intro j; obtain ⟨ k_j, hk_j ⟩ := hq₂ j; specialize hδ ( γ j * q ) k_j; simp_all +decide [ mul_div, mul_assoc, mul_comm, mul_left_comm, Real.pi_ne_zero ] ;
        exact hδ ( by rw [ abs_lt ] at *; constructor <;> nlinarith [ Real.pi_pos, mul_div_cancel₀ ( γ j * q ) ( by positivity : ( Real.pi * 2 ) ≠ 0 ), mul_div_cancel₀ ( δ : ℝ ) ( by positivity : ( Real.pi * 2 ) ≠ 0 ) ] )

end
