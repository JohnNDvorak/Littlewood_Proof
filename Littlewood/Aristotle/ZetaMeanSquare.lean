/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 270e0f99-a712-4ef3-adcb-de78d2cc6ed2

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Mean square estimates for the Riemann Zeta function on vertical lines.

KEY RESULTS (PROVED):
- chi_zeta_eq_factor: ζ(s) = χ(s)ζ(1-s) in critical strip
- integral_cpow_frac_it: ∫₀ᵀ (n/m)^(-it) dt = (x^(-iT) - 1)/(-i·log x)
- norm_chi_zeta_half: |χ(1/2 + it)| = 1
- diagonal_term_sigma_gt_half: Σ n^(-2σ) · T = ζ(2σ)·T

ASSUMPTIONS (via typeclasses):
- ZetaMeanSquareHalfBound: ∫|ζ(1/2+it)|² dt = T log T + O(T)
- ZetaMeanSquareSigmaBound: ∫|ζ(σ+it)|² dt = ζ(2σ)T + O(T^(2-2σ)) for σ > 1/2
- ZetaFourthMomentBound: ∫|ζ(1/2+it)|⁴ dt = O(T log⁴ T)
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Complex Filter Asymptotics MeasureTheory Set Topology

/-- Definition of the mean square of the Riemann Zeta function: ∫₀ᵀ |ζ(σ + it)|² dt. -/
noncomputable def mean_square_zeta (σ T : ℝ) : ℝ :=
  ∫ t in 0..T, ‖riemannZeta (↑σ + I * ↑t)‖ ^ 2

/-- The factor χ(s) from the functional equation ζ(s) = χ(s)ζ(1-s). -/
noncomputable def chi_zeta (s : ℂ) : ℂ :=
  2 ^ s * (↑Real.pi) ^ (s - 1) * Gamma (1 - s) * sin (↑Real.pi * s / 2)

/-- The functional equation factor: ζ(s) = χ(s)ζ(1-s) in the critical strip. -/
theorem chi_zeta_eq_factor {s : ℂ} (hs : 0 < s.re) (hs' : s.re < 1) :
    riemannZeta s = chi_zeta s * riemannZeta (1 - s) := by
  have h_eq : riemannZeta s = 2 * (2 * Real.pi) ^ (s - 1) * Complex.Gamma (1 - s) * Complex.cos (Real.pi * (1 - s) / 2) * riemannZeta (1 - s) := by
    have := @riemannZeta_one_sub ( 1 - s );
    convert this ( fun n => by intro h; norm_num [ Complex.ext_iff ] at h; linarith ) ( by intro h; norm_num [ Complex.ext_iff ] at h; linarith ) using 2 ; ring;
    rw [ show - ( 1 - s ) = s - 1 by ring ];
  convert h_eq using 1;
  unfold chi_zeta;
  field_simp;
  rw [ show ( 1 - s ) * Real.pi / 2 = Real.pi / 2 - s * Real.pi / 2 by ring, Complex.cos_sub ] ; norm_num ; ring;
  rw [ Complex.cpow_add, Complex.cpow_add ] <;> norm_num ; ring;
  rw [ Complex.cpow_def_of_ne_zero, Complex.cpow_def_of_ne_zero, Complex.cpow_def_of_ne_zero ] <;> norm_num [ Real.pi_ne_zero ] ; ring;
  rw [ Complex.cpow_def_of_ne_zero, Complex.cpow_def_of_ne_zero ] <;> norm_num [ Real.pi_ne_zero ] ; ring;
  rw [ Complex.log_mul ( by norm_num [ Real.pi_ne_zero ] ) ( by norm_num ) ] ; ring;
  · norm_num [ Complex.exp_add, Complex.exp_sub, Complex.exp_neg, Complex.exp_log ] ; ring;
  · norm_num [ Complex.arg ];
    split_ifs <;> constructor <;> linarith [ Real.pi_pos ]

/-- The integral of (n/m)^(-it) from 0 to T. -/
lemma integral_cpow_frac_it (T : ℝ) (n m : ℕ) (n_pos : 0 < n) (m_pos : 0 < m) (h_ne : n ≠ m) :
    let x := (n : ℂ) / (m : ℂ)
    ∫ t in 0..T, x ^ (-I * t) = (x ^ (-I * T) - 1) / (-I * log x) := by
  simp +zetaDelta at *;
  rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
  rotate_right;
  use fun t => ( ( n : ℂ ) / m ) ^ ( - ( Complex.I * t ) ) / ( - ( Complex.I * Complex.log ( ( n : ℂ ) / m ) ) );
  · norm_num [ sub_div ];
  · intro x hx; convert HasDerivAt.div_const ( HasDerivAt.comp x ( show HasDerivAt ( fun t : ℂ => ( ( n : ℂ ) / m ) ^ ( - ( Complex.I * t ) ) ) _ _ from HasDerivAt.cpow ( hasDerivAt_const _ _ ) ( HasDerivAt.neg ( HasDerivAt.const_mul Complex.I ( hasDerivAt_id _ ) ) ) ?_ ) ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ) _ using 1 <;> norm_num ; ring;
    · by_cases h : Complex.log ( ( n : ℂ ) * ( m : ℂ ) ⁻¹ ) = 0 <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
      · simp_all +decide [ Complex.ext_iff, Complex.log_re, Complex.log_im ];
        simp_all +decide [ ne_of_gt, mul_inv_cancel₀ ];
        exact h_ne ( Nat.cast_injective ( by nlinarith [ show ( 0 : ℝ ) < n by positivity, show ( 0 : ℝ ) < m by positivity, mul_inv_cancel₀ ( by positivity : ( m : ℝ ) ≠ 0 ), h.1.resolve_right ( by nlinarith [ show ( 0 : ℝ ) < n by positivity, show ( 0 : ℝ ) < m by positivity, mul_inv_cancel₀ ( by positivity : ( m : ℝ ) ≠ 0 ) ] ) ] : ( n : ℝ ) = m ) );
      · norm_num [ ← mul_assoc ];
    · exact Or.inl ( by norm_num [ div_pos, n_pos, m_pos ] );
  · exact Continuous.intervalIntegrable ( by exact continuous_iff_continuousAt.mpr fun x => by exact ContinuousAt.cpow ( continuousAt_const.div_const _ ) ( ContinuousAt.neg <| ContinuousAt.mul continuousAt_const <| Complex.continuous_ofReal.continuousAt ) <| Or.inl <| by norm_num; positivity ) _ _

/-- A class capturing the assumed fourth moment bound for the Riemann Zeta function. -/
class ZetaFourthMomentBound where
  bound : (fun T => ∫ t in 0..T, ‖riemannZeta (1/2 + I * ↑t)‖ ^ 4) =O[atTop] (fun T => T * (Real.log T) ^ 4)

/-- Fourth moment bound (assumed via class). -/
theorem fourth_moment_zeta_half_asymp [ZetaFourthMomentBound] :
    (fun T => ∫ t in 0..T, ‖riemannZeta (1/2 + I * ↑t)‖ ^ 4) =O[atTop] (fun T => T * (Real.log T) ^ 4) :=
  ZetaFourthMomentBound.bound

/-- Class capturing the assumed second moment bound on the critical line. -/
class ZetaMeanSquareHalfBound where
  bound : (fun T => mean_square_zeta (1/2) T - T * Real.log T) =O[atTop] (fun T => T)

/-- Second moment on critical line (assumed via class). -/
theorem mean_square_zeta_half_asymp [ZetaMeanSquareHalfBound] :
    (fun T => mean_square_zeta (1/2) T - T * Real.log T) =O[atTop] (fun T => T) :=
  ZetaMeanSquareHalfBound.bound

/-- Class capturing the assumed mean square bound for σ > 1/2. -/
class ZetaMeanSquareSigmaBound where
  bound : ∀ {σ : ℝ}, 1/2 < σ → σ ≠ 1 →
    (fun T => mean_square_zeta σ T - (riemannZeta (2 * ↑σ)).re * T) =O[atTop] (fun T => T ^ (2 - 2 * σ))

/-- Mean square for σ > 1/2 (assumed via class). -/
theorem mean_square_zeta_sigma_asymp [ZetaMeanSquareSigmaBound] {σ : ℝ} (hσ : 1/2 < σ) (hσ' : σ ≠ 1) :
    (fun T => mean_square_zeta σ T - (riemannZeta (2 * ↑σ)).re * T) =O[atTop] (fun T => T ^ (2 - 2 * σ)) :=
  ZetaMeanSquareSigmaBound.bound hσ hσ'

/-- The magnitude of the factor χ(s) on the critical line is 1. -/
lemma norm_chi_zeta_half (t : ℝ) : ‖chi_zeta (1/2 + I * t)‖ = 1 := by
  field_simp;
  have h_gamma : ‖Gamma (1 / 2 - Complex.I * t)‖ = Real.sqrt (Real.pi / Real.cosh (Real.pi * t)) := by
    have h_gamma_prop : Complex.Gamma (1 / 2 - Complex.I * t) * Complex.Gamma (1 / 2 + Complex.I * t) = Real.pi / Real.cosh (Real.pi * t) := by
      have := @Complex.Gamma_mul_Gamma_one_sub ( 1 / 2 - Complex.I * t );
      convert this using 2 <;> ring;
      norm_num [ Complex.ext_iff, Complex.sin, Complex.exp_re, Complex.exp_im, Real.cosh_eq ];
      norm_num [ mul_div ];
    have h_gamma_conj : Complex.Gamma (1 / 2 + Complex.I * t) = starRingEnd ℂ (Complex.Gamma (1 / 2 - Complex.I * t)) := by
      convert Complex.Gamma_conj ( 1 / 2 - Complex.I * t ) using 2 ; norm_num;
      erw [ Complex.conj_ofReal ] ; norm_num;
    simp_all +decide [ Complex.ext_iff, sq ];
    norm_cast at *; simp_all +decide [ Complex.normSq, Complex.norm_def ] ;
  have h_abs : ‖chi_zeta ((1 + 2 * Complex.I * t) / 2)‖ = Real.sqrt (2 / Real.pi) * ‖Complex.sin (Real.pi * (1 / 2 + Complex.I * t) / 2)‖ * Real.sqrt (Real.pi / Real.cosh (Real.pi * t)) := by
    convert congr_arg ( fun x : ℝ => Real.sqrt ( 2 / Real.pi ) * ‖Complex.sin ( Real.pi * ( 1 / 2 + Complex.I * t ) / 2 )‖ * x ) h_gamma using 1;
    norm_num [ chi_zeta ];
    rw [ Complex.norm_cpow_of_ne_zero, Complex.norm_cpow_of_ne_zero ] <;> norm_num ; ring;
    norm_num [ Complex.arg, Real.sqrt_eq_rpow, Real.rpow_neg, abs_of_pos Real.pi_pos ] ; ring;
    rw [ if_pos Real.pi_pos.le ] ; norm_num [ Real.rpow_neg, Real.pi_pos.le ] ; ring;
  have h_abs_simplified : ‖Complex.sin (Real.pi * (1 / 2 + Complex.I * t) / 2)‖ = Real.sqrt (Real.cosh (Real.pi * t)) / Real.sqrt 2 := by
    norm_num [ Complex.normSq, Complex.norm_def, Complex.sin, Complex.exp_re, Complex.exp_im ] ; ring;
    norm_num [ mul_div, Real.sin_sq, Real.cos_sq, Real.cosh_eq ] ; ring;
    norm_num [ ← Real.exp_nat_mul ] ; ring;
  rw [ h_abs, h_abs_simplified ] ; ring ; norm_num [ Real.pi_pos.le, ne_of_gt Real.pi_pos ];
  field_simp [mul_comm, mul_assoc, mul_left_comm]

/-- The diagonal terms in the mean square expansion for σ > 1/2 sum to ζ(2σ)T. -/
lemma diagonal_term_sigma_gt_half (σ : ℝ) (hσ : 1/2 < σ) (T : ℝ) :
    (∑' (n : ℕ+), (n : ℝ) ^ (-2 * σ)) * T = (riemannZeta (2 * σ)).re * T := by
  convert congr_arg ( fun x : ℝ => x * T ) _ using 1;
  rw [ zeta_eq_tsum_one_div_nat_add_one_cpow ] ; norm_num [ Real.rpow_neg ] ; ring;
  · convert ( Eq.symm <| Summable.tsum_eq_zero_add <| show Summable _ from _ ) using 1;
    case convert_6 => exact fun n => ( ( n + 1 : ℝ ) ^ ( σ * 2 ) ) ⁻¹;
    any_goals try infer_instance;
    · rw [ ← Equiv.tsum_eq ( Equiv.pnatEquivNat.symm ) ] ; norm_num;
      rw [ Summable.tsum_eq_zero_add ] <;> norm_num;
      exact_mod_cast summable_nat_add_iff 1 |>.2 <| Real.summable_nat_rpow_inv.2 <| by linarith;
    · convert Complex.ofReal_re _;
      rw [ Complex.ofReal_tsum ] ; congr ; ext n ; norm_cast ; ring;
      norm_num [ Complex.ofReal_cpow ( by positivity : 0 ≤ ( 1 + n : ℝ ) ) ];
    · exact_mod_cast summable_nat_add_iff 1 |>.2 <| Real.summable_nat_rpow_inv.2 <| by linarith;
  · norm_cast ; linarith

end
