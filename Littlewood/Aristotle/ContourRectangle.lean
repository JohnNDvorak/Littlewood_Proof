/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: aef4c96d-9895-4431-9088-87754720f430

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ContourRectangle

open Complex Set Topology

-- Rectangle with corners (a, c) and (b, d)
def rectangle (a b c d : ℝ) : Set ℂ :=
  {z : ℂ | a < z.re ∧ z.re < b ∧ c < z.im ∧ z.im < d}

-- Closed rectangle
def closedRectangle (a b c d : ℝ) : Set ℂ :=
  {z : ℂ | a ≤ z.re ∧ z.re ≤ b ∧ c ≤ z.im ∧ z.im ≤ d}

noncomputable def argChange (f : ℂ → ℂ) (γ : ℝ → ℂ) (t₁ t₂ : ℝ) : ℝ :=
  ∫ t in Icc t₁ t₂, (deriv γ t * deriv f (γ t) / f (γ t)).im

noncomputable def zeroCount (f : ℂ → ℂ) (a b c d : ℝ) : ℕ :=
  (rectangle a b c d ∩ {z | f z = 0}).ncard

noncomputable def rectIntegral (g : ℂ → ℂ) (a b c d : ℝ) : ℂ :=
  (∫ t in Icc (0 : ℝ) 1, (b - a) * g (a + t * (b - a) + c * I)) +
  (∫ t in Icc (0 : ℝ) 1, (d - c) * I * g (b + (c + t * (d - c)) * I)) +
  (∫ t in Icc (0 : ℝ) 1, -(b - a) * g (b - t * (b - a) + d * I)) +
  (∫ t in Icc (0 : ℝ) 1, -(d - c) * I * g (a + (d - t * (d - c)) * I))

/-
The integral along the bottom edge of the rectangle corresponds to the standard interval integral.
-/
lemma rectIntegral_bottom_eq (g : ℂ → ℂ) (a b c : ℝ) :
  ∫ t in (0:ℝ)..1, (b - a) * g (a + t * (b - a) + c * I) = ∫ x in a..b, g (x + c * I) := by
  cases eq_or_ne ( b - a ) 0 <;> simp_all +decide [ mul_comm, intervalIntegral.integral_comp_mul_right ];
  · simp_all +decide [ sub_eq_iff_eq_add ];
  · -- By substitution using $ u = a + t(b - a) $, we can transform the integral.
    have h_subst : ∀ {f : ℝ → ℂ}, ∫ t in (0 : ℝ)..1, f (a + t * (b - a)) = (1 / (b - a)) * ∫ u in (a)..b, f u := by
      intro f; rw [ intervalIntegral.integral_comp_mul_right fun x => f ( a + x ) ] ; norm_num [ sub_ne_zero.mpr ( by aesop : b ≠ a ) ] ;
      assumption;
    convert congr_arg ( fun x : ℂ => ( b - a : ℂ ) * x ) ( @h_subst ( fun x => g ( x + Complex.I * c ) ) ) using 1 <;> norm_num [ mul_assoc, mul_comm, mul_left_comm ];
    rw [ ← mul_assoc, mul_inv_cancel₀ ( by norm_cast ), one_mul ]

/-
The integral along the top edge of the rectangle corresponds to the negative of the standard interval integral.
-/
lemma rectIntegral_top_eq (g : ℂ → ℂ) (a b d : ℝ) :
  ∫ t in (0:ℝ)..1, -(b - a) * g (b - t * (b - a) + d * I) = - ∫ x in a..b, g (x + d * I) := by
  by_cases hab : a = b <;> simp_all +decide [ sub_eq_iff_eq_add ];
  -- Let $u = b - t(b-a)$, then $du = -(b-a) dt$.
  have h_sub : ∀ {f : ℝ → ℂ}, ∫ t in (0 : ℝ)..1, f (b - t * (b - a)) = (1 / (b - a)) * ∫ u in (b - 1 * (b - a))..(b - 0 * (b - a)), f u := by
    intro f; rw [ intervalIntegral.integral_comp_mul_right fun x => f ( b - x ) ] ; norm_num [ sub_ne_zero.mpr ( Ne.symm hab ) ] ;
    exact sub_ne_zero_of_ne <| Ne.symm hab;
  have := @h_sub ( fun x => g ( x + d * Complex.I ) ) ; simp_all +decide [ sub_eq_iff_eq_add ] ;
  rw [ ← mul_assoc, ← neg_sub, neg_mul, mul_inv_cancel₀ ( sub_ne_zero_of_ne <| by norm_cast; tauto ), neg_one_mul ]

/-
The integral along the right edge of the rectangle corresponds to the standard interval integral multiplied by I.
-/
lemma rectIntegral_right_eq (g : ℂ → ℂ) (b c d : ℝ) :
  ∫ t in (0:ℝ)..1, (d - c) * I * g (b + (c + t * (d - c)) * I) = I * ∫ y in c..d, g (b + y * I) := by
  cases eq_or_ne ( d - c ) 0 <;> simp_all +decide [ mul_div_cancel₀, intervalIntegral.integral_comp_add_mul ];
  · simp_all +decide [ sub_eq_iff_eq_add ];
  · -- Factor out and cancel common terms in the integral
    suffices h_suff : ∫ x in (0 : ℝ)..1, g (b + Complex.I * (c + (d - c) * x)) = (1 / (d - c)) * ∫ y in (c : ℝ)..d, g (b + Complex.I * y) by
      simp_all +decide [ mul_assoc, mul_comm, mul_left_comm ];
      rw [ ← mul_assoc, mul_inv_cancel₀ ( by norm_cast ), one_mul ];
    convert intervalIntegral.integral_comp_add_mul _ _ _ using 3 <;> norm_num [ * ];
    congr! 1;
    congr! 1;
    congr! 1;
    congr! 1;
    any_goals exact ‹¬d - c = 0›;
    · norm_cast;
    · ext; norm_num;
    · norm_num;
    · ring

/-
The integral along the left edge of the rectangle corresponds to the negative of the standard interval integral multiplied by I.
-/
lemma rectIntegral_left_eq (g : ℂ → ℂ) (a c d : ℝ) :
  ∫ t in (0:ℝ)..1, -(d - c) * I * g (a + (d - t * (d - c)) * I) = - I * ∫ y in c..d, g (a + y * I) := by
  by_cases h : c = d <;> simp_all +decide [ sub_eq_iff_eq_add ];
  -- By substitution using $ y = d - t(d - c) $, we can rewrite the integral.
  have h_subst : ∀ {f : ℝ → ℂ}, (∫ t in (0:ℝ)..1, f (d - t * (d - c))) = (∫ y in (c:ℝ)..d, f y / (d - c)) := by
    intro f; rw [ intervalIntegral.integral_comp_mul_right fun t => f ( d - t ) ] ; norm_num [ sub_ne_zero.mpr ( Ne.symm h ) ] ; ring;
    exact sub_ne_zero_of_ne ( Ne.symm h );
  have := @h_subst ( fun x => g ( a + x * Complex.I ) ) ; simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
  field_simp;
  rw [ div_eq_iff ( sub_ne_zero_of_ne <| by norm_cast; tauto ) ] ; ring

/-
If a function g is differentiable on a closed rectangle, then its integral around the boundary of the rectangle is 0.
-/
lemma rectIntegral_eq_zero_of_differentiable
    (g : ℂ → ℂ) (a b c d : ℝ)
    (hab : a < b) (hcd : c < d)
    (hg_diff : DifferentiableOn ℂ g (closedRectangle a b c d)) :
    rectIntegral g a b c d = 0 := by
  -- Convert Icc set integrals to interval integrals
  have hconv : ∀ f : ℝ → ℂ, ∫ t in Icc (0 : ℝ) 1, f t = ∫ t in (0 : ℝ)..1, f t := fun f => by
    rw [MeasureTheory.integral_Icc_eq_integral_Ioc, intervalIntegral.integral_of_le zero_le_one]
  unfold rectIntegral
  simp only [hconv]
  -- Apply edge conversion lemmas
  rw [rectIntegral_bottom_eq, rectIntegral_right_eq, rectIntegral_top_eq, rectIntegral_left_eq]
  -- Apply Mathlib's Cauchy-Goursat for rectangles
  have h_cauchy : (∫ x in a..b, g (↑x + ↑c * I)) - (∫ x in a..b, g (↑x + ↑d * I)) +
      I * (∫ y in c..d, g (↑b + ↑y * I)) - I * (∫ y in c..d, g (↑a + ↑y * I)) = 0 := by
    have := @Complex.integral_boundary_rect_eq_zero_of_differentiable_on_off_countable
    convert this g (a + c * I) (b + d * I) ∅ (by norm_num) ?_ ?_ using 1 <;> norm_num
    · exact hg_diff.continuousOn.mono fun x hx =>
        ⟨by simpa [hab.le] using hx.1.1, by simpa [hab.le] using hx.1.2,
         by simpa [hcd.le] using hx.2.1, by simpa [hcd.le] using hx.2.2⟩
    · simp_all +decide [min_eq_left hab.le, max_eq_right hab.le,
        min_eq_left hcd.le, max_eq_right hcd.le]
      intro x hx
      exact hg_diff.differentiableAt (Filter.mem_of_superset
        (IsOpen.mem_nhds
          ((isOpen_Ioi.preimage continuous_re).inter
            ((isOpen_Iio.preimage continuous_re).inter
              ((isOpen_Ioi.preimage continuous_im).inter
                (isOpen_Iio.preimage continuous_im))))
          ⟨hx.1.1, hx.1.2, hx.2.1, hx.2.2⟩)
        fun z hz => ⟨hz.1.le, hz.2.1.le, hz.2.2.1.le, hz.2.2.2.le⟩)
  linear_combination h_cauchy

end ContourRectangle
