/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 8cca9fb5-fbad-4389-adf9-cb1949363c6a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module proves that there are only finitely many zeros of the Riemann zeta function in the critical strip up to any given height T.
The proof relies on the fact that the Riemann zeta function is analytic on the critical strip (except at the pole s=1), not identically zero, and that zeros of an analytic function are isolated.
The main theorem is `zetaZeros_finite_below`.
Helper lemmas include:
- `riemannZeta_analyticOn_strip`: The Riemann zeta function is analytic on the strip {s : ℂ | 0 < s.re ∧ s.re < 1}.
- `riemannZeta_not_identically_zero`: The Riemann zeta function is not identically zero on the critical strip.
- `riemannZeta_ne_zero_near_one`: The Riemann zeta function is non-zero in a punctured neighborhood of 1.
- `riemannZeta_zeros_isolated'`: The zeros of the Riemann zeta function are isolated (away from the pole s=1).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ZetaZerosFiniteBelowV2

/-
The Riemann zeta function is analytic on the strip {s : ℂ | 0 < s.re ∧ s.re < 1}.
-/
lemma riemannZeta_analyticOn_strip :
    AnalyticOn ℂ riemannZeta {s : ℂ | 0 < s.re ∧ s.re < 1} := by
  apply_rules [ DifferentiableOn.analyticOn ];
  · refine' fun s hs => DifferentiableAt.differentiableWithinAt _;
    apply_rules [ differentiableAt_riemannZeta ];
    aesop;
  · exact isOpen_Ioo.preimage Complex.continuous_re

/-
The Riemann zeta function is not identically zero on the critical strip.
-/
lemma riemannZeta_not_identically_zero :
    ∃ s : ℂ, 0 < s.re ∧ s.re < 1 ∧ riemannZeta s ≠ 0 := by
  -- By contradiction, assume that riemannZeta(s) = 0 for all s with 0 < s.re < 1.
  by_contra h_contra; push_neg at h_contra;
  -- The strip S is a non-empty open set.
  have h_strip_open : IsOpen {s : ℂ | 0 < s.re ∧ s.re < 1} := by
    exact isOpen_Ioo.preimage Complex.continuous_re
  have h_strip_nonempty : {s : ℂ | 0 < s.re ∧ s.re < 1}.Nonempty := by
    exact ⟨ 1 / 2, by norm_num ⟩
  have h_strip_subset : {s : ℂ | 0 < s.re ∧ s.re < 1} ⊆ Set.univ \ {1} := by
    exact fun x hx => ⟨ Set.mem_univ _, by rintro rfl; norm_num at hx ⟩
  have h_strip_connected : IsPreconnected {s : ℂ | 0 < s.re ∧ s.re < 1} := by
    -- The strip S is convex, hence connected.
    have h_strip_convex : Convex ℝ {s : ℂ | 0 < s.re ∧ s.re < 1} := by
      exact convex_iff_forall_pos.mpr fun x hx y hy a b ha hb hab => ⟨ by norm_num; nlinarith [ hx.1, hx.2, hy.1, hy.2 ], by norm_num; nlinarith [ hx.1, hx.2, hy.1, hy.2 ] ⟩
    exact h_strip_convex.isPreconnected
  have h_zero_on_strip : ∀ s ∈ {s : ℂ | 0 < s.re ∧ s.re < 1}, riemannZeta s = 0 := by
    aesop
  have h_zero_on_D : ∀ s ∈ Set.univ \ {1}, riemannZeta s = 0 := by
    have h_zero_on_D : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOnNhd ];
      · exact fun s hs => DifferentiableAt.differentiableWithinAt ( differentiableAt_riemannZeta <| by aesop );
      · exact isOpen_univ.sdiff isClosed_singleton;
    apply_rules [ h_zero_on_D.eqOn_zero_of_preconnected_of_eventuallyEq_zero ];
    any_goals exact ( 1 / 2 : ℂ );
    · have h_connected : IsConnected (Set.univ \ {1} : Set ℂ) := by
        have h_connected : IsConnected (Set.univ \ {0} : Set ℂ) := by
          have h_connected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
            exact isConnected_range Complex.continuous_exp;
          convert h_connected using 1 ; ext ; simp +decide [ Complex.exp_ne_zero ]
        convert h_connected.image _ _ using 1;
        rotate_left;
        use fun x => x + 1;
        · exact continuousOn_id.add continuousOn_const;
        · ext; simp [Set.mem_image];
      exact h_connected.isPreconnected;
    · norm_num;
    · filter_upwards [ IsOpen.mem_nhds h_strip_open ⟨ show 0 < ( 1 / 2 : ℂ ).re by norm_num, show ( 1 / 2 : ℂ ).re < 1 by norm_num ⟩ ] with s hs using h_zero_on_strip s hs
  have h_contradiction : riemannZeta 2 = 0 := by
    grind
  exact absurd h_contradiction (by
  norm_num [ riemannZeta_two ])

/-
The zeros of the Riemann zeta function are isolated (away from the pole s=1).
-/
lemma riemannZeta_zeros_isolated {s : ℂ} (hs : s ≠ 1) (hz : riemannZeta s = 0) :
    Filter.Eventually (fun z => riemannZeta z ≠ 0) (nhdsWithin s {s}ᶜ) := by
  have h_analytic : AnalyticAt ℂ riemannZeta s := by
    apply_rules [ DifferentiableOn.analyticAt, differentiableAt_riemannZeta ];
    rotate_right;
    exact { z : ℂ | z ≠ 1 };
    · exact fun z hz => DifferentiableAt.differentiableWithinAt ( differentiableAt_riemannZeta hz );
    · exact isOpen_ne.mem_nhds hs;
  -- By the principle of isolated zeros, either riemannZeta is identically zero near s (and thus everywhere on ℂ \ {1} by connectivity), or s is an isolated zero.
  have h_principle : (∀ᶠ z in nhds s, riemannZeta z = 0) ∨ (∀ᶠ z in nhdsWithin s {s}ᶜ, riemannZeta z ≠ 0) := by
    exact AnalyticAt.eventually_eq_zero_or_eventually_ne_zero h_analytic;
  refine h_principle.resolve_left ?_;
  intro h;
  -- Since riemannZeta is analytic on the critical strip and not identically zero, it must have isolated zeros. Hence, there exists a neighborhood around s where riemannZeta is non-zero. This contradicts our assumption that riemannZeta is identically zero near s.
  have h_contradiction : ∀ z : ℂ, z ≠ 1 → riemannZeta z = 0 := by
    intro z hz_ne_one
    have h_analytic : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOnNhd ];
      · exact fun z hz => DifferentiableAt.differentiableWithinAt ( differentiableAt_riemannZeta hz.2 );
      · exact isOpen_univ.sdiff isClosed_singleton;
    apply h_analytic.eqOn_zero_of_preconnected_of_eventuallyEq_zero;
    any_goals tauto;
    have h_preconnected : IsConnected (Set.univ \ {1} : Set ℂ) := by
      have h_preconnected : IsConnected (Set.univ \ {0} : Set ℂ) := by
        have h_preconnected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
          exact isConnected_range ( Complex.continuous_exp );
        convert h_preconnected using 1;
        ext; simp [Complex.exp_ne_zero];
      have h_preconnected : IsConnected (Set.image (fun z : ℂ => z + 1) (Set.univ \ {0})) := by
        apply_rules [ IsConnected.image, h_preconnected ];
        exact continuousOn_id.add continuousOn_const;
      convert h_preconnected using 1 ; ext ; aesop;
    exact h_preconnected.isPreconnected;
  exact absurd ( h_contradiction 2 ( by norm_num ) ) ( by norm_num [ riemannZeta_two ] )

/-
The Riemann zeta function is non-zero in a punctured neighborhood of 1.
-/
lemma riemannZeta_ne_zero_near_one :
    Filter.Eventually (fun s => riemannZeta s ≠ 0) (nhdsWithin 1 {1}ᶜ) := by
  -- The Riemann zeta function has a simple pole at $s = 1$ with residue $1$. Hence, $(s - 1) \zeta(s)$ tends to $1$ as $s$ approaches $1$.
  have h_residue : Filter.Tendsto (fun s : ℂ => (s - 1) * riemannZeta s) (nhdsWithin 1 {1}ᶜ) (nhds 1) := by
    exact HurwitzZeta.hurwitzZetaEven_residue_one 0;
  filter_upwards [ h_residue.eventually_ne one_ne_zero ] with s hs using by aesop;

/-
The zeros of the Riemann zeta function are isolated (away from the pole s=1).
-/
lemma riemannZeta_zeros_isolated' {s : ℂ} (hs : s ≠ 1) (hz : riemannZeta s = 0) :
    Filter.Eventually (fun z => riemannZeta z ≠ 0) (nhdsWithin s {s}ᶜ) := by
  convert riemannZeta_zeros_isolated hs hz using 1

/-
There are only finitely many zeros of the Riemann zeta function in the critical strip up to any given height T.
-/
theorem zetaZeros_finite_below (T : ℝ) :
    Set.Finite {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T} := by
  -- Assume that $Z$ is infinite and derive a contradiction.
  by_contra hZ_inf;
  -- Since $Z$ is infinite and bounded, it must have an accumulation point $z_0$ in the closure of $Z$.
  obtain ⟨z₀, hz₀⟩ : ∃ z₀ : ℂ, z₀ ∈ closure {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T} ∧ ∀ U : Set ℂ, IsOpen U → z₀ ∈ U → ∃ z ∈ {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T}, z ∈ U ∧ z ≠ z₀ := by
    have h_compact : IsCompact (closure {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T}) := by
      refine' ( Metric.isCompact_iff_isClosed_bounded.mpr _ );
      simp +zetaDelta at *;
      exact isBounded_iff_forall_norm_le.mpr ⟨ 1 + T, by rintro s ⟨ hs₁, hs₂, hs₃, hs₄ ⟩ ; exact le_trans ( Complex.norm_le_abs_re_add_abs_im _ ) ( by cases abs_cases s.re <;> cases abs_cases s.im <;> linarith ) ⟩;
    -- Since $Z$ is infinite and compact, it must have an accumulation point $z_0$ in its closure.
    obtain ⟨z₀, hz₀⟩ : ∃ z₀ : ℂ, z₀ ∈ closure {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T} ∧ ∀ U : Set ℂ, IsOpen U → z₀ ∈ U → Set.Infinite (U ∩ {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T}) := by
      by_cases h_accum : ∀ z₀ : ℂ, z₀ ∈ closure {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T} → ∃ U : Set ℂ, IsOpen U ∧ z₀ ∈ U ∧ Set.Finite (U ∩ {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T});
      · choose! U hU using h_accum;
        have h_finite_cover : ∃ s : Finset ℂ, (∀ z ∈ s, z ∈ closure {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T}) ∧ closure {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T} ⊆ ⋃ z ∈ s, U z := by
          have := h_compact.elim_nhds_subcover;
          exact this U fun x hx => IsOpen.mem_nhds ( hU x hx |>.1 ) ( hU x hx |>.2.1 );
        obtain ⟨ s, hs₁, hs₂ ⟩ := h_finite_cover;
        have h_finite_union : Set.Finite (⋃ z ∈ s, U z ∩ {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| ≤ T}) := by
          exact Set.Finite.biUnion ( Finset.finite_toSet s ) fun z hz => hU z ( hs₁ z hz ) |>.2.2;
        exact False.elim <| hZ_inf <| h_finite_union.subset fun x hx => by have := hs₂ <| subset_closure hx; aesop;
      · push_neg at h_accum; exact h_accum;
    refine' ⟨ z₀, hz₀.1, fun U hU hz₀U => _ ⟩;
    exact Exists.imp ( by aesop ) ( Set.Infinite.nonempty ( hz₀.2 U hU hz₀U |> Set.Infinite.diff <| Set.finite_singleton z₀ ) );
  -- Since $z_0$ is an accumulation point of zeros, by continuity $\zeta(z_0) = 0$.
  have hz₀_zero : riemannZeta z₀ = 0 := by
    -- Since $z_0$ is an accumulation point of zeros, there exists a sequence $\{z_n\}$ in $Z$ such that $z_n \to z_0$.
    obtain ⟨z_n, hz_n⟩ : ∃ z_n : ℕ → ℂ, (∀ n, riemannZeta (z_n n) = 0 ∧ 0 < (z_n n).re ∧ (z_n n).re < 1 ∧ |(z_n n).im| ≤ T) ∧ Filter.Tendsto z_n Filter.atTop (nhds z₀) := by
      rw [ mem_closure_iff_seq_limit ] at hz₀;
      tauto;
    by_cases h : z₀ = 1 <;> simp_all +decide;
    · have := riemannZeta_ne_zero_near_one;
      rw [ eventually_nhdsWithin_iff ] at this;
      rw [ Metric.eventually_nhds_iff ] at this;
      obtain ⟨ ε, ε_pos, H ⟩ := this; rcases Metric.tendsto_atTop.mp hz_n.2 ε ε_pos with ⟨ N, hN ⟩ ; specialize hz₀ ; rcases hz₀.2 ( Metric.ball 1 ε ) ( Metric.isOpen_ball ) ( by simpa ) with ⟨ z, hz₁, hz₂, hz₃ ⟩ ; specialize H ( show Dist.dist z 1 < ε from by simpa using hz₂ ) ; aesop;
    · have hz₀_zero : Filter.Tendsto (fun n => riemannZeta (z_n n)) Filter.atTop (nhds (riemannZeta z₀)) := by
        exact DifferentiableAt.continuousAt ( differentiableAt_riemannZeta h ) |> ContinuousAt.tendsto |> Filter.Tendsto.comp <| hz_n.2;
      exact tendsto_nhds_unique hz₀_zero ( by simpa only [ hz_n.1 ] using tendsto_const_nhds );
  -- Since $z_0$ is an accumulation point of zeros, by the identity theorem (isolated zeros principle), since $z_0$ is not an isolated zero (it's an accumulation point of zeros), $\zeta$ must be identically zero in a neighborhood of $z_0$.
  have hz₀_id_zero : ∀ᶠ s in nhds z₀, riemannZeta s = 0 := by
    apply Classical.byContradiction
    intro hz₀_not_id_zero;
    -- Since $z_0$ is an accumulation point of zeros, by the identity theorem (isolated zeros principle), since $z_0$ is not an isolated zero (it's an accumulation point of zeros), $\zeta$ must be identically zero in a neighborhood of $z_0$. Hence, we can apply the identity theorem.
    have hz₀_id_zero : ∀ᶠ s in nhdsWithin z₀ {z₀}ᶜ, riemannZeta s ≠ 0 := by
      have hz₀_id_zero : AnalyticAt ℂ riemannZeta z₀ := by
        apply_rules [ DifferentiableOn.analyticAt ];
        refine' fun s hs => DifferentiableAt.differentiableWithinAt _;
        apply_rules [ differentiableAt_riemannZeta ];
        filter_upwards [ IsOpen.mem_nhds ( isOpen_compl_singleton.preimage continuous_id' ) ( show z₀ ≠ 1 from by rintro rfl; exact absurd hz₀_zero <| by exact riemannZeta_one_ne_zero ) ] with s hs using ⟨ _, DifferentiableAt.hasFDerivAt <| differentiableAt_riemannZeta hs ⟩;
      have := hz₀_id_zero.eventually_eq_zero_or_eventually_ne_zero;
      exact this.resolve_left hz₀_not_id_zero;
    rw [ eventually_nhdsWithin_iff ] at hz₀_id_zero;
    obtain ⟨ U, hU₁, hU₂ ⟩ := Metric.mem_nhds_iff.mp hz₀_id_zero;
    rcases hz₀.2 ( Metric.ball z₀ U ) ( Metric.isOpen_ball ) ( Metric.mem_ball_self hU₁ ) with ⟨ z, hz₁, hz₂, hz₃ ⟩ ; specialize hU₂ hz₂ ; aesop;
  -- Since the domain ℂ \ {1} is connected, this implies riemannZeta is identically zero on ℂ \ {1}.
  have hz₀_id_zero_all : ∀ s : ℂ, s ≠ 1 → riemannZeta s = 0 := by
    intro s hs_ne_one
    have hz₀_id_zero_all : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOnNhd ];
      · exact fun s hs => DifferentiableAt.differentiableWithinAt ( differentiableAt_riemannZeta ( by aesop ) );
      · exact isOpen_univ.sdiff isClosed_singleton;
    apply hz₀_id_zero_all.eqOn_zero_of_preconnected_of_eventuallyEq_zero;
    any_goals assumption;
    · have h_connected : IsConnected (Set.univ \ {1} : Set ℂ) := by
        have h_connected : IsConnected (Set.univ \ {0} : Set ℂ) := by
          have h_connected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
            exact isConnected_range ( Complex.continuous_exp );
          convert h_connected using 1;
          ext; simp [Complex.exp_ne_zero]
        convert h_connected.image _ _ using 1;
        rotate_left;
        use fun z => z + 1;
        · exact continuousOn_id.add continuousOn_const;
        · ext; simp [Set.mem_image];
      exact h_connected.isPreconnected;
    · simp +zetaDelta at *;
      rintro rfl; specialize hz₀_id_zero_all; have := hz₀_id_zero_all 1; simp_all +decide [ AnalyticAt ] ;
      exact absurd hz₀_zero ( by exact riemannZeta_one_ne_zero );
    · aesop;
  exact absurd ( hz₀_id_zero_all 2 ( by norm_num ) ) ( by norm_num [ riemannZeta_two ] )

end ZetaZerosFiniteBelowV2