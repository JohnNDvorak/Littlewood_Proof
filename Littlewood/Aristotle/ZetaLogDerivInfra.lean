/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ca4eb320-213b-47a2-9206-bce16fcb4c6b

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: Zeta logarithmic derivative infrastructure.
NOT imported by any bridge — standalone reference material.

Contains (ALL PROVED, 0 sorries — 6 exact? gaps closed by Claude):
- chebyshevPsi, zetaNontrivialZeros, chebyshevPsi₀: local definitions
- exists_analytic_zeta_mul_sub_one (PROVED): removable singularity via Complex.analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt
  (cont + diff on punctured nbhd → analytic). Residue closed via riemannZeta_residue_one.
- neg_zeta_logderiv_pole_at_one (PROVED): -ζ'/ζ has simple pole at s=1
- zeta_analytic_order_finite_pos (PROVED): analytic order at zeros is finite positive
- riemannZeta_locally_non_zero (PROVED): ζ not identically zero near any ρ≠1
- exists_zeta_eq_pow_mul_analytic_of_zero (PROVED): ζ(s) = (s-ρ)^m·g(s) factorization
- log_deriv_pow_mul_analytic (PROVED): log derivative of (s-a)^n·f(s)
- analyticAt_log_deriv (PROVED): f'/f analytic when f(z₀)≠0
- neg_log_deriv_of_pow_mul_analytic (PROVED): negative log derivative formula
- neg_zeta_logderiv_pole_at_zero (PROVED): -ζ'/ζ poles at nontrivial zeros
- pole_of_log_deriv_of_pow_mul_analytic (PROVED): general pole of log derivative
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.ZetaLogDerivInfra

/-
The Chebyshev psi function ψ(x) = Σ_{n ≤ x} Λ(n)
-/
noncomputable def chebyshevPsi (x : ℝ) : ℝ :=
  (Finset.range (Nat.floor x + 1)).sum (fun n => ArithmeticFunction.vonMangoldt n)

/-
The set of nontrivial zeros of the Riemann zeta function.
-/
def zetaNontrivialZeros : Set ℂ :=
  {s | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1}

/-
The normalized Chebyshev function ψ₀(x) = ψ(x) - Λ(x)/2
-/
noncomputable def chebyshevPsi₀ (x : ℝ) : ℝ :=
  chebyshevPsi x - (if x = Nat.floor x then ArithmeticFunction.vonMangoldt (Nat.floor x) / 2 else 0)

/-
There exists an analytic function h at s=1 such that h(1)=1 and h(s) = (s-1)ζ(s) near 1.
-/
theorem exists_analytic_zeta_mul_sub_one :
    ∃ (h : ℂ → ℂ), AnalyticAt ℂ h 1 ∧ h 1 = 1 ∧
      ∀ᶠ s in nhdsWithin 1 {1}ᶜ, h s = (s - 1) * riemannZeta s := by
  -- Define the function $f(s) = (s - 1) \zeta(s)$ for $s \neq 1$ and $f(1) = 1$.
  let f : ℂ → ℂ := fun s => if s = 1 then 1 else (s - 1) * riemannZeta s;
  -- We need to show that $f$ is analytic at $1$.
  have hf_analytic : AnalyticAt ℂ f 1 := by
    -- Since $f$ is continuous at $1$ and differentiable on a punctured neighborhood, we can apply the theorem that states if a function is continuous at a point and differentiable on a punctured neighborhood, then it's analytic there.
    have h_cont_diff : ContinuousAt f 1 ∧ ∀ᶠ s in nhdsWithin 1 {1}ᶜ, DifferentiableAt ℂ f s := by
      constructor;
      · -- We'll use the fact that if the denominator is non-zero and the numerator tends to zero, their division tends to zero.
        have h_cont : Filter.Tendsto (fun s : ℂ => (s - 1) * riemannZeta s) (nhdsWithin 1 {1}ᶜ) (nhds 1) := by
          exact riemannZeta_residue_one;
        rw [ Metric.tendsto_nhdsWithin_nhds ] at h_cont;
        exact Metric.tendsto_nhds_nhds.mpr fun ε hε => by rcases h_cont ε hε with ⟨ δ, hδ, H ⟩ ; exact ⟨ δ, hδ, by intro x hx; by_cases hx' : x = 1 <;> aesop ⟩ ;
      · filter_upwards [ self_mem_nhdsWithin ] with s hs;
        exact DifferentiableAt.congr_of_eventuallyEq ( DifferentiableAt.mul ( differentiableAt_id.sub_const _ ) ( differentiableAt_riemannZeta hs ) ) ( Filter.eventuallyEq_of_mem ( isOpen_compl_singleton.mem_nhds hs ) fun x hx => if_neg hx );
    -- Apply the theorem that states if a function is continuous at a point and differentiable on a punctured neighborhood, then it's analytic there.
    have h_analytic : ∀ {g : ℂ → ℂ}, ContinuousAt g 1 → (∀ᶠ s in nhdsWithin 1 {1}ᶜ, DifferentiableAt ℂ g s) → AnalyticAt ℂ g 1 := by
      exact fun hc hd => Complex.analyticAt_of_differentiable_on_punctured_nhds_of_continuousAt hd hc;
    exact h_analytic h_cont_diff.1 h_cont_diff.2;
  exact ⟨ f, hf_analytic, by aesop, Filter.eventually_of_mem self_mem_nhdsWithin fun s hs => by aesop ⟩

/-
The function -ζ'/ζ has a simple pole at s = 1 with residue 1.
-/
theorem neg_zeta_logderiv_pole_at_one :
    ∃ (g : ℂ → ℂ), AnalyticAt ℂ g 1 ∧ g 1 = 1 ∧
      ∀ᶠ s in nhdsWithin 1 {1}ᶜ, -deriv riemannZeta s / riemannZeta s = g s / (s - 1) := by
  -- Use exists_analytic_zeta_mul_sub_one to get h such that h(1)=1 and h(s) = (s-1)ζ(s).
  obtain ⟨h, h_analytic, h1, h_eq⟩ : ∃ h : ℂ → ℂ, AnalyticAt ℂ h 1 ∧ h 1 = 1 ∧ ∀ᶠ s in nhdsWithin 1 {1}ᶜ, h s = (s - 1) * riemannZeta s := by
    exact exists_analytic_zeta_mul_sub_one;
  -- Differentiating, ζ'(s) = (h'(s)(s-1) - h(s)) / (s-1)^2.
  have h_diff : ∀ᶠ s in nhdsWithin 1 {1}ᶜ, deriv riemannZeta s = (deriv h s * (s - 1) - h s) / (s - 1)^2 := by
    -- Since $h(s) = (s-1) * riemannZeta(s)$ for $s$ near $1$ (excluding $1$), we can differentiate both sides to get $h'(s) = riemannZeta(s) + (s-1) * deriv riemannZeta(s)$.
    have h_diff : ∀ᶠ s in nhdsWithin 1 {1}ᶜ, deriv h s = riemannZeta s + (s - 1) * deriv riemannZeta s := by
      have h_diff_step : ∀ᶠ s in nhdsWithin 1 {1}ᶜ, deriv h s = deriv (fun s => (s - 1) * riemannZeta s) s := by
        rw [ eventually_nhdsWithin_iff ] at *;
        rw [ Metric.eventually_nhds_iff ] at *;
        obtain ⟨ ε, ε_pos, hε ⟩ := h_eq; exact ⟨ ε, ε_pos, fun y hy hy' => Filter.EventuallyEq.deriv_eq <| Filter.eventuallyEq_of_mem ( IsOpen.mem_nhds ( isOpen_ne.preimage continuous_id' ) hy' |> Filter.inter_mem <| IsOpen.mem_nhds ( isOpen_lt ( continuous_id'.dist continuous_const ) continuous_const ) hy ) fun z hz => hε hz.2 hz.1 ⟩ ;
      filter_upwards [ h_diff_step, self_mem_nhdsWithin ] with s hs hs';
      convert HasDerivAt.deriv ( HasDerivAt.mul ( hasDerivAt_id' s |> HasDerivAt.sub <| hasDerivAt_const _ _ ) <| hasDerivAt_deriv_iff.mpr _ ) using 1;
      convert hs using 1;
      · norm_num;
      · apply_rules [ differentiableAt_riemannZeta ];
    filter_upwards [ h_diff, h_eq, self_mem_nhdsWithin ] with s hs hs' hs'' ; by_cases h : s = 1 <;> simp_all +decide [ sq, mul_assoc, sub_eq_iff_eq_add ];
    rw [ eq_div_iff ( mul_ne_zero ( sub_ne_zero_of_ne h ) ( sub_ne_zero_of_ne h ) ) ] ; ring;
  have h_g : ∀ᶠ s in nhdsWithin 1 {1}ᶜ, -deriv riemannZeta s / riemannZeta s = (h s - (s - 1) * deriv h s) / ((s - 1) * h s) := by
    filter_upwards [ h_diff, h_eq, self_mem_nhdsWithin ] with s hs hs' hs'';
    grind;
  -- Let g(s) = [h(s) - (s-1)(h'(s)/h(s))] / (s-1).
  obtain ⟨g, hg_analytic, hg⟩ : ∃ g : ℂ → ℂ, AnalyticAt ℂ g 1 ∧ g 1 = 1 ∧ ∀ᶠ s in nhdsWithin 1 {1}ᶜ, g s = (h s - (s - 1) * deriv h s) / h s := by
    refine' ⟨ fun s => ( h s - ( s - 1 ) * deriv h s ) / h s, _, _, _ ⟩ <;> norm_num [ h1 ];
    apply_rules [ AnalyticAt.div, AnalyticAt.sub, AnalyticAt.mul, analyticAt_id, analyticAt_const ];
    · exact h_analytic.deriv;
    · grind;
  refine' ⟨ g, hg_analytic, hg.1, _ ⟩;
  filter_upwards [ h_g, hg.2, self_mem_nhdsWithin ] with s hs hs' hs'' using by rw [ hs, hs', div_div ] ; ring;

/-
The analytic order of the Riemann zeta function at a zero ρ (≠ 1) is a finite positive integer.
-/
theorem zeta_analytic_order_finite_pos (ρ : ℂ) (hρ : riemannZeta ρ = 0) (hρ_ne_one : ρ ≠ 1) :
    ∃ (n : ℕ), n ≥ 1 ∧ analyticOrderAt riemannZeta ρ = n := by
  -- Since ζ has a simple pole at s=1, the order of vanishing at any other zero must be at least 1.
  have h_order_at_least_one : 1 ≤ analyticOrderAt riemannZeta ρ := by
    have h_order_pos : analyticOrderAt riemannZeta ρ ≠ 0 := by
      have h_analytic : AnalyticAt ℂ riemannZeta ρ := by
        refine' DifferentiableOn.analyticAt _ _;
        exact { s : ℂ | s ≠ 1 };
        · exact fun s hs => DifferentiableAt.differentiableWithinAt ( differentiableAt_riemannZeta hs );
        · exact isOpen_ne.mem_nhds hρ_ne_one;
      rw [ne_eq, h_analytic.analyticOrderAt_eq_zero]; exact not_not.mpr hρ;
    exact ENat.one_le_iff_ne_zero.mpr h_order_pos;
  by_cases h_order_at_most_one : analyticOrderAt riemannZeta ρ = ⊤;
  · -- Since ζ has a simple pole at s=1, the order of vanishing at any other zero must be at most 1.
    have h_order_at_most_one : ∀ᶠ s in nhds ρ, riemannZeta s = 0 := by
      rw [ analyticOrderAt_eq_top ] at h_order_at_most_one ; aesop;
    have h_identity_theorem : AnalyticOn ℂ riemannZeta (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOn ];
      · exact fun s hs => DifferentiableAt.differentiableWithinAt ( differentiableAt_riemannZeta ( by aesop ) );
      · exact isOpen_univ.sdiff isClosed_singleton;
    have h_identity_theorem : ∀ s : ℂ, s ≠ 1 → riemannZeta s = 0 := by
      intro s hs_ne_one
      have h_identity_theorem : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
        apply_rules [ DifferentiableOn.analyticOnNhd ];
        · exact h_identity_theorem.differentiableOn;
        · exact isOpen_univ.sdiff isClosed_singleton;
      apply h_identity_theorem.eqOn_zero_of_preconnected_of_eventuallyEq_zero;
      any_goals exact ρ;
      · have h_preconnected : IsPreconnected (Set.univ \ {0} : Set ℂ) := by
          have h_preconnected : IsConnected (Set.univ \ {0} : Set ℂ) := by
            have h_preconnected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
              exact isConnected_range ( Complex.continuous_exp );
            convert h_preconnected using 1;
            ext; simp [Complex.exp_ne_zero];
          exact h_preconnected.isPreconnected;
        convert h_preconnected.image ( fun x => x + 1 ) ( continuous_id.add continuous_const |> Continuous.continuousOn ) using 1 ; ext ; simp +decide [ Set.diff_eq ];
      · aesop;
      · exact h_order_at_most_one;
      · aesop;
    exact absurd ( h_identity_theorem 2 ( by norm_num ) ) ( by norm_num [ riemannZeta_two ] );
  · cases h : analyticOrderAt riemannZeta ρ <;> aesop

/-
The Riemann zeta function is not identically zero in any neighborhood of ρ (for ρ ≠ 1).
-/
theorem riemannZeta_locally_non_zero (ρ : ℂ) (hρ_ne_one : ρ ≠ 1) :
    ¬ ∀ᶠ s in nhds ρ, riemannZeta s = 0 := by
  have h_initial : ∃ ρ' : ℂ, riemannZeta ρ' ≠ 0 ∧ ρ' ≠ 1 := by
    refine' ⟨ 2, _, _ ⟩ <;> norm_num [ riemannZeta_two ];
  -- By the identity theorem for analytic functions, if riemannZeta is zero in a neighborhood of ρ, then it must be identically zero everywhere.
  have h_identity : (∀ᶠ s in nhds ρ, riemannZeta s = 0) → ∀ s : ℂ, s ≠ 1 → riemannZeta s = 0 := by
    intros h_zero_neighborhood s hs_ne_one
    have h_analytic : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOnNhd ];
      · exact fun s hs => DifferentiableAt.differentiableWithinAt ( differentiableAt_riemannZeta ( by aesop ) );
      · exact isOpen_univ.sdiff isClosed_singleton;
    apply h_analytic.eqOn_zero_of_preconnected_of_eventuallyEq_zero;
    any_goals tauto;
    -- The set of complex numbers excluding 1 is preconnected.
    have h_preconnected : IsPreconnected (Set.univ \ {0} : Set ℂ) := by
      have h_preconnected : IsConnected (Set.univ \ {0} : Set ℂ) := by
        have h_connected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
          exact isConnected_range ( Complex.continuous_exp )
        convert h_connected using 1 ; ext ; simp +decide [ Complex.exp_ne_zero ];
      exact h_preconnected.isPreconnected;
    convert h_preconnected.image ( fun x => x + 1 ) ( Continuous.continuousOn ( by continuity ) ) using 1 ; ext ; simp +decide [ Set.diff_eq ];
  exact fun h => h_initial.choose_spec.1 <| h_identity h _ h_initial.choose_spec.2

/-
If ρ is a zero of the Riemann zeta function and ρ ≠ 1, then there exists an integer m ≥ 1 and an analytic function g such that ζ(s) = (s - ρ)^m * g(s) near ρ, with g(ρ) ≠ 0.
-/
theorem exists_zeta_eq_pow_mul_analytic_of_zero (ρ : ℂ) (hρ : riemannZeta ρ = 0) (hρ_ne_one : ρ ≠ 1) :
    ∃ (m : ℕ) (g : ℂ → ℂ), m ≥ 1 ∧ AnalyticAt ℂ g ρ ∧ g ρ ≠ 0 ∧
      ∀ᶠ s in nhds ρ, riemannZeta s = (s - ρ)^m * g s := by
  -- Use zeta_analytic_order_finite_pos to get m ≥ 1 such that analyticOrderAt riemannZeta ρ = m.
  obtain ⟨m, hm⟩ : ∃ m : ℕ, m ≥ 1 ∧ analyticOrderAt riemannZeta ρ = m := by
    have := zeta_analytic_order_finite_pos ρ hρ hρ_ne_one; tauto;
  -- Use AnalyticAt.analyticOrderAt_eq_natCast to get g such that riemannZeta s = (s - ρ)^m * g s locally, with g analytic and g(ρ) ≠ 0.
  obtain ⟨g, hg_analytic, hg_nonzero, hg_eq⟩ : ∃ g : ℂ → ℂ, AnalyticAt ℂ g ρ ∧ g ρ ≠ 0 ∧ ∀ᶠ s in nhds ρ, riemannZeta s = (s - ρ) ^ m * g s := by
    have h_analytic : AnalyticAt ℂ riemannZeta ρ := by
      apply_rules [ DifferentiableOn.analyticAt, differentiableAt_riemannZeta ];
      rotate_right;
      exact { s : ℂ | s ≠ 1 };
      · exact fun s hs => DifferentiableAt.differentiableWithinAt ( differentiableAt_riemannZeta hs );
      · exact isOpen_ne.mem_nhds hρ_ne_one;
    convert h_analytic.analyticOrderAt_eq_natCast.mp hm.2 using 1;
  exact ⟨ m, g, hm.1, hg_analytic, hg_nonzero, hg_eq ⟩

/-
The logarithmic derivative of (s-a)^n * f(s) is n/(s-a) + f'(s)/f(s).
-/
theorem log_deriv_pow_mul_analytic (a : ℂ) (n : ℕ) (f : ℂ → ℂ) (hf : AnalyticAt ℂ f a) (hf_ne_zero : f a ≠ 0) :
    ∀ᶠ s in nhdsWithin a {a}ᶜ, deriv (fun s => (s - a)^n * f s) s / ((s - a)^n * f s) = n / (s - a) + deriv f s / f s := by
  refine' eventually_nhdsWithin_iff.mpr _;
  have h_log_deriv : ∀ᶠ x in nhds a, x ≠ a → deriv (fun s => (s - a) ^ n * f s) x / ((x - a) ^ n * f x) = (n / (x - a)) + (deriv f x / f x) := by
    have h_deriv : ∀ᶠ x in nhds a, deriv (fun s => (s - a) ^ n * f s) x = n * (x - a) ^ (n - 1) * f x + (x - a) ^ n * deriv f x := by
      have h_deriv : ∀ᶠ x in nhds a, deriv (fun s => (s - a) ^ n * f s) x = deriv (fun s => (s - a) ^ n) x * f x + (x - a) ^ n * deriv f x := by
        have h_deriv : ∀ᶠ x in nhds a, DifferentiableAt ℂ (fun s => (s - a) ^ n) x ∧ DifferentiableAt ℂ f x := by
          filter_upwards [ hf.eventually_analyticAt ] with x hx using ⟨ DifferentiableAt.pow ( differentiableAt_id.sub_const a ) _, hx.differentiableAt ⟩;
        filter_upwards [ h_deriv ] with x hx using deriv_mul hx.1 hx.2;
      filter_upwards [ h_deriv ] with x hx using hx.trans ( by norm_num [ sub_ne_zero ] )
    filter_upwards [ h_deriv, hf.continuousAt.eventually_ne hf_ne_zero ] with x hx hx' hx₃ ; simp_all +decide [ sub_eq_iff_eq_add, mul_assoc, mul_div_mul_left, mul_div_mul_right, pow_succ, mul_comm ] ; ring;
    rcases n <;> simp_all +decide [ pow_succ, mul_assoc, mul_comm, mul_left_comm, sub_ne_zero ];
    simp +decide [ mul_left_comm ( ( x - a ) ^ _ ), mul_assoc, mul_left_comm ( ( x - a ) ⁻¹ ), sub_ne_zero.mpr hx₃ ];
    exact Or.inl ( mul_div_cancel₀ _ ( sub_ne_zero_of_ne hx₃ ) );
  exact h_log_deriv

/-
If f is analytic at z₀ and f(z₀) ≠ 0, then f'/f is analytic at z₀.
-/
theorem analyticAt_log_deriv {f : ℂ → ℂ} {z₀ : ℂ} (hf : AnalyticAt ℂ f z₀) (hf_ne_zero : f z₀ ≠ 0) :
    AnalyticAt ℂ (fun z => deriv f z / f z) z₀ := by
  apply_rules [ AnalyticAt.div, hf, hf_ne_zero ];
  exact hf.deriv

/-
The negative logarithmic derivative of (s-a)^n * f(s) is -n/(s-a) - f'(s)/f(s).
-/
theorem neg_log_deriv_of_pow_mul_analytic (a : ℂ) (n : ℕ) (f : ℂ → ℂ) (hf : AnalyticAt ℂ f a) (hf_ne_zero : f a ≠ 0) :
    ∀ᶠ s in nhdsWithin a {a}ᶜ, -deriv (fun s => (s - a)^n * f s) s / ((s - a)^n * f s) = -n / (s - a) + (-deriv f s / f s) := by
  have h_log_deriv : ∀ᶠ s in nhdsWithin a {a}ᶜ, deriv (fun s => (s - a)^n * f s) s / ((s - a)^n * f s) = n / (s - a) + deriv f s / f s := by
    convert log_deriv_pow_mul_analytic a n f hf hf_ne_zero using 1;
  grind

/-
The function -ζ'/ζ has simple poles at each nontrivial zero ρ with residue -m (where m is the multiplicity).
-/
theorem neg_zeta_logderiv_pole_at_zero (ρ : ℂ) (hρ : riemannZeta ρ = 0)
    (hρ_nontrivial : 0 < ρ.re ∧ ρ.re < 1) :
    ∃ (m : ℕ) (g : ℂ → ℂ), m ≥ 1 ∧ AnalyticAt ℂ g ρ ∧
      ∀ᶠ s in nhdsWithin ρ {ρ}ᶜ, -deriv riemannZeta s / riemannZeta s = -m / (s - ρ) + g s := by
  obtain ⟨m, g, hm, hg⟩ : ∃ (m : ℕ) (g : ℂ → ℂ), 1 ≤ m ∧ AnalyticAt ℂ g ρ ∧ g ρ ≠ 0 ∧ ∀ᶠ s in nhds ρ, riemannZeta s = (s - ρ)^m * g s := by
    convert exists_zeta_eq_pow_mul_analytic_of_zero ρ hρ ( by aesop ) using 1;
  -- Apply `neg_log_deriv_of_pow_mul_analytic` to `g` and `m` at `ρ`.
  obtain ⟨g', hg'⟩ : ∃ (g' : ℂ → ℂ), AnalyticAt ℂ g' ρ ∧ ∀ᶠ s in nhdsWithin ρ {ρ}ᶜ, -deriv riemannZeta s / riemannZeta s = -m / (s - ρ) + g' s := by
    -- Apply `neg_log_deriv_of_pow_mul_analytic` to `g` and `m` at `ρ` to get the desired result.
    obtain ⟨g', hg'⟩ : ∃ (g' : ℂ → ℂ), AnalyticAt ℂ g' ρ ∧ ∀ᶠ s in nhdsWithin ρ {ρ}ᶜ, -deriv (fun s => (s - ρ)^m * g s) s / ((s - ρ)^m * g s) = -m / (s - ρ) + g' s := by
      -- Apply `neg_log_deriv_of_pow_mul_analytic` to `g` and `m` at `ρ` to get the desired result. Let `g'` be the function from the theorem.
      obtain ⟨g', hg'_analytic, hg'_eq⟩ : ∃ g' : ℂ → ℂ, AnalyticAt ℂ g' ρ ∧ ∀ᶠ s in nhdsWithin ρ {ρ}ᶜ, -deriv (fun s => (s - ρ)^m * g s) s / ((s - ρ)^m * g s) = -m / (s - ρ) + g' s := by
        have := neg_log_deriv_of_pow_mul_analytic ρ m g hg.left hg.right.left
        exact ⟨ _, by exact AnalyticAt.div ( by exact AnalyticAt.neg ( by exact hg.1.deriv ) ) ( by exact hg.1 ) ( by aesop ), this ⟩;
      use g';
    use g';
    -- Since $riemannZeta(s) = (s - ρ)^m * g(s)$ near $ρ$, their derivatives are equal there.
    have h_deriv_eq : ∀ᶠ s in nhdsWithin ρ {ρ}ᶜ, deriv riemannZeta s = deriv (fun s => (s - ρ)^m * g s) s := by
      have h_deriv_eq : ∀ᶠ s in nhdsWithin ρ {ρ}ᶜ, riemannZeta s = (s - ρ)^m * g s := by
        exact hg.2.2.filter_mono nhdsWithin_le_nhds;
      rw [ eventually_nhdsWithin_iff ] at *;
      rw [ Metric.eventually_nhds_iff ] at *;
      obtain ⟨ ε, ε_pos, hε ⟩ := h_deriv_eq; use ε, ε_pos; intro y hy hy'; refine' Filter.EventuallyEq.deriv_eq _ ; filter_upwards [ IsOpen.mem_nhds ( isOpen_compl_singleton.preimage continuous_id' ) hy', IsOpen.mem_nhds ( Metric.isOpen_ball ) hy ] with z hz₁ hz₂ ; aesop;
    simp_all +decide [ eventually_nhdsWithin_iff ];
    filter_upwards [ hg.2.2, hg'.2, h_deriv_eq ] with x hx₁ hx₂ hx₃ using by aesop;
  exact ⟨ m, g', hm, hg'.1, hg'.2 ⟩

/-
If a function has a zero of order m at a, its negative logarithmic derivative has a simple pole at a with residue -m.
-/
theorem pole_of_log_deriv_of_pow_mul_analytic (a : ℂ) (m : ℕ) (f : ℂ → ℂ) (hf : AnalyticAt ℂ f a) (hf_ne_zero : f a ≠ 0) :
    ∃ (g : ℂ → ℂ), AnalyticAt ℂ g a ∧
      ∀ᶠ s in nhdsWithin a {a}ᶜ, -deriv (fun s => (s - a)^m * f s) s / ((s - a)^m * f s) = -m / (s - a) + g s := by
  use fun s => -deriv f s / f s;
  constructor;
  · apply_rules [ AnalyticAt.div, AnalyticAt.neg, hf ];
    exact hf.deriv;
  · exact neg_log_deriv_of_pow_mul_analytic a m f hf hf_ne_zero

end Aristotle.ZetaLogDerivInfra