/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 11bec4f5-f17f-46f0-a320-b9d7366142c7

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
Partial progress: HasGammaGrowth structure, half-integer stepping, Stirling kernel/ratio
bounds, differentiability on strips. Missing: final Hadamard three-lines assembly.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.GammaGrowthGeneral

open Complex Real

structure HasGammaGrowth (σ : ℝ) (C₁ C₂ : ℝ) : Prop where
  hC₁ : 0 < C₁
  hC₂ : 0 < C₂
  lower : ∀ t : ℝ, 1 ≤ |t| → C₁ * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (↑σ + ↑t * Complex.I)‖
  upper : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (↑σ + ↑t * Complex.I)‖ ≤ C₂ * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2)

/-
The base case: Gamma growth bounds hold for σ = 1/2.
-/
theorem gamma_half_growth : ∃ C₁ C₂, HasGammaGrowth (1/2) C₁ C₂ := by
  have h_exists : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| → C₁ * |t|^(1 / 2 - 1 / 2) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ∧ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ≤ C₂ * |t|^(1 / 2 - 1 / 2) * Real.exp (-Real.pi * |t| / 2) := by
    have h_exists : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ = Real.sqrt (Real.pi / Real.cosh (Real.pi * t)) := by
      use 1, 1;
      have h_gamma_half : ∀ t : ℝ, Complex.Gamma (1 / 2 + t * Complex.I) * Complex.Gamma (1 / 2 - t * Complex.I) = Real.pi / Real.cosh (Real.pi * t) := by
        intro t
        have := Complex.Gamma_mul_Gamma_one_sub (1 / 2 + t * Complex.I);
        convert this using 2 <;> ring;
        norm_num [ Complex.ext_iff, Complex.sin, Complex.exp_re, Complex.exp_im, Real.cosh_eq ];
        norm_num [ mul_div ] ; ring;
      have h_gamma_conj : ∀ t : ℝ, Complex.Gamma (1 / 2 - t * Complex.I) = starRingEnd ℂ (Complex.Gamma (1 / 2 + t * Complex.I)) := by
        intro t;
        convert Complex.Gamma_conj ( 1 / 2 + t * Complex.I ) using 1 ; norm_num;
        erw [ Complex.conj_ofReal ] ; norm_num;
        ring;
      simp_all +decide [ Complex.ext_iff ];
      norm_cast at *; simp_all +decide [ Complex.normSq, Complex.norm_def ] ;
    obtain ⟨C₁, C₂, hC₁, hC₂, h_bound⟩ := h_exists;
    have h_bounds : ∃ C₁' C₂' : ℝ, 0 < C₁' ∧ 0 < C₂' ∧ ∀ t : ℝ, 1 ≤ |t| → C₁' * Real.exp (-Real.pi * |t| / 2) ≤ Real.sqrt (Real.pi / Real.cosh (Real.pi * t)) ∧ Real.sqrt (Real.pi / Real.cosh (Real.pi * t)) ≤ C₂' * Real.exp (-Real.pi * |t| / 2) := by
      have h_cosh_bounds : ∀ t : ℝ, 1 ≤ |t| → Real.sqrt (Real.pi / Real.cosh (Real.pi * t)) ≥ Real.sqrt (Real.pi / Real.exp (Real.pi * |t|)) ∧ Real.sqrt (Real.pi / Real.cosh (Real.pi * t)) ≤ Real.sqrt (2 * Real.pi / Real.exp (Real.pi * |t|)) := by
        intros t ht
        have h_cosh_bound : Real.cosh (Real.pi * t) ≥ Real.exp (Real.pi * |t|) / 2 ∧ Real.cosh (Real.pi * t) ≤ Real.exp (Real.pi * |t|) := by
          norm_num [ Real.cosh_eq ];
          cases abs_cases t <;> simp +decide [ * ];
          · constructor <;> linarith [ Real.exp_pos ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_le_exp.mpr ( show - ( Real.pi * t ) ≤ Real.pi * t by nlinarith [ Real.pi_pos ] ) ];
          · constructor <;> nlinarith [ Real.exp_pos ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_le_exp.2 ( by nlinarith [ Real.pi_pos ] : Real.pi * t ≤ - ( Real.pi * t ) ) ];
        exact ⟨ Real.sqrt_le_sqrt <| by rw [ div_le_div_iff₀ ] <;> nlinarith [ Real.pi_pos, Real.exp_pos ( Real.pi * |t| ) ], Real.sqrt_le_sqrt <| by rw [ div_le_div_iff₀ ] <;> nlinarith [ Real.pi_pos, Real.exp_pos ( Real.pi * |t| ) ] ⟩;
      refine' ⟨ Real.sqrt ( Real.pi ), Real.sqrt ( 2 * Real.pi ), _, _, _ ⟩ <;> norm_num [ Real.sqrt_pos, Real.pi_pos ];
      intro t ht; specialize h_cosh_bounds t ht; norm_num [ Real.exp_neg, Real.exp_half, Real.sqrt_div ( show 0 ≤ Real.pi by positivity ), Real.sqrt_div ( show 0 ≤ 2 * Real.pi by positivity ) ] at *; ring_nf at *; aesop;
    obtain ⟨ C₁', C₂', hC₁', hC₂', h_bounds ⟩ := h_bounds; use C₁', C₂'; aesop;
  obtain ⟨ C₁, C₂, hC₁, hC₂, h ⟩ := h_exists; exact ⟨ C₁, C₂, ⟨ hC₁, hC₂, fun t ht ↦ by simpa using h t ht |>.1, fun t ht ↦ by simpa using h t ht |>.2 ⟩ ⟩ ;

/-
Stepping lemma: if Gamma growth bounds hold for σ, they hold for σ + 1.
-/
theorem gamma_growth_step_up {σ : ℝ} {C₁ C₂ : ℝ} (h : HasGammaGrowth σ C₁ C₂) :
    ∃ C₁' C₂', HasGammaGrowth (σ + 1) C₁' C₂' := by
      have h_lower : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (σ + 1 + t * Complex.I)‖ ≥ C₁ * |t|^(σ - 1/2 + 1) * Real.exp (-Real.pi * |t| / 2) / (|σ| + 1) := by
        intro t ht
        have h_recurrence : Complex.Gamma (σ + 1 + t * Complex.I) = (σ + t * Complex.I) * Complex.Gamma (σ + t * Complex.I) := by
          convert Complex.Gamma_add_one _ using 2 ; ring;
          swap;
          exact σ + t * Complex.I;
          by_cases h : ( σ : ℂ ) + t * Complex.I = 0 <;> simp_all +decide [ add_assoc, mul_comm ];
          · simp_all +decide [ Complex.ext_iff ];
            linarith;
          · ring;
        have h_ind : ‖Complex.Gamma (σ + t * Complex.I)‖ ≥ C₁ * |t| ^ (σ - 1 / 2) * Real.exp (-Real.pi * |t| / 2) := by
          exact h.lower t ht;
        have h_abs : ‖σ + t * Complex.I‖ ≥ |t| / (|σ| + 1) := by
          norm_num [ Complex.normSq, Complex.norm_def ];
          exact Real.le_sqrt_of_sq_le ( by rw [ div_pow, div_le_iff₀ ] <;> nlinarith [ abs_mul_abs_self σ, abs_mul_abs_self t, abs_nonneg σ, abs_nonneg t ] );
        simp_all +decide [ Real.rpow_add ( abs_pos.mpr ( show t ≠ 0 by rintro rfl; norm_num at ht ) ) ];
        convert mul_le_mul h_abs h_ind ( by exact mul_nonneg ( mul_nonneg ( h.hC₁.le ) ( Real.rpow_nonneg ( abs_nonneg t ) _ ) ) ( Real.exp_nonneg _ ) ) ( by positivity ) using 1 ; ring;
      have h_upper : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (σ + 1 + t * Complex.I)‖ ≤ C₂ * |t|^(σ - 1/2 + 1) * Real.exp (-Real.pi * |t| / 2) * (|σ| + 1) := by
        intro t ht
        have h_recurrence : Complex.Gamma (σ + 1 + t * Complex.I) = (σ + t * Complex.I) * Complex.Gamma (σ + t * Complex.I) := by
          convert Complex.Gamma_add_one _ using 2 ; ring;
          swap;
          exact ↑σ + ↑t * Complex.I;
          by_cases h : ( σ : ℂ ) + t * Complex.I = 0 <;> simp_all +decide [ add_assoc, mul_comm ];
          · simp_all +decide [ Complex.ext_iff ];
            linarith;
          · ring;
        have h_ind : ‖Complex.Gamma (σ + t * Complex.I)‖ ≤ C₂ * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) := by
          exact h.upper t ht;
        have h_triangle : ‖σ + t * Complex.I‖ ≤ |σ| + |t| := by
          convert norm_add_le ( σ : ℂ ) ( t * Complex.I ) using 1 ; norm_num [ Complex.normSq, Complex.norm_def ];
        rw [ h_recurrence, norm_mul ];
        refine le_trans ( mul_le_mul h_triangle h_ind ( by positivity ) ( by positivity ) ) ?_;
        rw [ Real.rpow_add <| by positivity, Real.rpow_one ] ; ring_nf;
        exact add_le_add ( by nlinarith [ show 0 ≤ |σ| * C₂ * |t| ^ ( -1 / 2 + σ ) * Real.exp ( |t| * Real.pi * ( -1 / 2 ) ) by exact mul_nonneg ( mul_nonneg ( mul_nonneg ( abs_nonneg _ ) ( le_of_lt h.hC₂ ) ) ( Real.rpow_nonneg ( abs_nonneg _ ) _ ) ) ( Real.exp_nonneg _ ) ] ) le_rfl;
      refine' ⟨ C₁ / ( |σ| + 1 ), C₂ * ( |σ| + 1 ), _, _, _, _ ⟩ <;> norm_num;
      · exact div_pos h.hC₁ ( by positivity );
      · exact mul_pos h.hC₂ ( by positivity );
      · grind;
      · exact fun t ht => by convert h_upper t ht using 1 ; ring;

/-
Stepping lemma: if Gamma growth bounds hold for σ + 1, they hold for σ.
-/
theorem gamma_growth_step_down {σ : ℝ} {C₁ C₂ : ℝ} (h : HasGammaGrowth (σ + 1) C₁ C₂) :
    ∃ C₁' C₂', HasGammaGrowth σ C₁' C₂' := by
      have h_recurrence : ∀ t : ℝ, Complex.Gamma (σ + t * Complex.I) = Complex.Gamma (σ + 1 + t * Complex.I) / (σ + t * Complex.I) := by
        intro t;
        by_cases h : ( σ : ℂ ) + t * Complex.I = 0 <;> simp_all +decide [ Complex.Gamma_add_one, mul_comm, div_eq_mul_inv ];
        rw [ inv_mul_eq_div, eq_div_iff h ] ; rw [ show ( σ : ℂ ) + 1 + Complex.I * t = ( σ : ℂ ) + Complex.I * t + 1 by ring ] ; rw [ Complex.Gamma_add_one ] ; ring ; aesop;
      have h_bound : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (σ + t * Complex.I)‖ = ‖Complex.Gamma (σ + 1 + t * Complex.I)‖ / Real.sqrt (σ^2 + t^2) := by
        intro t ht; rw [ h_recurrence t ] ; rw [ norm_div ] ; norm_num [ Complex.normSq, Complex.norm_def ] ; ring;
      obtain ⟨C₁', C₂', hC₁', hC₂'⟩ : ∃ C₁' C₂' : ℝ, 0 < C₁' ∧ 0 < C₂' ∧ ∀ t : ℝ, 1 ≤ |t| → C₁' * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (σ + t * Complex.I)‖ ∧ ‖Complex.Gamma (σ + t * Complex.I)‖ ≤ C₂' * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) := by
        obtain ⟨C₁', C₂', hC₁', hC₂'⟩ : ∃ C₁' C₂' : ℝ, 0 < C₁' ∧ 0 < C₂' ∧ ∀ t : ℝ, 1 ≤ |t| → C₁' * |t|^(σ + 1 - 1/2) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (σ + 1 + t * Complex.I)‖ ∧ ‖Complex.Gamma (σ + 1 + t * Complex.I)‖ ≤ C₂' * |t|^(σ + 1 - 1/2) * Real.exp (-Real.pi * |t| / 2) := by
          exact ⟨ C₁, C₂, h.hC₁, h.hC₂, fun t ht => ⟨ by simpa using h.lower t ht, by simpa using h.upper t ht ⟩ ⟩;
        obtain ⟨C₁'', C₂'', hC₁'', hC₂''⟩ : ∃ C₁'' C₂'' : ℝ, 0 < C₁'' ∧ 0 < C₂'' ∧ ∀ t : ℝ, 1 ≤ |t| → C₁'' * |t| ≤ Real.sqrt (σ^2 + t^2) ∧ Real.sqrt (σ^2 + t^2) ≤ C₂'' * |t| := by
          have h_bounds : ∀ t : ℝ, 1 ≤ |t| → |t| ≤ Real.sqrt (σ^2 + t^2) ∧ Real.sqrt (σ^2 + t^2) ≤ |t| + |σ| := by
            exact fun t ht => ⟨ Real.abs_le_sqrt <| by nlinarith, Real.sqrt_le_iff.mpr ⟨ by positivity, by cases abs_cases t <;> cases abs_cases σ <;> nlinarith ⟩ ⟩;
          use 1, 1 + |σ|;
          exact ⟨ by norm_num, by positivity, fun t ht => ⟨ by linarith [ h_bounds t ht ], by nlinarith [ h_bounds t ht, abs_nonneg σ, abs_nonneg t ] ⟩ ⟩;
        refine' ⟨ C₁' / C₂'', C₂' / C₁'', div_pos hC₁' hC₂''.1, div_pos hC₂'.1 hC₁'', fun t ht => _ ⟩;
        constructor <;> simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
        · refine' le_trans _ ( mul_le_mul_of_nonneg_right ( hC₂'.2 t ht |>.1 ) ( inv_nonneg.2 ( Real.sqrt_nonneg _ ) ) );
          rw [ show σ + 1 - 2⁻¹ = σ - 2⁻¹ + 1 by ring, Real.rpow_add_one ( by positivity ) ] ; ring_nf ; norm_num [ hC₁''.ne', hC₂''.1.ne' ];
          field_simp;
          rw [ div_le_div_iff₀ ] <;> nlinarith [ hC₂''.2 t ht, Real.sqrt_nonneg ( σ ^ 2 + t ^ 2 ), Real.mul_self_sqrt ( by positivity : 0 ≤ σ ^ 2 + t ^ 2 ), abs_nonneg t ];
        · refine' le_trans ( mul_le_mul_of_nonneg_left ( inv_anti₀ ( by positivity ) ( hC₂''.2 t ht |>.1 ) ) ( by positivity ) ) _;
          convert mul_le_mul_of_nonneg_right ( hC₂'.2 t ht |>.2 ) ( inv_nonneg.2 ( mul_nonneg hC₁''.le ( abs_nonneg t ) ) ) using 1 ; ring;
          rw [ show ( -1 / 2 + σ : ℝ ) = ( 1 / 2 + σ ) - 1 by ring, Real.rpow_sub_one ( by positivity ) ] ; ring;
      exact ⟨ C₁', C₂', ⟨ hC₁', hC₂'.1, fun t ht => hC₂'.2 t ht |>.1, fun t ht => hC₂'.2 t ht |>.2 ⟩ ⟩

/-
Bounds for the complex sine function on vertical lines.
-/
theorem complex_sin_growth (σ : ℝ) :
    ∃ C₁ C₂, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
      C₁ * Real.exp (Real.pi * |t|) ≤ ‖Complex.sin (Real.pi * (↑σ + ↑t * Complex.I))‖ ∧
      ‖Complex.sin (Real.pi * (↑σ + ↑t * Complex.I))‖ ≤ C₂ * Real.exp (Real.pi * |t|) := by
        have h_sin_identity : ∀ t : ℝ, ‖Complex.sin (Real.pi * (σ + t * Complex.I))‖ = (1 / 2) * ‖Complex.exp (Complex.I * Real.pi * σ) * Complex.exp (-Real.pi * t) - Complex.exp (-Complex.I * Real.pi * σ) * Complex.exp (Real.pi * t)‖ := by
          norm_num [ Complex.sin, Complex.exp_add ] ; intros ; ring;
          norm_num [ ← Complex.exp_add ] ; ring;
          rw [ neg_add_eq_sub, norm_sub_rev ];
          rw [ neg_add_eq_sub ];
        field_simp;
        have h_triangle : ∀ t : ℝ, ‖Complex.exp (Complex.I * Real.pi * σ) * Complex.exp (-Real.pi * t) - Complex.exp (-Complex.I * Real.pi * σ) * Complex.exp (Real.pi * t)‖ ≥ Real.exp (Real.pi * |t|) - Real.exp (-Real.pi * |t|) := by
          intros t
          have h_triangle : ‖Complex.exp (Complex.I * Real.pi * σ) * Complex.exp (-Real.pi * t) - Complex.exp (-Complex.I * Real.pi * σ) * Complex.exp (Real.pi * t)‖ ≥ |‖Complex.exp (Complex.I * Real.pi * σ) * Complex.exp (-Real.pi * t)‖ - ‖Complex.exp (-Complex.I * Real.pi * σ) * Complex.exp (Real.pi * t)‖| := by
            exact abs_norm_sub_norm_le _ _;
          norm_num [ Complex.norm_exp ] at *;
          cases abs_cases t <;> simp +decide [ * ] at * <;> linarith [ abs_le.mp h_triangle ];
        have h_triangle_upper : ∀ t : ℝ, ‖Complex.exp (Complex.I * Real.pi * σ) * Complex.exp (-Real.pi * t) - Complex.exp (-Complex.I * Real.pi * σ) * Complex.exp (Real.pi * t)‖ ≤ Real.exp (Real.pi * |t|) + Real.exp (-Real.pi * |t|) := by
          intro t; refine' le_trans ( norm_sub_le _ _ ) _ ; norm_num [ ← Complex.exp_add ] ; ring_nf ;
          norm_num [ Complex.norm_exp ] ; cases abs_cases t <;> simp +decide [ * ] ; ring_nf ; norm_num [ Real.pi_pos.le ] ;
        refine' ⟨ 1 / 4, 1, by norm_num, by norm_num, fun t ht => ⟨ _, _ ⟩ ⟩ <;> norm_num [ h_sin_identity ];
        · have := h_triangle t; ring_nf at *; norm_num at *;
          nlinarith [ Real.pi_gt_three, Real.exp_pos ( |t| * Real.pi ), Real.exp_pos ( - ( |t| * Real.pi ) ), Real.exp_neg ( |t| * Real.pi ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( |t| * Real.pi ) ) ), Real.add_one_le_exp ( |t| * Real.pi ), Real.add_one_le_exp ( - ( |t| * Real.pi ) ) ];
        · have := h_triangle_upper t; ring_nf at *; norm_num at *;
          linarith [ Real.exp_pos ( |t| * Real.pi ), Real.exp_le_exp.2 ( show - ( |t| * Real.pi ) ≤ |t| * Real.pi by nlinarith [ Real.pi_pos, abs_nonneg t ] ) ]

/-
Gamma growth bounds hold for all half-integer lines Re(s) = 1/2 + k.
-/
theorem gamma_growth_half_int (k : ℤ) :
    ∃ C₁ C₂, HasGammaGrowth (1/2 + k) C₁ C₂ := by
      induction' k using Int.induction_on with k hk;
      · simpa using gamma_half_growth;
      · norm_num +zetaDelta at *;
        simpa only [ ← add_assoc ] using gamma_growth_step_up hk.choose_spec.choose_spec;
      · rename_i k hk;
        obtain ⟨ C₁, C₂, h ⟩ := hk; exact gamma_growth_step_down ( by convert h using 1; push_cast; ring ) ;

/-
The term e^{-t arg(σ+it)} behaves like e^{-π|t|/2} for fixed σ > 0.
-/
theorem exp_neg_t_arg_bound (σ : ℝ) (hσ : 0 < σ) :
    ∃ C₁ C₂, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
    C₁ * Real.exp (-Real.pi * |t| / 2) ≤ Real.exp (-t * Complex.arg (↑σ + ↑t * I)) ∧
    Real.exp (-t * Complex.arg (↑σ + ↑t * I)) ≤ C₂ * Real.exp (-Real.pi * |t| / 2) := by
      have h_arctan_pos : ∀ t : ℝ, 1 ≤ t → Complex.arg (σ + t * Complex.I) = Real.pi / 2 - Real.arctan (σ / t) := by
        intro t ht; rw [ Complex.arg ] ; norm_num [ Complex.normSq, Complex.norm_def, hσ.le, ht ];
        rw [ Real.arcsin_eq_of_sin_eq ];
        · rw [ Real.sin_pi_div_two_sub, Real.cos_arctan ];
          field_simp;
          rw [ add_comm, Real.sqrt_div ( by positivity ), Real.sqrt_sq ( by positivity ), mul_div_cancel₀ _ ( by positivity ) ];
        · constructor <;> linarith [ Real.arctan_nonneg.2 ( by positivity : 0 ≤ σ / t ), Real.arctan_lt_pi_div_two ( σ / t ) ];
      have h_exp_pos (t : ℝ) (ht : 1 ≤ t) : Real.exp (-t * Complex.arg (σ + t * Complex.I)) = Real.exp (-Real.pi * t / 2 + t * Real.arctan (σ / t)) := by
        exact congr_arg _ ( by rw [ h_arctan_pos t ht ] ; ring );
      have h_exp_pos_bound : ∀ t : ℝ, 1 ≤ t → Real.exp (-t * Complex.arg (σ + t * Complex.I)) ≤ Real.exp (-Real.pi * t / 2 + σ) := by
        have h_arctan_bound : ∀ t : ℝ, 1 ≤ t → t * Real.arctan (σ / t) ≤ σ := by
          intros t ht
          have h_arctan_le : Real.arctan (σ / t) ≤ σ / t := by
            simpa using Real.le_tan ( by positivity ) ( Real.arctan_lt_pi_div_two _ );
          rwa [ le_div_iff₀' ( by positivity ) ] at h_arctan_le;
        exact fun t ht => h_exp_pos t ht ▸ Real.exp_le_exp.mpr ( by linarith [ h_arctan_bound t ht ] );
      have h_exp_neg_bound : ∀ t : ℝ, t ≤ -1 → Real.exp (-t * Complex.arg (σ + t * Complex.I)) ≥ Real.exp (-Real.pi * |t| / 2) := by
        intros t ht
        have h_arg_neg : Complex.arg (σ + t * Complex.I) = -Real.pi / 2 + Real.arctan (σ / |t|) := by
          rw [ Complex.arg ];
          split_ifs <;> simp_all +decide [ Complex.normSq, Complex.norm_def, Real.arcsin_eq_arctan ];
          · rw [ Real.arcsin_eq_of_sin_eq ];
            · norm_num [ neg_div, Real.sin_add, Real.sin_arctan, Real.cos_arctan ];
              rw [ abs_of_nonpos ( by linarith ), inv_eq_one_div, neg_div', div_eq_div_iff ] <;> ring <;> norm_num [ hσ.le, hσ.ne', ht ];
              · rw [ show σ ^ 2 + t ^ 2 = t ^ 2 * ( 1 + σ ^ 2 / t ^ 2 ) by nlinarith [ mul_div_cancel₀ ( σ ^ 2 ) ( by nlinarith : t ^ 2 ≠ 0 ) ], Real.sqrt_mul ( by nlinarith ), Real.sqrt_sq_eq_abs, abs_of_nonpos ( by nlinarith ) ] ; ring;
              · positivity;
              · positivity;
            · constructor <;> linarith [ Real.arctan_nonneg.2 ( show 0 ≤ σ / |t| by positivity ), Real.arctan_lt_pi_div_two ( σ / |t| ) ];
          · linarith;
          · linarith;
        rw [ h_arg_neg, abs_of_nonpos ( by linarith ) ] ; ring_nf ; norm_num;
        exact mul_nonneg_of_nonpos_of_nonpos ( by linarith ) ( Real.arctan_le_zero.mpr ( mul_nonpos_of_nonneg_of_nonpos hσ.le ( inv_nonpos.mpr ( by linarith ) ) ) );
      have h_exp_neg_bound_upper : ∀ t : ℝ, t ≤ -1 → Real.exp (-t * Complex.arg (σ + t * Complex.I)) ≤ Real.exp (-Real.pi * |t| / 2 + σ) := by
        intros t ht
        have h_arg_neg : Complex.arg (σ + t * Complex.I) = -Real.pi / 2 + Real.arctan (σ / |t|) := by
          rw [ Complex.arg ];
          norm_num [ Complex.normSq, Complex.norm_def, Real.arctan_eq_arcsin ];
          rw [ if_pos hσ.le ];
          rw [ Real.arcsin_eq_of_sin_eq ];
          · norm_num [ neg_div, Real.sin_add, Real.sin_arcsin, Real.cos_arcsin ];
            rw [ neg_eq_iff_eq_neg, Real.sqrt_eq_iff_mul_self_eq_of_pos ] <;> norm_num [ abs_of_nonpos ( by linarith : t ≤ 0 ), hσ.ne', le_of_lt hσ ];
            · field_simp;
              rw [ Real.sq_sqrt <| by positivity, Real.sq_sqrt <| by positivity ] ; ring;
              norm_num [ show t ≠ 0 by linarith ];
              rw [ mul_right_comm, mul_inv_cancel₀ ( by nlinarith ), one_mul ];
            · exact div_neg_of_neg_of_pos ( by linarith ) ( Real.sqrt_pos.mpr ( by nlinarith ) );
          · constructor <;> linarith [ Real.arcsin_nonneg.2 ( show 0 ≤ σ / |t| / Real.sqrt ( 1 + ( σ / |t| ) ^ 2 ) by positivity ), Real.arcsin_le_pi_div_two ( σ / |t| / Real.sqrt ( 1 + ( σ / |t| ) ^ 2 ) ) ];
        simp_all +decide [ abs_of_nonpos ( by linarith : t ≤ 0 ) ];
        have := h_exp_pos_bound ( -t ) ( by linarith ) ; ring_nf at *; linarith [ Real.pi_pos, mul_inv_cancel₀ ( by linarith : ( -t ) ≠ 0 ) ] ;
      refine' ⟨ 1, Real.exp σ, zero_lt_one, Real.exp_pos _, fun t ht => ⟨ _, _ ⟩ ⟩ <;> cases abs_cases t <;> simp_all +decide [ Real.exp_add ];
      · rw [ abs_of_nonneg ‹_› ] ; exact le_mul_of_one_le_right ( by positivity ) ( Real.one_le_exp ( by exact mul_nonneg ( by positivity ) ( Real.arctan_nonneg.mpr ( by positivity ) ) ) ) ;
      · exact h_exp_neg_bound t ( by linarith );
      · convert h_exp_pos_bound t ht using 1 ; rw [ abs_of_nonneg ‹_› ] ; ring;
      · simpa only [ mul_comm ] using h_exp_neg_bound_upper t ( by linarith )

/-
Defining the Stirling kernel z^{z-1/2}e^{-z}.
-/
noncomputable def stirling_kernel (z : ℂ) : ℂ := z^(z - 1/2) * exp (-z)

/-
Proving the growth bound for the Stirling kernel.
-/
theorem stirling_kernel_bound (σ : ℝ) (hσ : 0 < σ) :
    ∃ C₁ C₂, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
    C₁ * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) ≤ ‖stirling_kernel (↑σ + ↑t * I)‖ ∧
    ‖stirling_kernel (↑σ + ↑t * I)‖ ≤ C₂ * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) := by
      obtain ⟨C₁, C₂, hC₁, hC₂, h_bounds⟩ : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| → C₁ * Real.exp (-Real.pi * |t| / 2) ≤ Real.exp (-t * Complex.arg (↑σ + ↑t * I)) ∧ Real.exp (-t * Complex.arg (↑σ + ↑t * I)) ≤ C₂ * Real.exp (-Real.pi * |t| / 2) := by
        convert exp_neg_t_arg_bound σ hσ using 1;
      have h_commensurable : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| → C₁ * |t| ^ (σ - 1 / 2) ≤ ‖(σ + t * I)‖ ^ (σ - 1 / 2) ∧ ‖(σ + t * I)‖ ^ (σ - 1 / 2) ≤ C₂ * |t| ^ (σ - 1 / 2) := by
        have h_bounds : ∀ t : ℝ, 1 ≤ |t| → |t| ≤ ‖(σ + t * I)‖ ∧ ‖(σ + t * I)‖ ≤ |t| * Real.sqrt (1 + σ^2) := by
          intro t ht; constructor <;> norm_num [ Complex.normSq, Complex.norm_def ];
          · exact Real.abs_le_sqrt ( by nlinarith );
          · rw [ Real.sqrt_le_iff ] ; ring_nf ; norm_num;
            exact ⟨ by positivity, by rw [ Real.sq_sqrt <| by positivity ] ; nlinarith [ show t ^ 2 ≥ 1 by nlinarith [ abs_mul_abs_self t ] ] ⟩;
        field_simp;
        by_cases h : ( σ * 2 - 1 ) / 2 ≥ 0;
        · refine' ⟨ 1, Real.sqrt ( 1 + σ ^ 2 ) ^ ( ( σ * 2 - 1 ) / 2 ), by positivity, by positivity, fun t ht => ⟨ _, _ ⟩ ⟩ <;> norm_num [ Real.rpow_nonneg, h ];
          · exact Real.rpow_le_rpow ( by positivity ) ( h_bounds t ht |>.1 ) ( by positivity );
          · rw [ ← Real.mul_rpow ( by positivity ) ( by positivity ) ] ; exact Real.rpow_le_rpow ( by positivity ) ( by nlinarith [ h_bounds t ht, abs_nonneg t ] ) ( by positivity );
        · refine' ⟨ ( Real.sqrt ( 1 + σ ^ 2 ) ) ^ ( ( σ * 2 - 1 ) / 2 ), 1, _, _, _ ⟩ <;> norm_num;
          · positivity;
          · intro t ht; rw [ ← Real.mul_rpow ( by positivity ) ( by positivity ) ] ; exact ⟨ by rw [ Real.rpow_le_rpow_iff_of_neg ] <;> nlinarith [ h_bounds t ht, Real.sqrt_nonneg ( 1 + σ ^ 2 ), Real.mul_self_sqrt ( by positivity : 0 ≤ 1 + σ ^ 2 ) ], by rw [ Real.rpow_le_rpow_iff_of_neg ] <;> nlinarith [ h_bounds t ht, Real.sqrt_nonneg ( 1 + σ ^ 2 ), Real.mul_self_sqrt ( by positivity : 0 ≤ 1 + σ ^ 2 ) ] ⟩ ;
      obtain ⟨C₁', C₂', hC₁', hC₂', h_commensurable'⟩ := h_commensurable;
      use C₁' * C₁ * Real.exp (-σ), C₂' * C₂ * Real.exp (-σ); (
      refine' ⟨ by positivity, by positivity, fun t ht => ⟨ _, _ ⟩ ⟩ <;> simp_all +decide [ stirling_kernel, Complex.norm_exp ];
      · convert mul_le_mul_of_nonneg_right ( mul_le_mul ( h_commensurable' t ht |>.1 ) ( h_bounds t ht |>.1 ) ( by positivity ) ( by positivity ) ) ( Real.exp_nonneg ( -σ ) ) using 1 ; ring;
        rw [ Complex.norm_cpow_of_ne_zero ] <;> norm_num [ Complex.ext_iff, hσ.ne' ] ; ring;
        rw [ ← Real.exp_neg ];
      · convert mul_le_mul_of_nonneg_right ( mul_le_mul ( h_commensurable' t ht |>.2 ) ( h_bounds t ht |>.2 ) ( by positivity ) ( by positivity ) ) ( Real.exp_nonneg ( -σ ) ) using 1 ; ring;
        · rw [ Complex.norm_cpow_of_ne_zero ] <;> norm_num [ Complex.ext_iff, hσ.ne' ] ; ring;
          rw [ ← Real.exp_neg ] ; ring;
        · ring)

/-
Proving that the Stirling ratio is bounded on vertical lines with positive real part.
-/
noncomputable def stirling_ratio (z : ℂ) : ℂ := Gamma z / stirling_kernel z

theorem stirling_ratio_bound_on_lines (k : ℤ) (hk : 0 < 1/2 + (k : ℝ)) :
    ∃ B : ℝ, ∀ t : ℝ, 1 ≤ |t| → ‖stirling_ratio (1/2 + k + t * I)‖ ≤ B := by
      obtain ⟨C₁, C₂, hC₁, hC₂, h_bound⟩ : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
        C₁ * |t|^(1/2 + k - 1/2 : ℝ) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (1/2 + k + t * Complex.I)‖ ∧
        ‖Complex.Gamma (1/2 + k + t * Complex.I)‖ ≤ C₂ * |t|^(1/2 + k - 1/2 : ℝ) * Real.exp (-Real.pi * |t| / 2) := by
          obtain ⟨ C₁', C₂', hC₁', hC₂', hC' ⟩ := gamma_growth_half_int k; use C₁', C₂'; aesop;
      have h_stirling_bound : ∃ B : ℝ, ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (1/2 + k + t * Complex.I)‖ / ‖stirling_kernel (1/2 + k + t * Complex.I)‖ ≤ B := by
        obtain ⟨D₁, D₂, hD₁, hD₂, h_stirling_bound⟩ : ∃ D₁ D₂ : ℝ, 0 < D₁ ∧ 0 < D₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
          D₁ * |t|^(1/2 + k - 1/2 : ℝ) * Real.exp (-Real.pi * |t| / 2) ≤ ‖stirling_kernel (1/2 + k + t * Complex.I)‖ ∧
          ‖stirling_kernel (1/2 + k + t * Complex.I)‖ ≤ D₂ * |t|^(1/2 + k - 1/2 : ℝ) * Real.exp (-Real.pi * |t| / 2) := by
            convert stirling_kernel_bound ( 1 / 2 + k ) ( by linarith ) using 1;
            norm_num [ Complex.ofReal_add, Complex.ofReal_mul ];
        use C₂ / D₁;
        intro t ht; rw [ div_le_div_iff₀ ] <;> nlinarith [ h_bound t ht, h_stirling_bound t ht, show 0 < |t| ^ ( 1 / 2 + ( k : ℝ ) - 1 / 2 ) * Real.exp ( -Real.pi * |t| / 2 ) by positivity ] ;
      unfold stirling_ratio; aesop;

/-
The Stirling ratio is differentiable on the strip and continuous on its closure.
-/
open Set Filter Topology

lemma stirling_ratio_diff_cont (k : ℤ) (hk : 0 < 1/2 + (k : ℝ)) :
    DiffContOnCl ℂ stirling_ratio {z : ℂ | 1/2 + k < z.re ∧ z.re < 1/2 + k + 1} := by
      refine' DifferentiableOn.diffContOnCl _;
      have h_diff : DifferentiableOn ℂ (fun z : ℂ => Gamma z / stirling_kernel z) {z : ℂ | 1 / 2 + (k : ℝ) ≤ z.re ∧ z.re ≤ 1 / 2 + (k : ℝ) + 1} := by
        refine' DifferentiableOn.div _ _ _;
        · refine' fun z hz => DifferentiableAt.differentiableWithinAt _;
          refine' Complex.differentiableAt_Gamma _ _;
          intro m hm; norm_num [ Complex.ext_iff ] at hm; linarith [ hz.1, hz.2 ] ;
        · refine' DifferentiableOn.mul _ _;
          · refine' DifferentiableOn.cpow _ _ _;
            · exact differentiableOn_id;
            · fun_prop;
            · exact fun z hz => Or.inl <| by linarith [ hz.1 ] ;
          · exact DifferentiableOn.cexp ( differentiableOn_id.neg );
        · unfold stirling_kernel;
          norm_num [ Complex.exp_ne_zero ];
          rintro x hx₁ hx₂ rfl; norm_num at * ; linarith;
      refine' h_diff.mono _;
      exact closure_minimal ( fun x hx => ⟨ hx.1.le, hx.2.le ⟩ ) ( isClosed_Icc.preimage Complex.continuous_re )

end Aristotle.GammaGrowthGeneral

end
