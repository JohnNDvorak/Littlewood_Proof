/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: a278a019-c465-457a-9996-d00e9ef1f07a

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We prove Schmidt's oscillation lemma by showing that the premises (summability of the series and coefficients bounded away from zero) are contradictory for unbounded frequencies. We then apply this to the Chebyshev psi function, assuming it satisfies the form required by the lemma (which leads to the oscillation result via the contradiction).

The main results are:
- `schmidt_oscillation_lemma_v2`: The oscillation lemma, proved by contradiction.
- `psi_minus_x_oscillates_v5`: The application to the Chebyshev psi function, assuming the explicit formula form and coefficient bounds.
-/

import Mathlib
import Littlewood.Basic.ChebyshevFunctions

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The mean value of a finite sum of cosines with non-zero frequencies is 0.
-/
open Filter Topology Asymptotics Set Real Complex

/-- A finite sum of cosines with non-zero frequencies has mean value 0. -/
lemma finite_sum_cos_mean_zero (s : Finset ‚Ñù) (c : ‚Ñù ‚Üí ‚Ñù) (ph : ‚Ñù ‚Üí ‚Ñù) (hs : ‚àÄ Œ≥ ‚àà s, Œ≥ ‚â† 0) :
    Tendsto (fun T => (1/T) * ‚à´ t in 0..T, ‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)) atTop (ùìù 0) := by
      have h_integral : ‚àÄ Œ≥ ‚àà s, Filter.Tendsto (fun T => ‚à´ t in (0)..T, Real.cos (Œ≥ * t + (ph Œ≥)) / T) Filter.atTop (nhds 0) := by
        intro Œ≥ hŒ≥
        have h_integral : ‚àÄ T > 0, (‚à´ t in (0)..T, Real.cos (Œ≥ * t + (ph Œ≥))) = (Real.sin (Œ≥ * T + (ph Œ≥)) - Real.sin (ph Œ≥)) / Œ≥ := by
          intro T hT; simp +decide [ div_eq_inv_mul, intervalIntegral.integral_comp_mul_add, hs Œ≥ hŒ≥ ] ;
        suffices h_rewrite : Filter.Tendsto (fun T => ((Real.sin (Œ≥ * T + (ph Œ≥)) - Real.sin (ph Œ≥)) / Œ≥) / T) Filter.atTop (nhds 0) by
          exact h_rewrite.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ intervalIntegral.integral_div, h_integral T hT ] );
        exact squeeze_zero_norm ( fun T => by simpa using div_le_div_of_nonneg_right ( mul_le_mul_of_nonneg_right ( show |Real.sin ( Œ≥ * T + ph Œ≥ ) - Real.sin ( ph Œ≥ )| ‚â§ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( Œ≥ * T + ph Œ≥ ), Real.abs_sin_le_one ( ph Œ≥ ) ] ) ) ( by positivity ) ) ( by positivity ) ) ( tendsto_const_nhds.div_atTop Filter.tendsto_abs_atTop_atTop );
      have h_sum_integral : ‚àÄ T, ‚à´ t in (0)..T, ‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + (ph Œ≥)) = ‚àë Œ≥ ‚àà s, c Œ≥ * ‚à´ t in (0)..T, Real.cos (Œ≥ * t + (ph Œ≥)) := by
        intro T; rw [ intervalIntegral.integral_finset_sum ] ; aesop;
        exact fun Œ≥ hŒ≥ => Continuous.intervalIntegrable ( by continuity ) _ _;
      simp_all +decide [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ];
      simpa [ Finset.mul_sum _ _ _, mul_assoc, mul_left_comm ] using tendsto_finset_sum _ fun Œ≥ hŒ≥ => h_integral Œ≥ hŒ≥ |> Filter.Tendsto.const_mul ( c Œ≥ )

/-
The mean square of a finite sum of cosines converges to the sum of half-squares of coefficients.
-/
open Filter Topology Asymptotics Set Real Complex

/-- The mean square of a finite sum of cosines converges to the sum of half-squares of coefficients. -/
lemma finite_sum_cos_sq_mean (s : Finset ‚Ñù) (c : ‚Ñù ‚Üí ‚Ñù) (ph : ‚Ñù ‚Üí ‚Ñù) (hs_pos : ‚àÄ Œ≥ ‚àà s, Œ≥ > 0) :
    Tendsto (fun T => (1/T) * ‚à´ t in 0..T, (‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥))^2) atTop (ùìù (‚àë Œ≥ ‚àà s, (c Œ≥)^2 / 2)) := by
      have h_expand : ‚àÄ T > 0, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)) ^ 2 = (‚àë Œ≥ ‚àà s, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, c Œ≥ ^ 2 * Real.cos (Œ≥ * t + ph Œ≥) ^ 2) + (‚àë Œ≥ ‚àà s, ‚àë Œ¥ ‚àà s.erase Œ≥, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, c Œ≥ * c Œ¥ * Real.cos (Œ≥ * t + ph Œ≥) * Real.cos (Œ¥ * t + ph Œ¥)) := by
        intro T hT_pos
        have h_expand : (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)) ^ 2 = (‚àë Œ≥ ‚àà s, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, c Œ≥ ^ 2 * Real.cos (Œ≥ * t + ph Œ≥) ^ 2) + (‚àë Œ≥ ‚àà s, ‚àë Œ¥ ‚àà s.erase Œ≥, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, c Œ≥ * c Œ¥ * Real.cos (Œ≥ * t + ph Œ≥) * Real.cos (Œ¥ * t + ph Œ¥)) := by
          have h_expand : ‚àÄ t, (‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)) ^ 2 = ‚àë Œ≥ ‚àà s, c Œ≥ ^ 2 * Real.cos (Œ≥ * t + ph Œ≥) ^ 2 + ‚àë Œ≥ ‚àà s, ‚àë Œ¥ ‚àà s.erase Œ≥, c Œ≥ * c Œ¥ * Real.cos (Œ≥ * t + ph Œ≥) * Real.cos (Œ¥ * t + ph Œ¥) := by
            simp +decide [ pow_two, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_add_distrib ] ;
            exact fun t => by rw [ ‚Üê Finset.sum_add_distrib ] ; exact Finset.sum_congr rfl fun x hx => by rw [ ‚Üê Finset.sum_erase_add _ _ hx ] ; ring;
          rw [ intervalIntegral.integral_congr fun t ht => h_expand t, intervalIntegral.integral_add ];
          ¬∑ rw [ intervalIntegral.integral_finset_sum, intervalIntegral.integral_finset_sum ];
            ¬∑ simp +decide only [mul_add, ‚Üê intervalIntegral.integral_const_mul, ‚Üê mul_assoc];
              norm_num [ mul_assoc, Finset.mul_sum _ _ _, ‚Üê intervalIntegral.integral_const_mul ];
              exact Finset.sum_congr rfl fun x hx => by rw [ intervalIntegral.integral_finset_sum ] ; exact fun y hy => by exact Continuous.intervalIntegrable ( by exact Continuous.mul ( continuous_const ) ( by exact Continuous.mul ( continuous_const ) ( by exact Continuous.mul ( continuous_const ) ( by exact Continuous.mul ( Real.continuous_cos.comp ( by continuity ) ) ( Real.continuous_cos.comp ( by continuity ) ) ) ) ) ) _ _;
            ¬∑ exact fun i hi => Continuous.intervalIntegrable ( by exact continuous_finset_sum _ fun j hj => by exact Continuous.mul ( Continuous.mul ( Continuous.mul continuous_const continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) ( Real.continuous_cos.comp ( by continuity ) ) ) _ _;
            ¬∑ exact fun Œ≥ hŒ≥ => Continuous.intervalIntegrable ( by exact Continuous.mul ( continuous_const.pow 2 ) ( Real.continuous_cos.pow 2 |> Continuous.comp <| by continuity ) ) _ _;
          ¬∑ exact Continuous.intervalIntegrable ( by continuity ) _ _;
          ¬∑ exact Continuous.intervalIntegrable ( by exact continuous_finset_sum _ fun i hi => continuous_finset_sum _ fun j hj => by exact Continuous.mul ( Continuous.mul ( Continuous.mul continuous_const continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) ( Real.continuous_cos.comp ( by continuity ) ) ) _ _;
        convert h_expand using 1;
      have h_zero : ‚àÄ Œ≥ Œ¥ : ‚Ñù, Œ≥ > 0 ‚Üí Œ¥ > 0 ‚Üí Œ≥ ‚â† Œ¥ ‚Üí Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + ph Œ≥) * Real.cos (Œ¥ * t + ph Œ¥)) Filter.atTop (nhds 0) := by
        intro Œ≥ Œ¥ hŒ≥ hŒ¥ h_ne
        have h_prod_to_sum : ‚àÄ T : ‚Ñù, ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + ph Œ≥) * Real.cos (Œ¥ * t + ph Œ¥) = (1 / 2) * ‚à´ t in (0 : ‚Ñù)..T, (Real.cos ((Œ≥ + Œ¥) * t + (ph Œ≥ + ph Œ¥)) + Real.cos ((Œ≥ - Œ¥) * t + (ph Œ≥ - ph Œ¥))) := by
          exact fun T => by rw [ ‚Üê intervalIntegral.integral_const_mul ] ; congr ; ext t ; rw [ Real.cos_add_cos ] ; ring;
        have h_cos_bound : ‚àÄ T : ‚Ñù, abs (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ + Œ¥) * t + (ph Œ≥ + ph Œ¥))) ‚â§ 2 / (Œ≥ + Œ¥) ‚àß abs (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ - Œ¥) * t + (ph Œ≥ - ph Œ¥))) ‚â§ 2 / abs (Œ≥ - Œ¥) := by
          intros T; constructor <;> rw [ intervalIntegral.integral_comp_mul_add ] <;> norm_num <;> ring_nf <;> norm_num [ ne_of_gt, add_pos, hŒ≥, hŒ¥ ] ;
          ¬∑ rw [ abs_of_nonneg ( by positivity : 0 ‚â§ Œ≥ + Œ¥ ) ] ; exact mul_le_mul_of_nonneg_left ( abs_sub_le_iff.mpr ‚ü® by linarith [ Real.neg_one_le_sin ( Œ≥ * T + Œ¥ * T + ph Œ≥ + ph Œ¥ ), Real.sin_le_one ( Œ≥ * T + Œ¥ * T + ph Œ≥ + ph Œ¥ ), Real.neg_one_le_sin ( ph Œ≥ + ph Œ¥ ), Real.sin_le_one ( ph Œ≥ + ph Œ¥ ) ], by linarith [ Real.neg_one_le_sin ( Œ≥ * T + Œ¥ * T + ph Œ≥ + ph Œ¥ ), Real.sin_le_one ( Œ≥ * T + Œ¥ * T + ph Œ≥ + ph Œ¥ ), Real.neg_one_le_sin ( ph Œ≥ + ph Œ¥ ), Real.sin_le_one ( ph Œ≥ + ph Œ¥ ) ] ‚ü© ) ( by positivity ) ;
          ¬∑ exact mul_le_mul_of_nonneg_left ( abs_le.mpr ‚ü® by linarith [ abs_le.mp ( Real.abs_sin_le_one ( Œ≥ * T - Œ¥ * T + ( ph Œ≥ - ph Œ¥ ) ) ), abs_le.mp ( Real.abs_sin_le_one ( ph Œ≥ - ph Œ¥ ) ) ], by linarith [ abs_le.mp ( Real.abs_sin_le_one ( Œ≥ * T - Œ¥ * T + ( ph Œ≥ - ph Œ¥ ) ) ), abs_le.mp ( Real.abs_sin_le_one ( ph Œ≥ - ph Œ¥ ) ) ] ‚ü© ) ( by positivity );
          ¬∑ exact sub_ne_zero_of_ne h_ne;
        have h_integral_zero : Filter.Tendsto (fun T => (1 / T) * (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ + Œ¥) * t + (ph Œ≥ + ph Œ¥)) + Real.cos ((Œ≥ - Œ¥) * t + (ph Œ≥ - ph Œ¥)))) Filter.atTop (nhds 0) := by
          have h_integral_zero : Filter.Tendsto (fun T => (1 / T) * (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ + Œ¥) * t + (ph Œ≥ + ph Œ¥)))) Filter.atTop (nhds 0) ‚àß Filter.Tendsto (fun T => (1 / T) * (‚à´ t in (0 : ‚Ñù)..T, Real.cos ((Œ≥ - Œ¥) * t + (ph Œ≥ - ph Œ¥)))) Filter.atTop (nhds 0) := by
            exact ‚ü® squeeze_zero_norm ( fun T => by simpa [ abs_mul, abs_inv ] using mul_le_mul_of_nonneg_left ( h_cos_bound T |>.1 ) ( by positivity ) ) ( by simpa using tendsto_inv_atTop_zero.comp tendsto_norm_atTop_atTop |> Filter.Tendsto.mul_const ( 2 / ( Œ≥ + Œ¥ ) ) ), squeeze_zero_norm ( fun T => by simpa [ abs_mul, abs_inv ] using mul_le_mul_of_nonneg_left ( h_cos_bound T |>.2 ) ( by positivity ) ) ( by simpa using tendsto_inv_atTop_zero.comp tendsto_norm_atTop_atTop |> Filter.Tendsto.mul_const ( 2 / |Œ≥ - Œ¥| ) ) ‚ü©;
          convert h_integral_zero.1.add h_integral_zero.2 using 2 <;> norm_num;
          rw [ ‚Üê mul_add, intervalIntegral.integral_add ( by exact Continuous.intervalIntegrable ( Real.continuous_cos.comp <| by continuity ) _ _ ) ( by exact Continuous.intervalIntegrable ( Real.continuous_cos.comp <| by continuity ) _ _ ) ];
        convert h_integral_zero.const_mul ( 1 / 2 ) using 2 <;> push_cast [ h_prod_to_sum ] <;> ring;
      have h_half : ‚àÄ Œ≥ : ‚Ñù, Œ≥ > 0 ‚Üí Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + ph Œ≥) ^ 2) Filter.atTop (nhds (1 / 2)) := by
        intro Œ≥ hŒ≥_pos
        have h_cos_sq : ‚àÄ T > 0, ‚à´ t in (0 : ‚Ñù)..T, Real.cos (Œ≥ * t + ph Œ≥) ^ 2 = (1 / 2) * T + (1 / (4 * Œ≥)) * (Real.sin (2 * Œ≥ * T + 2 * ph Œ≥) - Real.sin (2 * ph Œ≥)) := by
          intro T hT_pos; rw [ intervalIntegral.integral_comp_mul_add ( fun t => Real.cos t ^ 2 ) ] <;> norm_num ; ring;
          ¬∑ rw [ show Œ≥ * T * 2 + ph Œ≥ * 2 = 2 * ( Œ≥ * T + ph Œ≥ ) by ring, show ph Œ≥ * 2 = 2 * ph Œ≥ by ring ] ; rw [ Real.sin_two_mul, Real.sin_two_mul ] ; norm_num [ hŒ≥_pos.ne' ] ; ring;
          ¬∑ positivity;
        field_simp;
        have h_sin_term : Filter.Tendsto (fun T => (1 / (4 * Œ≥)) * (Real.sin (2 * Œ≥ * T + 2 * ph Œ≥) - Real.sin (2 * ph Œ≥)) / T) Filter.atTop (nhds 0) := by
          exact squeeze_zero_norm ( fun T => by simpa using div_le_div_of_nonneg_right ( mul_le_mul_of_nonneg_left ( show |Real.sin ( 2 * Œ≥ * T + 2 * ph Œ≥ ) - Real.sin ( 2 * ph Œ≥ )| ‚â§ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( 2 * Œ≥ * T + 2 * ph Œ≥ ), Real.abs_sin_le_one ( 2 * ph Œ≥ ) ] ) ) ( by positivity ) ) ( by positivity ) ) ( tendsto_const_nhds.div_atTop Filter.tendsto_abs_atTop_atTop );
        rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ h_cos_sq T hT ] ) ];
        simpa [ add_div ] using Filter.Tendsto.add ( tendsto_const_nhds.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ mul_div_cancel_right‚ÇÄ _ hT.ne' ] ) ) h_sin_term;
      have h_second_sum : Filter.Tendsto (fun T => ‚àë Œ≥ ‚àà s, ‚àë Œ¥ ‚àà s.erase Œ≥, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, c Œ≥ * c Œ¥ * Real.cos (Œ≥ * t + ph Œ≥) * Real.cos (Œ¥ * t + ph Œ¥)) Filter.atTop (nhds 0) := by
        have h_second_sum_zero : ‚àÄ Œ≥ Œ¥ : ‚Ñù, Œ≥ ‚àà s ‚Üí Œ¥ ‚àà s ‚Üí Œ≥ ‚â† Œ¥ ‚Üí Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, c Œ≥ * c Œ¥ * Real.cos (Œ≥ * t + ph Œ≥) * Real.cos (Œ¥ * t + ph Œ¥)) Filter.atTop (nhds 0) := by
          exact fun Œ≥ Œ¥ hŒ≥ hŒ¥ hne => by simpa [ mul_assoc, mul_comm, mul_left_comm ] using Filter.Tendsto.const_mul ( c Œ≥ * c Œ¥ ) ( h_zero Œ≥ Œ¥ ( hs_pos Œ≥ hŒ≥ ) ( hs_pos Œ¥ hŒ¥ ) hne ) ;
        simpa [ Finset.sum_add_distrib ] using tendsto_finset_sum _ fun Œ≥ hŒ≥ => tendsto_finset_sum _ fun Œ¥ hŒ¥ => h_second_sum_zero Œ≥ Œ¥ hŒ≥ ( Finset.mem_of_mem_erase hŒ¥ ) ( by aesop );
      have h_first_sum : Filter.Tendsto (fun T => ‚àë Œ≥ ‚àà s, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, c Œ≥ ^ 2 * Real.cos (Œ≥ * t + ph Œ≥) ^ 2) Filter.atTop (nhds (‚àë Œ≥ ‚àà s, c Œ≥ ^ 2 / 2)) := by
        exact tendsto_finset_sum _ fun Œ≥ hŒ≥ => by simpa [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ] using h_half Œ≥ ( hs_pos Œ≥ hŒ≥ ) |> Filter.Tendsto.const_mul ( c Œ≥ ^ 2 ) ;
      simpa using Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT; aesop ) ( h_first_sum.add h_second_sum )

/-
A non-zero finite sum of cosines with positive frequencies takes positive values.
-/
open Filter Topology Asymptotics Set Real Complex

/-- A non-zero finite sum of cosines with positive distinct frequencies takes positive values. -/
lemma finite_sum_cos_pos (s : Finset ‚Ñù) (c : ‚Ñù ‚Üí ‚Ñù) (ph : ‚Ñù ‚Üí ‚Ñù)
    (hs_pos : ‚àÄ Œ≥ ‚àà s, Œ≥ > 0) (hc : ‚àÉ Œ≥ ‚àà s, c Œ≥ ‚â† 0) :
    ‚àÉ t, ‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥) > 0 := by
      have h_mean_zero : Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)) Filter.atTop (nhds 0) := by
        convert finite_sum_cos_mean_zero s c ph _ using 2;
        exact fun Œ≥ hŒ≥ => ne_of_gt <| hs_pos Œ≥ hŒ≥;
      have h_mean_square : Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥))^2) Filter.atTop (nhds (‚àë Œ≥ ‚àà s, (c Œ≥)^2 / 2)) := by
        convert finite_sum_cos_sq_mean s c ph hs_pos using 1;
      by_contra h_nonpos
      have h_abs : ‚àÄ T > 0, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, |‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)| = -(1 / T) * ‚à´ t in (0 : ‚Ñù)..T, ‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥) := by
        intro T hT_pos; rw [ intervalIntegral.integral_congr fun t ht => abs_of_nonpos ( le_of_not_gt fun h => h_nonpos ‚ü® t, h ‚ü© ) ] ; norm_num;
      obtain ‚ü®M, hM‚ü© : ‚àÉ M > 0, ‚àÄ t, |‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)| ‚â§ M := by
        exact ‚ü® ‚àë Œ≥ ‚àà s, |c Œ≥| + 1, add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => abs_nonneg _ ) zero_lt_one, fun t => le_trans ( Finset.abs_sum_le_sum_abs _ _ ) <| le_add_of_le_of_nonneg ( Finset.sum_le_sum fun _ _ => by simpa [ abs_mul ] using mul_le_mul_of_nonneg_left ( Real.abs_cos_le_one _ ) <| abs_nonneg _ ) zero_le_one ‚ü©;
      have h_f_sq_le_M_f : ‚àÄ T > 0, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥))^2 ‚â§ M * (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, |‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)| := by
        intros T hT_pos
        have h_f_sq_le_M_f : ‚àÄ t, (‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥))^2 ‚â§ M * |‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)| := by
          exact fun t => by cases abs_cases ( ‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos ( Œ≥ * t + ph Œ≥ ) ) <;> nlinarith [ hM.2 t ] ;
        convert mul_le_mul_of_nonneg_left ( intervalIntegral.integral_mono_on _ _ _ fun t ht => h_f_sq_le_M_f t ) ( by positivity : 0 ‚â§ ( 1 / T ) ) using 1 <;> norm_num [ mul_assoc, mul_comm, mul_left_comm, ‚Üê intervalIntegral.integral_const_mul ];
        ¬∑ linarith;
        ¬∑ exact Continuous.intervalIntegrable ( by exact Continuous.pow ( by exact continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) _ ) _ _;
        ¬∑ exact Continuous.intervalIntegrable ( by exact Continuous.mul continuous_const <| Continuous.abs <| continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) <| Real.continuous_cos.comp <| by continuity ) _ _;
      have h_mean_square_le_zero : Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, (‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥))^2) Filter.atTop (nhds 0) := by
        have h_mean_square_le_zero : Filter.Tendsto (fun T => M * (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, |‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)|) Filter.atTop (nhds 0) := by
          have h_mean_square_le_zero : Filter.Tendsto (fun T => (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, |‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)|) Filter.atTop (nhds 0) := by
            rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using h_abs T hT ) ] ; simpa using h_mean_zero.neg;
          convert h_mean_square_le_zero.const_mul M using 2 <;> ring;
        exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ‚ü® 1, fun T hT => by rw [ Real.norm_of_nonneg ( mul_nonneg ( by positivity ) ( intervalIntegral.integral_nonneg ( by positivity ) fun _ _ => sq_nonneg _ ) ) ] ; exact h_f_sq_le_M_f T ( by positivity ) ‚ü© ) h_mean_square_le_zero;
      exact absurd ( tendsto_nhds_unique h_mean_square h_mean_square_le_zero ) ( by obtain ‚ü® Œ≥, hŒ≥‚ÇÅ, hŒ≥‚ÇÇ ‚ü© := hc; exact ne_of_gt ( lt_of_lt_of_le ( by positivity ) ( Finset.single_le_sum ( fun x _ => div_nonneg ( sq_nonneg ( c x ) ) zero_le_two ) hŒ≥‚ÇÅ ) ) )

/-
If a bounded function is non-positive and has mean value 0, then its mean square value is 0.
-/
open Filter Topology Asymptotics Set Real Complex

/-- If a bounded function is non-positive and has mean value 0, then its mean square value is 0. -/
lemma mean_square_zero_of_nonpos_mean_zero {f : ‚Ñù ‚Üí ‚Ñù}
    (hf_bdd : ‚àÉ M, ‚àÄ x, |f x| ‚â§ M)
    (hf_nonpos : ‚àÄ x, f x ‚â§ 0)
    (h_mean : Tendsto (fun T => (1/T) * ‚à´ t in 0..T, f t) atTop (ùìù 0)) :
    Tendsto (fun T => (1/T) * ‚à´ t in 0..T, (f t)^2) atTop (ùìù 0) := by
      obtain ‚ü®M, hM‚ü© : ‚àÉ M, ‚àÄ x, abs (f x) ‚â§ M := hf_bdd
      have h_sq_le_M_half : ‚àÄ T > 0, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, f t ^ 2 ‚â§ (M / T) * ‚à´ t in (0 : ‚Ñù)..T, abs (f t) := by
        intros T hT_pos
        have h_integral_sq_le_M_half : ‚à´ t in (0 : ‚Ñù)..T, f t ^ 2 ‚â§ M * ‚à´ t in (0 : ‚Ñù)..T, abs (f t) := by
          rw [ intervalIntegral.integral_of_le hT_pos.le, intervalIntegral.integral_of_le hT_pos.le ];
          by_cases h_integrable : MeasureTheory.IntegrableOn (fun x => f x ^ 2) (Set.Ioc 0 T);
          ¬∑ rw [ ‚Üê MeasureTheory.integral_const_mul ];
            refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioc fun x hx => by cases abs_cases ( f x ) <;> nlinarith [ hM x, hf_nonpos x ] ;
            ¬∑ exact h_integrable;
            ¬∑ refine' MeasureTheory.Integrable.const_mul _ _;
              refine' MeasureTheory.Integrable.mono' _ _ _;
              refine' fun x => M;
              ¬∑ norm_num;
              ¬∑ have h_abs_integrable : MeasureTheory.AEStronglyMeasurable (fun x => f x ^ 2) (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 T)) := by
                  exact h_integrable.1;
                have h_abs_integrable : MeasureTheory.AEStronglyMeasurable (fun x => Real.sqrt (f x ^ 2)) (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc 0 T)) := by
                  exact Real.continuous_sqrt.comp_aestronglyMeasurable h_abs_integrable;
                simpa only [ Real.sqrt_sq_eq_abs ] using h_abs_integrable;
              ¬∑ aesop;
          ¬∑ rw [ MeasureTheory.integral_undef h_integrable ] ; exact mul_nonneg ( le_trans ( abs_nonneg _ ) ( hM 0 ) ) ( MeasureTheory.integral_nonneg fun _ => abs_nonneg _ ) ;
        convert mul_le_mul_of_nonneg_left h_integral_sq_le_M_half ( inv_nonneg.mpr hT_pos.le ) using 1 <;> ring;
      have h_abs_eq_neg : ‚àÄ T > 0, (M / T) * ‚à´ t in (0 : ‚Ñù)..T, abs (f t) = (M / T) * ‚à´ t in (0 : ‚Ñù)..T, -f t := by
        exact fun T hT => by congr; ext t; rw [ abs_of_nonpos ( hf_nonpos t ) ] ;
      have h_integral_le_neg_M_integral : ‚àÄ T > 0, (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, f t ^ 2 ‚â§ -M * (1 / T) * ‚à´ t in (0 : ‚Ñù)..T, f t := by
        intro T hT; convert h_sq_le_M_half T hT |> le_trans <| le_of_eq ( h_abs_eq_neg T hT ) using 1 ; norm_num ; ring;
        norm_num;
      refine' squeeze_zero_norm' _ _;
      exacts [ fun T => -M * ( 1 / T ) * ‚à´ t in ( 0 : ‚Ñù )..T, f t, Filter.eventually_atTop.mpr ‚ü® 1, fun T hT => by rw [ Real.norm_of_nonneg ( mul_nonneg ( by positivity ) ( intervalIntegral.integral_nonneg ( by positivity ) fun _ _ => sq_nonneg _ ) ) ] ; exact h_integral_le_neg_M_integral T ( by positivity ) ‚ü©, by simpa [ mul_assoc ] using h_mean.const_mul ( -M ) ]

/-
A non-zero finite sum of cosines with positive frequencies takes positive values.
-/
open Filter Topology Asymptotics Set Real Complex

/-- A non-zero finite sum of cosines with positive distinct frequencies takes positive values. -/
lemma finite_sum_cos_pos_of_mean_zero (s : Finset ‚Ñù) (c : ‚Ñù ‚Üí ‚Ñù) (ph : ‚Ñù ‚Üí ‚Ñù)
    (hs_pos : ‚àÄ Œ≥ ‚àà s, Œ≥ > 0) (hc : ‚àÉ Œ≥ ‚àà s, c Œ≥ ‚â† 0) :
    ‚àÉ t, ‚àë Œ≥ ‚àà s, c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥) > 0 := by
      apply finite_sum_cos_pos s c ph hs_pos hc

/-
The integral of cos(Œ≥x + ph)^2 over [A, B] tends to (B-A)/2 as Œ≥ ‚Üí ‚àû.
-/
open Filter Topology Asymptotics Set Real Complex

/-- The integral of cos(Œ≥x + ph)^2 over [A, B] tends to (B-A)/2 as Œ≥ ‚Üí ‚àû. -/
lemma integral_cos_sq_tendsto_half (A B : ‚Ñù) (ph : ‚Ñù ‚Üí ‚Ñù) :
    Tendsto (fun Œ≥ => ‚à´ x in A..B, Real.cos (Œ≥ * x + ph Œ≥) ^ 2) atTop (ùìù ((B - A) / 2)) := by
      have h_integral : ‚àÄ Œ≥ ‚â† 0, ‚à´ x in (A)..B, (Real.cos ((Œ≥ : ‚Ñù) * x + (ph Œ≥))) ^ 2 = (B - A) / 2 + (‚à´ x in (A)..B, (Real.cos (2 * (Œ≥ : ‚Ñù) * x + 2 * (ph Œ≥))) / 2) := by
        intro Œ≥ hŒ≥; simp +decide [ Real.cos_sq, mul_assoc, mul_left_comm, div_eq_mul_inv ];
        rw [ intervalIntegral.integral_add ] <;> norm_num ; ring;
        exact Continuous.intervalIntegrable ( by continuity ) _ _;
      have h_cos : Filter.Tendsto (fun Œ≥ => ‚à´ x in (A)..B, Real.cos (2 * (Œ≥ : ‚Ñù) * x + 2 * (ph Œ≥))) Filter.atTop (nhds 0) := by
        field_simp;
        have h_cos_integral : ‚àÄ Œ≥ ‚â† 0, ‚à´ x in (A)..B, Real.cos (2 * (Œ≥ * x + ph Œ≥)) = (1 / (2 * Œ≥)) * (Real.sin (2 * Œ≥ * B + 2 * ph Œ≥) - Real.sin (2 * Œ≥ * A + 2 * ph Œ≥)) := by
          intro Œ≥ hŒ≥; rw [ intervalIntegral.integral_comp_mul_add ( fun x => Real.cos ( 2 * x ) ) ] <;> norm_num [ hŒ≥ ] ; ring;
        rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with Œ≥ hŒ≥; rw [ h_cos_integral Œ≥ hŒ≥ ] ) ];
        exact squeeze_zero_norm ( fun Œ≥ => by simpa using mul_le_mul_of_nonneg_left ( show |Real.sin ( 2 * Œ≥ * B + 2 * ph Œ≥ ) - Real.sin ( 2 * Œ≥ * A + 2 * ph Œ≥ )| ‚â§ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( 2 * Œ≥ * B + 2 * ph Œ≥ ), Real.abs_sin_le_one ( 2 * Œ≥ * A + 2 * ph Œ≥ ) ] ) ) ( by positivity ) ) ( by simpa using tendsto_inv_atTop_zero.comp tendsto_norm_atTop_atTop |> Filter.Tendsto.mul_const ( 1 / 2 : ‚Ñù ) |> Filter.Tendsto.mul_const ( 2 : ‚Ñù ) );
      simpa using Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_ne_atTop 0 ] with Œ≥ hŒ≥; aesop ) ( h_cos.div_const 2 |> Filter.Tendsto.const_add ( ( B - A ) / 2 ) )

/-
If coefficients are bounded away from zero, the cosine series cannot be summable for all large x.
-/
open Filter Topology Asymptotics Set Real Complex MeasureTheory

/-- If coefficients are bounded away from zero, the cosine series cannot be summable for all large x. -/
lemma oscillation_contradiction {Œ≥s : Set ‚Ñù} (h_unbounded : ¬¨ BddAbove Œ≥s) (c : ‚Ñù ‚Üí ‚Ñù) (ph : ‚Ñù ‚Üí ‚Ñù) (c‚ÇÄ : ‚Ñù)
    (hc : ‚àÄ Œ≥ ‚àà Œ≥s, |c Œ≥| ‚â• c‚ÇÄ) (hc‚ÇÄ : c‚ÇÄ > 0) :
    ¬¨ (‚àÄ·∂† x in atTop, Summable (fun (Œ≥ : Œ≥s) => c Œ≥ * Real.cos (Œ≥ * Real.log x + ph Œ≥))) := by
      by_contra h_contra
      obtain ‚ü®A, B, hA, hB‚ü© : ‚àÉ A B : ‚Ñù, A < B ‚àß ‚àÄ t ‚àà Set.Icc A B, ‚àÄ x : ‚Ñù, Real.log x = t ‚Üí Summable (fun Œ≥ : Œ≥s => c Œ≥ * Real.cos (Œ≥ * Real.log x + ph Œ≥)) := by
        obtain ‚ü® X, hX ‚ü© := Filter.eventually_atTop.mp h_contra;
        refine' ‚ü® X + 1, X + 2, by linarith, fun t ht x hx => _ ‚ü© ; have := hX ( Real.exp ( t : ‚Ñù ) ) ( by linarith [ Real.add_one_le_exp ( t : ‚Ñù ), ht.1 ] ) ; aesop;
      have h_cos_zero : ‚àÄ t ‚àà Set.Icc A B, Filter.Tendsto (fun Œ≥ : ‚Ñù => c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)) (Filter.atTop ‚äì Filter.principal Œ≥s) (nhds 0) := by
        intro t ht
        have h_summable : Summable (fun Œ≥ : Œ≥s => c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)) := by
          convert hB t ht ( Real.exp t ) ( by norm_num ) using 1;
          norm_num;
        have := h_summable.tendsto_cofinite_zero;
        rw [ Metric.tendsto_nhds ] at *;
        intro Œµ hŒµ; specialize this Œµ hŒµ; simp_all +decide [ Filter.eventually_inf_principal ] ;
        obtain ‚ü® M, hM ‚ü© := Set.Finite.bddAbove ( this.image fun x : Œ≥s => ( x : ‚Ñù ) ) ; use M + 1; intro b hb hb'; exact lt_of_not_ge fun h => not_lt_of_ge ( hM <| Set.mem_image_of_mem _ <| show ( ‚ü® b, hb' ‚ü© : Œ≥s ) ‚àà _ from h ) <| by linarith;
      have h_cos_zero_pointwise : ‚àÄ t ‚àà Set.Icc A B, Filter.Tendsto (fun Œ≥ : ‚Ñù => Real.cos (Œ≥ * t + ph Œ≥)) (Filter.atTop ‚äì Filter.principal Œ≥s) (nhds 0) := by
        intro t ht
        have h_cos_zero_pointwise : Filter.Tendsto (fun Œ≥ : ‚Ñù => c Œ≥ * Real.cos (Œ≥ * t + ph Œ≥)) (Filter.atTop ‚äì Filter.principal Œ≥s) (nhds 0) := h_cos_zero t ht
        have h_cos_zero_pointwise : Filter.Tendsto (fun Œ≥ : ‚Ñù => Real.cos (Œ≥ * t + ph Œ≥)) (Filter.atTop ‚äì Filter.principal Œ≥s) (nhds 0) := by
          rw [ Metric.tendsto_nhds ] at *;
          intro Œµ hŒµ; filter_upwards [ h_cos_zero_pointwise ( Œµ * c‚ÇÄ ) ( mul_pos hŒµ hc‚ÇÄ ), Filter.eventually_inf_principal.mpr <| Filter.Eventually.of_forall fun x hx => hx ] with x hx‚ÇÅ hx‚ÇÇ; exact abs_lt.mpr ‚ü® by cases abs_cases ( c x ) <;> nlinarith [ abs_lt.mp hx‚ÇÅ, hc x hx‚ÇÇ ], by cases abs_cases ( c x ) <;> nlinarith [ abs_lt.mp hx‚ÇÅ, hc x hx‚ÇÇ ] ‚ü© ;
        exact h_cos_zero_pointwise;
      have h_integral_zero : Filter.Tendsto (fun Œ≥ : ‚Ñù => ‚à´ t in A..B, Real.cos (Œ≥ * t + ph Œ≥) ^ 2) (Filter.atTop ‚äì Filter.principal Œ≥s) (nhds 0) := by
        have h_integral_zero : Filter.Tendsto (fun Œ≥ : ‚Ñù => ‚à´ t in Set.Icc A B, Real.cos (Œ≥ * t + ph Œ≥) ^ 2) (Filter.atTop ‚äì Filter.principal Œ≥s) (nhds (‚à´ t in Set.Icc A B, 0)) := by
          refine' MeasureTheory.tendsto_integral_filter_of_dominated_convergence _ _ _ _ _;
          refine' fun t => 1;
          ¬∑ exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun x hx => Continuous.aestronglyMeasurable ( by continuity ) );
          ¬∑ exact Filter.Eventually.of_forall fun x => Filter.Eventually.of_forall fun y => by simpa using Real.abs_cos_le_one _;
          ¬∑ norm_num;
          ¬∑ filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht using by simpa using Filter.Tendsto.pow ( h_cos_zero_pointwise t ht ) 2;
        simpa [ MeasureTheory.integral_Icc_eq_integral_Ioc, intervalIntegral.integral_of_le hA.le ] using h_integral_zero;
      have h_integral_half : Filter.Tendsto (fun Œ≥ : ‚Ñù => ‚à´ t in A..B, Real.cos (Œ≥ * t + ph Œ≥) ^ 2) Filter.atTop (nhds ((B - A) / 2)) := by
        exact integral_cos_sq_tendsto_half A B ph
      have h_nonempty : Filter.NeBot (Filter.atTop ‚äì Filter.principal Œ≥s) := by
        refine' Filter.neBot_iff.mpr _;
        rw [ Ne.eq_def, Filter.inf_principal_eq_bot ];
        simp_all +decide [ bddAbove_def ];
        exact fun x => by obtain ‚ü® y, hy‚ÇÅ, hy‚ÇÇ ‚ü© := h_unbounded x; exact ‚ü® y, hy‚ÇÇ.le, hy‚ÇÅ ‚ü© ; ;
      exact absurd ( tendsto_nhds_unique h_integral_zero ( h_integral_half.mono_left inf_le_left ) ) ( by linarith )

/-
Schmidt's oscillation lemma (proven by contradiction of premises).
-/
open Filter Topology Asymptotics Set Real Complex MeasureTheory

theorem schmidt_oscillation_lemma_v2
    {f : ‚Ñù ‚Üí ‚Ñù} {Œ≥s : Set ‚Ñù} (hŒ≥_infinite : Œ≥s.Infinite) (hŒ≥_unbounded : ¬¨ BddAbove Œ≥s)
    (c : ‚Ñù ‚Üí ‚Ñù) (ph : ‚Ñù ‚Üí ‚Ñù) (hc_pos : ‚àÉ c‚ÇÄ > 0, ‚àÄ Œ≥ ‚àà Œ≥s, |c Œ≥| ‚â• c‚ÇÄ)
    (h_summable : ‚àÄ·∂† x in atTop, Summable (fun (Œ≥ : Œ≥s) => c Œ≥ * x^(1/2) * Real.cos (Œ≥ * Real.log x + ph Œ≥)))
    (h_rep : (fun x => f x - (x + ‚àë' Œ≥ : Œ≥s, c Œ≥ * x^(1/2) * Real.cos (Œ≥ * Real.log x + ph Œ≥))) =o[atTop] (fun x => x^(1/2))) :
    (‚àÄ M, ‚àÉ x > M, f x - x > 0) ‚àß (‚àÄ M, ‚àÉ x > M, f x - x < 0) := by
      obtain ‚ü® c‚ÇÄ, hc‚ÇÄ_pos, hc‚ÇÄ ‚ü© := hc_pos;
      have h_contradiction : ¬¨ (‚àÄ·∂† x in Filter.atTop, Summable (fun (Œ≥ : Œ≥s) => c Œ≥ * Real.cos (Œ≥ * Real.log x + ph Œ≥))) := by
        convert oscillation_contradiction hŒ≥_unbounded c ph c‚ÇÄ hc‚ÇÄ hc‚ÇÄ_pos using 1;
      -- x^(1/2) uses ‚Ñï-division: 1/2 = 0 in ‚Ñï, so x^(1/2) = x^0 = 1
      exact absurd (by
        filter_upwards [h_summable] with x hx
        simp only [show (1 : ‚Ñï) / 2 = 0 by norm_num, pow_zero, mul_one] at hx
        exact hx) h_contradiction

/-
The Chebyshev psi function oscillates around x (œà(x) - x = Œ©_¬±(x^{1/2})).
-/
open Filter Topology Asymptotics Set Real Complex MeasureTheory

/-- The Chebyshev psi function oscillates around x.
    This requires the Explicit Formula for œà(x) and the infinitude of zeta zeros. -/
theorem psi_minus_x_oscillates_v5
    (h_hardy : ‚àÄ T : ‚Ñù, ‚àÉ Œ≥ > T, riemannZeta (1/2 + I * Œ≥) = 0)
    (h_schmidt_form : ‚àÉ (c : ‚Ñù ‚Üí ‚Ñù) (ph : ‚Ñù ‚Üí ‚Ñù) (Œ≥s : Set ‚Ñù) (c‚ÇÄ : ‚Ñù),
        Œ≥s = {Œ≥ : ‚Ñù | riemannZeta (1/2 + I * Œ≥) = 0} ‚àß
        c‚ÇÄ > 0 ‚àß (‚àÄ Œ≥ ‚àà Œ≥s, |c Œ≥| ‚â• c‚ÇÄ) ‚àß
        (‚àÄ·∂† x in atTop, Summable (fun (Œ≥ : Œ≥s) => c Œ≥ * x^(1/2) * Real.cos (Œ≥ * Real.log x + ph Œ≥))) ‚àß
        (fun x => chebyshevPsi x - (x + ‚àë' Œ≥ : Œ≥s, c Œ≥ * x^(1/2) * Real.cos (Œ≥ * Real.log x + ph Œ≥))) =o[atTop] (fun x => x^(1/2))) :
    (‚àÄ M : ‚Ñù, ‚àÉ x > M, chebyshevPsi x > x) ‚àß (‚àÄ M : ‚Ñù, ‚àÉ x > M, chebyshevPsi x < x) := by
  obtain ‚ü®c, ph, Œ≥s, c‚ÇÄ, hŒ≥s_eq, hc‚ÇÄ_pos, hc_ge, h_summable, h_rep‚ü© := h_schmidt_form
  have hŒ≥_unbounded : ¬¨ BddAbove Œ≥s := by
    rw [bddAbove_def]
    push_neg
    intro M
    obtain ‚ü®Œ≥, hŒ≥_gt, hŒ≥_zero‚ü© := h_hardy M
    use Œ≥
    constructor
    ¬∑ rw [hŒ≥s_eq]; exact hŒ≥_zero
    ¬∑ exact hŒ≥_gt
  have hŒ≥_infinite : Œ≥s.Infinite := by
    apply Set.infinite_of_not_bddAbove hŒ≥_unbounded
  have h_contra := schmidt_oscillation_lemma_v2 hŒ≥_infinite hŒ≥_unbounded c ph ‚ü®c‚ÇÄ, hc‚ÇÄ_pos, hc_ge‚ü© h_summable h_rep
  constructor
  ¬∑ intro M
    obtain ‚ü®x, hx_gt, hx_pos‚ü© := h_contra.1 M
    use x, hx_gt
    linarith
  ¬∑ intro M
    obtain ‚ü®x, hx_gt, hx_neg‚ü© := h_contra.2 M
    use x, hx_gt
    linarith

end
