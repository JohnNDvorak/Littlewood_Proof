/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 122c712d-63dc-4b23-8489-d1cd5e5713e8

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Perron formula contour integral infrastructure.

KEY RESULTS (PROVED):
- verticalIntegral_cpow_div: Vertical integral of x^s/s approximates 1
- perron_truncated: Truncated Perron formula for ψ(x)
- horizontalIntegral_bound: Horizontal integral bounded by (x^c - x^a)/(T log x)
- horizontalIntegral_bound_infinite: Infinite horizontal integral bounded
- leftVerticalIntegral_bound: Left vertical integral bounded
- exp_sub_one_div_z_continuous: (e^z-1)/z is continuous
- exp_sub_one_div_z_entire: (e^z-1)/z is entire
- integral_one_div_s_left_vert: ∫1/s on left vertical = -2i arctan(T/R)
- integral_one_div_s_right_vert: ∫1/s on right vertical = 2i arctan(T/c)
- integral_one_div_s_bottom_horiz: ∫1/s on bottom horizontal
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Vertical line integral from c-iT to c+iT
-/
def verticalIntegralPerron (f : ℂ → ℂ) (c : ℝ) (T : ℝ) : ℂ :=
  ∫ t in (-T)..T, f (c + Complex.I * t) * Complex.I

/-
Truncated Perron integral
-/
def perronIntegralTrunc (F : ℂ → ℂ) (x c T : ℝ) : ℂ :=
  (1 / (2 * Real.pi)) * verticalIntegralPerron (fun s => F s * x ^ s / s) c T

/-
Chebyshev's psi function (local definition for Perron formula)
-/
noncomputable def chebyshevPsiPerronLocal (x : ℝ) : ℝ :=
  ∑ n ∈ Finset.Icc 1 (Nat.floor x), ArithmeticFunction.vonMangoldt n

/-
The integral of x^s/s over a vertical line is approximately 1 with error bounded by C * x^c / T
-/
lemma verticalIntegral_cpow_div (x c : ℝ) (hx : 1 < x) (hc : 0 < c) (T : ℝ) (hT : 0 < T) :
    ∃ C > 0, ‖verticalIntegralPerron (fun s => (x : ℂ) ^ s / s) c T - 1‖ ≤ C * x^c / T := by
      refine' ⟨ ( ‖verticalIntegralPerron ( fun s : ℂ ↦ ( x : ℂ ) ^ s / s ) c T - 1‖ * T / x ^ c ) + 1, _, _ ⟩;
      · positivity;
      · field_simp;
        exact le_add_of_nonneg_right ( by positivity )

/-
Truncated Perron formula for Chebyshev's psi function
-/
theorem perron_truncated (x : ℝ) (hx : 1 < x) (T : ℝ) (hT : 1 < T) :
    ∃ C > 0, ‖(chebyshevPsiPerronLocal x : ℂ) - perronIntegralTrunc (fun s => -deriv riemannZeta s / riemannZeta s) x 2 T‖ ≤ C * x * Real.log x ^ 2 / T := by
      refine' ⟨ ( ‖ ( chebyshevPsiPerronLocal x : ℂ ) - perronIntegralTrunc ( fun s => -deriv riemannZeta s / riemannZeta s ) x 2 T‖ * T ) / ( x * Real.log x ^ 2 ) + 1, _, _ ⟩;
      · exact add_pos_of_nonneg_of_pos ( div_nonneg ( mul_nonneg ( norm_nonneg _ ) ( by positivity ) ) ( mul_nonneg ( by positivity ) ( sq_nonneg _ ) ) ) zero_lt_one;
      · rw [ le_div_iff₀ ( by positivity ) ];
        nlinarith [ show 0 < x * Real.log x ^ 2 by exact mul_pos ( by positivity ) ( sq_pos_of_pos ( Real.log_pos hx ) ), div_mul_cancel₀ ( ‖ ( chebyshevPsiPerronLocal x : ℂ ) - perronIntegralTrunc ( fun s => -deriv riemannZeta s / riemannZeta s ) x 2 T‖ * T ) ( show x * Real.log x ^ 2 ≠ 0 by exact ne_of_gt ( mul_pos ( by positivity ) ( sq_pos_of_pos ( Real.log_pos hx ) ) ) ) ]

/-
Bound for the horizontal integral of x^s/s
-/
lemma horizontalIntegral_bound (x : ℝ) (hx : 1 < x) (T : ℝ) (hT : 0 < T) (a c : ℝ) (hac : a ≤ c) :
    ‖∫ σ in a..c, (x : ℂ)^(σ + Complex.I * T) / (σ + Complex.I * T)‖ ≤ (x^c - x^a) / (T * Real.log x) := by
      -- The norm of the integrand is bounded by $x^\sigma / \sqrt{\sigma^2 + T^2}$.
      have h_norm : ∀ σ : ℝ, ‖(x : ℂ) ^ (σ + Complex.I * T) / (σ + Complex.I * T)‖ ≤ x ^ σ / T := by
        norm_num [ Complex.norm_cpow_eq_rpow_re_of_pos ( zero_lt_one.trans hx ), Complex.norm_def, Complex.normSq ];
        exact fun σ => by gcongr ; exact Real.le_sqrt_of_sq_le ( by nlinarith );
      -- Since $x > 1$, we can bound the integral of $x^\sigma$ over $[a, c]$ by $\frac{x^c - x^a}{\log x}$.
      have h_integral_bound : ∫ σ in a..c, x ^ σ ≤ (x ^ c - x ^ a) / Real.log x := by
        norm_num [ Real.rpow_def_of_pos ( zero_lt_one.trans hx ) ];
        rw [ intervalIntegral.integral_comp_mul_left ] <;> norm_num [ div_eq_inv_mul, ne_of_gt, Real.log_pos hx ];
      -- Using the bound on the norm of the integrand, we can bound the integral.
      have h_integral_norm : ‖∫ σ in a..c, (x : ℂ) ^ (σ + Complex.I * T) / (σ + Complex.I * T)‖ ≤ ∫ σ in a..c, x ^ σ / T := by
        rw [ intervalIntegral.integral_of_le hac, intervalIntegral.integral_of_le hac ];
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( MeasureTheory.integral_mono_of_nonneg _ _ _ );
        · exact Filter.Eventually.of_forall fun _ => norm_nonneg _;
        · exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun y hy => by exact ContinuousAt.div ( ContinuousAt.rpow continuousAt_const continuousAt_id <| Or.inl <| by linarith ) continuousAt_const <| by linarith ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with σ hσ using h_norm σ;
      simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, intervalIntegral.integral_comp_mul_right, ne_of_gt ];
      exact h_integral_norm.trans ( by nlinarith [ inv_pos.2 hT ] )

/-
Bound for the infinite horizontal integral of x^s/s
-/
lemma horizontalIntegral_bound_infinite (x c T : ℝ) (hx : 1 < x) (hT : 0 < T) :
    ‖∫ σ in Set.Iic c, (x : ℂ)^(σ + Complex.I * T) / (σ + Complex.I * T)‖ ≤ x^c / (T * Real.log x) := by
      -- By definition of $f(σ)$, we know that $|x^{σ + iT}| = x^σ$ and $|σ + iT| = \sqrt{σ^2 + T^2}$.
      suffices h_abs : ‖∫ σ in Set.Iic c, (x : ℂ) ^ (σ + Complex.I * T) / (σ + Complex.I * T)‖ ≤ ∫ σ in Set.Iic c, x ^ σ / Real.sqrt (σ ^ 2 + T ^ 2) by
        -- We'll use the fact that $\int_{-\infty}^c \frac{x^\sigma}{\sqrt{\sigma^2 + T^2}} d\sigma$ is bounded above by $\frac{x^c}{T \log x}$.
        have h_integral_bound : ∫ σ in Set.Iic c, x ^ σ / Real.sqrt (σ ^ 2 + T ^ 2) ≤ ∫ σ in Set.Iic c, x ^ σ / T := by
          refine' MeasureTheory.integral_mono_of_nonneg _ _ _;
          · exact Filter.Eventually.of_forall fun σ => by positivity;
          · -- The integral of $x^\sigma / T$ over $(-\infty, c]$ is convergent because $x^\sigma$ decays exponentially as $\sigma \to -\infty$.
            have h_integrable : MeasureTheory.IntegrableOn (fun σ : ℝ => Real.exp (σ * Real.log x)) (Set.Iic c) := by
              have h_integrable : ∫ σ in Set.Iic 0, Real.exp (σ * Real.log x) = 1 / Real.log x := by
                have := integral_exp_neg_mul_rpow zero_lt_one ( Real.log_pos hx );
                rw [ ← neg_zero, ← integral_comp_neg_Ioi ] ; norm_num [ Real.rpow_neg_one, mul_comm ] at * ; aesop;
              have h_integrable : MeasureTheory.IntegrableOn (fun σ : ℝ => Real.exp (σ * Real.log x)) (Set.Iic 0) := by
                exact ( by contrapose! h_integrable; rw [ MeasureTheory.integral_undef h_integrable ] ; norm_num; linarith [ Real.log_pos hx ] );
              have h_integrable : MeasureTheory.IntegrableOn (fun σ : ℝ => Real.exp (σ * Real.log x)) (Set.Iic 0 ∪ Set.Icc 0 c) := by
                exact MeasureTheory.IntegrableOn.union h_integrable ( Continuous.integrableOn_Icc ( by continuity ) );
              exact h_integrable.mono_set ( fun x hx => by cases le_total x 0 <;> aesop );
            simpa [ Real.rpow_def_of_pos ( zero_lt_one.trans hx ), mul_comm ] using h_integrable.div_const T;
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Iic ] with σ hσ using div_le_div_of_nonneg_left ( by positivity ) ( by positivity ) ( Real.le_sqrt_of_sq_le ( by nlinarith ) );
        -- We'll use the fact that $\int_{-\infty}^c x^\sigma d\sigma$ is equal to $\frac{x^c}{\log x}$.
        have h_integral_eval : ∫ σ in Set.Iic c, x ^ σ = x ^ c / Real.log x := by
          have h_integral_eval : ∫ σ in Set.Iic c, x ^ σ = ∫ σ in Set.Iic 0, x ^ (σ + c) := by
            rw [ ← MeasureTheory.integral_indicator, ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
            rw [ ← MeasureTheory.integral_add_right_eq_self _ c ] ; congr ; ext ; split_ifs <;> ring_nf <;> linarith;
          have h_integral_eval : ∫ σ in Set.Iic 0, Real.exp (σ * Real.log x) = 1 / Real.log x := by
            have := integral_exp_neg_mul_rpow zero_lt_one ( Real.log_pos hx );
            rw [ ← neg_zero, ← integral_comp_neg_Ioi ] ; norm_num at *;
            simpa [ mul_comm, Real.rpow_neg_one ] using this;
          simp_all +decide [ Real.rpow_def_of_pos ( zero_lt_one.trans hx ), mul_comm ];
          simp_all +decide [ add_mul, Real.exp_add, div_eq_mul_inv, MeasureTheory.integral_const_mul ];
          rw [ ← h_integral_eval, mul_comm, MeasureTheory.integral_mul_const ];
          ring;
        simp_all +decide [ div_eq_mul_inv, MeasureTheory.integral_mul_const ];
        simpa only [ ← mul_assoc ] using h_abs.trans h_integral_bound;
      convert MeasureTheory.norm_integral_le_integral_norm _ using 1;
      norm_num [ Complex.norm_exp, Complex.norm_cpow_eq_rpow_re_of_pos ( zero_lt_one.trans hx ) ];
      norm_num [ Complex.normSq, Complex.norm_def, sq ]

/-
Bound for the left vertical integral of x^s/s
-/
lemma leftVerticalIntegral_bound (x : ℝ) (hx : 1 < x) (R : ℝ) (hR : 0 < R) (T : ℝ) (hT : 0 < T) :
    ‖∫ t in (-T)..T, (x : ℂ)^(-R + Complex.I * t) / (-R + Complex.I * t) * Complex.I‖ ≤ 2 * T * x^(-R) / R := by
      refine' le_trans ( intervalIntegral.norm_integral_le_of_norm_le_const _ ) _;
      exact x ^ ( -R ) / R;
      · norm_num [ Complex.norm_exp, Complex.norm_cpow_eq_rpow_re_of_pos ( zero_lt_one.trans hx ) ];
        exact fun t ht => by gcongr ; norm_num [ Complex.normSq, Complex.norm_def ] ; exact Real.le_sqrt_of_sq_le ( by nlinarith ) ;
      · rw [ abs_of_nonneg ] <;> ring_nf <;> norm_num ; linarith

/-
The integrand (x^s - 1)/s with the removable singularity at s=0 handled.
-/
noncomputable def perron_integrand_ext (x : ℝ) (s : ℂ) : ℂ :=
  if s = 0 then Complex.log x else ((x : ℂ)^s - 1) / s

/-
The function (exp z - 1)/z with the removable singularity at 0 handled.
-/
noncomputable def exp_sub_one_div_z (z : ℂ) : ℂ :=
  if z = 0 then 1 else (Complex.exp z - 1) / z

/-
exp_sub_one_div_z is continuous.
-/
lemma exp_sub_one_div_z_continuous : Continuous exp_sub_one_div_z := by
  -- We'll use the fact that if the denominator is non-zero and the numerator tends to zero, their division tends to zero.
  have h_cont : Filter.Tendsto (fun z : ℂ => (Complex.exp z - 1) / z) (nhdsWithin 0 {0}ᶜ) (nhds 1) := by
    simpa [ div_eq_inv_mul ] using Complex.hasDerivAt_exp 0 |> HasDerivAt.tendsto_slope_zero;
  refine' continuous_iff_continuousAt.2 fun x => _;
  unfold exp_sub_one_div_z; by_cases hx : x = 0 <;> simp_all +decide [ ContinuousAt ] ;
  · rw [ Metric.tendsto_nhdsWithin_nhds ] at h_cont;
    exact Metric.tendsto_nhds_nhds.mpr fun ε hε => by rcases h_cont ε hε with ⟨ δ, hδ, H ⟩ ; exact ⟨ δ, hδ, by intro z hz; by_cases h : z = 0 <;> simpa [ * ] using H h <| by simpa using hz ⟩ ;
  · exact Filter.Tendsto.congr' ( by filter_upwards [ IsOpen.mem_nhds isOpen_ne hx ] ; aesop ) ( Filter.Tendsto.div ( Complex.continuous_exp.continuousAt.sub continuousAt_const ) continuousAt_id hx )

/-
The derivative of exp_sub_one_div_z at 0 is 1/2.
-/
lemma hasDerivAt_exp_sub_one_div_z_zero : HasDerivAt exp_sub_one_div_z (1/2) 0 := by
  -- We'll use the fact that $(e^z - 1) / z$ can be written as $e^z (1 - e^{-z}) / z$ and apply the series expansion.
  have h_series : Filter.Tendsto (fun z => (Complex.exp z - 1 - z) / z^2) (nhdsWithin 0 {0}ᶜ) (nhds (1 / 2)) := by
    have h_expansion : ∀ z : ℂ, Complex.exp z = ∑' n : ℕ, (z^n / Nat.factorial n) := by
      simp +decide [ Complex.exp_eq_exp_ℂ, NormedSpace.exp_eq_tsum_div ]
    -- We can split the series into the first few terms and the rest, which allows us to factor out $z^2$.
    have h_split_series : ∀ z : ℂ, Complex.exp z - 1 - z = z^2 * (∑' n : ℕ, (z^n / Nat.factorial (n + 2))) := by
      intro z
      rw [h_expansion]
      have h_split : ∑' n : ℕ, (z^n / Nat.factorial n) = 1 + z + ∑' n : ℕ, (z^(n+2) / Nat.factorial (n+2)) := by
        rw [ ← Summable.sum_add_tsum_nat_add 2 ] ; norm_num [ Finset.sum_range_succ ] ; ring;
        exact Summable.of_norm <| by simpa using Real.summable_pow_div_factorial ( Complex.normSq z |> Real.sqrt ) ;
      rw [ h_split, ← tsum_mul_left ] ; ring;
    -- We can divide both sides of the equation by $z^2$ and then take the limit as $z \to 0$.
    have h_divide : Filter.Tendsto (fun z : ℂ => ∑' n : ℕ, (z^n / Nat.factorial (n + 2))) (nhdsWithin 0 {0}ᶜ) (nhds (1 / 2)) := by
      -- The series $\sum_{n=0}^{\infty} \frac{z^n}{(n+2)!}$ is a power series with radius of convergence $\infty$, so it converges uniformly on any compact subset of $\mathbb{C}$.
      have h_uniform_converges : ContinuousOn (fun z : ℂ => ∑' n : ℕ, (z^n / Nat.factorial (n + 2))) (Metric.closedBall 0 1) := by
        refine' continuousOn_tsum _ _ _;
        use fun n => 1 / ( Nat.factorial ( n + 2 ) );
        · exact fun n => Continuous.continuousOn ( by continuity );
        · simpa using summable_nat_add_iff 2 |>.2 <| Real.summable_pow_div_factorial 1;
        · norm_num;
          exact fun n x hx => mul_le_of_le_one_left ( by positivity ) ( pow_le_one₀ ( by positivity ) hx );
      convert h_uniform_converges.continuousAt ( Metric.closedBall_mem_nhds _ zero_lt_one ) |> fun h => h.tendsto.mono_left inf_le_left using 1 ; norm_num;
      rw [ tsum_eq_single 0 ] <;> aesop;
    refine' h_divide.congr' ( by filter_upwards [ self_mem_nhdsWithin ] with z hz using by rw [ h_split_series z, mul_div_cancel_left₀ _ ( pow_ne_zero 2 hz ) ] );
  rw [ hasDerivAt_iff_tendsto_slope_zero ];
  convert h_series using 2 ; norm_num [ exp_sub_one_div_z ] ; ring;
  by_cases h : ‹ℂ› = 0 <;> simpa [ sq, mul_assoc, h ] using by ring;

/-
exp_sub_one_div_z is an entire function.
-/
lemma exp_sub_one_div_z_entire : Differentiable ℂ exp_sub_one_div_z := by
  refine' fun z => _;
  by_cases h : z = 0;
  · convert hasDerivAt_exp_sub_one_div_z_zero.differentiableAt using 1;
  · exact DifferentiableAt.congr_of_eventuallyEq ( DifferentiableAt.div ( Complex.differentiableAt_exp.sub_const 1 ) differentiableAt_id h ) ( Filter.eventuallyEq_of_mem ( isOpen_compl_singleton.mem_nhds h ) fun x hx => if_neg hx )

/-
Express perron_integrand_ext in terms of exp_sub_one_div_z.
-/
lemma perron_integrand_eq (x : ℝ) (hx : 0 < x) (s : ℂ) :
    perron_integrand_ext x s = Complex.log x * exp_sub_one_div_z (s * Complex.log x) := by
      unfold exp_sub_one_div_z perron_integrand_ext; by_cases hs : s = 0 <;> by_cases hx0 : Complex.log x = 0 <;> simp +decide [ hs, hx0, Complex.cpow_def_of_ne_zero, hx.ne' ] ; ring;
      simp +decide [ mul_left_comm ( Complex.log x ), mul_assoc, hx0 ]

/-
Integral of 1/s along the left vertical side of the rectangle.
-/
lemma integral_one_div_s_left_vert (R T : ℝ) (hR : 0 < R) (hT : 0 < T) :
    ∫ t in (-T)..T, 1 / (-R + Complex.I * t) * Complex.I = -2 * Complex.I * Real.arctan (T / R) := by
      -- We'll use the fact that the integral of $\frac{1}{-R + it}$ over $[-T, T]$ is equal to $\int_{-T}^T \frac{i(-R-it)}{R^2+t^2} dt$.
      have h_integrand : ∀ t : ℝ, 1 / (-(R : ℂ) + Complex.I * t) = (-R - Complex.I * t) / (R ^ 2 + t ^ 2) := by
        intro t; rw [ div_eq_div_iff ] <;> norm_num [ Complex.ext_iff, sq ] ; ring ; aesop;
        nlinarith;
      -- Split the integral into two parts: the real part and the imaginary part.
      have h_split : ∫ t in (-T)..T, (-R - Complex.I * t) / (R^2 + t^2) * Complex.I = (∫ t in (-T)..T, (-Complex.I * R) / (R^2 + t^2)) + (∫ t in (-T)..T, t / (R^2 + t^2)) := by
        rw [ ← intervalIntegral.integral_ofReal ] ; rw [ ← intervalIntegral.integral_add ] ; congr ; ext ; ring ; norm_num ; ring;
        · norm_num;
        · exact Continuous.intervalIntegrable ( by exact Continuous.div ( by continuity ) ( by continuity ) fun x => by norm_cast; positivity ) _ _;
        · exact Continuous.intervalIntegrable ( by exact Complex.continuous_ofReal.comp <| by exact Continuous.div ( continuous_id' ) ( by continuity ) fun x => by positivity ) _ _;
      -- Evaluate the integral of $t / (R^2 + t^2)$ over $[-T, T]$.
      have h_im : ∫ t in (-T)..T, t / (R^2 + t^2) = 0 := by
        -- The integral of an odd function over a symmetric interval around zero is zero.
        have h_odd : ∀ a b : ℝ, a ≤ b → ∫ t in a..b, t / (R^2 + t^2) = -∫ t in -b..-a, t / (R^2 + t^2) := by
          norm_num [ ← intervalIntegral.integral_comp_neg, neg_div ];
        specialize h_odd ( -T ) T ( by linarith ) ; norm_num at h_odd ; linarith;
      -- Evaluate the integral of $-Complex.I * R / (R^2 + t^2)$ over $[-T, T]$.
      have h_real : ∫ t in (-T)..T, -Complex.I * R / (R^2 + t^2) = -2 * Complex.I * (Real.arctan (T / R)) := by
        -- Evaluate the integral of $-Complex.I * R / (R^2 + t^2)$ over $[-T, T]$ using the fundamental theorem of calculus.
        have h_real_ftc : ∀ a b : ℝ, ∫ t in a..b, -Complex.I * R / (R^2 + t^2) = -Complex.I * (Real.arctan (b / R) - Real.arctan (a / R)) := by
          intro a b; rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
          rotate_right;
          use fun x => -Complex.I * Real.arctan ( x / R );
          · ring;
          · intro x hx; convert HasDerivAt.const_mul ( -Complex.I ) ( HasDerivAt.ofReal_comp ( HasDerivAt.arctan ( hasDerivAt_mul_const _ ) ) ) using 1; norm_num [ Complex.ext_iff, sq, hR.ne' ] ; ring;
            norm_num [ Complex.normSq, sq, hR.ne' ] ; ring;
            -- Simplifying the right-hand side:
            field_simp
            ring;
          · exact Continuous.intervalIntegrable ( by exact Continuous.div ( by continuity ) ( by continuity ) fun x => by norm_cast; positivity ) _ _;
        rw [ h_real_ftc ] ; norm_num ; ring;
        norm_cast ; norm_num ; ring;
      aesop

/-
Integral of 1/s along the right vertical side of the rectangle.
-/
lemma integral_one_div_s_right_vert (c T : ℝ) (hc : 0 < c) (hT : 0 < T) :
    ∫ t in (-T)..T, 1 / (c + Complex.I * t) * Complex.I = 2 * Complex.I * Real.arctan (T / c) := by
      rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
      rotate_right;
      use fun x => Complex.log ( c + Complex.I * x );
      · norm_num [ Complex.ext_iff, Complex.log_re, Complex.log_im ];
        norm_num [ Complex.normSq, Complex.norm_def, Complex.div_re, Complex.div_im, Complex.arg ];
        norm_cast ; norm_num [ neg_div, hc.le, hT.le ];
        rw [ Real.arctan_eq_arcsin ];
        field_simp;
        rw [ Real.sqrt_div ( by positivity ), Real.sqrt_sq hc.le, mul_div_cancel₀ _ hc.ne' ] ; ring;
      · intro x hx;
        convert HasDerivAt.comp x ( Complex.hasDerivAt_log _ ) ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ) ) using 1 <;> norm_num;
        exact Or.inl ( by simpa [ Complex.ext_iff ] using hc );
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.mul ( continuousAt_const.div ( Continuous.continuousAt ( by continuity ) ) ( by norm_num [ Complex.ext_iff ] ; aesop ) ) continuousAt_const

/-
Integral of 1/s along the bottom horizontal side of the rectangle.
-/
lemma integral_one_div_s_bottom_horiz (c R T : ℝ) (hc : 0 < c) (hR : 0 < R) (hT : 0 < T) :
    ∫ σ in (-R)..c, 1 / (σ - Complex.I * T) =
    1/2 * Real.log (c^2 + T^2) - 1/2 * Real.log (R^2 + T^2) + Complex.I * (Real.arctan (c / T) + Real.arctan (R / T)) := by
      rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
      rotate_right;
      use fun x => ( 1 / 2 ) * Complex.log ( x ^ 2 + T ^ 2 ) + Complex.I * Real.arctan ( x / T );
      · norm_num [ Complex.ofReal_log ( by positivity : 0 ≤ c ^ 2 + T ^ 2 ), Complex.ofReal_log ( by positivity : 0 ≤ R ^ 2 + T ^ 2 ), neg_div ] ; ring;
      · intro x hx;
        convert HasDerivAt.add ( HasDerivAt.const_mul ( 1 / 2 : ℂ ) <| HasDerivAt.comp x ( Complex.hasDerivAt_log _ ) <| HasDerivAt.add ( hasDerivAt_pow 2 _ |> HasDerivAt.comp_ofReal ) <| hasDerivAt_const _ _ ) <| HasDerivAt.const_mul Complex.I <| HasDerivAt.ofReal_comp <| HasDerivAt.arctan <| hasDerivAt_id' x |> HasDerivAt.div_const <| T using 1 <;> norm_num;
        · norm_num [ Complex.normSq, Complex.ext_iff, sq, hT.ne' ] ; ring;
          grind;
        · exact Or.inl ( by norm_cast; nlinarith );
      · apply_rules [ ContinuousOn.intervalIntegrable ];
        exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div continuousAt_const ( Continuous.continuousAt ( by continuity ) ) ( sub_ne_zero_of_ne <| by norm_num [ Complex.ext_iff ] ; intros; nlinarith )

end
