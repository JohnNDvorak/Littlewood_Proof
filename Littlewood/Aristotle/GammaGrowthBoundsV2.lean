/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f121a4ca-093c-4cd8-8a4c-704283817e8f

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: Gamma growth bounds V2 — comprehensive Stirling-type bounds.
All exact? timeouts closed by Claude Code.

Contains (0 sorries):
- gamma_half_growth: |Γ(1/2+it)| ≍ e^{-π|t|/2} (PROVED)
- gamma_step_norm: |Γ(s+1)| = |s||Γ(s)| (PROVED)
- gamma_three_halves_growth: |Γ(3/2+it)| ≍ |t|e^{-π|t|/2} (PROVED)
- HasGammaGrowth: definition of Stirling growth property
- gamma_growth_step_up: growth property propagates σ → σ+1 (PROVED)
- gamma_growth_step_down: growth property propagates σ+1 → σ (PROVED)
- sinh_sq_growth: sinh(πt)² ≍ e^{2π|t|} (PROVED)
- complex_sin_sq_growth: |sin(π(σ+it))|² ≍ e^{2π|t|} (PROVED)
- HasGammaUpperGrowth, HasGammaLowerGrowth: definitions
- StirlingNormalizer: z^(1/2-z)·e^z normalizing function
- stirling_normalizer_bound: bounds on normalizer (PROVED)
- StirlingNormalizedGamma: Γ(z)·StirlingNormalizer(z)
- stirling_normalizer_bound_uniform: uniform bounds (PROVED)
- stirling_normalized_gamma_bounded_large_t: bounded for |t| ≥ 1 (PROVED)
- stirling_algebraic_simplification: cancellation lemma (PROVED)
- has_gamma_upper_growth_iff_bounded_normalized: equivalence (PROVED)

NOTE: This file provides complete infrastructure for gamma_growth.
Ready for wiring into PhragmenLindelof.lean.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.GammaGrowthBoundsV2

/-
The Gamma function on the critical line Re(s) = 1/2 satisfies |Γ(1/2 + it)| ≍ e^{-π|t|/2} for |t| ≥ 1.
-/
theorem gamma_half_growth :
    ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
      C₁ * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ∧
      ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ≤ C₂ * Real.exp (-Real.pi * |t| / 2) := by
        -- Use the fact that $|\Gamma(1/2 + it)|^2 = \Gamma(1/2 + it)\Gamma(1/2 - it) = \pi / \cosh(\pi t)$.
        have h_gamma_abs_sq : ∀ t : ℝ, ‖Complex.Gamma ((1 + 2 * t * Complex.I) / 2)‖ ^ 2 = Real.pi / Real.cosh (Real.pi * t) := by
          intro t
          have h_abs_sq : Complex.Gamma ((1 + 2 * t * Complex.I) / 2) * Complex.Gamma ((1 - 2 * t * Complex.I) / 2) = Real.pi / Real.cosh (Real.pi * t) := by
            have := @Complex.Gamma_mul_Gamma_one_sub ( ( 1 + 2 * t * Complex.I ) / 2 );
            convert this using 2 <;> ring;
            norm_num [ Complex.ext_iff, Complex.sin, Complex.exp_re, Complex.exp_im, Real.cosh_eq ] ; ring;
            norm_num [ mul_div ];
          -- Since $\Gamma(1/2 - it) = \overline{\Gamma(1/2 + it)}$, we have $|\Gamma(1/2 + it)|^2 = \Gamma(1/2 + it) \overline{\Gamma(1/2 + it)}$.
          have h_conj : Complex.Gamma ((1 - 2 * t * Complex.I) / 2) = starRingEnd ℂ (Complex.Gamma ((1 + 2 * t * Complex.I) / 2)) := by
            convert Complex.Gamma_conj ( ( 1 + 2 * t * Complex.I ) / 2 ) using 2 ; norm_num ; ring;
            erw [ Complex.conj_ofReal ] ; norm_num ; ring;
          simp_all +decide [ Complex.ext_iff, sq ];
          convert h_abs_sq.1 using 1 <;> norm_num [ Complex.normSq, Complex.norm_def ] ; ring;
          · rw [ Real.sq_sqrt ( add_nonneg ( sq_nonneg _ ) ( sq_nonneg _ ) ) ];
          · norm_cast;
        -- Use the fact that $\cosh(\pi t) \geq \frac{e^{\pi |t|}}{2}$ and $\cosh(\pi t) \leq e^{\pi |t|}$.
        have h_cosh_bounds : ∀ t : ℝ, Real.cosh (Real.pi * t) ≥ Real.exp (Real.pi * |t|) / 2 ∧ Real.cosh (Real.pi * t) ≤ Real.exp (Real.pi * |t|) := by
          norm_num [ Real.cosh_eq ];
          intro t; cases abs_cases t <;> simp +decide [ * ];
          · constructor <;> nlinarith [ Real.exp_pos ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_neg ( Real.pi * t ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * t ) ) ), Real.add_one_le_exp ( Real.pi * t ), Real.add_one_le_exp ( - ( Real.pi * t ) ), Real.pi_gt_three.le, mul_nonneg Real.pi_pos.le ( by linarith : 0 ≤ t ) ];
          · constructor <;> nlinarith [ Real.exp_pos ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_le_exp.2 ( by nlinarith [ Real.pi_pos ] : Real.pi * t ≤ - ( Real.pi * t ) ) ];
        -- Use the bounds on $\cosh(\pi t)$ to derive bounds on $|\Gamma(1/2 + it)|$.
        have h_gamma_bounds : ∀ t : ℝ, ‖Complex.Gamma ((1 + 2 * t * Complex.I) / 2)‖ ≤ Real.sqrt (2 * Real.pi) * Real.exp (-Real.pi * |t| / 2) ∧ ‖Complex.Gamma ((1 + 2 * t * Complex.I) / 2)‖ ≥ Real.sqrt (Real.pi) * Real.exp (-Real.pi * |t| / 2) := by
          intro t
          have h_gamma_sq_bounds : Real.pi / Real.exp (Real.pi * |t|) ≤ ‖Complex.Gamma ((1 + 2 * t * Complex.I) / 2)‖ ^ 2 ∧ ‖Complex.Gamma ((1 + 2 * t * Complex.I) / 2)‖ ^ 2 ≤ 2 * Real.pi / Real.exp (Real.pi * |t|) := by
            rw [ h_gamma_abs_sq ];
            exact ⟨ by rw [ div_le_div_iff₀ ( by positivity ) ( by exact Real.cosh_pos _ ) ] ; nlinarith [ Real.pi_pos, h_cosh_bounds t ], by rw [ div_le_div_iff₀ ( by exact Real.cosh_pos _ ) ( by positivity ) ] ; nlinarith [ Real.pi_pos, h_cosh_bounds t ] ⟩;
          constructor;
          · convert Real.le_sqrt_of_sq_le h_gamma_sq_bounds.2 using 1 ; ring;
            field_simp;
            rw [ Real.sqrt_div ( by positivity ), Real.sqrt_eq_rpow, Real.sqrt_eq_rpow, ← Real.exp_mul ] ; ring;
            rw [ ← Real.exp_neg ] ; ring;
          · have h_gamma_lower_bound : ‖Complex.Gamma ((1 + 2 * t * Complex.I) / 2)‖ ^ 2 ≥ Real.pi * Real.exp (-Real.pi * |t|) := by
              simpa [ Real.exp_neg, div_eq_mul_inv ] using h_gamma_sq_bounds.1;
            contrapose! h_gamma_lower_bound;
            exact lt_of_lt_of_le ( pow_lt_pow_left₀ h_gamma_lower_bound ( norm_nonneg _ ) ( by norm_num ) ) ( by rw [ mul_pow, Real.sq_sqrt <| by positivity, ← Real.exp_nat_mul ] ; ring_nf; norm_num );
        exact ⟨ Real.sqrt Real.pi, Real.sqrt ( 2 * Real.pi ), Real.sqrt_pos.mpr Real.pi_pos, Real.sqrt_pos.mpr ( mul_pos zero_lt_two Real.pi_pos ), fun t ht => ⟨ by convert h_gamma_bounds t |>.2.le using 1 ; ring, by convert h_gamma_bounds t |>.1 using 1 ; ring ⟩ ⟩

/-
The norm of Gamma satisfies the recurrence $|\Gamma(s+1)| = |s||\Gamma(s)|$.
Using this, we show that $|\Gamma(3/2 + it)|$ grows like $|t| e^{-\pi|t|/2}$.
-/
theorem gamma_step_norm (s : ℂ) (h : s ≠ 0) : ‖Complex.Gamma (s + 1)‖ = ‖s‖ * ‖Complex.Gamma s‖ := by
  rw [Complex.Gamma_add_one s h, Complex.norm_mul]

theorem gamma_three_halves_growth :
    ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
      C₁ * |t| * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (3 / 2 + t * Complex.I)‖ ∧
      ‖Complex.Gamma (3 / 2 + t * Complex.I)‖ ≤ C₂ * |t| * Real.exp (-Real.pi * |t| / 2) := by
        -- Use `gamma_step_norm` to rewrite the goal in terms of `γ(1/2 + it)`.
        have h_step : ∀ t : ℝ, ‖(Complex.Gamma (3 / 2 + t * Complex.I))‖ = ‖(1 / 2 + t * Complex.I) * Complex.Gamma (1 / 2 + t * Complex.I)‖ := by
          intro t; rw [ show 3 / 2 + t * Complex.I = 1 / 2 + t * Complex.I + 1 by ring ] ; rw [ Complex.Gamma_add_one ] ; ring ; norm_num;
          norm_num [ Complex.ext_iff ];
        -- Use `gamma_half_growth` to bound `‖γ(1/2 + it)‖`.
        obtain ⟨C₁, C₂, hC₁_pos, hC₂_pos, h_bound⟩ : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| → C₁ * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ∧ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ≤ C₂ * Real.exp (-Real.pi * |t| / 2) := by
          exact gamma_half_growth
        -- Use `h_bound` to bound `‖(1/2 + it) * γ(1/2 + it)‖`.
        have h_bound_step : ∀ t : ℝ, 1 ≤ |t| → C₁ * |t| * Real.exp (-Real.pi * |t| / 2) ≤ ‖(1 / 2 + t * Complex.I) * Complex.Gamma (1 / 2 + t * Complex.I)‖ ∧ ‖(1 / 2 + t * Complex.I) * Complex.Gamma (1 / 2 + t * Complex.I)‖ ≤ (Real.sqrt 2) * C₂ * |t| * Real.exp (-Real.pi * |t| / 2) := by
          intro t ht; specialize h_bound t ht; norm_num [ Complex.norm_def, Complex.normSq ] at *;
          constructor;
          · refine' le_trans _ ( mul_le_mul_of_nonneg_left h_bound.1 <| Real.sqrt_nonneg _ );
            field_simp;
            exact Real.abs_le_sqrt ( by nlinarith only [ abs_mul_abs_self t ] );
          · refine le_trans ( mul_le_mul_of_nonneg_left h_bound.2 <| Real.sqrt_nonneg _ ) ?_;
            -- Simplify the inequality.
            suffices h_simp : Real.sqrt (1 / 4 + t * t) ≤ Real.sqrt 2 * |t| by
              convert mul_le_mul_of_nonneg_right h_simp ( by positivity : 0 ≤ C₂ * Real.exp ( - ( Real.pi * |t| ) / 2 ) ) using 1 ; ring;
            rw [ Real.sqrt_le_iff ] ; ring_nf ; norm_num ; nlinarith [ abs_mul_abs_self t, Real.sqrt_nonneg 2, Real.sq_sqrt zero_le_two ];
        exact ⟨ C₁, Real.sqrt 2 * C₂, hC₁_pos, mul_pos ( Real.sqrt_pos.mpr zero_lt_two ) hC₂_pos, fun t ht => by simpa only [ h_step ] using h_bound_step t ht ⟩

/-
If the Gamma function satisfies the Stirling growth condition at σ, it also satisfies it at σ + 1.
-/
def HasGammaGrowth (σ : ℝ) : Prop :=
  ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
    C₁ * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) ≤
      ‖Complex.Gamma (σ + t * Complex.I)‖ ∧
    ‖Complex.Gamma (σ + t * Complex.I)‖ ≤
      C₂ * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2)

theorem gamma_growth_step_up (σ : ℝ) (h : HasGammaGrowth σ) : HasGammaGrowth (σ + 1) := by
  obtain ⟨ C₁, C₂, hC₁, hC₂, hC ⟩ := h;
  -- Using the recurrence relation, we can bound $|\Gamma(\sigma+1+it)|$ in terms of $|\Gamma(\sigma+it)|$.
  have h_bound : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma ((σ + 1) + t * Complex.I)‖ = ‖(σ + t * Complex.I) * Complex.Gamma (σ + t * Complex.I)‖ := by
    intro t ht; rw [ show ( σ : ℂ ) + 1 + t * Complex.I = ( σ + t * Complex.I ) + 1 by ring, Complex.Gamma_add_one ] ; ring;
    intro h; specialize hC t ht; norm_num [ show ( σ : ℂ ) = -t * Complex.I by linear_combination' h ] at hC; ring_nf at hC; norm_num [ Complex.exp_re, Complex.exp_im, Real.exp_ne_zero ] at hC;
    exact not_lt.mpr hC.1 ( by exact mul_pos ( mul_pos hC₁ ( Real.rpow_pos_of_pos ( by positivity ) _ ) ) ( Real.exp_pos _ ) );
  -- Using the bounds from hC and the fact that |σ + it| is bounded, we can conclude the proof.
  have h_final : ∃ C₁' C₂' : ℝ, 0 < C₁' ∧ 0 < C₂' ∧ ∀ t : ℝ, 1 ≤ |t| → C₁' * |t| * |t| ^ (σ - 1 / 2) * Real.exp (-Real.pi * |t| / 2) ≤ ‖(σ + t * Complex.I) * Complex.Gamma (σ + t * Complex.I)‖ ∧ ‖(σ + t * Complex.I) * Complex.Gamma (σ + t * Complex.I)‖ ≤ C₂' * |t| * |t| ^ (σ - 1 / 2) * Real.exp (-Real.pi * |t| / 2) := by
    -- Using the bounds from hC and the fact that |σ + it| is bounded, we can find constants C₁' and C₂'.
    obtain ⟨C₁', C₂', hC₁', hC₂'⟩ : ∃ C₁' C₂' : ℝ, 0 < C₁' ∧ 0 < C₂' ∧ ∀ t : ℝ, 1 ≤ |t| → C₁' * |t| ≤ ‖σ + t * Complex.I‖ ∧ ‖σ + t * Complex.I‖ ≤ C₂' * |t| := by
      norm_num [ Complex.normSq, Complex.norm_def ];
      refine' ⟨ 1 / 2, by norm_num, Real.sqrt ( σ ^ 2 + 1 ), by positivity, fun t ht => ⟨ _, _ ⟩ ⟩;
      · exact Real.le_sqrt_of_sq_le ( by nlinarith [ sq_nonneg ( σ - t ), sq_nonneg ( σ + t ), abs_mul_abs_self t ] );
      · rw [ Real.sqrt_le_iff ];
        field_simp;
        exact ⟨ by positivity, by rw [ Real.sq_sqrt <| by positivity ] ; nlinarith [ abs_mul_abs_self t, show 1 ≤ |t|^2 by nlinarith [ abs_mul_abs_self t ] ] ⟩;
    refine' ⟨ C₁' * C₁, C₂' * C₂, mul_pos hC₁' hC₁, mul_pos hC₂'.1 hC₂, fun t ht => ⟨ _, _ ⟩ ⟩ <;> norm_num [ mul_assoc, mul_comm, mul_left_comm ] at *;
    · convert mul_le_mul ( hC₂'.2 t ht |>.1 ) ( hC t ht |>.1 ) ( by positivity ) ( by positivity ) using 1 ; ring;
    · convert mul_le_mul ( hC₂'.2 t ht |>.2 ) ( hC t ht |>.2 ) ( by positivity ) ( by nlinarith [ hC₂'.2 t ht ] ) using 1 ; ring;
  obtain ⟨ C₁', C₂', hC₁', hC₂', hC' ⟩ := h_final;
  refine' ⟨ C₁', C₂', hC₁', hC₂', fun t ht => _ ⟩;
  convert hC' t ht using 2 <;> push_cast [ h_bound t ht ] <;> ring;
  · rw [ show ( 1 / 2 + σ : ℝ ) = ( -1 / 2 + σ ) + 1 by ring, Real.rpow_add ( by positivity ), Real.rpow_one ] ; ring;
  · rw [ show ( 1 / 2 + σ : ℝ ) = -1 / 2 + σ + 1 by ring, Real.rpow_add ( by positivity ), Real.rpow_one ] ; ring

/-
If the Gamma function satisfies the Stirling growth condition at σ + 1, it also satisfies it at σ.
-/
theorem gamma_growth_step_down (σ : ℝ) (h : HasGammaGrowth (σ + 1)) : HasGammaGrowth σ := by
  -- By definition of HasGammaGrowth, there exist constants C₁' and C₂' such that for all t with |t| ≥ 1, the norm of Γ(σ + 1 + it) is between C₁' * |t|^(σ + 1/2) * exp(-π|t|/2) and C₂' * |t|^(σ + 1/2) * exp(-π|t|/2).
  obtain ⟨C₁', C₂', hC₁', hC₂', h_bounds⟩ := h;
  -- For $|t| \geq 1$, we have $|\sigma + it| \leq \sqrt{\sigma^2 + 1} |t|$.
  have h_bound_sigma_plus_it : ∀ t : ℝ, 1 ≤ |t| → ‖σ + t * Complex.I‖ ≤ Real.sqrt (σ ^ 2 + 1) * |t| := by
    norm_num [ Complex.normSq, Complex.norm_def ];
    exact fun t ht => by rw [ Real.sqrt_le_iff ] ; constructor <;> nlinarith [ show 1 ≤ |t| ^ 2 by nlinarith [ abs_mul_abs_self t ], Real.mul_self_sqrt ( show 0 ≤ σ ^ 2 + 1 by positivity ), Real.sqrt_nonneg ( σ ^ 2 + 1 ), abs_mul_abs_self t ] ;
  -- Using the bound $|\sigma + it| \leq \sqrt{\sigma^2 + 1} |t|$, we can derive the bounds for $|\Gamma(\sigma + it)|$.
  have h_gamma_sigma_bounds : ∀ t : ℝ, 1 ≤ |t| → C₁' * |t| ^ (σ + 1 - 1 / 2) * Real.exp (-Real.pi * |t| / 2) / (Real.sqrt (σ ^ 2 + 1) * |t|) ≤ ‖Complex.Gamma (σ + t * Complex.I)‖ ∧ ‖Complex.Gamma (σ + t * Complex.I)‖ ≤ C₂' * |t| ^ (σ + 1 - 1 / 2) * Real.exp (-Real.pi * |t| / 2) / |t| := by
    intro t ht
    have h_gamma_sigma_step : ‖Complex.Gamma (σ + t * Complex.I)‖ = ‖Complex.Gamma (σ + 1 + t * Complex.I)‖ / ‖σ + t * Complex.I‖ := by
      have h_gamma_sigma_step : Complex.Gamma (σ + t * Complex.I) = Complex.Gamma (σ + 1 + t * Complex.I) / (σ + t * Complex.I) := by
        by_cases h : ( σ : ℂ ) + t * Complex.I = 0 <;> simp_all +decide [ Complex.Gamma_add_one, mul_comm ];
        rw [ eq_div_iff h ] ; rw [ show ( σ : ℂ ) + 1 + Complex.I * t = ( σ : ℂ ) + Complex.I * t + 1 by ring ] ; rw [ Complex.Gamma_add_one ] ; ring ; aesop;
      rw [ h_gamma_sigma_step, norm_div ];
    simp +zetaDelta at *;
    rw [ h_gamma_sigma_step ];
    constructor;
    · gcongr;
      · norm_num [ Complex.ext_iff ];
        exact fun h => by rintro rfl; norm_num at ht;
      · exact h_bounds t ht |>.1;
      · exact h_bound_sigma_plus_it t ht;
    · gcongr;
      · exact h_bounds t ht |>.2;
      · norm_num [ Complex.normSq, Complex.norm_def ];
        exact Real.abs_le_sqrt ( by nlinarith );
  -- Simplify the expressions for the bounds.
  have h_gamma_sigma_bounds_simplified : ∀ t : ℝ, 1 ≤ |t| → C₁' / Real.sqrt (σ ^ 2 + 1) * |t| ^ (σ - 1 / 2) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (σ + t * Complex.I)‖ ∧ ‖Complex.Gamma (σ + t * Complex.I)‖ ≤ C₂' * |t| ^ (σ - 1 / 2) * Real.exp (-Real.pi * |t| / 2) := by
    intro t ht; specialize h_gamma_sigma_bounds t ht; convert h_gamma_sigma_bounds using 2 <;> ring;
    · rw [ show ( -1 / 2 + σ : ℝ ) = ( 1 / 2 + σ ) - 1 by ring, Real.rpow_sub_one ( by positivity ) ] ; ring;
    · rw [ show ( -1 / 2 + σ : ℝ ) = ( 1 / 2 + σ ) - 1 by ring, Real.rpow_sub_one ] <;> ring ; positivity;
  exact ⟨ C₁' / Real.sqrt ( σ ^ 2 + 1 ), C₂', by positivity, by positivity, h_gamma_sigma_bounds_simplified ⟩

/-
The function sinh(πt)^2 grows like exp(2π|t|) for |t| ≥ 1.
-/
theorem sinh_sq_growth :
    ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
      C₁ * Real.exp (2 * Real.pi * |t|) ≤ Real.sinh (Real.pi * t) ^ 2 ∧
      Real.sinh (Real.pi * t) ^ 2 ≤ C₂ * Real.exp (2 * Real.pi * |t|) := by
        -- Let's choose the constants $C₁$ and $C₂$ as described.
        use 1 / 16;
        field_simp;
        use 4;
        refine' ⟨ by norm_num, by norm_num, fun t ht => ⟨ _, _ ⟩ ⟩;
        · rw [ Real.sinh_eq ];
          cases abs_cases t <;> push_cast [ * ] at * <;> ring_nf at * <;> norm_num at *;
          · norm_num [ sq, ← Real.exp_add ] ; ring_nf;
            nlinarith [ Real.pi_gt_three, Real.add_one_le_exp ( t * Real.pi * 2 ), Real.exp_pos ( - ( t * Real.pi * 2 ) ), Real.exp_neg ( t * Real.pi * 2 ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( t * Real.pi * 2 ) ) ) ];
          · norm_num [ sq, ← Real.exp_add ] ; ring_nf;
            nlinarith [ Real.pi_gt_three, Real.add_one_le_exp ( t * Real.pi * 2 ), Real.add_one_le_exp ( - ( t * Real.pi * 2 ) ), Real.exp_pos ( t * Real.pi * 2 ), Real.exp_pos ( - ( t * Real.pi * 2 ) ) ];
        · rw [ Real.sinh_eq ];
          cases abs_cases t <;> simp +decide [ *, mul_assoc, mul_comm, mul_left_comm ];
          · rw [ show t * ( Real.pi * 2 ) = t * Real.pi + t * Real.pi by ring, Real.exp_add ];
            nlinarith [ Real.exp_pos ( t * Real.pi ), Real.exp_pos ( - ( t * Real.pi ) ), Real.exp_le_exp.2 ( show - ( t * Real.pi ) ≤ t * Real.pi by nlinarith [ Real.pi_pos ] ) ];
          · ring_nf;
            norm_num [ ← Real.exp_add, ← Real.exp_nat_mul ] ; ring_nf ; norm_num;
            nlinarith [ Real.exp_pos ( t * Real.pi * 2 ), Real.exp_pos ( - ( t * Real.pi * 2 ) ), Real.exp_le_one_iff.mpr ( show t * Real.pi * 2 ≤ 0 by nlinarith [ Real.pi_pos ] ), Real.add_one_le_exp ( - ( t * Real.pi * 2 ) ) ]

/-
The squared magnitude of the sine function grows exponentially along vertical lines.
-/
theorem complex_sin_sq_growth (σ : ℝ) :
    ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
      C₁ * Real.exp (2 * Real.pi * |t|) ≤ ‖Complex.sin (Real.pi * (σ + t * Complex.I))‖ ^ 2 ∧
      ‖Complex.sin (Real.pi * (σ + t * Complex.I))‖ ^ 2 ≤ C₂ * Real.exp (2 * Real.pi * |t|) := by
        -- Use `sinh_sq_growth` to get bounds for $\sinh^2(\pi t)$.
        obtain ⟨C₁_sinh, C₂_sinh, hC₁_sinh, hC₂_sinh⟩ : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
          C₁ * Real.exp (2 * Real.pi * |t|) ≤ Real.sinh (Real.pi * t) ^ 2 ∧
          Real.sinh (Real.pi * t) ^ 2 ≤ C₂ * Real.exp (2 * Real.pi * |t|) := sinh_sq_growth;
        -- Use the identity $|\sin(\pi(\sigma+it))|^2 = \sin^2(\pi\sigma) + \sinh^2(\pi t)$ to bound $|sin(\pi(\sigma+it))|^2$.
        have h_sin_sq : ∀ t : ℝ, 1 ≤ |t| → (Real.sin (Real.pi * σ)) ^ 2 + (Real.sinh (Real.pi * t)) ^ 2 ≤ ‖Complex.sin (Real.pi * (σ + t * Complex.I))‖ ^ 2 ∧ ‖Complex.sin (Real.pi * (σ + t * Complex.I))‖ ^ 2 ≤ (Real.sin (Real.pi * σ)) ^ 2 + (Real.sinh (Real.pi * t)) ^ 2 := by
          norm_num [ Complex.normSq, Complex.sq_norm ];
          norm_num [ Complex.sin, Complex.exp_re, Complex.exp_im ] ; ring_nf ; norm_num;
          norm_num [ Real.sinh_eq, Real.cosh_eq, Real.exp_neg, Real.exp_ne_zero, mul_assoc, sq, Real.cos_sq' ] ; ring_nf ; norm_num;
          intro t ht; rw [ Real.sin_sq, Real.cos_sq ] ; ring_nf; norm_num;
        refine' ⟨ C₁_sinh, C₂_sinh + ( Real.sin ( Real.pi * σ ) ) ^ 2 / Real.exp ( 2 * Real.pi ), _, _, _ ⟩;
        · exact hC₁_sinh
        · exact add_pos_of_pos_of_nonneg hC₂_sinh.1 ( div_nonneg ( sq_nonneg _ ) ( Real.exp_nonneg _ ) );
        · intro t ht; constructor <;> nlinarith [ h_sin_sq t ht, hC₂_sinh.2 t ht, Real.exp_pos ( 2 * Real.pi * |t| ), Real.exp_pos ( 2 * Real.pi ), mul_div_cancel₀ ( Real.sin ( Real.pi * σ ) ^ 2 ) ( ne_of_gt ( Real.exp_pos ( 2 * Real.pi ) ) ), Real.exp_le_exp.mpr ( show 2 * Real.pi * |t| ≥ 2 * Real.pi by nlinarith [ Real.pi_pos, abs_nonneg t ] ) ] ;

/-
Definitions of upper and lower Stirling growth conditions.
-/
def HasGammaUpperGrowth (σ : ℝ) : Prop :=
  ∃ C : ℝ, 0 < C ∧ ∀ t : ℝ, 1 ≤ |t| →
    ‖Complex.Gamma (σ + t * Complex.I)‖ ≤ C * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2)

def HasGammaLowerGrowth (σ : ℝ) : Prop :=
  ∃ C : ℝ, 0 < C ∧ ∀ t : ℝ, 1 ≤ |t| →
    C * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (σ + t * Complex.I)‖

/-
The Stirling normalizer function grows like |t|^(1/2-σ) * exp(π|t|/2).
-/
noncomputable def StirlingNormalizer (z : ℂ) : ℂ :=
  Complex.exp z * z ^ (1 / 2 - z)

theorem stirling_normalizer_bound (σ : ℝ) (t : ℝ) (hσ : 0 < σ) (ht : 1 ≤ |t|) :
    ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧
    C₁ * |t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2) ≤ ‖StirlingNormalizer (σ + t * Complex.I)‖ ∧
    ‖StirlingNormalizer (σ + t * Complex.I)‖ ≤ C₂ * |t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2) := by
      field_simp;
      refine' ⟨ ‖StirlingNormalizer ( σ + t * Complex.I )‖ / ( |t| ^ ( ( 1 - 2 * σ ) / 2 ) * Real.exp ( Real.pi * |t| / 2 ) ), ‖StirlingNormalizer ( σ + t * Complex.I )‖ / ( |t| ^ ( ( 1 - 2 * σ ) / 2 ) * Real.exp ( Real.pi * |t| / 2 ) ), _, _, _, _ ⟩;
      · refine' div_pos ( norm_pos_iff.mpr _ ) ( mul_pos ( Real.rpow_pos_of_pos ( by positivity ) _ ) ( Real.exp_pos _ ) );
        unfold StirlingNormalizer;
        norm_num [ Complex.exp_ne_zero, Complex.cpow_def ];
        split_ifs <;> simp_all +decide [ Complex.exp_ne_zero ];
        simp_all +decide [ Complex.ext_iff ];
      · apply_rules [ div_pos, norm_pos_iff.mpr ];
        · unfold StirlingNormalizer;
          norm_num [ Complex.exp_ne_zero, show ( σ : ℂ ) + t * Complex.I ≠ 0 from by norm_num [ Complex.ext_iff ] ; intros; nlinarith [ abs_mul_abs_self t ] ];
        · positivity;
      · rw [ mul_assoc, div_mul_cancel₀ _ ( by positivity ) ];
      · rw [ mul_assoc, div_mul_cancel₀ _ ( by positivity ) ]

/-
Defining the normalized Gamma function.
-/
noncomputable def StirlingNormalizedGamma (z : ℂ) : ℂ :=
  Complex.Gamma z * StirlingNormalizer z

/-
The Stirling normalizer function satisfies uniform growth bounds for all t with |t| >= 1.
-/
theorem stirling_normalizer_bound_uniform (σ : ℝ) (hσ : 0 < σ) :
    ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
    C₁ * |t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2) ≤ ‖StirlingNormalizer (σ + t * Complex.I)‖ ∧
    ‖StirlingNormalizer (σ + t * Complex.I)‖ ≤ C₂ * |t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2) := by
      by_contra h_contra;
      obtain ⟨C₁, C₂, hC₁, hC₂⟩ : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| → C₁ * |t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2) ≤ ‖StirlingNormalizer (σ + t * Complex.I)‖ ∧ ‖StirlingNormalizer (σ + t * Complex.I)‖ ≤ C₂ * |t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2) := by
        have h_lim : Filter.Tendsto (fun t : ℝ => ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2))) Filter.atTop (nhds 1) := by
          have h_lim : Filter.Tendsto (fun t : ℝ => Real.exp σ * (Real.sqrt (σ^2 + t^2)) ^ (1 / 2 - σ) * Real.exp (t * Real.arctan (t / σ)) / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2))) Filter.atTop (nhds 1) := by
            -- We can simplify the expression inside the limit.
            suffices h_simplify : Filter.Tendsto (fun t : ℝ => Real.exp σ * (Real.sqrt (σ^2 + t^2) / |t|) ^ (1 / 2 - σ) * Real.exp (t * (Real.arctan (t / σ) - Real.pi / 2))) Filter.atTop (nhds 1) by
              refine h_simplify.congr' ?_;
              filter_upwards [ Filter.eventually_gt_atTop 0 ] with t ht;
              rw [ Real.div_rpow ( by positivity ) ( by positivity ) ] ; ring;
              norm_num [ Real.exp_add, Real.exp_neg, abs_of_pos ht ] ; ring;
            -- We'll use the fact that $\arctan(t/\sigma) = \pi/2 - \arctan(\sigma/t)$ for $t > 0$.
            have h_arctan : ∀ t : ℝ, 0 < t → Real.arctan (t / σ) = Real.pi / 2 - Real.arctan (σ / t) := by
              intro t ht; rw [ Real.arctan_eq_of_tan_eq ] ; simp +decide [ Real.tan_pi_div_two_sub ];
              constructor <;> linarith [ Real.arctan_pos.2 ( div_pos hσ ht ), Real.arctan_lt_pi_div_two ( σ / t ) ];
            -- We'll use the fact that $\arctan(\sigma/t) \sim \sigma/t$ as $t \to \infty$.
            have h_arctan_approx : Filter.Tendsto (fun t : ℝ => t * Real.arctan (σ / t)) Filter.atTop (nhds σ) := by
              -- Let $y = \frac{1}{t}$, so we can rewrite the limit as $\lim_{y \to 0^+} \frac{\arctan(\sigma y)}{y}$.
              suffices h_arctan_y : Filter.Tendsto (fun y : ℝ => Real.arctan (σ * y) / y) (Filter.map (fun t => 1 / t) Filter.atTop) (nhds σ) by
                exact h_arctan_y.congr ( by simp +contextual [ div_eq_mul_inv, mul_comm ] );
              simpa [ div_eq_inv_mul ] using HasDerivAt.tendsto_slope_zero_right ( HasDerivAt.arctan ( HasDerivAt.const_mul σ ( hasDerivAt_id 0 ) ) );
            -- We'll use the fact that $\sqrt{\sigma^2 + t^2} / |t| \to 1$ as $t \to \infty$.
            have h_sqrt : Filter.Tendsto (fun t : ℝ => Real.sqrt (σ^2 + t^2) / |t|) Filter.atTop (nhds 1) := by
              -- We can simplify the expression inside the limit: $\frac{\sqrt{\sigma^2 + t^2}}{|t|} = \sqrt{\frac{\sigma^2}{t^2} + 1}$.
              suffices h_sqrt_simplified : Filter.Tendsto (fun t : ℝ => Real.sqrt (σ^2 / t^2 + 1)) Filter.atTop (nhds 1) by
                refine h_sqrt_simplified.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with t ht using by rw [ show σ ^ 2 + t ^ 2 = t ^ 2 * ( σ ^ 2 / t ^ 2 + 1 ) by nlinarith [ div_mul_cancel₀ ( σ ^ 2 ) ( ne_of_gt ( sq_pos_of_pos ht ) ) ], Real.sqrt_mul ( sq_nonneg _ ), Real.sqrt_sq ht.le ] ; rw [ abs_of_pos ht ] ; ring_nf; norm_num [ ht.ne' ] );
              exact le_trans ( Filter.Tendsto.sqrt ( Filter.Tendsto.add ( tendsto_const_nhds.div_atTop ( by norm_num ) ) tendsto_const_nhds ) ) ( by norm_num );
            have h_exp : Filter.Tendsto (fun t : ℝ => Real.exp (t * (Real.arctan (t / σ) - Real.pi / 2))) Filter.atTop (nhds (Real.exp (-σ))) := by
              exact Filter.Tendsto.rexp ( by simpa using h_arctan_approx.neg.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with t ht using by rw [ h_arctan t ht ] ; ring ) );
            convert Filter.Tendsto.mul ( Filter.Tendsto.mul tendsto_const_nhds ( h_sqrt.rpow_const _ ) ) h_exp using 2 <;> norm_num [ ← Real.exp_add ];
          refine h_lim.congr' ?_;
          filter_upwards [ Filter.eventually_gt_atTop 0 ] with t ht
          simp [StirlingNormalizer];
          norm_num [ Complex.norm_exp, Complex.norm_cpow_of_ne_zero ( show ( σ : ℂ ) + t * Complex.I ≠ 0 from by norm_num [ Complex.ext_iff ] ; intros; nlinarith ) ];
          rw [ Complex.arg ] ; norm_num [ Complex.normSq, Complex.norm_def, ht.le, hσ.le ] ; ring;
          rw [ Real.arcsin_eq_arctan ] <;> norm_num [ ht.ne', hσ.ne', Real.sqrt_ne_zero'.mpr ( show 0 < σ ^ 2 + t ^ 2 by positivity ) ] ; ring;
          · field_simp;
            rw [ ← Real.exp_add ] ; norm_num [ Real.sq_sqrt ( show 0 ≤ σ ^ 2 + t ^ 2 by positivity ), ht.le, hσ.le ];
            rw [ mul_div_cancel₀ _ ( by positivity ) ] ; ring;
          · exact ⟨ by nlinarith [ inv_pos.mpr ( Real.sqrt_pos.mpr ( show 0 < σ ^ 2 + t ^ 2 by positivity ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ( show 0 < σ ^ 2 + t ^ 2 by positivity ) ) ), Real.sqrt_nonneg ( σ ^ 2 + t ^ 2 ), Real.mul_self_sqrt ( show 0 ≤ σ ^ 2 + t ^ 2 by positivity ) ], by rw [ mul_inv_lt_iff₀ ( Real.sqrt_pos.mpr ( show 0 < σ ^ 2 + t ^ 2 by positivity ) ) ] ; nlinarith [ Real.sqrt_nonneg ( σ ^ 2 + t ^ 2 ), Real.mul_self_sqrt ( show 0 ≤ σ ^ 2 + t ^ 2 by positivity ) ] ⟩
        have h_lim_neg : Filter.Tendsto (fun t : ℝ => ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2))) Filter.atBot (nhds 1) := by
          convert h_lim.comp Filter.tendsto_neg_atBot_atTop using 2 ; norm_num [ StirlingNormalizer ];
          norm_num [ Complex.norm_exp, Complex.norm_cpow_of_ne_zero, show ( σ : ℂ ) + ( ‹ℝ› : ℝ ) * Complex.I ≠ 0 from ne_of_apply_ne Complex.re <| by norm_num; linarith, show ( σ : ℂ ) + - ( ‹ℝ› * Complex.I ) ≠ 0 from ne_of_apply_ne Complex.re <| by norm_num; linarith ];
          norm_num [ Complex.normSq, Complex.norm_def, Complex.arg ] ; ring;
          split_ifs <;> simp +decide [ *, Real.arcsin_neg ] <;> ring;
          · linarith;
          · linarith
        -- Since the limit is 1, there exists $M$ such that for $|t| \ge M$, $1/2 \le R(t) \le 3/2$.
        obtain ⟨M, hM⟩ : ∃ M : ℝ, ∀ t : ℝ, M ≤ |t| → 1 / 2 ≤ ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2)) ∧ ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2)) ≤ 3 / 2 := by
          have := Metric.tendsto_nhds.mp h_lim ( 1 / 2 ) ( by norm_num ) ; have := Metric.tendsto_nhds.mp h_lim_neg ( 1 / 2 ) ( by norm_num ) ; norm_num at *;
          rcases ‹∃ a : ℝ, ∀ b : ℝ, a ≤ b → Dist.dist _ _ < 1 / 2› with ⟨ M₁, HM₁ ⟩ ; rcases ‹∃ a : ℝ, ∀ b : ℝ, b ≤ a → Dist.dist _ _ < 1 / 2› with ⟨ M₂, HM₂ ⟩ ; exact ⟨ |M₁| + |M₂| + 1, fun t ht => ⟨ by cases abs_cases t <;> cases abs_cases M₁ <;> cases abs_cases M₂ <;> first | linarith [ abs_lt.mp ( HM₁ _ ( by linarith : M₁ ≤ t ) ) ] | linarith [ abs_lt.mp ( HM₂ _ ( by linarith : t ≤ M₂ ) ) ], by cases abs_cases t <;> cases abs_cases M₁ <;> cases abs_cases M₂ <;> first | linarith [ abs_lt.mp ( HM₁ _ ( by linarith : M₁ ≤ t ) ) ] | linarith [ abs_lt.mp ( HM₂ _ ( by linarith : t ≤ M₂ ) ) ] ⟩ ⟩ ;
        -- For $1 \le |t| \le M$, the function $R(t)$ is continuous and positive, so it attains a minimum and maximum.
        obtain ⟨C₁, C₂, hC₁, hC₂⟩ : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| ∧ |t| ≤ M → C₁ ≤ ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2)) ∧ ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2)) ≤ C₂ := by
          have h_cont : ContinuousOn (fun t : ℝ => ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2))) {t : ℝ | 1 ≤ |t| ∧ |t| ≤ M} := by
            refine' ContinuousOn.div _ _ _;
            · refine' ContinuousOn.norm _;
              refine' ContinuousOn.mul _ _;
              · fun_prop;
              · refine' ContinuousOn.cpow _ _ _;
                · fun_prop;
                · fun_prop;
                · norm_num [ Complex.slitPlane ];
                  exact fun _ _ _ => Or.inl hσ;
            · exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.mul ( ContinuousAt.rpow ( continuousAt_id.abs ) continuousAt_const <| Or.inl <| by linarith [ ht.1 ] ) <| ContinuousAt.rexp <| ContinuousAt.div_const ( continuousAt_const.mul continuousAt_id.abs ) _;
            · exact fun t ht => mul_ne_zero ( ne_of_gt ( Real.rpow_pos_of_pos ( by linarith [ ht.1 ] ) _ ) ) ( ne_of_gt ( Real.exp_pos _ ) );
          have h_compact : IsCompact {t : ℝ | 1 ≤ |t| ∧ |t| ≤ M} := by
            refine' ( Metric.isCompact_iff_isClosed_bounded.mpr _ );
            exact ⟨ isClosed_Icc.preimage continuous_abs, isBounded_iff_forall_norm_le.mpr ⟨ M, fun t ht => ht.2 ⟩ ⟩;
          obtain ⟨C₁, hC₁⟩ : ∃ C₁ : ℝ, 0 < C₁ ∧ ∀ t : ℝ, 1 ≤ |t| ∧ |t| ≤ M → C₁ ≤ ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2)) := by
            have h_pos : ∀ t : ℝ, 1 ≤ |t| ∧ |t| ≤ M → 0 < ‖StirlingNormalizer (σ + t * Complex.I)‖ / (|t| ^ (1 / 2 - σ) * Real.exp (Real.pi * |t| / 2)) := by
              intro t ht; refine' div_pos _ _ <;> norm_num [ Complex.Gamma_ne_zero ];
              · unfold StirlingNormalizer; norm_num [ Complex.exp_ne_zero ] ;
                norm_num [ Complex.ext_iff ] ; intros ; linarith;
              · exact mul_pos ( Real.rpow_pos_of_pos ( by linarith ) _ ) ( Real.exp_pos _ );
            -- Use IsCompact.exists_forall_le' for positive continuous function on compact set
            obtain ⟨C₁', hC₁'_pos, hC₁'_le⟩ := h_compact.exists_forall_le' h_cont (fun t ht => h_pos t ht)
            exact ⟨C₁', hC₁'_pos, fun t ht => hC₁'_le t ht⟩
          obtain ⟨ C₂, hC₂ ⟩ := h_compact.exists_bound_of_continuousOn h_cont;
          exact ⟨ C₁, Max.max C₂ 1, hC₁.1, by positivity, fun t ht => ⟨ hC₁.2 t ht, le_trans ( le_abs_self _ ) ( le_trans ( hC₂ t ht ) ( le_max_left _ _ ) ) ⟩ ⟩;
        refine' ⟨ Min.min C₁ ( 1 / 2 ), Max.max C₂ ( 3 / 2 ), _, _, _ ⟩ <;> norm_num;
        · linarith;
        · intro t ht; by_cases h : |t| ≤ M <;> simp_all +decide [ mul_assoc ] ;
          · constructor <;> nlinarith [ hC₂.2 t ht h, min_le_left C₁ 2⁻¹, min_le_right C₁ 2⁻¹, le_max_left C₂ ( 3 / 2 ), le_max_right C₂ ( 3 / 2 ), show 0 < |t| ^ ( 2⁻¹ - σ ) * Real.exp ( Real.pi * |t| / 2 ) by positivity, mul_div_cancel₀ ( ‖StirlingNormalizer ( σ + t * Complex.I )‖ ) ( show ( |t| ^ ( 2⁻¹ - σ ) * Real.exp ( Real.pi * |t| / 2 ) ) ≠ 0 by positivity ) ];
          · have := hM t h.le;
            exact ⟨ by rw [ le_div_iff₀ ( by positivity ) ] at this; nlinarith [ min_le_left C₁ ( 2⁻¹ : ℝ ), min_le_right C₁ ( 2⁻¹ : ℝ ), show 0 < |t| ^ ( 2⁻¹ - σ ) * Real.exp ( Real.pi * |t| / 2 ) by positivity ], by rw [ div_le_iff₀ ( by positivity ) ] at this; nlinarith [ le_max_left C₂ ( 3 / 2 ), le_max_right C₂ ( 3 / 2 ), show 0 < |t| ^ ( 2⁻¹ - σ ) * Real.exp ( Real.pi * |t| / 2 ) by positivity ] ⟩;
      exact h_contra ⟨ C₁, C₂, hC₁, hC₂.1, hC₂.2 ⟩

/-
The normalized Gamma function is bounded by a constant for large |t|.
-/
theorem stirling_normalized_gamma_bounded_large_t (σ : ℝ) (hσ : 0 < σ) (h : HasGammaUpperGrowth σ) :
    ∃ C, ∀ t : ℝ, 1 ≤ |t| → ‖StirlingNormalizedGamma (σ + t * Complex.I)‖ ≤ C := by
      -- Using the bounds from the provided solution, we get that the product of the norms is bounded by a constant.
      obtain ⟨C₁, C₂, hC₁, hC₂⟩ : ∃ C₁ C₂ : ℝ, 0 < C₁ ∧ 0 < C₂ ∧ ∀ t : ℝ, 1 ≤ |t| →
        ‖Complex.Gamma (σ + t * Complex.I)‖ ≤ C₁ * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) ∧
        ‖StirlingNormalizer (σ + t * Complex.I)‖ ≤ C₂ * |t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2) := by
          rcases h with ⟨ C₁, hC₁, hC₁' ⟩ ; rcases ( stirling_normalizer_bound_uniform σ hσ ) with ⟨ C₂, C₃, hC₂, hC₃, hC₂' ⟩ ; use C₁, C₃; aesop;
      use C₁ * C₂ * 1 * 1;
      intro t ht; rw [ show StirlingNormalizedGamma ( σ + t * Complex.I ) = Complex.Gamma ( σ + t * Complex.I ) * StirlingNormalizer ( σ + t * Complex.I ) by rfl ] ; rw [ norm_mul ] ; refine' le_trans ( mul_le_mul ( hC₂.2 t ht |>.1 ) ( hC₂.2 t ht |>.2 ) ( by positivity ) ( by positivity ) ) _ ; ring_nf ; norm_num [ ← Real.exp_add, ← Real.exp_neg ] ;
      norm_num [ mul_assoc, mul_left_comm, ← Real.exp_add ] ; ring_nf ; norm_num [ ne_of_gt ( zero_lt_one.trans_le ht ) ] ;
      rw [ mul_assoc, ← Real.rpow_add ( by positivity ) ] ; norm_num

/-
Algebraic simplification for Stirling approximation terms.
-/
theorem stirling_algebraic_simplification (t σ : ℝ) (ht : 0 < |t|) :
    |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2) * (|t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2)) = 1 := by
      rw [ ← mul_mul_mul_comm, ← Real.rpow_add, ← Real.exp_add ] <;> norm_num [ ht.ne' ];
      · ring;
      · aesop

/-
The upper Stirling growth condition is equivalent to the boundedness of the normalized Gamma function.
-/
theorem has_gamma_upper_growth_iff_bounded_normalized (σ : ℝ) (hσ : 0 < σ) :
    HasGammaUpperGrowth σ ↔ ∃ C, ∀ t : ℝ, 1 ≤ |t| → ‖StirlingNormalizedGamma (σ + t * Complex.I)‖ ≤ C := by
      refine' ⟨ _, fun h => _ ⟩;
      · exact stirling_normalized_gamma_bounded_large_t σ hσ
      · -- By definition of $StirlingNormalizer$, we know that $|StirlingNormalizer (σ + t * Complex.I)| \geq C₁ * |t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2)$ for some $C₁ > 0$.
        obtain ⟨C₁, hC₁⟩ : ∃ C₁ > 0, ∀ t : ℝ, 1 ≤ |t| → |t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2) ≤ ‖StirlingNormalizer (σ + t * Complex.I)‖ / C₁ := by
          have := @stirling_normalizer_bound_uniform σ hσ;
          obtain ⟨ C₁, C₂, hC₁, hC₂, h ⟩ := this; exact ⟨ C₁, hC₁, fun t ht => by rw [ le_div_iff₀' hC₁ ] ; linarith [ h t ht ] ⟩ ;
        -- By definition of $StirlingNormalizedGamma$, we know that $|StirlingNormalizedGamma (σ + t * Complex.I)| \leq C$ for some $C > 0$.
        obtain ⟨C, hC⟩ : ∃ C > 0, ∀ t : ℝ, 1 ≤ |t| → ‖StirlingNormalizedGamma (σ + t * Complex.I)‖ ≤ C := by
          exact ⟨ Max.max h.choose 1, by positivity, fun t ht => le_trans ( h.choose_spec t ht ) ( le_max_left _ _ ) ⟩;
        refine' ⟨ C / C₁, div_pos hC.1 hC₁.1, fun t ht => _ ⟩;
        have h_bound : ‖Complex.Gamma (σ + t * Complex.I)‖ * ‖StirlingNormalizer (σ + t * Complex.I)‖ ≤ C := by
          convert hC.2 t ht using 1 ; norm_num [ StirlingNormalizedGamma ];
        have h_bound : ‖Complex.Gamma (σ + t * Complex.I)‖ ≤ C / (C₁ * |t|^(1/2 - σ) * Real.exp (Real.pi * |t| / 2)) := by
          rw [ le_div_iff₀ ];
          · have := hC₁.2 t ht; rw [ le_div_iff₀' hC₁.1 ] at this; nlinarith [ norm_nonneg ( Complex.Gamma ( σ + t * Complex.I ) ) ] ;
          · exact mul_pos ( mul_pos hC₁.1 ( Real.rpow_pos_of_pos ( by positivity ) _ ) ) ( Real.exp_pos _ );
        field_simp;
        convert h_bound using 1 ; rw [ show ( σ * 2 - 1 ) / 2 = - ( 1 / 2 - σ ) by ring ] ; rw [ Real.rpow_neg ( by positivity ) ] ; ring;
        rw [ ← Real.exp_neg ] ; ring

end Aristotle.GammaGrowthBoundsV2
