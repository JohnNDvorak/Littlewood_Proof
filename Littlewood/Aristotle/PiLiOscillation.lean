/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9a2738e7-1e41-4e58-9d09-adef303a1f27

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

open Real Nat Filter Topology

/-- Chebyshev's psi function: ψ(x) = ∑_{n ≤ x} Λ(n) -/
noncomputable def chebyshevPsi (x : ℝ) : ℝ := (Finset.range (Nat.floor x + 1)).sum (fun n => ArithmeticFunction.vonMangoldt n)

/-- Real-valued prime counting function: π(x) -/
noncomputable def primeCountingReal (x : ℝ) : ℝ := (primeCounting (Nat.floor x) : ℝ)

/-- Logarithmic integral: li(x) = ∫₂ˣ dt/log t -/
noncomputable def li (x : ℝ) : ℝ := ∫ t in (2 : ℝ)..x, 1 / Real.log t

/-- The error term T(x) = Σ_{p^k ≤ x, k≥2} 1/k -/
noncomputable def T_error (x : ℝ) : ℝ := (Finset.range (Nat.floor x + 1)).sum (fun n => if IsPrimePow n ∧ ¬ n.Prime then 1 / ((Nat.factorization n) n.minFac : ℝ) else 0)

/-- The integral error term -/
noncomputable def integral_error (x : ℝ) : ℝ := ∫ t in (2 : ℝ)..x, (chebyshevPsi t - t) / (t * (Real.log t)^2)

variable (key_decomposition : ∃ C, ∀ x ≥ 2, primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - T_error x + integral_error x + C)

variable (T_error_bound : ∃ C_T, ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)

variable (integral_error_bound : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x)

/-
The combined error term |-T(x) + integral(x) + C| is bounded by (C_T + ε) * √x/log x for large x.
-/
variable (key_decomposition : ∃ C, ∀ x ≥ 2, primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - T_error x + integral_error x + C)

variable (T_error_bound : ∃ C_T, ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)

variable (integral_error_bound : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x)

variable (hardy_bound_pos : ∀ C, ∀ M, ∃ x > M, chebyshevPsi x - x > C * Real.sqrt x)
variable (hardy_bound_neg : ∀ C, ∀ M, ∃ x > M, chebyshevPsi x - x < -C * Real.sqrt x)

lemma combined_error_bound
    (C_decomp : ℝ)
    (C_T : ℝ)
    (hT : ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)
    (hInt : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x) :
    ∀ ε > 0, ∃ M, ∀ x > M, |- T_error x + integral_error x + C_decomp| ≤ (C_T + ε) * Real.sqrt x / Real.log x := by
      -- Let's choose any $\epsilon > 0$.
      intro ε hεpos
      -- Let's choose $M$ such that for all $x > M$, $|C_decomp| < \frac{\epsilon}{3} \cdot \frac{\sqrt{x}}{\log x}$.
      obtain ⟨M₁, hM₁⟩ : ∃ M₁ : ℝ, ∀ x > M₁, |C_decomp| < ε / 3 * Real.sqrt x / Real.log x := by
        -- We can choose $M$ such that for all $x > M$, $\frac{\sqrt{x}}{\have x} > \frac{3|C_decomp|}{\epsilon}$.
        have hM₁_exists : ∃ M₁ : ℝ, ∀ x > M₁, Real.sqrt x / Real.log x > 3 * |C_decomp| / ε := by
          have h_lim : Filter.Tendsto (fun x : ℝ => Real.sqrt x / Real.log x) Filter.atTop Filter.atTop := by
            -- We can use the change of variables $u = \log x$ to transform the limit expression.
            suffices h_log : Filter.Tendsto (fun u : ℝ => Real.exp (u / 2) / u) Filter.atTop Filter.atTop by
              have := h_log.comp Real.tendsto_log_atTop;
              refine this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Function.comp_apply, Real.sqrt_eq_rpow, Real.rpow_def_of_pos hx ] ; ring );
            -- Let $y = \frac{u}{2}$, so we can rewrite the limit expression as $\lim_{y \to \infty} \frac{e^y}{2y}$.
            suffices h_y : Filter.Tendsto (fun y : ℝ => Real.exp y / (2 * y)) Filter.atTop Filter.atTop by
              convert h_y.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 2⁻¹ : ℝ ) ) ) using 2 ; norm_num ; ring;
            ring_nf;
            exact Filter.Tendsto.atTop_mul_const ( by norm_num ) ( by simpa using Real.tendsto_exp_div_pow_atTop 1 );
          exact Filter.eventually_atTop.mp ( h_lim.eventually_gt_atTop ( 3 * |C_decomp| / ε ) ) |> fun ⟨ M₁, hM₁ ⟩ => ⟨ M₁, fun x hx => hM₁ x hx.le ⟩;
        exact hM₁_exists.imp fun M₁ hM₁ x hx => by have := hM₁ x hx; ring_nf at this ⊢; nlinarith [ mul_inv_cancel_left₀ hεpos.ne' |C_decomp| ] ;
      obtain ⟨ M₂, hM₂ ⟩ := hInt ( ε / 3 ) ( by positivity );
      refine' ⟨ Max.max M₁ ( Max.max M₂ 2 ), fun x hx => abs_le.mpr ⟨ _, _ ⟩ ⟩ <;> have := hM₁ x ( lt_of_le_of_lt ( le_max_left _ _ ) hx ) <;> have := hM₂ x ( lt_of_le_of_lt ( le_max_of_le_right ( le_max_left _ _ ) ) hx ) <;> have := hT x ( le_of_lt ( lt_of_le_of_lt ( le_max_of_le_right ( le_max_right _ _ ) ) hx ) ) <;> norm_num at *;
      · ring_nf at *;
        linarith [ abs_le.mp ‹|T_error x| ≤ C_T * Real.sqrt x * ( Real.log x ) ⁻¹›, abs_le.mp ‹|integral_error x| ≤ ε * Real.sqrt x * ( Real.log x ) ⁻¹ * ( 1 / 3 ) ›, abs_lt.mp this ];
      · ring_nf at *;
        nlinarith [ abs_le.mp ‹|T_error x| ≤ C_T * Real.sqrt x * ( Real.log x ) ⁻¹›, abs_le.mp ‹|integral_error x| ≤ ε * Real.sqrt x * ( Real.log x ) ⁻¹ * ( 1 / 3 ) ›, abs_lt.mp ‹|C_decomp| < ε * Real.sqrt x * ( Real.log x ) ⁻¹ * ( 1 / 3 ) ›, show 0 ≤ Real.sqrt x * ( Real.log x ) ⁻¹ by exact mul_nonneg ( Real.sqrt_nonneg _ ) ( inv_nonneg.mpr ( Real.log_nonneg ( by linarith ) ) ) ]

lemma exists_pos_oscillation
    (key_decomposition : ∃ C, ∀ x ≥ 2, primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - T_error x + integral_error x + C)
    (T_error_bound : ∃ C_T, ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)
    (integral_error_bound : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x)
    (hardy_bound_pos : ∀ C, ∀ M, ∃ x > M, chebyshevPsi x - x > C * Real.sqrt x)
    : ∀ M, ∃ x > M, primeCountingReal x - li x > 0 := by
      -- Set C_Hardy = C_T + 2.
      obtain ⟨C_decomp, h_decomp⟩ := key_decomposition
      obtain ⟨C_T, h_T⟩ := T_error_bound
      set C_Hardy := C_T + 2;
      -- Use combined_error_bound with ε=1 to find M_err such that error is bounded by (C_T+1)√x/log x for x > M_err.
      obtain ⟨M_ERR, hM_ERR⟩ : ∃ M_ERR, ∀ x > M_ERR, |- T_error x + integral_error x + C_decomp| ≤ (C_T + 1) * (Real.sqrt x) / (Real.log x) := by
        have := combined_error_bound C_decomp C_T h_T ( fun ε ε_pos => integral_error_bound ε ε_pos ) 1 one_pos; aesop;
      intro M;
      -- Use hardy_bound_pos to find x > max(M, M_ERR, 2) such that ψ(x) - x > C_Hardy√x.
      obtain ⟨x, hx_gt, hx_pos⟩ : ∃ x > max M (max M_ERR 2), (chebyshevPsi x - x) > C_Hardy * Real.sqrt x := by
        exact hardy_bound_pos _ _;
      refine' ⟨ x, lt_of_le_of_lt ( le_max_left _ _ ) hx_gt, _ ⟩;
      rw [ h_decomp x ( by linarith [ le_max_right M ( Max.max M_ERR 2 ), le_max_right M_ERR 2 ] ) ];
      simp +zetaDelta at *;
      have := abs_le.mp ( hM_ERR x hx_gt.2.1 );
      ring_nf at *;
      nlinarith [ inv_pos.mpr ( Real.log_pos ( by linarith : 1 < x ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos ( by linarith : 1 < x ) ) ), Real.sqrt_nonneg x, Real.sq_sqrt ( by linarith : 0 ≤ x ), Real.log_le_sub_one_of_pos ( by linarith : 0 < x ) ]

lemma exists_pos_oscillation_aux
    (key_decomposition : ∃ C, ∀ x ≥ 2, primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - T_error x + integral_error x + C)
    (T_error_bound : ∃ C_T, ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)
    (integral_error_bound : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x)
    (hardy_bound_pos : ∀ C, ∀ M, ∃ x > M, chebyshevPsi x - x > C * Real.sqrt x)
    : ∀ M, ∃ x > M, primeCountingReal x - li x > 0 := by
      -- Apply the lemma exists_pos_oscillation with the given hypotheses.
      apply exists_pos_oscillation key_decomposition T_error_bound integral_error_bound hardy_bound_pos

lemma exists_pos_oscillation_aux_v2
    (key_decomposition : ∃ C, ∀ x ≥ 2, primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - T_error x + integral_error x + C)
    (T_error_bound : ∃ C_T, ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)
    (integral_error_bound : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x)
    (hardy_bound_pos : ∀ C, ∀ M, ∃ x > M, chebyshevPsi x - x > C * Real.sqrt x)
    : ∀ M, ∃ x > M, primeCountingReal x - li x > 0 := by
      convert exists_pos_oscillation_aux key_decomposition T_error_bound integral_error_bound hardy_bound_pos using 1

lemma exists_neg_oscillation_aux
    (key_decomposition : ∃ C, ∀ x ≥ 2, primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - T_error x + integral_error x + C)
    (T_error_bound : ∃ C_T, ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)
    (integral_error_bound : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x)
    (hardy_bound_neg : ∀ C, ∀ M, ∃ x > M, chebyshevPsi x - x < -C * Real.sqrt x)
    : ∀ M, ∃ x > M, primeCountingReal x - li x < 0 := by
      -- By combining the results from key_decomposition, T_error_bound, and integral_error_bound, we get the desired inequality for π(x) - li(x).
      have h_combined_bound : ∀ ε > 0, ∃ M : ℝ, ∀ x > M, abs (-(T_error x) + integral_error x + key_decomposition.choose) ≤ (T_error_bound.choose + ε) * Real.sqrt x / Real.log x := by
        apply combined_error_bound;
        · exact T_error_bound.choose_spec;
        · assumption;
      -- Choose ε = 1 in the combined error bound.
      obtain ⟨M_combined, hM_combined⟩ : ∃ M_combined : ℝ, ∀ x > M_combined, abs (-(T_error x) + integral_error x + key_decomposition.choose) ≤ (T_error_bound.choose + 1) * Real.sqrt x / Real.log x := h_combined_bound 1 (by norm_num);
      -- Choose $C_Hardy = T_error_bound.choose + 2$.
      set C_Hardy : ℝ := T_error_bound.choose + 2;
      -- Use hardy_bound_neg to find x > max(M, M_combined, 2) such that ψ(x) - x < -C_Hardy√x.
      intro M
      obtain ⟨x, hx_gt, hx_neg⟩ : ∃ x > max M (max M_combined 2), chebyshevPsi x - x < -C_Hardy * Real.sqrt x := by
        exact Exists.elim ( hardy_bound_neg C_Hardy ( Max.max M ( Max.max M_combined 2 ) ) ) fun x hx => ⟨ x, hx.1, hx.2 ⟩;
      -- Substitute into decomposition:
      have h_subst : primeCountingReal x - li x < (-C_Hardy * Real.sqrt x) / Real.log x + (C_Hardy - 1) * Real.sqrt x / Real.log x := by
        have := key_decomposition.choose_spec x ( by linarith [ le_max_right M ( Max.max M_combined 2 ), le_max_left M ( Max.max M_combined 2 ), le_max_right M_combined 2, le_max_left M_combined 2 ] );
        simp +zetaDelta at *;
        ring_nf at *;
        nlinarith [ inv_pos.mpr ( Real.log_pos ( by linarith : 1 < x ) ), abs_le.mp ( hM_combined x hx_gt.2.1 ), Real.sqrt_nonneg x, Real.sq_sqrt ( by linarith : 0 ≤ x ), mul_inv_cancel₀ ( ne_of_gt ( Real.log_pos ( by linarith : 1 < x ) ) ) ];
      exact ⟨ x, lt_of_le_of_lt ( le_max_left _ _ ) hx_gt, h_subst.trans_le <| by ring_nf; nlinarith [ inv_pos.mpr <| Real.log_pos <| show 1 < x from by linarith [ le_max_right M ( Max.max M_combined 2 ), le_max_right M_combined 2 ], Real.sqrt_nonneg x, Real.log_pos <| show 1 < x from by linarith [ le_max_right M ( Max.max M_combined 2 ), le_max_right M_combined 2 ] ] ⟩

lemma exists_pos_oscillation_final
    (key_decomposition : ∃ C, ∀ x ≥ 2, primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - T_error x + integral_error x + C)
    (T_error_bound : ∃ C_T, ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)
    (integral_error_bound : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x)
    (hardy_bound_pos : ∀ C, ∀ M, ∃ x > M, chebyshevPsi x - x > C * Real.sqrt x)
    : ∀ M, ∃ x > M, primeCountingReal x - li x > 0 := by
      exact fun M => exists_pos_oscillation_aux_v2 key_decomposition T_error_bound integral_error_bound hardy_bound_pos M


lemma exists_pos_oscillation_valid
    (key_decomposition : ∃ C, ∀ x ≥ 2, primeCountingReal x - li x = (chebyshevPsi x - x) / Real.log x - T_error x + integral_error x + C)
    (T_error_bound : ∃ C_T, ∀ x ≥ 2, |T_error x| ≤ C_T * Real.sqrt x / Real.log x)
    (integral_error_bound : ∀ ε > 0, ∃ M, ∀ x > M, |integral_error x| ≤ ε * Real.sqrt x / Real.log x)
    (hardy_bound_pos : ∀ C, ∀ M, ∃ x > M, chebyshevPsi x - x > C * Real.sqrt x)
    : ∀ M, ∃ x > M, primeCountingReal x - li x > 0 := by
      convert exists_pos_oscillation_final key_decomposition T_error_bound integral_error_bound hardy_bound_pos using 1