/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: cb19581d-0d91-4901-8004-71b1eca06578

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib
import Littlewood.Basic.ChebyshevFunctions

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
For any finite list of real numbers and any positive epsilon, there exists a positive integer q such that q times each number (scaled by 1/2pi) is within epsilon of an integer.
-/
lemma simultaneous_dirichlet_approx (γs : List ℝ) (ε : ℝ) (hε : ε > 0) :
    ∃ q : ℕ, q > 0 ∧ ∀ γ ∈ γs, ∃ k : ℤ, |q * (γ / (2 * Real.pi)) - k| < ε := by
      have h_pigeonhole : ∀ (n : ℕ), ∀ (αs : Fin n → ℝ), ∀ ε > 0, ∃ m : ℕ, m > 0 ∧ ∀ i : Fin n, ∃ k : ℤ, |(m * αs i) - k| < ε := by
        intro n αs ε hε
        set N := Nat.ceil (1 / ε) with hN;
        set seq := fun m : ℕ => fun i : Fin n => (m * αs i - ⌊m * αs i⌋ : ℝ) with hseq;
        obtain ⟨m1, m2, hm1m2, h_subcube⟩ : ∃ m1 m2 : ℕ, m1 < m2 ∧ m1 ≤ N^n ∧ m2 ≤ N^n + 1 ∧ ∀ i : Fin n, |seq m1 i - seq m2 i| < 1 / N := by
          have h_pigeonhole : Finset.card (Finset.image (fun m : ℕ => fun i : Fin n => ⌊seq m i * N⌋) (Finset.range (N^n + 1))) ≤ N^n := by
            refine' le_trans ( Finset.card_le_card <| Finset.image_subset_iff.mpr _ ) _;
            exact Finset.Icc ( 0 : Fin n → ℤ ) ( fun _ => N - 1 );
            · simp +zetaDelta at *;
              exact fun x hx => ⟨ fun i => Int.floor_nonneg.2 <| mul_nonneg ( Int.fract_nonneg _ ) <| Nat.cast_nonneg _, fun i => Int.le_sub_one_of_lt <| Int.floor_lt.2 <| mul_lt_of_lt_one_left ( Nat.cast_pos.2 <| Nat.ceil_pos.2 <| inv_pos.2 hε ) <| Int.fract_lt_one _ ⟩;
            · erw [ Finset.card_map, Finset.card_pi ] ; aesop;
          obtain ⟨m1, m2, hm1m2, h_subcube⟩ : ∃ m1 m2 : ℕ, m1 < m2 ∧ m1 ≤ N^n ∧ m2 ≤ N^n + 1 ∧ (fun m : ℕ => fun i : Fin n => ⌊seq m i * N⌋) m1 = (fun m : ℕ => fun i : Fin n => ⌊seq m i * N⌋) m2 := by
            contrapose! h_pigeonhole;
            rw [ Finset.card_image_of_injOn fun m hm m' hm' h => le_antisymm ( le_of_not_gt fun h' => h_pigeonhole _ _ h' ( by linarith [ Finset.mem_range.mp hm', Finset.mem_range.mp hm ] ) ( by linarith [ Finset.mem_range.mp hm', Finset.mem_range.mp hm ] ) h.symm ) ( le_of_not_gt fun h' => h_pigeonhole _ _ h' ( by linarith [ Finset.mem_range.mp hm', Finset.mem_range.mp hm ] ) ( by linarith [ Finset.mem_range.mp hm', Finset.mem_range.mp hm ] ) h ) ] ; simp +arith +decide;
          use m1, m2;
          simp_all +decide [ funext_iff, Int.floor_eq_iff ];
          intro i; rw [ abs_lt ] ; constructor <;> nlinarith [ h_subcube.2.2 i, Int.floor_le ( Int.fract ( ( m2 : ℝ ) * αs i ) * ⌈ε⁻¹⌉₊ ), Int.lt_floor_add_one ( Int.fract ( ( m2 : ℝ ) * αs i ) * ⌈ε⁻¹⌉₊ ), Nat.le_ceil ( ε⁻¹ ), mul_inv_cancel₀ ( ne_of_gt hε ), mul_inv_cancel₀ ( show ( ⌈ε⁻¹⌉₊ : ℝ ) ≠ 0 by positivity ) ] ;
        refine' ⟨ m2 - m1, tsub_pos_of_lt hm1m2, fun i => _ ⟩;
        simp +zetaDelta at *;
        exact ⟨ ⌊ ( m2 : ℝ ) * αs i⌋ - ⌊ ( m1 : ℝ ) * αs i⌋, by rw [ Nat.cast_sub hm1m2.le ] ; exact abs_lt.mpr ⟨ by push_cast; linarith [ abs_lt.mp ( h_subcube.2.2 i ), Int.fract_add_floor ( ( m2 : ℝ ) * αs i ), Int.fract_add_floor ( ( m1 : ℝ ) * αs i ), inv_le_of_inv_le₀ hε <| Nat.le_ceil <| ε⁻¹ ], by push_cast; linarith [ abs_lt.mp ( h_subcube.2.2 i ), Int.fract_add_floor ( ( m2 : ℝ ) * αs i ), Int.fract_add_floor ( ( m1 : ℝ ) * αs i ), inv_le_of_inv_le₀ hε <| Nat.le_ceil <| ε⁻¹ ] ⟩ ⟩;
      obtain ⟨m, hm_pos, hm⟩ : ∃ m : ℕ, m > 0 ∧ ∀ i : Fin γs.length, ∃ k : ℤ, |(m * (γs.get i / (2 * Real.pi))) - k| < ε := by
        exact h_pigeonhole _ _ _ hε;
      use m, hm_pos; intro γ hγ; obtain ⟨ i, hi ⟩ := List.mem_iff_get.mp hγ; aesop;

/-
There exists a strictly increasing sequence of positive real numbers gamma_n such that 1/2 + i*gamma_n is a zero of the Riemann zeta function.
-/
lemma exists_seq_zeros (h_hardy : ∀ (T : ℝ), ∃ (γ : ℝ), γ > T ∧ riemannZeta (1/2 + Complex.I * γ) = 0) :
    ∃ γ : ℕ → ℝ, StrictMono γ ∧ (∀ n, γ n > 0) ∧ ∀ n, riemannZeta (1/2 + Complex.I * (γ n)) = 0 := by
      choose f hf using h_hardy;
      refine' ⟨ fun n => Nat.recOn n ( f 1 ) fun n ih => f ih, strictMono_nat_of_lt_succ fun n => _, _, _ ⟩ <;> norm_num;
      · exact hf _ |>.1;
      · exact fun n => Nat.recOn n ( by linarith [ hf 1 ] ) fun n ih => by linarith [ hf ( Nat.rec ( f 1 ) ( fun n ih => f ih ) n ) ] ;
      · exact fun n => Nat.recOn n ( hf _ |>.2 ) fun n ih => hf _ |>.2

/-
The set of critical zeros of the Riemann zeta function with imaginary part between -T and T.
-/
noncomputable def critical_zeros_set (T : ℝ) : Set ℂ :=
  (Set.Icc (-T) T).image (fun (t : ℝ) => (1/2 : ℂ) + Complex.I * (t : ℂ)) ∩ {s | riemannZeta s = 0}

/-
The set of critical zeros with imaginary part between -T and T is finite.
-/
lemma critical_zeros_finite (T : ℝ) : (critical_zeros_set T).Finite := by
  by_contra h_inf_zeros;
  set K := {s : ℂ | s.re = 1 / 2 ∧ |s.im| ≤ T} with hK_def
  have hK_compact : IsCompact K := by
    refine' ( Metric.isCompact_iff_isClosed_bounded.mpr _ );
    exact ⟨ isClosed_eq Complex.continuous_re continuous_const |> IsClosed.inter <| isClosed_le ( continuous_abs.comp Complex.continuous_im ) continuous_const, isBounded_iff_forall_norm_le.mpr ⟨ 1 / 2 + T, by rintro s ⟨ hs₁, hs₂ ⟩ ; exact Complex.norm_le_abs_re_add_abs_im _ |> le_trans <| by norm_num [ hs₁ ] ; linarith [ abs_le.mp hs₂ ] ⟩ ⟩
  have hS_subset_K : critical_zeros_set T ⊆ K := by
    exact fun s hs => by obtain ⟨ t, ht, rfl ⟩ := hs.1; exact ⟨ by norm_num, by simpa [ abs_le ] using ht ⟩ ;
  obtain ⟨s₀, hs₀⟩ : ∃ s₀ ∈ K, ∀ ε > 0, ∃ s ∈ critical_zeros_set T, s ≠ s₀ ∧ ‖s - s₀‖ < ε := by
    have h_accumulation : ∃ s₀ ∈ K, ∀ ε > 0, ∃ s ∈ critical_zeros_set T, ‖s - s₀‖ < ε ∧ s ≠ s₀ := by
      have h_seq : ∃ seq : ℕ → ℂ, (∀ n, seq n ∈ critical_zeros_set T) ∧ Function.Injective seq := by
        have := Set.Infinite.to_subtype h_inf_zeros;
        have := this.natEmbedding;
        exact ⟨ _, fun n => this n |>.2, Subtype.coe_injective.comp this.injective ⟩
      obtain ⟨s₀, hs₀⟩ : ∃ s₀ ∈ K, ∃ subseq : ℕ → ℕ, StrictMono subseq ∧ Filter.Tendsto (fun n => h_seq.choose (subseq n)) Filter.atTop (nhds s₀) := by
        have := hK_compact.isSeqCompact fun n => hS_subset_K <| h_seq.choose_spec.1 n; aesop;
      refine' ⟨ s₀, hs₀.1, fun ε ε_pos => _ ⟩;
      rcases Metric.tendsto_atTop.mp hs₀.2.choose_spec.2 ε ε_pos with ⟨ N, hN ⟩;
      by_cases h_eq : ∀ n ≥ N, h_seq.choose (hs₀.2.choose n) = s₀;
      · exact absurd ( h_seq.choose_spec.2 ( show h_seq.choose ( hs₀.2.choose N ) = h_seq.choose ( hs₀.2.choose ( N + 1 ) ) from by rw [ h_eq N le_rfl, h_eq ( N + 1 ) ( Nat.le_succ _ ) ] ) ) ( by exact fun h => by have := hs₀.2.choose_spec.1 ( Nat.lt_succ_self N ) ; aesop );
      · exact by push_neg at h_eq; obtain ⟨ n, hn₁, hn₂ ⟩ := h_eq; exact ⟨ _, h_seq.choose_spec.1 _, hN n hn₁, hn₂ ⟩ ;
    exact ⟨ h_accumulation.choose, h_accumulation.choose_spec.1, fun ε hε => by obtain ⟨ s, hs₁, hs₂, hs₃ ⟩ := h_accumulation.choose_spec.2 ε hε; exact ⟨ s, hs₁, hs₃, hs₂ ⟩ ⟩;
  have h_riemann_zero : ∀ s ∈ {s : ℂ | s.re = 1 / 2 ∧ |s.im| ≤ T}, riemannZeta s = 0 := by
    have h_riemann_zero : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOnNhd ];
      · intro s hs;
        refine' DifferentiableAt.differentiableWithinAt _;
        apply_rules [ differentiableAt_riemannZeta ];
        aesop;
      · exact isOpen_univ.sdiff isClosed_singleton;
    intro s hs;
    apply h_riemann_zero.eqOn_zero_of_preconnected_of_frequently_eq_zero;
    any_goals exact s₀;
    · have h_connected : IsConnected (Set.univ \ {1} : Set ℂ) := by
        have h_connected : IsConnected (Set.univ \ {0} : Set ℂ) := by
          have h_connected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
            exact isConnected_range ( Complex.continuous_exp );
          convert h_connected using 1 ; ext ; simp +decide [ Complex.exp_ne_zero ];
        convert h_connected.image _ _ using 1;
        rotate_left;
        use fun z => z + 1;
        · exact continuousOn_id.add continuousOn_const;
        · ext; simp [Set.mem_image];
      exact h_connected.isPreconnected;
    · aesop;
    · rw [ Metric.nhdsWithin_basis_ball.frequently_iff ];
      exact fun ε hε => by rcases hs₀.2 ε hε with ⟨ s, hs₁, hs₂, hs₃ ⟩ ; exact ⟨ s, ⟨ hs₃, hs₂ ⟩, by unfold critical_zeros_set at hs₁; aesop ⟩ ;
    · norm_num [ Complex.ext_iff ] at * ; aesop;
  have h_riemann_two : riemannZeta 2 ≠ 0 := by
    norm_num [ riemannZeta_two ];
  have h_riemann_zero_everywhere : ∀ s : ℂ, s ≠ 1 → riemannZeta s = 0 := by
    have h_identity : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
      apply_rules [ DifferentiableOn.analyticOnNhd ];
      · intro s hs;
        refine' DifferentiableAt.differentiableWithinAt _;
        apply_rules [ differentiableAt_riemannZeta ];
        simp only [Set.mem_diff, Set.mem_univ, Set.mem_singleton_iff, true_and] at hs; exact hs;
      · exact isOpen_univ.sdiff isClosed_singleton;
    intro s hs_ne_one
    have h_zero_on_K : ∀ s ∈ K, riemannZeta s = 0 := by
      exact h_riemann_zero
    apply h_identity.eqOn_zero_of_preconnected_of_frequently_eq_zero;
    any_goals exact s₀;
    · have h_path_connected : IsPathConnected (Set.univ \ {1} : Set ℂ) := by
        have h_path_connected : IsPathConnected (Set.univ \ {0} : Set ℂ) := by
          have h_path_connected : IsPathConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
            exact isPathConnected_range ( Complex.continuous_exp );
          convert h_path_connected using 1;
          ext; simp [Complex.exp_ne_zero];
        have h_path_connected : IsPathConnected (Set.image (fun z : ℂ => z + 1) (Set.univ \ {0})) := by
          apply_rules [ IsPathConnected.image, h_path_connected ];
          exact continuous_id.add continuous_const;
        convert h_path_connected using 1;
        ext; simp [Set.mem_image];
      exact h_path_connected.isConnected.isPreconnected;
    · exact ⟨ Set.mem_univ _, by rintro rfl; exact absurd hs₀.1.1 ( by norm_num ) ⟩;
    · rw [ Metric.nhdsWithin_basis_ball.frequently_iff ];
      exact fun ε ε_pos => by obtain ⟨ s, hs₁, hs₂, hs₃ ⟩ := hs₀.2 ε ε_pos; exact ⟨ s, ⟨ hs₃, hs₂ ⟩, h_zero_on_K s ( hS_subset_K hs₁ ) ⟩ ;
    · exact ⟨Set.mem_univ s, hs_ne_one⟩;
  exact h_riemann_two <| h_riemann_zero_everywhere 2 <| by norm_num;

/-
The finite set of critical zeros with imaginary part between -T and T.
-/
noncomputable def critical_zeros_upto (T : ℝ) : Finset ℂ :=
  (critical_zeros_finite T).toFinset

/-
The sum of the reciprocals of the moduli of the critical zeros with imaginary part between -T and T.
-/
noncomputable def sum_recip_zeros (T : ℝ) : ℝ :=
  ∑ ρ ∈ critical_zeros_upto T, 1 / norm ρ

/-
The explicit formula approximation holds with constant C if the error term is bounded by C * x * log(x)^2 / T for all x >= 2 and T >= 2.
-/
def ExplicitFormulaApprox (C : ℝ) : Prop :=
  ∀ (x : ℝ), x ≥ 2 → ∀ (T : ℝ), T ≥ 2 → ∃ R : ℝ,
    ‖(chebyshevPsi x : ℂ) - (x : ℂ) - (- ∑ ρ ∈ critical_zeros_upto T, ((x : ℂ) ^ ρ) / ρ)‖ ≤ R ∧
    R ≤ C * x * (Real.log x)^2 / T

end
