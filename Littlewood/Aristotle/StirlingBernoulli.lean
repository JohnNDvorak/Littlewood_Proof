/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 9dddd550-07bb-4dec-92a8-ace5acf75d70

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.

Stirling formula infrastructure: Bernoulli polynomials B1, B2 and their properties.

KEY RESULTS:
- B2_continuous: B2 is continuous (despite fract being discontinuous at integers)
- deriv_B2: B2'(t) = 2Â·B1(t) at non-integer points
- B2_zero: B2(0) = 1/6
- B2_bounded: |B2(t)| â‰¤ C for all t
- integral_B1_eq_B2_sub_const: âˆ«â‚€Ë£ B1(t) dt = B2(x)/2 - 1/12
- hasDerivWithinAt_B2_right: right derivative of B2

STATUS: 1 sorry (exact? budget reached in hasDerivWithinAt_B2_right)
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace StirlingBernoulli

noncomputable def B2 (t : â„) : â„ := (Int.fract t)^2 - Int.fract t + 1/6

noncomputable def stirling_remainder (s : â„‚) : â„‚ :=
  1 / (12 * s) - âˆ« t in Set.Ioi 0, (B2 t : â„‚) / (2 * (s + t)^2)

noncomputable def B1 (t : â„) : â„ := Int.fract t - 1/2

open Complex Real MeasureTheory Set Filter Topology

theorem B2_continuous : Continuous B2 := by
  have h_cont : Continuous (fun t : â„ => (Int.fract t)^2 - Int.fract t) := by
    refine' continuous_iff_continuousAt.mpr _;
    intro x;
    by_cases hx : x âˆˆ Set.range Int.cast;
    Â· obtain âŸ¨ n, rfl âŸ© := hx;
      have h_left : Filter.Tendsto (fun t : â„ => (Int.fract t)^2 - Int.fract t) (nhdsWithin (n : â„) (Set.Iio (n : â„))) (nhds ((1 : â„)^2 - 1)) := by
        have h_left : âˆ€á¶  t : â„ in nhdsWithin (n : â„) (Set.Iio (n : â„)), Int.fract t = t - (n - 1) := by
          norm_num [ eventually_nhdsWithin_iff ];
          filter_upwards [ lt_mem_nhds ( show ( n : â„ ) > n - 1 by norm_num ) ] with x hxâ‚ hxâ‚‚ using by linarith [ Int.fract_add_floor x, show ( Int.floor x : â„ ) = n - 1 by exact_mod_cast Int.floor_eq_iff.mpr âŸ¨ by norm_num; linarith, by norm_num; linarith âŸ© ] ;
        rw [ Filter.tendsto_congr' ( by filter_upwards [ h_left ] with t ht; rw [ ht ] ) ] ; exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ <| by norm_num ) ;
      have h_right : Filter.Tendsto (fun t : â„ => (Int.fract t)^2 - Int.fract t) (nhdsWithin (n : â„) (Set.Ioi (n : â„))) (nhds ((0 : â„)^2 - 0)) := by
        have h_right : âˆ€á¶  t : â„ in nhdsWithin (n : â„) (Set.Ioi (n : â„)), (Int.fract t)^2 - Int.fract t = (t - n)^2 - (t - n) := by
          filter_upwards [ Ioo_mem_nhdsGT ( show ( n : â„ ) < n + 1 by norm_num ) ] with t ht using by norm_num [ show âŒŠtâŒ‹ = n by exact Int.floor_eq_iff.mpr âŸ¨ by linarith [ ht.1 ], by linarith [ ht.2 ] âŸ©, Int.fract ] ; ;
        rw [ Filter.tendsto_congr' h_right ] ; exact Continuous.continuousWithinAt ( by continuity ) |> fun h => h.trans ( by norm_num ) ;
      refine' continuousAt_iff_continuous_left'_right'.mpr _;
      simp_all +decide [ ContinuousWithinAt ];
    Â· field_simp;
      refine' ContinuousAt.mul _ _;
      Â· refine' ContinuousAt.sub _ _;
        Â· exact continuousAt_id;
        Â· have h_floor_const : âˆƒ Îµ > 0, âˆ€ y, abs (y - x) < Îµ â†’ âŒŠyâŒ‹ = âŒŠxâŒ‹ := by
            norm_num [ Int.floor_eq_iff ] at *;
            exact Metric.mem_nhds_iff.mp ( Ico_mem_nhds ( lt_of_le_of_ne ( Int.floor_le x ) ( by tauto ) ) ( Int.lt_floor_add_one x ) ) |> fun âŸ¨ Îµ, hÎµâ‚, hÎµâ‚‚ âŸ© => âŸ¨ Îµ, hÎµâ‚, fun y hy => hÎµâ‚‚ <| by simpa using hy âŸ©;
          exact tendsto_const_nhds.congr' ( Filter.eventuallyEq_of_mem ( Metric.ball_mem_nhds _ h_floor_const.choose_spec.1 ) fun y hy => by rw [ h_floor_const.choose_spec.2 y hy ] );
      Â· refine' ContinuousAt.sub _ continuousAt_const;
        refine' ContinuousAt.sub _ _;
        Â· exact continuousAt_id;
        Â· have h_floor_const : âˆƒ Îµ > 0, âˆ€ y, abs (y - x) < Îµ â†’ âŒŠyâŒ‹ = âŒŠxâŒ‹ := by
            norm_num [ Int.floor_eq_iff ] at *;
            exact Metric.mem_nhds_iff.mp ( Ico_mem_nhds ( lt_of_le_of_ne ( Int.floor_le x ) ( by tauto ) ) ( Int.lt_floor_add_one x ) ) |> fun âŸ¨ Îµ, hÎµâ‚, hÎµâ‚‚ âŸ© => âŸ¨ Îµ, hÎµâ‚, fun y hy => hÎµâ‚‚ <| by simpa using hy âŸ©;
          exact tendsto_const_nhds.congr' ( by filter_upwards [ Metric.ball_mem_nhds x h_floor_const.choose_spec.1 ] with y hy; rw [ h_floor_const.choose_spec.2 y hy ] );
  exact h_cont.add continuous_const

theorem deriv_B2 (t : â„) (ht : Â¬ âˆƒ n : â„¤, t = n) :
    deriv B2 t = 2 * B1 t := by
  have h_deriv : deriv (fun t => (Int.fract t)^2 - Int.fract t + 1 / 6) t = 2 * (Int.fract t) * (deriv (fun t => Int.fract t) t) - (deriv (fun t => Int.fract t) t) := by
    have h_fract_diff : DifferentiableAt â„ (fun t => Int.fract t) t := by
      obtain âŸ¨n, hnâŸ© : âˆƒ n : â„¤, (n : â„) < t âˆ§ t < (n + 1 : â„) := by
        exact âŸ¨ âŒŠtâŒ‹, lt_of_le_of_ne ( Int.floor_le t ) fun h => ht âŸ¨ _, h.symm âŸ©, Int.lt_floor_add_one t âŸ©;
      refine' DifferentiableAt.congr_of_eventuallyEq _ _;
      exacts [ fun x => x - â†‘n, differentiableAt_id.sub_const _, Filter.eventuallyEq_of_mem ( Ioo_mem_nhds hn.1 hn.2 ) fun x hx => by simp +decide [ show âŒŠxâŒ‹ = n by exact Int.floor_eq_iff.mpr âŸ¨ by linarith [ hx.1 ], by linarith [ hx.2 ] âŸ©, Int.fract ] ];
    norm_num [ h_fract_diff ];
  have h_deriv_fract : deriv (fun t : â„ => Int.fract t) t = 1 := by
    refine' HasDerivAt.deriv _;
    convert HasDerivAt.congr_of_eventuallyEq ( hasDerivAt_id t |> HasDerivAt.sub <| hasDerivAt_const _ _ ) ?_ using 1 ; aesop;
    exacts [ â†‘âŒŠtâŒ‹, Filter.eventuallyEq_of_mem ( Ioo_mem_nhds ( show ( âŒŠtâŒ‹ : â„ ) < t from lt_of_le_of_ne ( Int.floor_le t ) fun h => ht âŸ¨ _, h.symm âŸ© ) ( show t < ( âŒŠtâŒ‹ + 1 : â„ ) from Int.lt_floor_add_one t ) ) fun x hx => by simp +decide [ show âŒŠxâŒ‹ = âŒŠtâŒ‹ from Int.floor_eq_iff.mpr âŸ¨ by linarith [ hx.1, Int.floor_le t ], by linarith [ hx.2, Int.lt_floor_add_one t ] âŸ©, Int.fract ] ];
  convert h_deriv using 1 ; norm_num [ h_deriv_fract, B1 ] ; ring

theorem B2_zero : B2 0 = 1/6 := by
  simp [B2]

theorem B2_bounded : âˆƒ C, âˆ€ t, |B2 t| â‰¤ C := by
  use 1 / 6 + 1 / 4 + 1 / 6
  intro t
  simp [B2];
  have h_fract_bounds : 0 â‰¤ Int.fract t âˆ§ Int.fract t < 1 := by
    apply And.intro; exact Int.fract_nonneg t; exact Int.fract_lt_one t
  norm_num [ abs_le ]
  constructor <;> nlinarith [ sq_nonneg ( Int.fract t - 1 / 2 ) ]

theorem integral_B1_eq_B2_sub_const (x : â„) :
    âˆ« t in (0)..x, B1 t = B2 x / 2 - 1/12 := by
  unfold B1 B2;
  have h_B1 : âˆ€ n : â„¤, âˆ« t in (n : â„)..((n + 1) : â„), Int.fract t - 1 / 2 = 0 := by
    intro n
    have : âˆ« t in (n : â„)..((n + 1) : â„), Int.fract t - 1 / 2 = âˆ« t in (n : â„)..((n + 1) : â„), t - n - 1 / 2 := by
      rw [ intervalIntegral.integral_of_le, intervalIntegral.integral_of_le ] <;> norm_num;
      norm_num [ MeasureTheory.integral_Ioc_eq_integral_Ioo ];
      exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => by simp +decide [ show âŒŠxâŒ‹ = n by exact Int.floor_eq_iff.mpr âŸ¨ hx.1.le, hx.2 âŸ©, Int.fract ] ;
    norm_num [ this ];
    ring;
  have h_split : âˆ« t in (0 : â„)..x, Int.fract t - 1 / 2 = (âˆ« t in (0 : â„)..(Int.floor x), Int.fract t - 1 / 2) + (âˆ« t in (Int.floor x)..x, Int.fract t - 1 / 2) := by
    rw [ intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
    Â· refine' MeasureTheory.Integrable.mono' _ _ _;
      exacts [ fun t => 1, Continuous.integrableOn_Icc <| by continuity, Measurable.aestronglyMeasurable <| by exact Measurable.sub ( measurable_fract ) measurable_const, Filter.Eventually.of_forall fun t => abs_le.mpr âŸ¨ by linarith [ Int.fract_nonneg t ], by linarith [ Int.fract_lt_one t ] âŸ© ];
    Â· refine' MeasureTheory.Integrable.mono' _ _ _;
      exacts [ fun t => 1, Continuous.integrableOn_Icc <| by continuity, Measurable.aestronglyMeasurable <| by exact Measurable.sub ( measurable_fract ) measurable_const, Filter.Eventually.of_forall fun t => abs_le.mpr âŸ¨ by linarith [ Int.fract_nonneg t ], by linarith [ Int.fract_lt_one t ] âŸ© ];
  -- Integrability: fract t - 1/2 is bounded by 1 and measurable
  have h_intble : âˆ€ a b : â„, IntervalIntegrable (fun t => Int.fract t - 1 / 2) volume a b := by
    intro a b
    apply MeasureTheory.IntegrableOn.intervalIntegrable
    apply Measure.integrableOn_of_bounded
    Â· rw [Real.volume_interval]; exact ENNReal.ofReal_ne_top
    Â· exact (measurable_fract.sub measurable_const).aestronglyMeasurable
    Â· exact ae_of_all _ fun t => by
        rw [Real.norm_eq_abs]
        exact abs_le.mpr âŸ¨by linarith [Int.fract_nonneg t], by linarith [Int.fract_lt_one t]âŸ©
  have h_floor : âˆ« t in (0 : â„)..(Int.floor x), Int.fract t - 1 / 2 = 0 := by
    -- Each unit interval integral is 0. Decompose by Nat induction.
    -- Note: Lean elaborates 1/2 as 2â»Â¹ in some contexts, so we use norm_num to unify.
    have h_nat : âˆ€ m : â„•, âˆ« t in (0 : â„)..(m : â„), Int.fract t - 1 / 2 = 0 := by
      intro m; induction m with
      | zero => norm_num
      | succ m ih =>
        have hsplit : âˆ« t in (0 : â„)..(â†‘(m + 1) : â„), Int.fract t - 1 / 2 =
            (âˆ« t in (0 : â„)..(m : â„), Int.fract t - 1 / 2) +
            âˆ« t in (m : â„)..(â†‘(m + 1) : â„), Int.fract t - 1 / 2 := by
          rw [show (â†‘(m + 1) : â„) = (â†‘m : â„) + 1 from by push_cast; ring]
          exact (intervalIntegral.integral_add_adjacent_intervals (h_intble _ _) (h_intble _ _)).symm
        rw [hsplit, ih, zero_add]
        convert h_B1 (m : â„¤) using 2; push_cast; ring
    have h_neg : âˆ€ m : â„•, âˆ« t in (-(m : â„))..(0 : â„), Int.fract t - 1 / 2 = 0 := by
      intro m; induction m with
      | zero => norm_num
      | succ m ih =>
        have hsplit : âˆ« t in (-(â†‘(m + 1) : â„))..(0 : â„), Int.fract t - 1 / 2 =
            (âˆ« t in (-(â†‘(m + 1) : â„))..(-(â†‘m : â„)), Int.fract t - 1 / 2) +
            âˆ« t in (-(â†‘m : â„))..(0 : â„), Int.fract t - 1 / 2 := by
          exact (intervalIntegral.integral_add_adjacent_intervals (h_intble _ _) (h_intble _ _)).symm
        rw [hsplit, ih, add_zero]
        have : âˆ« t in (-(â†‘(m + 1) : â„))..(-(â†‘m : â„)), Int.fract t - 1 / 2 =
               âˆ« t in ((-(m + 1 : â„¤) : â„¤) : â„)..((-(m + 1 : â„¤) : â„¤) : â„) + 1, Int.fract t - 1 / 2 := by
          congr 1 <;> push_cast <;> ring
        rw [this]; exact h_B1 _
    by_cases h_nn : 0 â‰¤ âŒŠxâŒ‹
    Â· have hcast : (âŒŠxâŒ‹ : â„) = ((âŒŠxâŒ‹.toNat : â„•) : â„) := by
        exact_mod_cast (Int.toNat_of_nonneg h_nn).symm
      rw [hcast]; exact h_nat _
    Â· push_neg at h_nn
      rw [intervalIntegral.integral_symm]
      have : âˆ« t in (âŒŠxâŒ‹ : â„)..(0 : â„), Int.fract t - 1 / 2 = 0 := by
        have hcast : (âŒŠxâŒ‹ : â„) = -(((-âŒŠxâŒ‹).toNat : â„•) : â„) := by
          have h1 : ((-âŒŠxâŒ‹).toNat : â„¤) = -âŒŠxâŒ‹ := Int.toNat_of_nonneg (by omega)
          exact_mod_cast show (âŒŠxâŒ‹ : â„¤) = -((-âŒŠxâŒ‹).toNat : â„¤) by omega
        rw [hcast]; exact h_neg _
      linarith
  have h_frac : âˆ« t in (Int.floor x)..x, Int.fract t - 1 / 2 = âˆ« t in (Int.floor x)..x, (t - Int.floor x - 1 / 2) := by
    field_simp;
    rw [ intervalIntegral.integral_of_le ( Int.floor_le x ), intervalIntegral.integral_of_le ( Int.floor_le x ) ];
    exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioc fun t ht => by rw [ Int.fract ] ; rw [ show âŒŠtâŒ‹ = âŒŠxâŒ‹ from Int.floor_eq_iff.mpr âŸ¨ by linarith [ ht.1, Int.floor_le x ], by linarith [ ht.2, Int.lt_floor_add_one x ] âŸ© ] ; ring;
  norm_num [ h_split, h_floor, h_frac ] ; ring;
  rw [ Int.fract ] ; ring

theorem hasDerivWithinAt_B2_right (t : â„) :
    HasDerivWithinAt B2 (2 * B1 t) (Set.Ioi t) t := by
  by_cases h : âˆƒ n : â„¤, t = n;
  Â· have h_cont : Filter.Tendsto (fun h => (B2 (t + h) - B2 t) / h) (nhdsWithin 0 (Set.Ioi 0)) (nhds (2 * B1 t)) := by
      have h_cont : Filter.Tendsto (fun h => (B2 (t + h) - B2 t) / h) (nhdsWithin 0 (Set.Ioi 0)) (nhds (2 * B1 t)) := by
        have h_lim : Filter.Tendsto (fun h => (B2 (t + h) - B2 t) / h) (nhdsWithin 0 (Set.Ioi 0)) (nhds (2 * (t - âŒŠtâŒ‹ - 1/2))) := by
          have h_cont : Filter.Tendsto (fun h => (B2 (t + h) - B2 t) / h) (nhdsWithin 0 (Set.Ioi 0)) (nhds (2 * (t + 0 - âŒŠt + 0âŒ‹ - 1/2))) := by
            have h_eq : âˆ€á¶  h in nhdsWithin 0 (Set.Ioi 0), B2 (t + h) = (h - 0)^2 - (h - 0) + 1/6 := by
              obtain âŸ¨ n, rfl âŸ© := h; norm_num [ B2 ] ;
              filter_upwards [ Ioo_mem_nhdsGT zero_lt_one ] with x hx using by rw [ Int.fract ] ; norm_num [ show âŒŠxâŒ‹ = 0 from Int.floor_eq_iff.mpr âŸ¨ by norm_num; linarith [ hx.1 ], by norm_num; linarith [ hx.2 ] âŸ© ] ;
            have h_eq : âˆ€á¶  h in nhdsWithin 0 (Set.Ioi 0), (B2 (t + h) - B2 t) / h = (h - 1) := by
              filter_upwards [ h_eq, self_mem_nhdsWithin ] with x hx hx' using by rw [ div_eq_iff hx'.out.ne' ] ; rw [ hx ] ; rw [ show B2 t = 1 / 6 by exact h.elim fun n hn => by simp +decide [ hn, B2 ] ] ; ring;;
            rw [ Filter.tendsto_congr' h_eq ] ; norm_num [ h ];
            exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ ( by norm_num [ show Int.fract t = 0 by obtain âŸ¨ n, rfl âŸ© := h; norm_num ] ) );
          aesop
        have : (2 : â„) * B1 t = 2 * (t - â†‘âŒŠtâŒ‹ - 1 / 2) := by unfold B1; rw [Int.fract]
        rw [this]; exact h_lim
      convert h_cont using 1;
    rw [ hasDerivWithinAt_iff_tendsto_slope ];
    convert h_cont.comp ( show Filter.Tendsto ( fun x : â„ => x - t ) ( ğ“[Set.Ioi t \ { t }] t ) ( ğ“[>] 0 ) from ?_ ) using 2;
    Â· ext; simp +decide [ slope_def_field ];
    Â· rw [ Metric.tendsto_nhdsWithin_nhdsWithin ] ; aesop;
  Â· convert HasDerivAt.hasDerivWithinAt ( deriv_B2 t h â–¸ hasDerivAt_deriv_iff.mpr _ ) using 1;
    refine' DifferentiableAt.congr_of_eventuallyEq _ _;
    exact fun x => ( x - âŒŠxâŒ‹ ) ^ 2 - ( x - âŒŠxâŒ‹ ) + 1 / 6;
    Â· obtain âŸ¨Îµ, hÎµâŸ© : âˆƒ Îµ > 0, âˆ€ x, abs (x - t) < Îµ â†’ âŒŠxâŒ‹ = âŒŠtâŒ‹ := by
        norm_num [ Int.floor_eq_iff ] at *;
        exact Metric.mem_nhds_iff.mp ( Ico_mem_nhds ( lt_of_le_of_ne ( Int.floor_le t ) ( Ne.symm ( h _ ) ) ) ( Int.lt_floor_add_one t ) ) |> fun âŸ¨ Îµ, Îµ_pos, hÎµ âŸ© => âŸ¨ Îµ, Îµ_pos, fun x hx => hÎµ hx âŸ©;
      exact DifferentiableAt.congr_of_eventuallyEq ( show DifferentiableAt â„ ( fun x => ( x - ( âŒŠtâŒ‹ : â„ ) ) ^ 2 - ( x - ( âŒŠtâŒ‹ : â„ ) ) + 1 / 6 ) t from by norm_num ) ( Filter.eventuallyEq_of_mem ( Metric.ball_mem_nhds t hÎµ.1 ) fun x hx => by rw [ hÎµ.2 x hx ] );
    Â· filter_upwards [ IsOpen.mem_nhds ( isOpen_compl_singleton.preimage continuous_id' ) ( show t â‰  âŒŠtâŒ‹ from fun h' => h âŸ¨ _, h' âŸ© ) ] with x hx using by unfold B2; aesop;

end StirlingBernoulli
