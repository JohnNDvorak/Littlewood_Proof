/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 256d1421-2ae1-4053-b32c-15b52aa43d6c

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

#check riemannZeta
#check Complex.Gamma
#check PhragmenLindelof.vertical_strip

#check ArithmeticFunction.zeta
#check LSeries
#check ArithmeticFunction.LSeries_zeta_eq_riemannZeta

/-
Bound at σ = 2: |ζ(2+it)| ≤ ζ(2) < 2
-/
open Complex Filter Topology

theorem zeta_bound_two_line (t : ℝ) :
    ‖riemannZeta (2 + I * t)‖ ≤ ‖riemannZeta 2‖ ∧ ‖riemannZeta 2‖ < 2 := by
  constructor;
  · -- By definition of zeta, we know that for $\Re(s) > 1$, $\zeta(s) = \sum_{n=1}^{\infty} n^{-s}$.
    have h_zeta_def : ∀ s : ℂ, 1 < s.re → riemannZeta s = ∑' n : ℕ, (n : ℂ)⁻¹ ^ s := by
      intro s hs;
      rw [ zeta_eq_tsum_one_div_nat_cpow ];
      · refine' tsum_congr fun n => _;
        rw [ one_div, Complex.inv_cpow ];
        rw [ Ne.eq_def, Complex.arg_eq_pi_iff ] ; aesop;
      · exact hs;
    -- Apply the definition of zeta to both sides of the inequality.
    have h_apply_zeta_def : ‖∑' n : ℕ, (n : ℂ)⁻¹ ^ (2 + Complex.I * t)‖ ≤ ∑' n : ℕ, ‖(n : ℂ)⁻¹ ^ (2 + Complex.I * t)‖ := by
      convert norm_tsum_le_tsum_norm _;
      -- We'll use the fact that |n^{-s}| = n^{-σ} for σ > 1.
      have h_abs : ∀ n : ℕ, n ≥ 1 → ‖(n : ℂ)⁻¹ ^ (2 + Complex.I * t)‖ = (n : ℝ)⁻¹ ^ 2 := by
        intro n hn; rw [ Complex.norm_cpow_of_ne_zero ] <;> norm_num [ hn ] ; ring; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ] ;
        · norm_num [ Complex.arg ];
        · linarith;
      rw [ ← summable_nat_add_iff 1 ];
      exact Summable.of_nonneg_of_le ( fun n => norm_nonneg _ ) ( fun n => by simpa using h_abs ( n + 1 ) ( by linarith ) |> le_of_eq ) ( by simpa using summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two );
    -- Since $|n^{-s}| = n^{-\Re(s)}$, we have $\sum' n : ℕ, ‖(n : ℂ)⁻¹ ^ (2 + Complex.I * t)‖ = \sum' n : ℕ, n^{-2}$.
    have h_norm_eq : ∑' n : ℕ, ‖(n : ℂ)⁻¹ ^ (2 + Complex.I * t)‖ = ∑' n : ℕ, (n : ℝ)⁻¹ ^ 2 := by
      refine' tsum_congr fun n => _;
      by_cases hn : n = 0 <;> simp +decide [ hn, Complex.norm_cpow_of_ne_zero ];
      · norm_num [ Complex.ext_iff ];
      · norm_num [ Complex.arg ];
    convert h_apply_zeta_def.trans ( h_norm_eq.le ) using 1 <;> norm_num [ h_zeta_def ];
    convert Complex.norm_of_nonneg _;
    · norm_num [ Complex.ofReal_tsum ];
    · exact tsum_nonneg fun _ => by positivity;
  · -- We know that $\zeta(2) = \frac{\pi^2}{6}$.
    have h_zeta2 : riemannZeta 2 = Real.pi ^ 2 / 6 := by
      exact?;
    norm_num [ h_zeta2 ];
    -- We know that $\pi \approx 3.14$, so we can estimate $\pi^2 \approx 9.86$.
    have h_pi_approx : Real.pi < 3.4 := by
      pi_upper_bound [ 7 / 5 ];
    norm_num at h_pi_approx ; nlinarith [ Real.pi_gt_three ]

/-
Bound for the Gamma factor in the functional equation
-/
open Complex Filter Topology

lemma abs_Gamma_mul_cos_bound (t : ℝ) (ht : |t| ≥ 1) :
    ‖Gamma (I * t) * cos (π * (I * t) / 2)‖ = Real.sqrt (π / (2 * |t| * Real.tanh (π * |t| / 2))) := by
  -- Use the properties of the Gamma function and the cosine function.
  have h_gamma : ‖Complex.Gamma (Complex.I * t)‖ = Real.sqrt (Real.pi / (abs t * Real.sinh (Real.pi * abs t))) := by
    -- Use the fact that $|\Gamma(it)|^2 = \frac{\pi}{t \sinh(\pi t)}$ for $t > 0$.
    have h_gamma_abs_sq : ∀ t : ℝ, 0 < t → ‖Complex.Gamma (Complex.I * t)‖^2 = Real.pi / (t * Real.sinh (Real.pi * t)) := by
      intro t ht_pos
      have h_gamma_sq : ‖Complex.Gamma (Complex.I * t)‖ ^ 2 = (Complex.Gamma (Complex.I * t)) * (Complex.Gamma (-Complex.I * t)) := by
        have h_gamma_sq : ‖Complex.Gamma (Complex.I * t)‖ ^ 2 = (Complex.Gamma (Complex.I * t)) * (starRingEnd ℂ (Complex.Gamma (Complex.I * t))) := by
          rw [ Complex.mul_conj, Complex.normSq_eq_norm_sq, Complex.ofReal_pow ];
        convert h_gamma_sq using 2;
        convert Complex.Gamma_conj ( Complex.I * t ) using 2 ; norm_num;
      -- Use the fact that $\Gamma(it)\Gamma(-it) = \frac{\pi}{t \sinh(\pi t)}$.
      have h_gamma_prod : Complex.Gamma (Complex.I * t) * Complex.Gamma (-Complex.I * t) = Real.pi / (t * Real.sinh (Real.pi * t)) := by
        have := @Complex.Gamma_mul_Gamma_one_sub ( Complex.I * t );
        rw [ show ( 1 - Complex.I * t : ℂ ) = -Complex.I * t + 1 by ring, Complex.Gamma_add_one ] at this <;> norm_num at *;
        · simp_all +decide [ Complex.sinh, Complex.sin, div_eq_mul_inv ];
          convert congr_arg ( fun x : ℂ => x / ( Complex.I * t ) ) this using 1 <;> ring ; norm_num [ Complex.ext_iff, ht_pos.ne' ];
          · grind;
          · norm_num [ mul_assoc, mul_comm, mul_left_comm ];
            norm_num [ ← mul_assoc ];
        · linarith;
      exact_mod_cast h_gamma_sq.trans h_gamma_prod;
    cases abs_cases t <;> simp_all +decide [ Complex.normSq, Complex.norm_def ];
    · rw [ abs_of_nonneg ‹_›, ← h_gamma_abs_sq t ( by positivity ), Real.sqrt_sq ( Real.sqrt_nonneg _ ) ];
    · convert congr_arg Real.sqrt ( h_gamma_abs_sq ( -t ) ( by linarith ) ) using 1 <;> norm_num [ abs_of_nonpos ( by linarith : t ≤ 0 ) ];
      have := Complex.Gamma_conj ( Complex.I * t ) ; simp_all +decide [ Complex.ext_iff ];
  field_simp;
  convert congr_arg ( · * ‖Complex.cos ( Complex.I * t * Real.pi / 2 )‖ ) h_gamma using 1 <;> norm_num [ Complex.normSq, Complex.norm_def ] ; ring;
  rw [ ← Real.sqrt_mul <| by positivity ] ; norm_num [ Complex.cos, Complex.exp_re, Complex.exp_im, Real.tanh_eq_sinh_div_cosh ] ; ring;
  rw [ show Real.pi * |t| = Real.pi * |t| * ( 1 / 2 ) + Real.pi * |t| * ( 1 / 2 ) by ring ] ; norm_num [ Real.sinh_add, Real.cosh_add, Real.sinh_eq, Real.cosh_eq, Real.exp_add, Real.exp_neg ] ; ring;
  cases abs_cases t <;> simp +decide [ *, Real.exp_neg, Real.exp_mul, Real.exp_log ] <;> ring_nf <;> norm_num [ ne_of_gt, Real.pi_pos, Real.exp_pos ];
  · field_simp;
    rw [ ← Real.sqrt_mul ( by positivity ) ] ; rw [ ← mul_div_mul_right _ _ ( by positivity : ( 2 : ℝ ) ≠ 0 ) ] ; ring;
    grind;
  · field_simp;
    rw [ ← Real.sqrt_mul ( by norm_num ) ] ; ring;
    grind

/-
Correct relation between norms of zeta on critical line and 1-line for |t| >= 1
-/
open Complex Filter Topology

lemma norm_zeta_eq_norm_zeta_one_sub_correct (t : ℝ) (ht : |t| ≥ 1) :
    ‖riemannZeta (I * t)‖ = ‖riemannZeta (1 - I * t)‖ * 2⁻¹ * ‖Gamma (I * t) * cos (π * (I * t) / 2)‖⁻¹ := by
  have h_zeta_bound : riemannZeta (Complex.I * t) = riemannZeta (1 - Complex.I * t) / (2 * Gamma (Complex.I * t) * Complex.cos (Real.pi * (Complex.I * t) / 2) / (2 * Real.pi) ^ (Complex.I * t)) := by
    rw [ eq_div_iff ];
    · have := @riemannZeta_one_sub ( Complex.I * t );
      rw [ this ];
      · rw [ Complex.cpow_neg ] ; ring;
      · norm_num [ Complex.ext_iff ];
        cases abs_cases t <;> linarith;
      · norm_num [ Complex.ext_iff ];
    · norm_num [ Complex.Gamma_eq_zero_iff, Real.pi_ne_zero ];
      norm_num [ Complex.ext_iff, Complex.cos, Complex.exp_re, Complex.exp_im ];
      exact ⟨ by rintro rfl; norm_num at ht, by positivity ⟩;
  rw [ h_zeta_bound, norm_div ] ; ring;
  norm_num [ Complex.norm_exp, Complex.norm_cpow_of_ne_zero, Real.pi_ne_zero ] ; ring;
  norm_num [ Complex.arg ] ; ring;
  exact Or.inl <| Or.inl <| by rw [ if_pos Real.pi_pos.le ] ; norm_num;

/-
Simplified expression for norm of zeta on critical line
-/
open Complex Filter Topology

lemma norm_zeta_zero_line_eq (t : ℝ) (ht : |t| ≥ 1) :
    ‖riemannZeta (I * t)‖ = ‖riemannZeta (1 - I * t)‖ * Real.sqrt (|t| * Real.tanh (π * |t| / 2) / (2 * π)) := by
  rw [ norm_zeta_eq_norm_zeta_one_sub_correct t ht, abs_Gamma_mul_cos_bound t ht ];
  field_simp;
  rw [ div_eq_mul_inv, ← Real.sqrt_inv ] ; ring;
  norm_num [ mul_assoc, mul_comm, mul_left_comm ] ; ring;
  exact Or.inl ( by rw [ show ( Real.pi⁻¹ * Real.tanh ( Real.pi * |t| * ( 1 / 2 ) ) * 2 : ℝ ) = ( Real.pi⁻¹ * Real.tanh ( Real.pi * |t| * ( 1 / 2 ) ) * ( 1 / 2 ) ) * 4 by ring ] ; norm_num ; ring )

/-
Bound for tanh
-/
open Complex Filter Topology

lemma Real.abs_tanh_le_one (x : ℝ) : |tanh x| ≤ 1 := by
  exact abs_le.mpr ⟨ by rw [ Real.tanh_eq_sinh_div_cosh ] ; rw [ le_div_iff₀ ( Real.cosh_pos _ ) ] ; nlinarith [ Real.sinh_sq x, Real.cosh_pos x ], by rw [ Real.tanh_eq_sinh_div_cosh ] ; rw [ div_le_one₀ ( Real.cosh_pos _ ) ] ; nlinarith [ Real.sinh_sq x, Real.cosh_pos x ] ⟩

/-
Bound for 1/sqrt(2pi)
-/
open Complex Filter Topology

lemma inv_sqrt_two_pi_le : 1 / Real.sqrt (2 * Real.pi) ≤ 0.4 := by
  -- Square both sides to remove the square roots.
  suffices h_sqr : (Real.sqrt (2 * Real.pi))⁻¹ ^ 2 ≤ (0.4) ^ 2 by
    simpa using le_of_pow_le_pow_left₀ ( by positivity ) ( by positivity ) h_sqr;
  -- We know that $\pi \approx 3.14$, so we can use this to approximate the value.
  have h_pi_approx : Real.pi > 3.14 := by
    exact?;
  field_simp;
  rw [ Real.sq_sqrt ] <;> norm_num at * <;> linarith

/-
tanh x is non-negative if x is non-negative
-/
open Complex Filter Topology

lemma Real.tanh_nonneg_of_nonneg {x : ℝ} (hx : 0 ≤ x) : 0 ≤ Real.tanh x := by
  rw [Real.tanh_eq_sinh_div_cosh]
  apply div_nonneg
  · rw [Real.sinh_nonneg_iff]
    exact hx
  · exact le_of_lt (Real.cosh_pos x)