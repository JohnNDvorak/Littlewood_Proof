/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 42943281-b163-4fc6-b3e1-42f212a00040

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Stirling approximation bounds for the Gamma function.

KEY RESULTS:
- complex_sin_vertical_bound: |1/sin(π(σ+it))| ≤ C exp(-π|t|)
- gamma_reflection_bound: |Γ(s)||Γ(1-s)| ≤ C exp(-π|t|)
- gamma_one_bound: |Γ(1+it)| ≤ C |t|^{1/2} exp(-π|t|/2)
- gamma_two_bound: |Γ(2+it)| ≤ C |t|^{3/2} exp(-π|t|/2)
- stirling_proxy_bounded_strip: stirling_proxy bounded on 1 ≤ Re(z) ≤ 2
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Bound for 1/|sin(π(σ+it))| on vertical lines.
-/
lemma complex_sin_vertical_bound (σ : ℝ) :
    ∃ C > 0, ∀ t : ℝ, |t| > 1 →
    ‖(Complex.sin (Real.pi * (σ + Complex.I * t)))⁻¹‖ ≤ C * Real.exp (-Real.pi * |t|) := by
      -- Let $z = \sigma + it$ with $t \neq 0$, then we have $|\sin(\pi z)|^2 = \sin^2(\pi \sigma) + \sinh^2(\pi t)$.
      suffices h_sin_bound : ∃ C > 0, ∀ t : ℝ, |t| > 1 → |Real.sin (Real.pi * σ)|^2 + |Real.sinh (Real.pi * t)|^2 ≥ C * Real.exp (2 * Real.pi * |t|) by
        -- Using the bound $|\sin(\pi z)|^2 \geq C e^{2\pi|t|}$, we get $\frac{1}{|\sin(\pi z)|^2} \leq \frac{1}{C} e^{-2\pi|t|}$.
        obtain ⟨C, hC_pos, hC⟩ := h_sin_bound;
        use Real.sqrt (1 / C); (
        -- Using the bound $|\sin(\pi z)|^2 \geq C e^{2\pi|t|}$, we get $\frac{1}{|\sin(\pi z)|^2} \leq \frac{1}{C} e^{-2\pi|t|}$, hence $\frac{1}{|\sin(\pi z)|} \leq \frac{1}{\sqrt{C}} e^{-\pi|t|}$.
        have h_inv_sin_bound : ∀ t : ℝ, |t| > 1 → ‖(Complex.sin (Real.pi * (σ + Complex.I * t)))⁻¹‖ ≤ Real.sqrt (1 / C) * Real.exp (-Real.pi * |t|) := by
          -- Using the bound $|\sin(\pi z)|^2 \geq C e^{2\pi|t|}$, we get $\frac{1}{|\sin(\pi z)|^2} \leq \frac{1}{C} e^{-2\pi|t|}$, hence $\frac{1}{|\sin(\pi z)|} \leq \frac{1}{\sqrt{C}} e^{-\pi|t|}$ by taking the square root.
          intros t ht
          have h_inv_sin_bound : ‖(Complex.sin (Real.pi * (σ + Complex.I * t)))⁻¹‖ ^ 2 ≤ (1 / C) * Real.exp (-2 * Real.pi * |t|) := by
            -- Using the bound $|\sin(\pi z)|^2 \geq C e^{2\pi|t|}$, we get $\frac{1}{|\sin(\pi z)|^2} \leq \frac{1}{C} e^{-2\pi|t|}$ by taking the square root.
            have h_inv_sin_bound : ‖Complex.sin (Real.pi * (σ + Complex.I * t))‖ ^ 2 ≥ C * Real.exp (2 * Real.pi * |t|) := by
              convert hC t ht using 1 ; norm_num [ Complex.normSq, Complex.sq_norm, Complex.exp_re, Complex.exp_im, Complex.sin ] ; ring;
              norm_num [ Complex.normSq, Complex.sq_norm, Complex.exp_re, Complex.exp_im, Real.sinh_eq ] ; ring;
              norm_num [ Real.sin_sq, Real.cos_sq, mul_assoc, mul_left_comm, ← Real.exp_add ] ; ring;
            simp_all +decide [ Real.exp_neg ];
            simpa only [ ← mul_inv ] using inv_anti₀ ( by positivity ) h_inv_sin_bound;
          convert Real.le_sqrt_of_sq_le h_inv_sin_bound using 1 ; rw [ Real.sqrt_mul ( by positivity ), Real.sqrt_eq_rpow, Real.sqrt_eq_rpow, ← Real.exp_mul ] ; ring;
        exact ⟨ Real.sqrt_pos.mpr <| one_div_pos.mpr hC_pos, h_inv_sin_bound ⟩);
      -- Since $|\sinh(\pi t)| \geq \frac{1}{2} e^{\pi |t|} - \frac{1}{2} e^{-\pi |t|}$, we have $|\sinh(\pi t)|^2 \geq \frac{1}{4} e^{2\pi |t|} - \frac{1}{2} + \frac{1}{4} e^{-2\pi |t|}$.
      have h_sinh_bound : ∀ t : ℝ, |t| > 1 → |Real.sinh (Real.pi * t)|^2 ≥ (1 / 4) * Real.exp (2 * Real.pi * |t|) - (1 / 2) + (1 / 4) * Real.exp (-2 * Real.pi * |t|) := by
        -- Since $|\sinh(\pi t)| \geq \frac{1}{2} e^{\pi |t|} - \frac{1}{2} e^{-\pi |t|}$, we have $|\sinh(\pi t)|^2 \geq \frac{1}{4} e^{2\pi |t|} - \frac{1}{2} + \frac{1}{4} e^{-2\pi |t|}$ by squaring both sides.
        intros t ht
        have h_sinh_sq : |Real.sinh (Real.pi * t)|^2 = (Real.sinh (Real.pi * |t|))^2 := by
          cases abs_cases t <;> simp +decide [ * ];
        rw [ h_sinh_sq, Real.sinh_eq ] ; ring_nf ; norm_num;
        norm_num [ sq, ← Real.exp_add ] ; ring_nf ; norm_num;
      -- Choose $C$ such that $C < \frac{1}{4}$.
      use 1 / 8;
      norm_num +zetaDelta at *;
      intro t ht; nlinarith [ h_sinh_bound t ht, Real.exp_pos ( 2 * Real.pi * |t| ), Real.exp_pos ( - ( 2 * Real.pi * |t| ) ), Real.add_one_le_exp ( 2 * Real.pi * |t| ), Real.add_one_le_exp ( - ( 2 * Real.pi * |t| ) ), Real.pi_gt_three, abs_mul_abs_self t ] ;

/-
Bound for the product of Gamma functions using the reflection formula.
-/
lemma gamma_reflection_bound (σ : ℝ) (hσ : 0 < σ) (hσ' : σ < 2) :
    ∃ C > 0, ∀ t : ℝ, |t| > 1 →
    ‖Complex.Gamma (σ + Complex.I * t)‖ * ‖Complex.Gamma (1 - σ - Complex.I * t)‖ ≤ C * Real.exp (-Real.pi * |t|) := by
      -- Use the reflection formula: Γ(s)Γ(1-s) = π/sin(πs).
      have h_reflection : ∀ t : ℝ, ‖(Complex.Gamma ((σ : ℂ) + Complex.I * t))‖ * ‖(Complex.Gamma (1 - (σ : ℂ) - Complex.I * t))‖ = Real.pi / ‖(Complex.sin (Real.pi * (σ + Complex.I * t)))‖ := by
        intro t;
        have := @Complex.Gamma_mul_Gamma_one_sub ( σ + Complex.I * t );
        convert congr_arg Norm.norm this using 1 <;> norm_num [ sub_sub ];
        rw [ abs_of_nonneg Real.pi_pos.le ];
      -- Use `complex_sin_vertical_bound` to bound |1/sin(πs)| by C * exp(-π|t|).
      obtain ⟨C, hC_pos, hC⟩ : ∃ C > 0, ∀ t : ℝ, |t| > 1 → ‖(Complex.sin (Real.pi * (σ + Complex.I * t)))⁻¹‖ ≤ C * Real.exp (-Real.pi * |t|) := by
        convert complex_sin_vertical_bound σ;
      simp_all +decide [ div_eq_mul_inv ];
      exact ⟨ Real.pi * C, mul_pos Real.pi_pos hC_pos, fun t ht => by nlinarith [ hC t ht, Real.pi_pos ] ⟩

/-
Step down lemma for the Gamma bound using the functional equation.
-/
lemma gamma_step_down (σ : ℝ) :
    (∃ (C : ℝ), C > 0 ∧ ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (σ + 1 + Complex.I * t)‖ ≤ C * |t|^(σ + 1/2) * Real.exp (-Real.pi * |t| / 2)) →
    (∃ (C : ℝ), C > 0 ∧ ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (σ + Complex.I * t)‖ ≤ C * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2)) := by
      rintro ⟨ C, hC₀, hC ⟩;
      -- Using the functional equation $\Gamma(s+1) = s\Gamma(s)$, we can relate the bounds for $\Gamma(\sigma + 1 + it)$ and $\Gamma(\sigma + it)$.
      have h_fun_eq : ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (σ + Complex.I * t)‖ = ‖Complex.Gamma (σ + 1 + Complex.I * t)‖ / ‖σ + Complex.I * t‖ := by
        intro t ht;
        have h_fun_eq : Complex.Gamma (σ + 1 + Complex.I * t) = (σ + Complex.I * t) * Complex.Gamma (σ + Complex.I * t) := by
          convert Complex.Gamma_add_one _ using 2 ; ring;
          swap;
          exact σ + Complex.I * t;
          by_cases h : ( σ : ℂ ) + Complex.I * t = 0 <;> simp_all +decide [ add_assoc, mul_comm ];
          · simp_all +decide [ Complex.ext_iff ];
            linarith;
          · ring;
        rw [ h_fun_eq, norm_mul, mul_div_cancel_left₀ _ ( ne_of_gt <| norm_pos_iff.mpr <| by norm_num [ Complex.ext_iff ] ; aesop ) ];
      -- Using the bound for Γ(σ + 1 + it), we can relate it to Γ(σ + it) by dividing by |σ + it|.
      have h_div : ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (σ + Complex.I * t)‖ ≤ (C * |t| ^ (σ + 1 / 2) * Real.exp (-Real.pi * |t| / 2)) / ‖σ + Complex.I * t‖ := by
        exact fun t ht => h_fun_eq t ht ▸ div_le_div_of_nonneg_right ( hC t ht ) ( norm_nonneg _ );
      -- We'll use that ‖σ + Complex.I * t‖ ≥ |t| / 2 for |t| > 1.
      have h_bound : ∀ t : ℝ, |t| > 1 → ‖σ + Complex.I * t‖ ≥ |t| / 2 := by
        norm_num [ Complex.normSq, Complex.norm_def ];
        field_simp;
        exact fun t ht => by nlinarith [ abs_mul_abs_self t, Real.sqrt_nonneg ( σ ^ 2 + t ^ 2 ), Real.mul_self_sqrt ( by positivity : 0 ≤ σ ^ 2 + t ^ 2 ) ] ;
      refine' ⟨ C * 2, mul_pos hC₀ zero_lt_two, fun t ht => le_trans ( h_div t ht ) _ ⟩;
      field_simp;
      rw [ div_le_iff₀ ( by linarith [ h_bound t ht, abs_pos.mpr ( show t ≠ 0 by rintro rfl; norm_num at ht ) ] ) ];
      rw [ show ( σ * 2 + 1 ) / 2 = ( σ * 2 - 1 ) / 2 + 1 by ring, Real.rpow_add ] <;> norm_num;
      · nlinarith [ h_bound t ht, Real.rpow_pos_of_pos ( zero_lt_one.trans ht ) ( ( σ * 2 - 1 ) / 2 ) ];
      · rintro rfl; norm_num at ht

/-
Bound for Gamma on the line Re(s) = 1.
-/
lemma gamma_one_bound :
    ∃ C > 0, ∀ t : ℝ, |t| > 1 →
    ‖Complex.Gamma (1 + Complex.I * t)‖ ≤ C * |t|^(1/2 : ℝ) * Real.exp (-Real.pi * |t| / 2) := by
      -- Using the bound from part 1, we get:
      have h_bound : ∃ C > 0, ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (1 + Complex.I * t)‖^2 ≤ C * |t| * Real.exp (-Real.pi * |t|) := by
        -- Using the bound from part 1, we get $|Γ(1+it)|^2 = π|t|/|sinh(πt)|$.
        have h_gamma_sq : ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (1 + Complex.I * t)‖^2 = Real.pi * |t| / |Real.sinh (Real.pi * t)| := by
          -- Using the bound from part 1, we get $|Γ(1+it)|^2 = π|t|/|sinh(πt)|$ by the properties of the Gamma function.
          intros t ht
          have h_gamma_sq : ‖Complex.Gamma (1 + Complex.I * t)‖^2 = Real.pi * |t| / |Real.sinh (Real.pi * t)| := by
            have h_gamma_prod : Complex.Gamma (1 + Complex.I * t) * Complex.Gamma (1 - Complex.I * t) = Real.pi * t / Real.sinh (Real.pi * t) := by
              have := @Complex.Gamma_mul_Gamma_one_sub ( 1 + Complex.I * t );
              convert congr_arg ( fun x : ℂ => -x * Complex.I * t ) this using 1 <;> ring;
              · rw [ show ( 1 - Complex.I * t : ℂ ) = - ( Complex.I * t ) + 1 by ring, Complex.Gamma_add_one ] ; ring ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.sinh ];
                cases abs_cases t <;> linarith;
              · norm_num [ Complex.sin_add, Complex.sin_mul_I, Complex.cos_mul_I ] ; ring;
                norm_num [ Complex.ext_iff ]
            -- Using the fact that $\Gamma(1-it) = \overline{\Gamma(1+it)}$, we get $|\Gamma(1+it)|^2 = \Gamma(1+it)\Gamma(1-it)$.
            have h_gamma_conj : Complex.Gamma (1 - Complex.I * t) = starRingEnd ℂ (Complex.Gamma (1 + Complex.I * t)) := by
              convert Complex.Gamma_conj ( 1 + Complex.I * t ) using 1 ; norm_num [ Complex.ext_iff ];
              exact ⟨ rfl, rfl ⟩;
            simp_all +decide [ Complex.ext_iff, sq ];
            field_simp;
            convert h_gamma_prod.1 using 1 <;> norm_cast ; norm_num [ Complex.normSq, Complex.sq_norm ] ; ring;
            cases abs_cases t <;> simp +decide [ * ];
            · exact Or.inl ( mul_nonneg Real.pi_pos.le ( by linarith ) );
            · rw [ abs_of_neg ( Real.sinh_neg_iff.mpr ( by nlinarith [ Real.pi_pos ] ) ) ] ; ring;
          exact h_gamma_sq;
        -- Using the bound from part 2, we get $|sinh(πt)| \geq \frac{e^{π|t|}}{4}$.
        have h_sinh_bound : ∀ t : ℝ, |t| > 1 → |Real.sinh (Real.pi * t)| ≥ Real.exp (Real.pi * |t|) / 4 := by
          intro t ht; rw [ Real.sinh_eq ] ; cases abs_cases t <;> simp +decide [ * ] at *;
          · rw [ abs_of_nonneg ] <;> nlinarith [ Real.pi_gt_three, Real.exp_pos ( Real.pi * t ), Real.exp_neg ( Real.pi * t ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * t ) ) ), Real.add_one_le_exp ( Real.pi * t ), Real.add_one_le_exp ( - ( Real.pi * t ) ) ];
          · rw [ abs_of_nonpos ] <;> nlinarith [ Real.pi_gt_three, Real.exp_pos ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_neg ( Real.pi * t ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * t ) ) ), Real.add_one_le_exp ( Real.pi * t ), Real.add_one_le_exp ( - ( Real.pi * t ) ) ];
        refine' ⟨ 4 * Real.pi, by positivity, fun t ht => _ ⟩ ; rw [ h_gamma_sq t ht ] ; rw [ div_le_iff₀ ] <;> norm_num [ Real.exp_neg ];
        · field_simp;
          linarith [ h_sinh_bound t ht ];
        · cases abs_cases t <;> linarith;
      -- Taking the square root of both sides of the inequality, we obtain:
      obtain ⟨C, hC_pos, hC_bound⟩ := h_bound;
      use Real.sqrt C; (
      refine' ⟨ Real.sqrt_pos.mpr hC_pos, fun t ht => _ ⟩;
      convert Real.le_sqrt_of_sq_le ( hC_bound t ht ) using 1 ; norm_num [ Real.sqrt_eq_rpow, Real.rpow_def_of_pos, hC_pos ];
      rw [ Real.mul_rpow ( by positivity ) ( by positivity ), Real.mul_rpow ( by positivity ) ( by positivity ), Real.rpow_def_of_pos ( by positivity ), Real.rpow_def_of_pos ( by positivity ) ] ; ring;
      rw [ ← Real.exp_mul ] ; ring)

/-
Bound for Gamma on the line Re(s) = 2.
-/
lemma gamma_two_bound :
    ∃ C > 0, ∀ t : ℝ, |t| > 1 →
    ‖Complex.Gamma (2 + Complex.I * t)‖ ≤ C * |t|^(3/2 : ℝ) * Real.exp (-Real.pi * |t| / 2) := by
      -- Use the functional equation $\Gamma(s+1) = s\Gamma(s)$ to express $\Gamma(2+it)$ in terms of $\Gamma(1+it)$.
      have h_gamma_two : ∀ t : ℝ, Complex.Gamma (2 + Complex.I * t) = (1 + Complex.I * t) * Complex.Gamma (1 + Complex.I * t) := by
        intro t; rw [ show 2 + Complex.I * t = 1 + Complex.I * t + 1 by ring ] ; rw [ Complex.Gamma_add_one ] ; ring ; norm_num [ Complex.ext_iff ];
      -- Use the bound for $\Gamma(1+it)$ to bound $\Gamma(2+it)$.
      obtain ⟨C₁, hC₁⟩ : ∃ C₁ > 0, ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (1 + Complex.I * t)‖ ≤ C₁ * |t|^(1/2 : ℝ) * Real.exp (-Real.pi * |t| / 2) := by
        convert gamma_one_bound using 1;
      refine' ⟨ 2 * C₁, mul_pos zero_lt_two hC₁.1, fun t ht => _ ⟩ ; rw [ h_gamma_two t ] ; norm_num [ Complex.normSq, Complex.norm_def ] at *;
      convert mul_le_mul ( show Real.sqrt ( 1 + t * t ) ≤ 2 * |t| by rw [ Real.sqrt_le_left ] <;> nlinarith [ abs_mul_abs_self t ] ) ( hC₁.2 t ht ) ( by positivity ) ( by nlinarith [ abs_nonneg t ] ) using 1 ; ring;
      rw [ show ( 3 / 2 : ℝ ) = 1 + 1 / 2 by norm_num, Real.rpow_add' ] <;> norm_num ; linarith [ abs_nonneg t ]

/-
Helper function for Phragmen-Lindelof: ratio of Gamma to its Stirling approximation.
-/
noncomputable def stirling_proxy (z : ℂ) : ℂ :=
  Complex.Gamma z * (Complex.exp (-(z - 1/2) * Complex.log z + z))

/-
Bound for stirling_proxy on the line Re(z) = 1.
-/
lemma stirling_proxy_bound_one :
    ∃ C > 0, ∀ t : ℝ, |t| > 1 → ‖stirling_proxy (1 + Complex.I * t)‖ ≤ C := by
      -- Use the bound from `gamma_one_bound` for the Gamma function.
      obtain ⟨C_gamma, hC_gamma⟩ : ∃ C_gamma > 0, ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (1 + Complex.I * t)‖ ≤ C_gamma * |t|^(1/2 : ℝ) * Real.exp (-Real.pi * |t| / 2) := gamma_one_bound
      -- Use the bound from `stirling_proxy_series_bound` for the exponential term.
      have h_exp_bound : ∀ t : ℝ, |t| > 1 → ‖Complex.exp (-(1 + Complex.I * t - 1 / 2) * Complex.log (1 + Complex.I * t) + (1 + Complex.I * t))‖ ≤ Real.exp (Real.pi * |t| / 2) * |t| ^ (-1 / 2 : ℝ) * Real.exp 1 := by
        -- The real part of the argument is bounded by $1/2 \log(|1 + it|) + t \arg(1 + it) + 1$.
        have h_real_part_bound : ∀ t : ℝ, |t| > 1 → Complex.re (-(1 + Complex.I * t - 1 / 2) * Complex.log (1 + Complex.I * t) + (1 + Complex.I * t)) ≤ Real.pi * |t| / 2 - Real.log |t| / 2 + 1 := by
          intros t ht
          have h_arg_bound : Complex.arg (1 + Complex.I * t) ≤ Real.pi / 2 := by
            rw [ Complex.arg_le_pi_div_two_iff ] ; norm_num;
          have h_arg_bound : Complex.arg (1 + Complex.I * t) ≥ -Real.pi / 2 := by
            rw [ neg_div, Complex.arg ];
            norm_num [ Complex.normSq, Complex.norm_def ];
            linarith [ Real.neg_pi_div_two_le_arcsin ( t / Real.sqrt ( 1 + t * t ) ) ];
          norm_num [ Complex.log_re, Complex.log_im ];
          cases abs_cases t <;> simp +decide [ * ] at *;
          · norm_num [ Complex.normSq, Complex.norm_def ];
            rw [ Real.log_sqrt ( by positivity ) ];
            rw [ show ( 1 + t * t ) = t * ( t + 1 / t ) by nlinarith [ mul_div_cancel₀ 1 ( by linarith : t ≠ 0 ) ], Real.log_mul ( by linarith ) ( by positivity ) ];
            nlinarith [ Real.pi_gt_three, Real.log_pos ht, Real.log_le_log ( by positivity ) ( by nlinarith [ one_div_mul_cancel ( by positivity : ( t : ℝ ) ≠ 0 ) ] : t + 1 / t ≥ t ) ];
          · norm_num [ Complex.normSq, Complex.norm_def ];
            rw [ Real.log_sqrt ( by nlinarith ) ];
            rw [ show ( 1 + t * t ) = t ^ 2 * ( 1 + 1 / t ^ 2 ) by nlinarith [ one_div_mul_cancel ( by nlinarith : t ^ 2 ≠ 0 ) ], Real.log_mul ( by nlinarith ) ( by nlinarith [ one_div_mul_cancel ( by nlinarith : t ^ 2 ≠ 0 ) ] ), Real.log_pow ] ; ring_nf at * ; norm_num at *;
            nlinarith [ Real.pi_pos, Real.log_nonneg ( show 1 + ( t ^ 2 ) ⁻¹ ≥ 1 by exact le_add_of_nonneg_right ( by positivity ) ) ];
        intro t ht; rw [ Complex.norm_exp ] ; specialize h_real_part_bound t ht; norm_num [ Real.rpow_def_of_pos ( abs_pos.mpr <| show t ≠ 0 by rintro rfl; norm_num at ht ) ] at *;
        rw [ ← Real.exp_add, ← Real.exp_add ] ; exact Real.exp_le_exp.mpr ( by linarith );
      refine' ⟨ C_gamma * Real.exp 1, mul_pos hC_gamma.1 ( Real.exp_pos _ ), fun t ht => _ ⟩ ; convert le_trans ( norm_mul_le _ _ ) ( mul_le_mul ( hC_gamma.2 t ht ) ( h_exp_bound t ht ) ( by positivity ) ( by exact le_trans ( by positivity ) ( hC_gamma.2 t ht ) ) ) using 1 ; ring! ; norm_num [ Real.exp_neg, Real.exp_add, Real.exp_log ] ;
      rw [ mul_assoc, ← Real.rpow_add ( by positivity ), add_neg_cancel, Real.rpow_zero, mul_one ]

/-
Bound for stirling_proxy on the line Re(z) = 2.
-/
lemma stirling_proxy_bound_two :
    ∃ C > 0, ∀ t : ℝ, |t| > 1 → ‖stirling_proxy (2 + Complex.I * t)‖ ≤ C := by
      -- Apply the bound for Gamma on the line Re(s) = 2.
      obtain ⟨C₂, hC₂_pos, hC₂⟩ := gamma_two_bound;
      -- Now consider the term $\exp(-(2 + it - 1/2) \log(2 + it) + (2 + it))$.
      have h_exp : ∀ t : ℝ, |t| > 1 → ‖Complex.exp (-(2 + Complex.I * t - 1 / 2) * Complex.log (2 + Complex.I * t) + (2 + Complex.I * t))‖ ≤ Real.exp (|t| * Real.pi / 2 + 2) * (Real.sqrt (4 + t^2)) ^ (-3 / 2 : ℝ) := by
        intros t ht
        have h_exp_arg : Complex.re (-(2 + Complex.I * t - 1 / 2) * Complex.log (2 + Complex.I * t) + (2 + Complex.I * t)) ≤ |t| * Real.pi / 2 + 2 - (3 / 2) * Real.log (Real.sqrt (4 + t^2)) := by
          norm_num [ Complex.log_re, Complex.log_im ];
          norm_num [ Complex.normSq, Complex.norm_def, Complex.arg ] ; ring_nf ; norm_num;
          cases abs_cases t <;> simp +decide [ * ] <;> nlinarith [ Real.pi_pos, Real.arcsin_le_pi_div_two ( t * ( Real.sqrt ( 4 + t ^ 2 ) ) ⁻¹ ), Real.neg_pi_div_two_le_arcsin ( t * ( Real.sqrt ( 4 + t ^ 2 ) ) ⁻¹ ) ];
        convert Real.exp_le_exp.mpr h_exp_arg using 1 ; norm_num [ Complex.norm_exp, Real.rpow_def_of_pos ( Real.sqrt_pos.mpr ( show 0 < 4 + t ^ 2 by positivity ) ) ] ; ring;
        rw [ Real.rpow_def_of_pos ( by positivity ) ] ; rw [ Real.exp_add ] ; ring;
        rw [ ← Real.exp_add, ← Real.exp_add ];
      -- Combine the bounds for Gamma and the exponential term.
      have h_combined : ∀ t : ℝ, |t| > 1 → ‖Complex.Gamma (2 + Complex.I * t)‖ * ‖Complex.exp (-(2 + Complex.I * t - 1 / 2) * Complex.log (2 + Complex.I * t) + (2 + Complex.I * t))‖ ≤ C₂ * Real.exp 2 * |t|^(3 / 2 : ℝ) * (Real.sqrt (4 + t^2)) ^ (-3 / 2 : ℝ) := by
        intro t ht; convert mul_le_mul ( hC₂ t ht ) ( h_exp t ht ) ( by positivity ) ( by positivity ) using 1 ; ring;
        norm_num [ mul_assoc, ← Real.exp_add ] ; ring;
        norm_num;
      -- Simplify the expression $|t|^{3/2} * (Real.sqrt (4 + t^2)) ^ (-3 / 2 : ℝ)$ to $(Real.sqrt (t^2 / (4 + t^2))) ^ (3 / 2 : ℝ)$.
      have h_simplified : ∀ t : ℝ, |t| > 1 → |t|^(3 / 2 : ℝ) * (Real.sqrt (4 + t^2)) ^ (-3 / 2 : ℝ) ≤ 1 := by
        field_simp;
        intro t ht; rw [ Real.rpow_neg ( by positivity ) ] ; rw [ ← div_eq_mul_inv ] ; rw [ div_le_one ( by positivity ) ] ; exact Real.rpow_le_rpow ( by positivity ) ( by nlinarith [ abs_mul_abs_self t, Real.sqrt_nonneg ( 4 + t ^ 2 ), Real.mul_self_sqrt ( show 0 ≤ 4 + t ^ 2 by positivity ) ] ) ( by positivity ) ;
      refine' ⟨ C₂ * Real.exp 2, mul_pos hC₂_pos <| Real.exp_pos _, fun t ht => _ ⟩;
      convert le_trans ( h_combined t ht ) _ using 1;
      · exact norm_mul _ _;
      · nlinarith [ h_simplified t ht, show 0 < C₂ * Real.exp 2 by positivity ]

/-
The stirling_proxy function is differentiable on the right half-plane.
-/
lemma stirling_proxy_differentiable :
    DifferentiableOn ℂ stirling_proxy {z : ℂ | 0 < z.re} := by
      -- The Gamma function is differentiable on the right half-plane, and the exponential function is entire.
      have h_gamma_diff : AnalyticOn ℂ Complex.Gamma {z : ℂ | 0 < z.re} := by
        apply_rules [ DifferentiableOn.analyticOn ];
        · intro z hz;
          refine' DifferentiableAt.differentiableWithinAt _;
          apply_rules [ Complex.differentiableAt_Gamma ];
          exact fun m => ne_of_apply_ne Complex.re <| by norm_num; linarith [ hz.out ];
        · exact isOpen_lt continuous_const Complex.continuous_re;
      apply_rules [ DifferentiableOn.mul, DifferentiableOn.exp, DifferentiableOn.neg, DifferentiableOn.add, DifferentiableOn.mul, differentiableOn_id, differentiableOn_const ];
      · exact h_gamma_diff.differentiableOn;
      · refine' DifferentiableOn.cexp _;
        refine' DifferentiableOn.add _ differentiableOn_id;
        refine' DifferentiableOn.mul _ _;
        · exact DifferentiableOn.neg ( differentiableOn_id.sub_const _ );
        · refine' DifferentiableOn.clog _ _;
          · exact differentiableOn_id;
          · exact fun z hz => Or.inl hz

/-
Crude growth bound for Gamma. Actually, checking if |Gamma(z)| <= Gamma(Re(z)).
-/
lemma gamma_growth_crude :
    ∃ A B : ℝ, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖Complex.Gamma z‖ ≤ A * Real.exp (B * ‖z‖ * Real.log ‖z‖) := by
      -- By the maximum modulus principle, away from poles, |Γ(z)| is bounded by a constant on any compact set. Hence, |Γ(z)| ≤ exp(O(|z| log|z|)).
      have h_max_modulus : ∃ C > 0, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖Complex.Gamma z‖ ≤ C := by
        -- By the properties of the Gamma function, we know that |Γ(z)| is bounded by a constant on the strip 1 ≤ Re(z) ≤ 2.
        have h_gamma_bound : ∃ C > 0, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖Complex.Gamma z‖ ≤ C := by
          have h_cont : ContinuousOn (fun z : ℂ => ‖Complex.Gamma z‖) {z : ℂ | 1 ≤ z.re ∧ z.re ≤ 2} := by
            refine' continuousOn_of_forall_continuousAt _;
            intro z hz;
            refine' ContinuousAt.norm _;
            refine' Complex.differentiableAt_Gamma _ _ |> DifferentiableAt.continuousAt;
            intro m hm; norm_num [ Complex.ext_iff ] at hm; linarith [ hz.1, hz.2 ] ;
          -- By the maximum modulus principle, away from poles, |Γ(z)| is bounded by a constant on any compact set. Hence, |Γ(z)| ≤ exp(O(|z| log|z|)) on the strip 1 ≤ Re(z) ≤ 2.
          have h_max_modulus : ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖Complex.Gamma z‖ ≤ 2 * Real.Gamma 2 := by
            intros z hz;
            have h_gamma_bound : ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖Complex.Gamma z‖ ≤ Real.Gamma (z.re) := by
              intro z hz;
              rw [ Complex.Gamma_eq_integral ( by linarith ) ];
              refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) _;
              rw [ Real.Gamma_eq_integral ( by linarith ) ];
              refine' le_of_eq _;
              refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioi fun x hx => _;
              norm_num [ Complex.norm_exp, Complex.norm_cpow_eq_rpow_re_of_pos hx ];
            have h_gamma_bound : ∀ x : ℝ, 1 ≤ x ∧ x ≤ 2 → Real.Gamma x ≤ 2 * Real.Gamma 2 := by
              -- Since $\Gamma(x)$ is convex on $(0, \infty)$, we have $\Gamma(x) \leq \max(\Gamma(1), \Gamma(2))$ for $1 \leq x \leq 2$.
              have h_convex : ConvexOn ℝ (Set.Ioi 0) Real.Gamma := by
                exact ( Real.convexOn_Gamma );
              intros x hx
              have h_convex_bound : Real.Gamma x ≤ (1 - (x - 1)) * Real.Gamma 1 + (x - 1) * Real.Gamma 2 := by
                have := h_convex.2 ( show 0 < ( 1 : ℝ ) by norm_num ) ( show 0 < ( 2 : ℝ ) by norm_num );
                convert this ( show 0 ≤ 1 - ( x - 1 ) by linarith ) ( show 0 ≤ x - 1 by linarith ) ( by linarith ) using 1 ; norm_num ; ring;
              norm_num at * ; nlinarith;
            exact le_trans ( by solve_by_elim ) ( h_gamma_bound _ hz );
          exact ⟨ 2 * Real.Gamma 2, by positivity, h_max_modulus ⟩;
        exact h_gamma_bound;
      obtain ⟨ C, hC₀, hC ⟩ := h_max_modulus; exact ⟨ C, 0, fun z hz => by simpa using hC z hz ⟩ ;

/-
Intermediate growth bound for stirling_proxy.
-/
lemma stirling_proxy_growth_bound_aux :
    ∃ A B : ℝ, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖stirling_proxy z‖ ≤ A * Real.exp (B * ‖z‖ * Real.log ‖z‖) := by
      -- Use `gamma_growth_crude` to get |Gamma(z)| <= A1 * exp(B1 * |z| * log |z|).
      obtain ⟨A1, B1, h_gamma_growth⟩ : ∃ A1 B1 : ℝ, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖Complex.Gamma z‖ ≤ A1 * Real.exp (B1 * ‖z‖ * Real.log ‖z‖) := gamma_growth_crude
      -- Analyze the exponential term: |exp(-(z-1/2)log z + z)| = exp(Re(-(z-1/2)log z + z)).
      have h_exp_growth : ∃ A2 B2 : ℝ, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖Complex.exp (-(z - 1 / 2) * Complex.log z + z)‖ ≤ A2 * Real.exp (B2 * ‖z‖ * Real.log ‖z‖) := by
        -- Re(-(z-1/2)log z + z) = -Re(z)log|z| + Im(z)arg(z) + 1/2 log|z| + Re(z).
        have h_re_exp : ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → Complex.re (-(z - 1 / 2) * Complex.log z + z) ≤ Real.pi * ‖z‖ + 2 := by
          norm_num [ Complex.log_re, Complex.log_im ];
          intro z hz₁ hz₂; nlinarith [ Real.pi_gt_three, abs_le.mp ( Complex.abs_re_le_norm z ), abs_le.mp ( Complex.abs_im_le_norm z ), Real.log_nonneg ( show 1 ≤ ‖z‖ from by exact le_trans ( by linarith ) ( Complex.re_le_norm z ) ), Complex.arg_le_pi z, Complex.neg_pi_lt_arg z ] ;
        -- For large |z|, π|z| + 2 ≤ C|z|log|z|. For small |z| (bounded), it's bounded by a constant.
        obtain ⟨C, hC⟩ : ∃ C : ℝ, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → Real.pi * ‖z‖ + 2 ≤ C * ‖z‖ * Real.log ‖z‖ + C := by
          use Real.pi + 2 + 2;
          intro z hz;
          by_cases hz_abs : ‖z‖ ≥ 1;
          · nlinarith [ Real.pi_gt_three, mul_le_mul_of_nonneg_left hz_abs <| Real.pi_pos.le, Real.log_inv ‖z‖ ▸ Real.log_le_sub_one_of_pos ( inv_pos.mpr <| zero_lt_one.trans_le hz_abs ), mul_inv_cancel₀ <| ne_of_gt <| zero_lt_one.trans_le hz_abs ];
          · nlinarith [ Real.pi_gt_three, show ‖z‖ ≥ 1 by exact le_trans ( by norm_num ) ( Complex.re_le_norm z |> le_trans hz.1 ) ];
        use Real.exp C, C;
        intro z hz; rw [ ← Real.exp_add ] ; norm_num [ Complex.norm_exp ];
        have := h_re_exp z hz; have := hC z hz; norm_num [ Complex.log_re, Complex.log_im ] at *; linarith;
      obtain ⟨ A2, B2, h_exp_growth ⟩ := h_exp_growth; use A1 * A2, B1 + B2; intro z hz; rw [ show stirling_proxy z = Complex.Gamma z * Complex.exp ( - ( z - 1 / 2 ) * Complex.log z + z ) by rfl ] ; convert mul_le_mul ( h_gamma_growth z hz ) ( h_exp_growth z hz ) ( by positivity ) ( by exact le_trans ( by positivity ) ( h_gamma_growth z hz ) ) using 1 ; ring;
      · exact norm_mul _ _;
      · rw [ show ( B1 + B2 ) * ‖z‖ * Real.log ‖z‖ = B1 * ‖z‖ * Real.log ‖z‖ + B2 * ‖z‖ * Real.log ‖z‖ by ring, Real.exp_add ] ; ring

/-
Growth comparison: x log x vs exp(x).
-/
lemma log_growth_vs_exp (B : ℝ) :
    ∀ᶠ x : ℝ in Filter.atTop, B * x * Real.log x ≤ Real.exp x := by
      -- We'll use the fact that $B * x * \log x / \exp(x) \to 0$ as $x \to \infty$.
      have h_lim : Filter.Tendsto (fun x : ℝ => B * x * Real.log x / Real.exp x) Filter.atTop (nhds 0) := by
        -- We'll use the fact that $x \log x / e^x$ tends to $0$ as $x$ tends to infinity.
        have h_lim : Filter.Tendsto (fun x : ℝ => x * Real.log x / Real.exp x) Filter.atTop (nhds 0) := by
          -- We'll use the fact that $e^x$ grows much faster than $x \log x$.
          have h_exp_growth : Filter.Tendsto (fun x : ℝ => x ^ 2 / Real.exp x) Filter.atTop (nhds 0) := by
            simpa [ Real.exp_neg ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 2;
          refine' squeeze_zero_norm' _ h_exp_growth;
          filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx using by rw [ Real.norm_of_nonneg ( div_nonneg ( mul_nonneg ( by linarith ) ( Real.log_nonneg ( by linarith ) ) ) ( Real.exp_nonneg _ ) ) ] ; rw [ div_le_div_iff_of_pos_right ( Real.exp_pos _ ) ] ; nlinarith [ Real.log_le_sub_one_of_pos ( by linarith : 0 < x ) ] ;
        convert h_lim.const_mul B using 2 <;> ring;
      filter_upwards [ h_lim.eventually ( gt_mem_nhds zero_lt_one ), Filter.eventually_gt_atTop 1 ] with x hx₁ hx₂ using by rw [ div_lt_one ( Real.exp_pos x ) ] at hx₁; linarith;

/-
Bound for the norm of z in the strip.
-/
lemma norm_le_im_add_two (z : ℂ) (h : 1 ≤ z.re ∧ z.re ≤ 2) : ‖z‖ ≤ |z.im| + 2 := by
  exact Real.sqrt_le_iff.mpr ⟨ by positivity, by cases abs_cases z.im <;> nlinarith [ sq_nonneg z.im, sq_nonneg ( z.re - 1 ), Complex.normSq_apply z, Complex.sq_norm z ] ⟩

/-
Inequality comparing polynomial-logarithmic growth to exponential growth.
-/
lemma log_growth_inequality (B : ℝ) :
    ∀ᶠ y : ℝ in Filter.atTop, B * (y + 2) * Real.log (y + 2) ≤ Real.exp y := by
      -- We can rewrite the inequality as $B \cdot (y + 2) \cdot \log(y + 2) / \exp(y) \to 0$ as $y \to \infty$.
      suffices h_lim : Filter.Tendsto (fun y : ℝ => B * (y + 2) * Real.log (y + 2) / Real.exp y) Filter.atTop (nhds 0) by
        filter_upwards [ h_lim.eventually ( gt_mem_nhds zero_lt_one ), Filter.eventually_gt_atTop 0 ] with y hy₁ hy₂ using by rw [ div_lt_one ( Real.exp_pos _ ) ] at hy₁; linarith;
      -- Let $x = y + 2$. Then we need to show that $B \cdot x \cdot \log x / \exp(x - 2) \to 0$ as $x \to \infty$.
      suffices h_lim : Filter.Tendsto (fun x : ℝ => B * x * Real.log x / Real.exp (x - 2)) Filter.atTop (nhds 0) by
        convert h_lim.comp ( show Filter.Tendsto ( fun y : ℝ => y + 2 ) Filter.atTop Filter.atTop from Filter.tendsto_id.atTop_add tendsto_const_nhds ) using 2 ; norm_num;
      -- We can rewrite the limit expression using properties of exponents: $\exp(x - 2) = \exp(x) / \exp(2)$.
      suffices h_lim : Filter.Tendsto (fun x : ℝ => B * x * Real.log x * Real.exp 2 / Real.exp x) Filter.atTop (nhds 0) by
        convert h_lim using 2 ; norm_num [ Real.exp_sub ] ; ring;
        norm_num ; ring;
      -- We can use the fact that $x \log x / e^x$ tends to $0$ as $x$ tends to infinity.
      have h_lim : Filter.Tendsto (fun x : ℝ => x * Real.log x / Real.exp x) Filter.atTop (nhds 0) := by
        -- We can use the fact that $x \log x / e^x$ tends to $0$ as $x$ tends to infinity by the properties of exponential functions and logarithms.
        have h_lim : Filter.Tendsto (fun x : ℝ => x^2 / Real.exp x) Filter.atTop (nhds 0) := by
          simpa [ Real.exp_neg ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 2;
        refine' squeeze_zero_norm' _ h_lim;
        filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx using by rw [ Real.norm_of_nonneg ( div_nonneg ( mul_nonneg ( by positivity ) ( Real.log_nonneg ( by linarith ) ) ) ( Real.exp_nonneg _ ) ) ] ; rw [ div_le_div_iff_of_pos_right ( Real.exp_pos _ ) ] ; nlinarith [ Real.log_le_sub_one_of_pos ( by positivity : 0 < x ) ] ;
      convert h_lim.const_mul ( B * Real.exp 2 ) using 2 <;> ring

/-
A function with |z| log |z| growth satisfies the Phragmen-Lindelof condition.
-/
lemma growth_bound_implies_condition {f : ℂ → ℂ} (A B : ℝ)
    (h : ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖f z‖ ≤ A * Real.exp (B * ‖z‖ * Real.log ‖z‖)) :
    ∃ c < Real.pi / (2 - 1), ∃ (C : ℝ), f =O[Filter.comap (abs ∘ Complex.im) Filter.atTop ⊓ Filter.principal (Complex.re ⁻¹' Set.Ioo 1 2)] fun (z : ℂ) => Real.exp (C * Real.exp (c * |z.im|)) := by
      refine' ⟨ 1, _, _ ⟩;
      · norm_num; linarith [ Real.pi_gt_three ];
      · -- Choose C such that B * (y + 2) * log(y + 2) ≤ C * exp(y) for all y ≥ Y.
        obtain ⟨Y, hY⟩ : ∃ Y : ℝ, ∀ y : ℝ, y ≥ Y → B * (y + 2) * Real.log (y + 2) ≤ Real.exp y := by
          have := log_growth_inequality B;
          aesop;
        -- Choose C such that for all z in the strip, ‖f z‖ ≤ A * exp(B * (|z.im| + 2) * log(|z.im| + 2)).
        have h_bound : ∃ C : ℝ, ∀ z : ℂ, 1 < z.re ∧ z.re < 2 → |z.im| ≥ Y → ‖f z‖ ≤ A * Real.exp (C * Real.exp |z.im|) := by
          use 1;
          intros z hz hz_im
          have h_bound : B * ‖z‖ * Real.log ‖z‖ ≤ Real.exp |z.im| := by
            have h_bound : B * (|z.im| + 2) * Real.log (|z.im| + 2) ≤ Real.exp |z.im| := by
              exact hY _ hz_im;
            have h_bound : ‖z‖ ≤ |z.im| + 2 := by
              exact Real.sqrt_le_iff.mpr ⟨ by positivity, by norm_num [ Complex.normSq_apply ] ; cases abs_cases z.im <;> nlinarith ⟩;
            by_cases hB : B ≤ 0;
            · exact le_trans ( mul_nonpos_of_nonpos_of_nonneg ( mul_nonpos_of_nonpos_of_nonneg hB ( norm_nonneg _ ) ) ( Real.log_nonneg ( by linarith [ show 1 ≤ ‖z‖ from by rw [ Complex.norm_def ] ; exact Real.le_sqrt_of_sq_le ( by norm_num [ Complex.normSq ] ; nlinarith ) ] ) ) ) ( by positivity );
            · have h_bound : B * ‖z‖ * Real.log ‖z‖ ≤ B * (|z.im| + 2) * Real.log (|z.im| + 2) := by
                gcongr;
                · exact Real.log_nonneg ( by rw [ Complex.norm_def ] ; exact Real.le_sqrt_of_sq_le ( by norm_num [ Complex.normSq ] ; nlinarith ) );
                · exact mul_nonneg ( le_of_not_ge hB ) ( by positivity );
                · linarith;
                · exact norm_pos_iff.mpr ( show z ≠ 0 from by rintro rfl; norm_num at hz );
              linarith;
          field_simp;
          exact le_trans ( h z ⟨ by linarith, by linarith ⟩ ) ( mul_le_mul_of_nonneg_left ( Real.exp_le_exp.mpr h_bound ) ( show 0 ≤ A by have := h 1 ⟨ by norm_num, by norm_num ⟩ ; norm_num at this ; nlinarith [ Real.exp_pos ( B * ‖( 1 : ℂ )‖ * Real.log ‖( 1 : ℂ )‖ ), norm_nonneg ( f 1 ) ] ) );
        obtain ⟨ C, hC ⟩ := h_bound;
        refine' ⟨ C, _ ⟩;
        rw [ Asymptotics.isBigO_iff ];
        refine' ⟨ A, _ ⟩ ; rw [ Filter.eventually_inf_principal ] ; aesop

/-
Growth condition for stirling_proxy in the vertical strip.
-/
lemma stirling_proxy_growth_proven :
    ∃ c < Real.pi / (2 - 1), ∃ (B : ℝ), stirling_proxy =O[Filter.comap (abs ∘ Complex.im) Filter.atTop ⊓ Filter.principal (Complex.re ⁻¹' Set.Ioo 1 2)] fun (z : ℂ) => Real.exp (B * Real.exp (c * |z.im|)) := by
  obtain ⟨A, B, h_bound⟩ := stirling_proxy_growth_bound_aux
  exact growth_bound_implies_condition A B h_bound

/-
The stirling_proxy function is bounded in the strip 1 <= Re(z) <= 2.
-/
lemma stirling_proxy_bounded_strip :
    ∃ C > 0, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖stirling_proxy z‖ ≤ C := by
      -- By the Phragmen-Lindelöf principle, since `stirling_proxy` is bounded on the lines Re(z) = 1 and Re(z) = 2, and its growth in the strip is controlled, it must be bounded in the entire strip.
      have h_bounded : ∃ C > 0, ∀ z : ℂ, z.re = 1 → ‖stirling_proxy z‖ ≤ C ∧ ∀ z : ℂ, z.re = 2 → ‖stirling_proxy z‖ ≤ C := by
        have h_bounded : ∃ C > 0, ∀ z : ℂ, z.re = 1 → ‖stirling_proxy z‖ ≤ C := by
          -- By the properties of the Gamma function and the Stirling approximation, we know that `stirling_proxy` is bounded on the line Re(z) = 1.
          have h_bounded_one : ∃ C > 0, ∀ t : ℝ, ‖stirling_proxy (1 + Complex.I * t)‖ ≤ C := by
            obtain ⟨ C, hC ⟩ := stirling_proxy_bound_one;
            -- Since $|t| \leq 1$ implies $t \in [-1, 1]$, we can bound the norm of the stirling_proxy on this interval.
            have h_bounded_interval : ∃ M > 0, ∀ t : ℝ, |t| ≤ 1 → ‖stirling_proxy (1 + Complex.I * t)‖ ≤ M := by
              have h_bounded_interval : ContinuousOn (fun t : ℝ => ‖stirling_proxy (1 + Complex.I * t)‖) (Set.Icc (-1 : ℝ) 1) := by
                refine' ContinuousOn.norm _;
                refine' ContinuousOn.mul _ _;
                · refine' continuousOn_of_forall_continuousAt fun t ht => _;
                  refine' ( Complex.differentiableAt_Gamma _ _ ).continuousAt.comp ( Continuous.continuousAt ( by continuity ) );
                  norm_num [ Complex.ext_iff ];
                  intros; linarith;
                · refine' ContinuousOn.cexp _;
                  refine' ContinuousOn.add _ _;
                  · refine' ContinuousOn.mul _ _;
                    · exact Continuous.continuousOn ( by continuity );
                    · refine' ContinuousOn.clog _ _;
                      · exact Continuous.continuousOn ( by continuity );
                      · norm_num [ Complex.slitPlane ];
                  · exact Continuous.continuousOn ( by continuity );
              obtain ⟨ M, hM ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_bounded_interval;
              exact ⟨ Max.max M 1, by norm_num, fun t ht => le_trans ( by simpa using hM t ⟨ by linarith [ abs_le.mp ht ], by linarith [ abs_le.mp ht ] ⟩ ) ( le_max_left _ _ ) ⟩;
            exact ⟨ Max.max C h_bounded_interval.choose, lt_max_of_lt_left hC.1, fun t => if ht : |t| ≤ 1 then le_trans ( h_bounded_interval.choose_spec.2 t ht ) ( le_max_right _ _ ) else le_trans ( hC.2 t ( not_le.mp ht ) ) ( le_max_left _ _ ) ⟩;
          obtain ⟨ C, hC₀, hC ⟩ := h_bounded_one; use C, hC₀; intros z hz; convert hC ( z.im ) ; simp +decide [ Complex.ext_iff, hz ] ;
        have h_bounded' : ∃ C > 0, ∀ z : ℂ, z.re = 2 → ‖stirling_proxy z‖ ≤ C := by
          obtain ⟨ C, hC₀, hC ⟩ := stirling_proxy_bound_two;
          -- Since $z.re = 2$, we can write $z = 2 + it$ for some $t \in \mathbb{R}$.
          obtain ⟨C', hC'₀, hC'⟩ : ∃ C' > 0, ∀ t : ℝ, |t| ≤ 1 → ‖stirling_proxy (2 + Complex.I * t)‖ ≤ C' := by
            -- The function $t \mapsto \text{stirling\_proxy}(2 + it)$ is continuous on the compact interval $[-1, 1]$.
            have h_cont : ContinuousOn (fun t : ℝ => stirling_proxy (2 + Complex.I * t)) (Set.Icc (-1 : ℝ) 1) := by
              refine' ContinuousOn.mul _ _;
              · refine' continuousOn_of_forall_continuousAt fun t ht => _;
                refine' ( Complex.differentiableAt_Gamma _ _ ).continuousAt.comp ( Continuous.continuousAt ( by continuity ) );
                norm_num [ Complex.ext_iff ];
                intros; linarith;
              · refine' ContinuousOn.cexp _;
                refine' ContinuousOn.add _ _;
                · refine' ContinuousOn.mul _ _;
                  · exact Continuous.continuousOn ( by continuity );
                  · refine' ContinuousOn.clog _ _;
                    · exact Continuous.continuousOn ( by continuity );
                    · norm_num [ Complex.slitPlane ];
                · exact Continuous.continuousOn ( by continuity );
            obtain ⟨ C', hC' ⟩ := IsCompact.exists_bound_of_continuousOn ( CompactIccSpace.isCompact_Icc ) h_cont;
            exact ⟨ Max.max C' 1, by positivity, fun t ht => le_trans ( hC' t ⟨ by linarith [ abs_le.mp ht ], by linarith [ abs_le.mp ht ] ⟩ ) ( le_max_left _ _ ) ⟩;
          refine' ⟨ Max.max C C', lt_max_of_lt_left hC₀, fun z hz => _ ⟩ ; rcases eq_or_ne z.re 2 with h|h <;> simp_all +decide [ Complex.ext_iff ];
          rw [ show z = 2 + Complex.I * ( z.im : ℂ ) by simpa [ Complex.ext_iff, h ] ] ; exact if h : |z.im| ≤ 1 then Or.inr ( hC' _ h ) else Or.inl ( hC _ ( not_le.mp h ) ) ;
        obtain ⟨C₁, hC₁⟩ := h_bounded
        obtain ⟨C₂, hC₂⟩ := h_bounded'
        use max C₁ C₂
        aesop;
      -- By the Phragmen-Lindelöf principle, since `stirling_proxy` is bounded on the lines Re(z) = 1 and Re(z) = 2, and its growth in the strip is controlled, it must be bounded in the entire strip. Hence, we can conclude that `stirling_proxy` is bounded in the strip 1 ≤ Re(z) ≤ 2.
      obtain ⟨C, hC_pos, hC_bound⟩ := h_bounded;
      have h_bounded_strip : ∃ C' > 0, ∀ z : ℂ, 1 ≤ z.re ∧ z.re ≤ 2 → ‖stirling_proxy z‖ ≤ C' := by
        have := @PhragmenLindelof.vertical_strip;
        refine' ⟨ C, hC_pos, fun z hz => this _ _ ( fun w hw => hC_bound w hw |>.1 ) ( fun w hw => hC_bound 1 rfl |>.2 w hw ) hz.1 hz.2 ⟩;
        · refine' DifferentiableOn.diffContOnCl _;
          refine' DifferentiableOn.mul _ _;
          · refine' fun z hz => DifferentiableAt.differentiableWithinAt _;
            refine' Complex.differentiableAt_Gamma _ _;
            intro m hm; rw [ mem_closure_iff_seq_limit ] at hz; obtain ⟨ u, hu ⟩ := hz; simp_all +decide [ Complex.ext_iff ] ;
            exact absurd ( hu.2.eventually ( Metric.ball_mem_nhds _ zero_lt_one ) ) fun h => by rcases h.exists with ⟨ n, hn ⟩ ; linarith [ abs_lt.mp ( show |( u n |> Complex.re ) - z.re| < 1 by simpa [ hm ] using lt_of_le_of_lt ( Complex.abs_re_le_norm _ ) hn ), hu.1 n ] ;
          · refine' DifferentiableOn.cexp _;
            refine' DifferentiableOn.add _ _;
            · refine' DifferentiableOn.mul _ _;
              · exact DifferentiableOn.neg ( differentiableOn_id.sub_const _ );
              · refine' DifferentiableOn.clog _ _;
                · fun_prop;
                · norm_num [ Complex.slitPlane, mem_closure_iff_seq_limit ];
                  exact fun x y hy hx => Or.inl <| by exact lt_of_lt_of_le zero_lt_one <| le_of_tendsto_of_tendsto' tendsto_const_nhds ( Complex.continuous_re.continuousAt.tendsto.comp hx ) fun n => hy n |>.1.le;
            · exact differentiableOn_id;
        · exact stirling_proxy_growth_proven;
      exact h_bounded_strip

end
