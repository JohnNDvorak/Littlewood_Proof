/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: fbc6e4ce-b58d-47ce-bc0a-4d4033dd7014

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Off-diagonal sum of squares bound for mean square estimates.

KEY RESULTS (PROVED):
- offDiagSsqReal: Real-valued off-diagonal sum Σ_{n≠m} (nm)^{-1/2} cos(t log(n/m))
- norm_integral_offDiagSsqReal_le: ‖∫₁ᵀ offDiagSsqReal(N,t) dt‖ ≤ 8N²

This is a KEY bound for showing the off-diagonal contribution is negligible
in the mean square estimate for ζ(s).
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
Definition of the off-diagonal sum of squares term (real-valued version).
-/
noncomputable def offDiagSsqReal (N : ℕ) (t : ℝ) : ℝ :=
  ∑ n ∈ Finset.Icc 1 N, ∑ m ∈ Finset.Icc 1 N,
    if n ≠ m then (1 / Real.sqrt (n * m : ℝ)) * Real.cos (t * Real.log (n / m : ℝ)) else 0

/-
The integral of the off-diagonal sum of squares is bounded by 8N^2.
-/
lemma norm_integral_offDiagSsqReal_le (N : ℕ) (T : ℝ) (hT : 1 ≤ T) :
    ‖∫ t in (1:ℝ)..T, offDiagSsqReal N t‖ ≤ 8 * N^2 := by
      -- For n ≠ m, the integral ∫₁ᵀ cos(t * log(n/m)) dt is bounded by 2N.
      have h_integral : ∀ n m : ℕ, 1 ≤ n → n ≤ N → 1 ≤ m → m ≤ N → n ≠ m → ‖∫ t in (1 : ℝ)..T, Real.cos (t * Real.log (n / m : ℝ))‖ ≤ 2 * N := by
        -- Using the fact that |log(n/m)| ≥ 1/max(n,m) and n,m ≤ N, we have |log(n/m)| ≥ 1/N.
        intros n m hn hnN hm hmN hnm
        have h_log_bound : |Real.log (n / m : ℝ)| ≥ 1 / (N : ℝ) := by
          -- Since $| \log(n/m) | \geq 1 / \max(n, m)$ and $n, m \leq N$, we have $| \log(n/m) | \geq 1 / N$.
          have h_log_bound : |Real.log (n / m : ℝ)| ≥ 1 / (max n m : ℝ) := by
            -- Without loss of generality, assume $n > m$.
            wlog hnm' : n > m generalizing n m;
            · convert this m n hm hmN hn hnN hnm.symm ( lt_of_le_of_ne ( le_of_not_gt hnm' ) hnm ) using 1 ; norm_num [ abs_div, abs_of_nonneg, Real.log_div, show n ≠ 0 by linarith, show m ≠ 0 by linarith ];
              · exact abs_sub_comm _ _;
              · rw [ max_comm ];
            · field_simp;
              rw [ abs_of_nonneg ( Real.log_nonneg <| by rw [ le_div_iff₀ <| by positivity ] ; norm_cast ; linarith ) ];
              -- Using the inequality $\log(x) \geq \frac{x - 1}{x}$ for $x > 1$, we get $\log(n/m) \geq \frac{n/m - 1}{n/m} = \frac{n - m}{n}$.
              have h_log_ineq : Real.log (n / m : ℝ) ≥ (n - m) / n := by
                have h_log_ineq : ∀ x : ℝ, 1 < x → Real.log x ≥ (x - 1) / x := by
                  exact fun x hx => by rw [ ge_iff_le ] ; rw [ div_le_iff₀ ( by positivity ) ] ; nlinarith [ Real.log_inv x ▸ Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by positivity ) ), mul_inv_cancel₀ ( by positivity : x ≠ 0 ) ] ; ;
                convert h_log_ineq ( n / m ) ( by rw [ lt_div_iff₀ ] <;> norm_cast ; linarith ) using 1 ; ring;
                simp +decide [ ne_of_gt ( zero_lt_one.trans_le hn ), ne_of_gt ( zero_lt_one.trans_le hm ) ] ; ring;
              rw [ ge_iff_le, div_le_iff₀ ] at h_log_ineq <;> norm_num <;> nlinarith [ show ( n : ℝ ) ≥ m + 1 by norm_cast, show ( m : ℝ ) ≥ 1 by norm_cast, le_max_left ( n : ℝ ) m, le_max_right ( n : ℝ ) m ];
          exact le_trans ( one_div_le_one_div_of_le ( by positivity ) ( mod_cast max_le hnN hmN ) ) h_log_bound;
        -- Using the fact that |∫ cos(αt) dt| ≤ 2/|α|, we get |∫ cos(t * log(n/m)) dt| ≤ 2/|log(n/m)|.
        have h_integral_bound : ‖∫ t in (1 : ℝ)..T, Real.cos (t * Real.log (n / m : ℝ))‖ ≤ 2 / |Real.log (n / m : ℝ)| := by
          have h_integral_cos : ∀ α : ℝ, α ≠ 0 → ‖∫ t in (1 : ℝ)..T, Real.cos (α * t)‖ ≤ 2 / |α| := by
            intro α hα; rw [ intervalIntegral.integral_comp_mul_left ] <;> norm_num [ hα ];
            rw [ inv_mul_eq_div, div_le_div_iff_of_pos_right ( abs_pos.mpr hα ) ] ; exact abs_le.mpr ⟨ by linarith [ abs_le.mp ( Real.abs_sin_le_one ( α * T ) ), abs_le.mp ( Real.abs_sin_le_one α ) ], by linarith [ abs_le.mp ( Real.abs_sin_le_one ( α * T ) ), abs_le.mp ( Real.abs_sin_le_one α ) ] ⟩;
          simpa only [ mul_comm ] using h_integral_cos ( Real.log ( n / m ) ) ( by contrapose! hnm; rw [ ← Real.exp_log ( by positivity : 0 < ( n : ℝ ) ), ← Real.exp_log ( by positivity : 0 < ( m : ℝ ) ), ← Real.exp_eq_exp ] at *; rw [ Real.log_div ( by positivity ) ( by positivity ) ] at *; aesop );
        exact h_integral_bound.trans ( by rw [ div_le_iff₀ ] <;> nlinarith [ show ( N : ℝ ) ≥ 1 by norm_cast; linarith, one_div_mul_cancel ( by norm_cast; linarith : ( N : ℝ ) ≠ 0 ) ] );
      -- We'll use the fact that the integral of the off-diagonal sum is the sum of the integrals.
      have h_sum_integral : ‖∫ t in (1 : ℝ)..T, offDiagSsqReal N t‖ ≤ ∑ n ∈ Finset.Icc 1 N, ∑ m ∈ Finset.Icc 1 N, if n ≠ m then (1 / Real.sqrt (n * m : ℝ)) * ‖∫ t in (1 : ℝ)..T, Real.cos (t * Real.log (n / m : ℝ))‖ else 0 := by
        -- Applying the triangle inequality to the integral of the off-diagonal sum.
        have h_triangle : ‖∫ t in (1 : ℝ)..T, ∑ n ∈ Finset.Icc 1 N, ∑ m ∈ Finset.Icc 1 N, if n ≠ m then (1 / Real.sqrt (n * m : ℝ)) * Real.cos (t * Real.log (n / m : ℝ)) else 0‖ ≤ ∑ n ∈ Finset.Icc 1 N, ∑ m ∈ Finset.Icc 1 N, ‖∫ t in (1 : ℝ)..T, if n ≠ m then (1 / Real.sqrt (n * m : ℝ)) * Real.cos (t * Real.log (n / m : ℝ)) else 0‖ := by
          rw [ intervalIntegral.integral_finset_sum ];
          · refine' le_trans ( norm_sum_le _ _ ) ( Finset.sum_le_sum fun i hi => _ );
            rw [ intervalIntegral.integral_finset_sum ];
            · exact norm_sum_le _ _;
            · exact fun j hj => Continuous.intervalIntegrable ( by split_ifs <;> continuity ) _ _;
          · exact fun _ _ => Continuous.intervalIntegrable ( by exact continuous_finset_sum _ fun _ _ => by split_ifs <;> continuity ) _ _;
        convert h_triangle using 3;
        split_ifs <;> simp +decide [ *, intervalIntegral.integral_comp_mul_right ];
        exact Or.inl ( by rw [ abs_of_nonneg ( Real.sqrt_nonneg _ ), abs_of_nonneg ( Real.sqrt_nonneg _ ) ] );
      -- Applying the bound from h_integral to each term in the sum.
      have h_sum_bound : ∑ n ∈ Finset.Icc 1 N, ∑ m ∈ Finset.Icc 1 N, (if n ≠ m then (1 / Real.sqrt (n * m : ℝ)) * ‖∫ t in (1 : ℝ)..T, Real.cos (t * Real.log (n / m : ℝ))‖ else 0) ≤ ∑ n ∈ Finset.Icc 1 N, ∑ m ∈ Finset.Icc 1 N, (if n ≠ m then (1 / Real.sqrt (n * m : ℝ)) * (2 * N) else 0) := by
        norm_num +zetaDelta at *;
        exact Finset.sum_le_sum fun i hi => Finset.sum_le_sum fun j hj => by split_ifs <;> [ norm_num; exact mul_le_mul_of_nonneg_left ( h_integral i j ( Finset.mem_Icc.mp hi |>.1 ) ( Finset.mem_Icc.mp hi |>.2 ) ( Finset.mem_Icc.mp hj |>.1 ) ( Finset.mem_Icc.mp hj |>.2 ) ( by aesop ) ) ( by positivity ) ] ;
      -- We'll use the fact that $\sum_{n=1}^N \sum_{m=1}^N \frac{1}{\sqrt{nm}} \leq 4N$.
      have h_sum_sqrt : ∑ n ∈ Finset.Icc 1 N, ∑ m ∈ Finset.Icc 1 N, (if n ≠ m then (1 / Real.sqrt (n * m : ℝ)) else 0) ≤ 4 * N := by
        -- We'll use the fact that $\sum_{n=1}^N \frac{1}{\sqrt{n}} \leq 2\sqrt{N}$.
        have h_sum_sqrt_n : ∑ n ∈ Finset.Icc 1 N, (1 / Real.sqrt (n : ℝ)) ≤ 2 * Real.sqrt (N : ℝ) := by
          clear h_integral h_sum_integral h_sum_bound;
          induction' N with N ih <;> norm_num [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] at *;
          nlinarith [ sq_nonneg ( Real.sqrt ( N:ℝ ) - Real.sqrt ( N+1 ) ), Real.mul_self_sqrt ( show ( N:ℝ ) ≥ 0 by positivity ), Real.mul_self_sqrt ( show ( N+1:ℝ ) ≥ 0 by positivity ), inv_pos.2 ( Real.sqrt_pos.2 ( show ( N+1:ℝ ) > 0 by positivity ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.2 ( show ( N+1:ℝ ) > 0 by positivity ) ) ) ];
        -- Applying the bound from h_sum_sqrt_n to each term in the sum.
        have h_sum_sqrt_m : ∑ n ∈ Finset.Icc 1 N, ∑ m ∈ Finset.Icc 1 N, (if n ≠ m then (1 / Real.sqrt (n * m : ℝ)) else 0) ≤ (∑ n ∈ Finset.Icc 1 N, (1 / Real.sqrt (n : ℝ))) * (∑ m ∈ Finset.Icc 1 N, (1 / Real.sqrt (m : ℝ))) := by
          norm_num [ Finset.sum_mul _ _ _ ];
          exact Finset.sum_le_sum fun i hi => by rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_le_sum fun j hj => by split_ifs <;> nlinarith [ inv_nonneg.2 ( Real.sqrt_nonneg ( i : ℝ ) ), inv_nonneg.2 ( Real.sqrt_nonneg ( j : ℝ ) ) ] ;
        exact h_sum_sqrt_m.trans ( by nlinarith [ Real.mul_self_sqrt ( Nat.cast_nonneg N ), show ( 0 : ℝ ) ≤ ∑ n ∈ Finset.Icc 1 N, 1 / Real.sqrt ( n : ℝ ) from Finset.sum_nonneg fun _ _ => by positivity ] );
      refine le_trans h_sum_integral <| le_trans h_sum_bound ?_;
      convert mul_le_mul_of_nonneg_right h_sum_sqrt ( show ( 0 : ℝ ) ≤ 2 * N by positivity ) using 1 <;> norm_num [ Finset.sum_ite ] ; ring;
      · simp +decide only [mul_comm, mul_left_comm, Finset.mul_sum _ _ _];
      · ring

end
