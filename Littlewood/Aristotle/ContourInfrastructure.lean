/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2c31a5ff-86d0-4495-9b18-abf079501264

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Contour infrastructure: rectangular contour definition, rectangular integral definition,
and measure-zero argument for integrals over line segments.

Note: 3 `exact?` calls from budget-exceeded output replaced with `sorry`.
These are all measure-preimage lemmas in `zeta_arg_bound_uniform`.

WARNING: `zero_counting_argument_principle_vacuous` and `stirling_arg_gamma_vacuous`
are VACUOUS — they prove ∃ C by choosing C := |LHS|/log T, so C depends on T.
They are included for completeness but should not be relied upon.
The `zeta_arg_bound_uniform` proof and `RectIntegral` definition are the main value.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ContourInfrastructure

open Complex Real Set Filter Topology

/-
Define the completed zeta function Xi(s) = s(s-1)/2 · Λ(s).
Note: ZeroCountingXi.xi uses a different (better) definition via completedRiemannZeta₀.
-/
noncomputable def Xi_completed (s : ℂ) : ℂ := s * (s - 1) / 2 * completedRiemannZeta s

/-
Define the set of zeros and its count.
-/
def N_set (T : ℝ) : Set ℂ := {ρ : ℂ | riemannZeta ρ = 0 ∧ 0 < ρ.re ∧ ρ.re < 1 ∧ 0 < ρ.im ∧ ρ.im ≤ T}

noncomputable def N_count (T : ℝ) : ℕ := Set.ncard (N_set T)

/-
Define the rectangular contour Gamma as a union of four segments.
-/
def Gamma_rect (T : ℝ) : Set ℂ :=
  segment ℝ (-1/2 : ℂ) (3/2 : ℂ) ∪
  segment ℝ (3/2 : ℂ) (3/2 + I * (T : ℂ)) ∪
  segment ℝ (3/2 + I * (T : ℂ)) (-1/2 + I * (T : ℂ)) ∪
  segment ℝ (-1/2 + I * (T : ℂ)) (-1/2 : ℂ)

/-
VACUOUS: The argument principle formula for counting zeta zeros.
C is chosen as |LHS|/log T, making it T-dependent. Included for completeness only.
-/
theorem zero_counting_argument_principle_vacuous (T : ℝ) (hT : T ≥ 2) :
    let N := Set.ncard {ρ : ℂ | riemannZeta ρ = 0 ∧ 0 < ρ.re ∧ ρ.re < 1 ∧ 0 < ρ.im ∧ ρ.im ≤ T}
    ∃ C : ℝ, |N - (T / (2 * π)) * Real.log (T / (2 * π * Real.exp 1))| ≤ C * Real.log T := by
      use ( |(↑{ρ : ℂ | riemannZeta ρ = 0 ∧ 0 < ρ.re ∧ ρ.re < 1 ∧ 0 < ρ.im ∧ ρ.im ≤ T}.ncard : ℝ) - T / (2 * Real.pi) * Real.log (T / (2 * Real.pi * Real.exp 1))| ) / Real.log T ; rw [ div_mul_cancel₀ _ ( ne_of_gt <| Real.log_pos <| by linarith ) ] ;

/-
VACUOUS: Stirling's formula for the argument of Gamma.
C₁ is chosen as |LHS|/log T.
-/
lemma stirling_arg_gamma_vacuous (T : ℝ) (hT : T ≥ 2) :
    ∃ C₁ : ℝ, |im (∫ s in Gamma_rect T, (deriv (fun z => z.Gammaℝ) s) / (s.Gammaℝ)) - T * Real.log (T / (2 * Real.pi * Real.exp 1))| ≤ C₁ * Real.log T := by
      refine ⟨ ( |( ∫ s in Gamma_rect T, deriv ( fun z => Complex.Gammaℝ z ) s / Complex.Gammaℝ s |> Complex.im ) - T * Real.log ( T / ( 2 * Real.pi * Real.exp 1 ) ) - 0| / Real.log T ), ?_ ⟩ ; rw [ div_mul_eq_mul_div, le_div_iff₀ ] <;> norm_num [ Real.log_pos ( by linarith : 1 < T ) ] ;

/-
Bound the argument of zeta on the boundary.

This proof shows the Lebesgue integral over line segments (measure-zero sets) vanishes.
Contains 3 sorries from `exact?` calls — all are measure-preimage lemmas
showing that preimages of lines under the ℂ ≃ ℝ×ℝ equivalence have the expected measure.
-/
lemma zeta_arg_bound_uniform :
    ∃ C₂ : ℝ, ∀ T ≥ 2, |im (∫ s in Gamma_rect T, (deriv riemannZeta s) / (riemannZeta s))| ≤ C₂ * Real.log T := by
      use 0;
      intro T hT; erw [ show Gamma_rect T = ( segment ℝ ( -1 / 2 : ℂ ) ( 3 / 2 : ℂ ) ) ∪ ( segment ℝ ( 3 / 2 : ℂ ) ( 3 / 2 + I * T ) ) ∪ ( segment ℝ ( 3 / 2 + I * T ) ( -1 / 2 + I * T ) ) ∪ ( segment ℝ ( -1 / 2 + I * T ) ( -1 / 2 : ℂ ) ) by rfl ] ; erw [ MeasureTheory.Measure.restrict_eq_zero.mpr ] <;> norm_num;
      refine' ⟨ ⟨ ⟨ _, _ ⟩, _ ⟩, _ ⟩;
      · norm_num [ segment_eq_image ];
        refine' MeasureTheory.measure_mono_null _ _;
        exact { z : ℂ | z.im = 0 };
        · norm_num [ Set.image_subset_iff ];
        · -- The set of complex numbers with zero imaginary part is a line, which has measure zero.
          have h_line : MeasureTheory.volume {z : ℝ × ℝ | z.2 = 0} = 0 := by
            erw [ show { z : ℝ × ℝ | z.2 = 0 } = ( Set.univ : Set ℝ ) ×ˢ { 0 } by ext ; aesop, MeasureTheory.Measure.prod_prod ] ; norm_num;
          convert h_line using 1;
          erw [ ← Complex.volume_preserving_equiv_real_prod.measure_preimage ];
          · sorry  -- was: exact?  (measure preimage of {z : ℂ | z.im = 0} under ℂ ≃ ℝ×ℝ)
          · exact measurableSet_eq_fun measurable_snd measurable_const |> MeasurableSet.nullMeasurableSet;
      · rw [ segment_eq_image ];
        refine' MeasureTheory.measure_mono_null _ _;
        exact { z : ℂ | z.re = 3 / 2 };
        · norm_num [ Set.subset_def, Complex.ext_iff ];
          grind;
        · -- The set { z ∈ ℂ | z.re = 3/2 } is a line, which has measure zero.
          have h_line : MeasureTheory.volume {z : ℝ × ℝ | z.1 = 3 / 2} = 0 := by
            erw [ show { z : ℝ × ℝ | z.1 = 3 / 2 } = ( { 3 / 2 } ×ˢ Set.univ ) by ext ; aesop, MeasureTheory.Measure.prod_prod ] ; norm_num;
          convert h_line using 1;
          erw [ ← Complex.volume_preserving_equiv_real_prod.measure_preimage ];
          · sorry  -- was: exact?  (measure preimage of {z : ℂ | z.re = 3/2} under ℂ ≃ ℝ×ℝ)
          · exact measurableSet_eq_fun measurable_fst measurable_const |> MeasurableSet.nullMeasurableSet;
      · rw [ segment_eq_image ];
        refine' MeasureTheory.measure_mono_null _ _;
        exact { z : ℂ | z.im = T };
        · norm_num [ Complex.ext_iff, Set.image_subset_iff ];
          exact fun x hx => by norm_num; linarith [ hx.1, hx.2 ] ;
        · -- The set { z ∈ ℂ | z.im = T } is a line, which has measure zero.
          have h_line : MeasureTheory.volume {z : ℝ × ℝ | z.2 = T} = 0 := by
            erw [ show { z : ℝ × ℝ | z.2 = T } = ( Set.univ : Set ℝ ) ×ˢ { T } by ext ; aesop, MeasureTheory.Measure.prod_prod ] ; norm_num;
          convert h_line using 1;
          erw [ ← Complex.volume_preserving_equiv_real_prod.measure_preimage ];
          · sorry  -- was: exact?  (measure preimage of {z : ℂ | z.im = T} under ℂ ≃ ℝ×ℝ)
          · exact measurableSet_eq_fun measurable_snd measurable_const |> MeasurableSet.nullMeasurableSet;
      · rw [ segment_eq_image ];
        refine' MeasureTheory.measure_mono_null _ _;
        exact { z : ℂ | z.re = -1 / 2 };
        · norm_num [ Set.image_subset_iff, Complex.ext_iff ];
          exact fun x hx => by norm_num; linarith [ hx.1, hx.2 ] ;
        · -- The set { z ∈ ℂ | z.re = -1/2 } is a vertical line, which has zero area.
          have h_line : MeasureTheory.volume {z : ℝ × ℝ | z.1 = -1 / 2} = 0 := by
            erw [ show { z : ℝ × ℝ | z.1 = -1 / 2 } = ( { -1 / 2 } ×ˢ Set.univ ) by ext ; aesop, MeasureTheory.Measure.prod_prod ] ; norm_num;
          convert h_line using 1;
          erw [ ← Complex.volume_preserving_equiv_real_prod.measure_preimage ] ; norm_num;
          exact measurableSet_eq_fun measurable_fst measurable_const |> MeasurableSet.nullMeasurableSet

/-
Define the contour integral over a rectangle.
This parameterizes the boundary integral as four line integrals.
-/
noncomputable def RectIntegral (f : ℂ → ℂ) (z w : ℂ) : ℂ :=
  (∫ x : ℝ in z.re..w.re, f (x + z.im * I)) +
  (∫ y : ℝ in z.im..w.im, f (w.re + y * I)) * I -
  (∫ x : ℝ in z.re..w.re, f (x + w.im * I)) -
  (∫ y : ℝ in z.im..w.im, f (z.re + y * I)) * I

end ContourInfrastructure
