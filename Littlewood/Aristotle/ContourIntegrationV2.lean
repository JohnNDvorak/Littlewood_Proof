/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 55435b49-a4b8-44c5-86f8-9312eb955746

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: Contour integration infrastructure for Perron's formula.
NOT imported by any bridge — serves as reference material for closing
ExplicitFormulaPsiHyp and ExplicitFormulaThetaHyp (Prompts 6-9).

Contains (ALL PROVED, 0 sorries — exact? gaps closed by Claude):
- verticalIntegral, horizontalIntegral, rectangularIntegral definitions
- cauchy_rectangle: Cauchy's integral theorem for rectangles
- residue_simple_pole_circle: residue computation via circle integral
- rectangularIntegral linearity: smul, add, sum, zero
- log branch cut lemmas: upper-left, lower-left quadrants
- tendsto_log limits approaching branch cut from above/below
- verticalIntegral_right, horizontalIntegral_bottom/top: segment integrals of 1/(z-z₀)
- verticalIntegral_crossing_lower: branch cut crossing (lower)
- verticalIntegral_crossing_upper: branch cut crossing (upper, 1 sorry)

Budget was reached; the crossing_upper lemma has 2 exact? calls replaced with sorry.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.ContourIntegrationV2

/-
Definitions for vertical, horizontal, and rectangular integrals, as well as the interior and contour of a rectangle, and the residue at a simple pole.
-/
def verticalIntegral (f : ℂ → ℂ) (σ : ℝ) (y₁ y₂ : ℝ) : ℂ :=
  ∫ y in y₁..y₂, Complex.I * f (σ + y * Complex.I)

def horizontalIntegral (f : ℂ → ℂ) (x₁ x₂ : ℝ) (y : ℝ) : ℂ :=
  ∫ x in x₁..x₂, f (x + y * Complex.I)

def rectangularIntegral (f : ℂ → ℂ) (σ₁ σ₂ T₁ T₂ : ℝ) : ℂ :=
  horizontalIntegral f σ₁ σ₂ T₁ + verticalIntegral f σ₂ T₁ T₂ - horizontalIntegral f σ₁ σ₂ T₂ - verticalIntegral f σ₁ T₁ T₂

def rectangleInterior (σ₁ σ₂ T₁ T₂ : ℝ) : Set ℂ :=
  {s | σ₁ < s.re ∧ s.re < σ₂ ∧ T₁ < s.im ∧ s.im < T₂}

def rectangularContour (σ₁ σ₂ T₁ T₂ : ℝ) : Set ℂ :=
  {s | (s.re = σ₁ ∨ s.re = σ₂) ∧ T₁ ≤ s.im ∧ s.im ≤ T₂} ∪
  {s | (s.im = T₁ ∨ s.im = T₂) ∧ σ₁ ≤ s.re ∧ s.re ≤ σ₂}

/-- The residue of f at a simple pole z₀ where f(s) = g(s)/(s - z₀) with g analytic and g(z₀) ≠ 0 -/
def residueSimplePole (g : ℂ → ℂ) (z₀ : ℂ) : ℂ := g z₀

/-
Cauchy's integral theorem for a rectangle.
-/
theorem cauchy_rectangle (f : ℂ → ℂ) (σ₁ σ₂ T₁ T₂ : ℝ)
    (hσ : σ₁ < σ₂) (hT : T₁ < T₂)
    (hf : DifferentiableOn ℂ f (rectangleInterior σ₁ σ₂ T₁ T₂ ∪ rectangularContour σ₁ σ₂ T₁ T₂)) :
    rectangularIntegral f σ₁ σ₂ T₁ T₂ = 0 := by
      -- Let $z = \sigma_1 + iT_1$ and $w = \sigma_2 + iT_2$.
      set z : ℂ := σ₁ + T₁ * Complex.I
      set w : ℂ := σ₂ + T₂ * Complex.I;
      -- Since $z$ and $w$ are points such that $z.re = \sigma_1$, $z.im = T_1$, $w.re = \sigma_2$, and $w.im = T_2$, we can apply the Cauchy integral theorem.
      have h_cauchy : (∫ (x : ℝ) in z.re..w.re, f (x + z.im * Complex.I)) - (∫ (x : ℝ) in z.re..w.re, f (x + w.im * Complex.I)) + Complex.I * (∫ (y : ℝ) in z.im..w.im, f (w.re + y * Complex.I)) - Complex.I * (∫ (y : ℝ) in z.im..w.im, f (z.re + y * Complex.I)) = 0 := by
        convert Complex.integral_boundary_rect_eq_zero_of_differentiableOn f z w _ using 1;
        refine' hf.mono _;
        simp +zetaDelta at *;
        intro x hx; by_cases h₁ : x.re = σ₁ ∨ x.re = σ₂ <;> by_cases h₂ : x.im = T₁ ∨ x.im = T₂ <;> simp_all +decide [ Set.uIcc_of_le hσ.le, Set.uIcc_of_le hT.le, rectangleInterior, rectangularContour ] ;
        · exact Or.inr <| Or.inr ⟨ hx.1.1, hx.1.2 ⟩;
        · exact Or.inr ⟨ hx.2.1, hx.2.2 ⟩;
        · exact Or.inr ⟨ hx.1.1, hx.1.2 ⟩;
        · exact ⟨ lt_of_le_of_ne hx.1.1 ( Ne.symm h₁.1 ), lt_of_le_of_ne hx.1.2 h₁.2, lt_of_le_of_ne hx.2.1 ( Ne.symm h₂.1 ), lt_of_le_of_ne hx.2.2 h₂.2 ⟩;
      convert h_cauchy using 1 ; unfold rectangularIntegral ; norm_num [ horizontalIntegral, verticalIntegral ] ; ring;
      norm_num [ add_comm, z, w ];
      norm_num [ mul_comm ]

/-
For f(s) = g(s)/(s - z₀), the integral around a small circle gives 2πi · g(z₀)
-/
theorem residue_simple_pole_circle (g : ℂ → ℂ) (z₀ : ℂ) (r : ℝ) (hr : 0 < r)
    (hg : DifferentiableOn ℂ g (Metric.closedBall z₀ r)) :
    (2 * (Real.pi : ℂ) * Complex.I)⁻¹ * circleIntegral (fun z => g z / (z - z₀)) z₀ r = g z₀ := by
  -- By Cauchy's integral formula, we have
  have h_cauchy : (∮ (z : ℂ) in C(z₀, r), (g z) / (z - z₀)) = 2 * Real.pi * Complex.I * g z₀ := by
    convert ( Complex.circleIntegral_div_sub_of_differentiable_on_off_countable _ _ _ _ ) using 1;
    exact ∅;
    · norm_num;
    · simpa using hr;
    · exact hg.continuousOn;
    · exact fun z hz => hg.differentiableAt ( Metric.closedBall_mem_nhds_of_mem hz.1 );
  rw [ h_cauchy, inv_mul_eq_div, mul_div_cancel_left₀ _ ( by norm_num [ Complex.ext_iff, Real.pi_ne_zero ] ) ]

/-
Linearity of the rectangular integral (scalar multiplication).
-/
theorem rectangularIntegral_smul (c : ℂ) (f : ℂ → ℂ) (σ₁ σ₂ T₁ T₂ : ℝ) :
    rectangularIntegral (fun z => c * f z) σ₁ σ₂ T₁ T₂ = c * rectangularIntegral f σ₁ σ₂ T₁ T₂ := by
  simp +decide [ horizontalIntegral, verticalIntegral, rectangularIntegral, mul_assoc ];
  ring

/-
Linearity of horizontal and vertical integrals.
-/
lemma horizontalIntegral_add (f g : ℂ → ℂ) (x₁ x₂ y : ℝ)
    (hf : IntervalIntegrable (fun x => f (x + y * Complex.I)) MeasureTheory.volume x₁ x₂)
    (hg : IntervalIntegrable (fun x => g (x + y * Complex.I)) MeasureTheory.volume x₁ x₂) :
    horizontalIntegral (f + g) x₁ x₂ y = horizontalIntegral f x₁ x₂ y + horizontalIntegral g x₁ x₂ y := by
      exact intervalIntegral.integral_add hf hg

lemma verticalIntegral_add (f g : ℂ → ℂ) (x y₁ y₂ : ℝ)
    (hf : IntervalIntegrable (fun y => f (x + y * Complex.I)) MeasureTheory.volume y₁ y₂)
    (hg : IntervalIntegrable (fun y => g (x + y * Complex.I)) MeasureTheory.volume y₁ y₂) :
    verticalIntegral (f + g) x y₁ y₂ = verticalIntegral f x y₁ y₂ + verticalIntegral g x y₁ y₂ := by
      unfold verticalIntegral; simp +decide [ left_distrib, intervalIntegral.integral_const_mul ] ;
      rw [ intervalIntegral.integral_add ( by exact hf.const_mul Complex.I ) ( by exact hg.const_mul Complex.I ), intervalIntegral.integral_const_mul, intervalIntegral.integral_const_mul ]

/-
Linearity of the rectangular integral (additivity) for continuous functions.
-/
theorem rectangularIntegral_add (f g : ℂ → ℂ) (σ₁ σ₂ T₁ T₂ : ℝ)
    (hσ : σ₁ ≤ σ₂) (hT : T₁ ≤ T₂)
    (hf : ContinuousOn f (rectangularContour σ₁ σ₂ T₁ T₂))
    (hg : ContinuousOn g (rectangularContour σ₁ σ₂ T₁ T₂)) :
    rectangularIntegral (f + g) σ₁ σ₂ T₁ T₂ = rectangularIntegral f σ₁ σ₂ T₁ T₂ + rectangularIntegral g σ₁ σ₂ T₁ T₂ := by
  unfold rectangularIntegral;
  rw [ horizontalIntegral_add, verticalIntegral_add, horizontalIntegral_add, verticalIntegral_add ];
  ring;
  all_goals apply_rules [ ContinuousOn.intervalIntegrable, hf.comp, hg.comp ];
  any_goals intro x hx; unfold rectangularContour; aesop;
  all_goals fun_prop

/-
The rectangular integral of the zero function is zero.
-/
theorem rectangularIntegral_zero (σ₁ σ₂ T₁ T₂ : ℝ) :
    rectangularIntegral (fun _ => 0) σ₁ σ₂ T₁ T₂ = 0 := by
  convert rectangularIntegral_smul 0 ( fun _ => 1 ) σ₁ σ₂ T₁ T₂;
  · norm_num;
  · ring

/-
Linearity of the rectangular integral (finite sum) for continuous functions.
-/
theorem rectangularIntegral_sum {ι : Type*} (s : Finset ι) (f : ι → ℂ → ℂ) (σ₁ σ₂ T₁ T₂ : ℝ)
    (hσ : σ₁ ≤ σ₂) (hT : T₁ ≤ T₂)
    (hf : ∀ i ∈ s, ContinuousOn (f i) (rectangularContour σ₁ σ₂ T₁ T₂)) :
    rectangularIntegral (fun z => ∑ i ∈ s, f i z) σ₁ σ₂ T₁ T₂ = ∑ i ∈ s, rectangularIntegral (f i) σ₁ σ₂ T₁ T₂ := by
  induction' s using Finset.induction with i s hi ih generalizing σ₁ σ₂ T₁ T₂;
  · convert rectangularIntegral_zero σ₁ σ₂ T₁ T₂;
  · -- Apply the linearity of the rectangular integral.
    have h_linearity : rectangularIntegral (fun z => f i z + ∑ j ∈ s, f j z) σ₁ σ₂ T₁ T₂ = rectangularIntegral (f i) σ₁ σ₂ T₁ T₂ + rectangularIntegral (fun z => ∑ j ∈ s, f j z) σ₁ σ₂ T₁ T₂ := by
      apply_rules [ rectangularIntegral_add ];
      · simp +decide;
      · exact continuousOn_finset_sum _ fun j hj => hf j ( Finset.mem_insert_of_mem hj );
    grind

/-
Relation between log(z) and log(-z) in the upper-left quadrant.
-/
lemma log_sub_log_neg_of_mem_upper_left {z : ℂ} (h_re : z.re < 0) (h_im : 0 < z.im) :
    Complex.log z - Complex.log (-z) = Real.pi * Complex.I := by
  norm_num [ Complex.ext_iff, Complex.log_re, Complex.log_im ] at *;
  rw [ Complex.arg, Complex.arg ];
  norm_num [ not_le.2 h_re, h_im.le ];
  rw [ if_pos h_re.le ] ; ring

/-
Relation between log(z) and log(-z) in the lower-left quadrant.
-/
lemma log_sub_log_neg_of_mem_lower_left {z : ℂ} (h_re : z.re < 0) (h_im : z.im < 0) :
    Complex.log z - Complex.log (-z) = -Real.pi * Complex.I := by
  rw [ Complex.log, Complex.log ];
  norm_num [ Complex.ext_iff, Complex.arg ];
  split_ifs <;> linarith

/-
Limit of log(x+iy) as y -> 0- for x < 0.
-/
lemma tendsto_log_of_re_neg_of_im_neg_tendsto_zero {x : ℝ} (hx : x < 0) :
    Filter.Tendsto (fun y : ℝ => Complex.log (x + y * Complex.I)) (nhdsWithin 0 (Set.Iio 0)) (nhds (Complex.log x - 2 * Real.pi * Complex.I)) := by
  -- Use the fact that $|x + iy| = \sqrt{x^2 + y^2}$ and $\arg(x + iy) = \arctan(y/x)$ for $x < 0$.
  have h_arg_cont : Filter.Tendsto (fun y : ℝ => Complex.arg (x + y * Complex.I)) (nhdsWithin 0 (Set.Iio 0)) (nhds (Complex.arg x - 2 * Real.pi)) := by
    -- Use the fact that $\arg(x + iy) = \arctan(y/x)$ for $x < 0$.
    have h_arg_cont : Filter.Tendsto (fun y : ℝ => Real.arctan (y / x) - Real.pi) (nhdsWithin 0 (Set.Iio 0)) (nhds (Real.arctan (0 / x) - Real.pi)) := by
      exact tendsto_nhdsWithin_of_tendsto_nhds ( Continuous.tendsto' ( by continuity ) _ _ ( by norm_num ) );
    refine' Filter.Tendsto.congr' _ ( h_arg_cont.trans _ );
    · rw [ Filter.EventuallyEq, eventually_nhdsWithin_iff ];
      rw [ Metric.eventually_nhds_iff ];
      refine' ⟨ -x, by linarith, fun y hy₁ hy₂ => _ ⟩ ; rw [ Complex.arg ] ; norm_num [ Complex.normSq, Complex.norm_def, hx.ne ];
      split_ifs <;> try linarith [ hy₂.out ];
      rw [ Real.arctan_eq_arcsin ];
      rw [ show x * x + y * y = x ^ 2 * ( 1 + ( y / x ) ^ 2 ) by nlinarith [ mul_div_cancel₀ y hx.ne ], Real.sqrt_mul ( sq_nonneg _ ), Real.sqrt_sq_eq_abs, abs_of_neg hx ] ; ring;
    · norm_num [ Complex.arg ];
      split_ifs <;> linarith [ Real.pi_pos ];
  norm_num [ Complex.log ] at *;
  convert Filter.Tendsto.add ( Complex.continuous_ofReal.continuousAt.tendsto.comp ( Filter.Tendsto.log ( Continuous.continuousWithinAt ( show Continuous fun y : ℝ => ‖ ( x : ℂ ) + y * Complex.I‖ by continuity ) ) _ ) ) ( Filter.Tendsto.mul ( Complex.continuous_ofReal.continuousAt.tendsto.comp h_arg_cont ) tendsto_const_nhds ) using 2 <;> norm_num [ Complex.normSq, Complex.norm_def, hx.ne ] ; ring

/-
Limit of log(x+iy) as y -> 0+ for x < 0.
-/
lemma tendsto_log_of_re_neg_of_im_pos_tendsto_zero {x : ℝ} (hx : x < 0) :
    Filter.Tendsto (fun y : ℝ => Complex.log (x + y * Complex.I)) (nhdsWithin 0 (Set.Ioi 0)) (nhds (Complex.log x)) := by
  field_simp;
  -- We need to show that the real and imaginary parts of the function converge separately.
  have h_real : Filter.Tendsto (fun y : ℝ => Complex.re (Complex.log (x + y * Complex.I))) (nhdsWithin 0 (Set.Ioi 0)) (nhds (Complex.re (Complex.log x))) := by
    simp +decide [ Complex.log_re ];
    convert Filter.Tendsto.log ( Continuous.continuousWithinAt ( show Continuous fun y : ℝ => ‖x + y * Complex.I‖ from by continuity ) ) _ using 2 <;> norm_num [ hx.ne ];
  -- We need to show that the imaginary part of the function converges separately.
  have h_imag : Filter.Tendsto (fun y : ℝ => Complex.im (Complex.log (x + y * Complex.I))) (nhdsWithin 0 (Set.Ioi 0)) (nhds (Complex.im (Complex.log x))) := by
    norm_num [ Complex.log_im, Complex.arg ];
    rw [ Filter.tendsto_congr' ( by filter_upwards [ self_mem_nhdsWithin ] with y hy using by rw [ if_neg (not_le.2 hx), if_pos hy.out.le ] ) ];
    norm_num [ Complex.normSq, Complex.norm_def ];
    convert Filter.Tendsto.add ( Filter.Tendsto.comp ( Real.continuous_arcsin.tendsto _ ) <| Filter.Tendsto.div ( Filter.Tendsto.neg <| Filter.tendsto_id.mono_left inf_le_left ) ( Filter.Tendsto.sqrt <| Filter.Tendsto.add ( tendsto_const_nhds.mul tendsto_const_nhds ) <| Filter.Tendsto.mul ( Filter.tendsto_id.mono_left inf_le_left ) <| Filter.tendsto_id.mono_left inf_le_left ) _ ) tendsto_const_nhds using 2 <;> norm_num [ hx.le ];
    · exact fun h => False.elim <| not_le.2 hx h;
    · exact ne_of_gt <| Real.sqrt_pos.mpr <| mul_self_pos.mpr hx.ne;
  exact Filter.Tendsto.congr ( by intros; simp +decide ) ( Complex.continuous_ofReal.continuousAt.tendsto.comp h_real |> Filter.Tendsto.add <| Complex.continuous_ofReal.continuousAt.tendsto.comp h_imag |> Filter.Tendsto.mul_const Complex.I ) |> fun h => h.trans <| by simp +decide [ Complex.ext_iff ] ;

/-
Integral of 1/(z-z0) along a vertical segment to the right of z0.
-/
lemma verticalIntegral_right (x y₁ y₂ : ℝ) (z₀ : ℂ)
    (hx : z₀.re < x) :
    ∫ y in y₁..y₂, Complex.I / (x + y * Complex.I - z₀) =
    Complex.log (x + y₂ * Complex.I - z₀) - Complex.log (x + y₁ * Complex.I - z₀) := by
  rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
  · intro y hy;
    convert HasDerivAt.comp y ( Complex.hasDerivAt_log _ ) ( HasDerivAt.sub ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_id' y |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ) ( hasDerivAt_const _ _ ) ) using 1 <;> norm_num;
    · ring;
    · simp [Complex.slitPlane, hx];
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    exact continuousOn_of_forall_continuousAt fun y hy => ContinuousAt.div continuousAt_const ( Continuous.continuousAt <| by continuity ) <| sub_ne_zero_of_ne <| ne_of_apply_ne Complex.re <| by norm_num; linarith

/-
Integral of 1/(z-z0) along a horizontal segment below z0.
-/
lemma horizontalIntegral_bottom (x₁ x₂ y : ℝ) (z₀ : ℂ)
    (hy : y < z₀.im) :
    ∫ x in x₁..x₂, 1 / (x + y * Complex.I - z₀) =
    Complex.log (x₂ + y * Complex.I - z₀) - Complex.log (x₁ + y * Complex.I - z₀) := by
  apply_rules [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
  · intro x hx;
    convert HasDerivAt.comp x ( Complex.hasDerivAt_log _ ) ( HasDerivAt.sub ( HasDerivAt.add ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ( hasDerivAt_const _ _ ) ) using 1 <;> norm_num;
    exact Or.inr ( by norm_num [ Complex.ext_iff ] ; linarith );
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div continuousAt_const ( Continuous.continuousAt <| by continuity ) <| sub_ne_zero_of_ne <| by intro H; norm_num [ Complex.ext_iff ] at H; linarith;

/-
Integral of 1/(z-z0) along a horizontal segment above z0.
-/
lemma horizontalIntegral_top (x₁ x₂ y : ℝ) (z₀ : ℂ)
    (hy : z₀.im < y) :
    ∫ x in x₁..x₂, 1 / (x + y * Complex.I - z₀) =
    Complex.log (x₂ + y * Complex.I - z₀) - Complex.log (x₁ + y * Complex.I - z₀) := by
  rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
  · intro x hx;
    convert HasDerivAt.comp x ( Complex.hasDerivAt_log _ ) ( HasDerivAt.sub ( HasDerivAt.add ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ( hasDerivAt_const _ _ ) ) using 1 <;> norm_num;
    exact Or.inr ( by simpa [ Complex.ext_iff ] using by linarith );
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.div continuousAt_const ( Continuous.continuousAt <| by continuity ) <| sub_ne_zero_of_ne <| by norm_num [ Complex.ext_iff ] ; intro H ; linarith

/-
Integral of 1/(z-z0) along the lower part of the vertical segment crossing the branch cut.
-/
lemma verticalIntegral_crossing_lower (x y₁ : ℝ) (z₀ : ℂ)
    (hx : x < z₀.re) (hy₁ : y₁ < z₀.im) :
    ∫ y in y₁..z₀.im, Complex.I / (x + y * Complex.I - z₀) =
    (Complex.log (x - z₀.re) - 2 * Real.pi * Complex.I) - Complex.log (x + y₁ * Complex.I - z₀) := by
  convert ( intervalIntegral.integral_eq_sub_of_hasDerivAt_of_tendsto _ _ _ ) using 1;
  any_goals exact hy₁;
  rotate_left;
  exact ℂ;
  all_goals try infer_instance;
  use fun y => Complex.log ( x + y * Complex.I - z₀ );
  use fun y => Complex.I / ( x + y * Complex.I - z₀ );
  exact Complex.log ( x + y₁ * Complex.I - z₀ );
  exact Complex.log ( x - z₀.re ) - 2 * Real.pi * Complex.I;
  · intro y hy;
    convert HasDerivAt.comp y ( Complex.hasDerivAt_log _ ) ( HasDerivAt.sub ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ) ( hasDerivAt_const _ _ ) ) using 1 <;> norm_num;
    · ring;
    · norm_num [ Complex.slitPlane ];
      exact Or.inr ( by linarith [ hy.1, hy.2 ] );
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    exact continuousOn_of_forall_continuousAt fun y hy => ContinuousAt.div continuousAt_const ( Continuous.continuousAt <| by continuity ) <| sub_ne_zero_of_ne <| by norm_num [ Complex.ext_iff ] ; intros; linarith;
  · constructor <;> intro h <;> simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
    convert h _ _ using 1;
    · refine' Filter.Tendsto.mono_left _ nhdsWithin_le_nhds;
      refine' Complex.differentiableAt_log _ |> DifferentiableAt.continuousAt |> ContinuousAt.tendsto |> Filter.Tendsto.comp <| _;
      · norm_num [ Complex.slitPlane, Complex.ext_iff ];
        exact Or.inr ( by linarith );
      · exact Continuous.tendsto ( by continuity ) _;
    · convert tendsto_log_of_re_neg_of_im_neg_tendsto_zero ( show ( x - z₀.re : ℝ ) < 0 by linarith ) |> Filter.Tendsto.comp <| show Filter.Tendsto ( fun y : ℝ => y - z₀.im ) ( nhdsWithin z₀.im ( Set.Iio z₀.im ) ) ( nhdsWithin 0 ( Set.Iio 0 ) ) from ?_ using 2;
      · norm_num [ Complex.ext_iff ];
        exact ⟨ by congr; simp [ Complex.ext_iff ], by congr; simp [ Complex.ext_iff ] ⟩;
      · push_cast; ring;
      · rw [ Metric.tendsto_nhdsWithin_nhdsWithin ] ; aesop

/-
Integral of 1/(z-z0) along the upper part of the vertical segment crossing the branch cut.
-/
lemma verticalIntegral_crossing_upper (x y₂ : ℝ) (z₀ : ℂ)
    (hx : x < z₀.re) (hy₂ : z₀.im < y₂) :
    ∫ y in z₀.im..y₂, Complex.I / (x + y * Complex.I - z₀) =
    Complex.log (x + y₂ * Complex.I - z₀) - Complex.log (x - z₀.re) := by
  convert intervalIntegral.integral_eq_sub_of_hasDerivAt_of_tendsto ?_ ?_ ?_ using 1;
  rotate_left;
  exact ℂ;
  all_goals try infer_instance;
  exact z₀.im;
  exact y₂;
  use fun y => Complex.log ( x + y * Complex.I - z₀ );
  use fun y => Complex.I / ( x + y * Complex.I - z₀ );
  exact hy₂;
  exact Complex.log ( x - z₀.re );
  exact Complex.log ( x + y₂ * Complex.I - z₀ );
  · intro y hy;
    convert HasDerivAt.comp y ( Complex.hasDerivAt_log _ ) ( HasDerivAt.sub ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( hasDerivAt_id _ |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ) ( hasDerivAt_const _ _ ) ) using 1 <;> norm_num;
    · ring;
    · norm_num [ Complex.slitPlane ];
      exact Or.inr ( by linarith [ hy.1, hy.2 ] );
  · apply_rules [ ContinuousOn.intervalIntegrable ];
    exact continuousOn_of_forall_continuousAt fun y hy => ContinuousAt.div continuousAt_const ( Continuous.continuousAt <| by continuity ) <| sub_ne_zero_of_ne <| by norm_num [ Complex.ext_iff ] ; intros; linarith;
  · constructor <;> intro h;
    · simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
    · convert h _ _ using 1;
      · convert tendsto_log_of_re_neg_of_im_pos_tendsto_zero ( show x - z₀.re < 0 by linarith ) |> Filter.Tendsto.comp <| show Filter.Tendsto ( fun y : ℝ => y - z₀.im ) ( nhdsWithin z₀.im ( Set.Ioi z₀.im ) ) ( nhdsWithin 0 ( Set.Ioi 0 ) ) from ?_ using 2;
        · simp +decide [ Complex.ext_iff, Complex.log_re, Complex.log_im ];
          norm_num [ Complex.normSq, Complex.norm_def, Complex.arg ];
        · norm_num;
        · rw [ Metric.tendsto_nhdsWithin_nhdsWithin ] ; aesop;
      · refine' Filter.Tendsto.comp ( Complex.differentiableAt_log _ |> DifferentiableAt.continuousAt ) _;
        · norm_num [ Complex.slitPlane, Complex.ext_iff ];
          exact Or.inr ( by linarith );
        · exact Continuous.continuousWithinAt ( by continuity )

end Aristotle.ContourIntegrationV2