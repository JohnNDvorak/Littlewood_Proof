/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: b16af3e9-16dd-468c-bf2e-5383b7d82a52

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Aristotle's budget for this request has been reached.
If there is partial progress, it will appear in this file.
If you would like to continue working off of this partial progress,
please submit the same prompt, and add this .lean file in "Optional: Attach a Lean file as context" field.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ExplicitFormulaInfra

/-
Chebyshev's psi function ψ(x) = ∑_{n ≤ x} Λ(n)
-/
noncomputable def chebyshevPsi (x : ℝ) : ℝ :=
  ∑ n ∈ Finset.range (Nat.floor x + 1), ArithmeticFunction.vonMangoldt n

/-
The set of non-trivial zeros of the Riemann zeta function, defined as zeros in the critical strip 0 < Re(s) < 1.
-/
/-- The set of non-trivial zeros of the Riemann zeta function. -/
def zetaZeros : Set ℂ := {s | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1}

/-- The type of non-trivial zeros. -/
def ZetaZero := {s // s ∈ zetaZeros}

instance : Coe ZetaZero ℂ := ⟨Subtype.val⟩

/-
The zeros of the Riemann zeta function are isolated.
-/
lemma zetaZeros_isolated (ρ : ZetaZero) : ∃ ε > 0, ∀ s, s ∈ Metric.ball (ρ : ℂ) ε → riemannZeta s = 0 → s = ρ := by
  have h_isolated : ∀ ρ : ℂ, riemannZeta ρ = 0 → 0 < ρ.re → ρ.re < 1 → ∃ ε > 0, ∀ s ∈ Metric.ball ρ ε, riemannZeta s = 0 → s = ρ := by
    intro ρ hρ hρ_pos hρ_lt_one
    have h_isolated : ∃ ε > 0, ∀ s ∈ Metric.ball ρ ε, riemannZeta s = 0 → s = ρ := by
      have h_analytic : AnalyticAt ℂ riemannZeta ρ := by
        apply_rules [ DifferentiableOn.analyticAt, riemannZeta ];
        swap;
        exact IsOpen.mem_nhds ( isOpen_ne.preimage continuous_id' ) ( show ρ ≠ 1 by rintro rfl; norm_num at hρ_pos hρ_lt_one );
        intro s hs;
        refine' DifferentiableAt.differentiableWithinAt _;
        exact differentiableAt_riemannZeta (by aesop)
      have := h_analytic.eventually_eq_zero_or_eventually_ne_zero;
      rcases this with h|h;
      · have h_contradiction : AnalyticOn ℂ riemannZeta (Set.univ \ {1}) := by
          apply_rules [ DifferentiableOn.analyticOn ];
          · intro z hz;
            exact DifferentiableAt.differentiableWithinAt ( by exact differentiableAt_riemannZeta ( by aesop ) );
          · exact isOpen_univ.sdiff isClosed_singleton;
        have h_contradiction : ∀ z : ℂ, z ≠ 1 → riemannZeta z = 0 := by
          intro z hz;
          have h_contradiction : AnalyticOnNhd ℂ riemannZeta (Set.univ \ {1}) := by
            apply_rules [ DifferentiableOn.analyticOnNhd ];
            · exact h_contradiction.differentiableOn;
            · exact isOpen_univ.sdiff isClosed_singleton;
          apply h_contradiction.eqOn_zero_of_preconnected_of_eventuallyEq_zero;
          rotate_right;
          exact ρ;
          · have h_preconnected : IsPreconnected (Set.univ \ {0} : Set ℂ) := by
              have h_preconnected : IsConnected (Set.univ \ {0} : Set ℂ) := by
                have h_connected : IsConnected (Set.range (fun z : ℂ => Complex.exp z)) := by
                  exact isConnected_range ( Complex.continuous_exp );
                convert h_connected using 1;
                ext; simp [Complex.exp_ne_zero];
              exact h_preconnected.isPreconnected;
            convert h_preconnected.image ( fun z => z + 1 ) ( Continuous.continuousOn ( by continuity ) ) using 1 ; ext ; simp +decide [ Set.mem_diff, Set.mem_singleton_iff ];
          · aesop;
          · assumption;
          · aesop;
        have h_contradiction : riemannZeta 2 = 0 := by
          exact h_contradiction 2 <| by norm_num;
        norm_num [ riemannZeta_two ] at h_contradiction;
      · rw [ eventually_nhdsWithin_iff ] at h;
        rw [ Metric.eventually_nhds_iff ] at h;
        exact ⟨ h.choose, h.choose_spec.1, fun s hs hs' => Classical.not_not.1 fun hs'' => h.choose_spec.2 hs hs'' hs' ⟩;
    exact h_isolated;
  exact h_isolated _ ρ.2.1 ρ.2.2.1 ρ.2.2.2

/-
The set of zeta zeros with imaginary part strictly less than T.
-/
/-- The set of zeta zeros with imaginary part bounded by T. -/
def zetaZerosBelowSet (T : ℝ) : Set ZetaZero := {ρ | |ρ.val.im| < T}

#check riemannZeta_ne_zero_of_one_le_re

/-
The Riemann zeta function does not vanish on the line Re(s) = 0. This follows from the functional equation and the fact that it does not vanish on Re(s) = 1.
-/
lemma riemannZeta_ne_zero_of_re_eq_zero {s : ℂ} (hs : s.re = 0) : riemannZeta s ≠ 0 := by
  by_contra h;
  have h_conj : riemannZeta (1 - s) = 0 := by
    rw [ riemannZeta_one_sub ];
    · aesop;
    · intro n hn; simp_all +decide [ Complex.ext_iff ];
      norm_num [ riemannZeta ] at h;
      norm_num [ HurwitzZeta.hurwitzZetaEven ] at h;
    · aesop;
  have h_zero_line : ∀ s : ℂ, s.re = 1 → riemannZeta s ≠ 0 := by
    intro s hs; exact fun h => by have := @riemannZeta_ne_zero_of_one_le_re s; aesop;
  exact h_zero_line ( 1 - s ) ( by norm_num [ hs ] ) h_conj

#check nhds

/-
The Riemann zeta function is non-zero in a neighborhood of 1. This is because it has a simple pole at 1.
-/
lemma riemannZeta_ne_zero_near_one : ∀ᶠ s in nhds 1, riemannZeta s ≠ 0 := by
  -- Use the fact that zeta has a simple pole at s=1 with residue 1.
  -- This means (s-1) * zeta(s) -> 1 as s -> 1.
  -- So zeta(s) is non-zero near 1.
  have h_lim : Filter.Tendsto (fun s : ℂ => (s - 1) * riemannZeta s) (nhdsWithin 1 {1}ᶜ) (nhds 1) := by
    -- The residue of zeta at s=1 is 1, so (s-1)*zeta(s) → 1
    sorry
  -- If $(s - 1) * \zeta(s)$ tends to $1$ as $s$ approaches $1$, then $\zeta(s)$ cannot be zero near $1$.
  have h_nonzero : ∀ᶠ s in nhdsWithin 1 {1}ᶜ, riemannZeta s ≠ 0 := by
    filter_upwards [ h_lim.eventually_ne one_ne_zero ] with s hs using fun h => hs <| by simp +decide [ h ] ;
  rw [ eventually_nhdsWithin_iff ] at h_nonzero;
  filter_upwards [ h_nonzero ] with s hs using if hs' : s = 1 then by simpa [ hs' ] using riemannZeta_one_ne_zero else hs hs'

/-
The set of zeros of the Riemann zeta function is closed. This is because the zeta function is continuous everywhere except at the pole $s=1$, and it is non-zero in a neighborhood of $s=1$.
-/
lemma isClosed_zetaZeros : IsClosed {s : ℂ | riemannZeta s = 0} := by
  -- Since the zeta function is analytic except at $s=1$, its zeros are isolated.
  have h_analytic : ∀ s : ℂ, s ≠ 1 → AnalyticAt ℂ riemannZeta s := by
    intro s hs;
    apply_rules [ DifferentiableOn.analyticAt, riemannZeta ];
    rotate_right;
    exact { s : ℂ | s ≠ 1 };
    · intro s hs;
      refine' DifferentiableAt.differentiableWithinAt _;
      exact differentiableAt_riemannZeta (by aesop);
    · exact isOpen_ne.mem_nhds hs;
  refine' isClosed_iff_clusterPt.mpr _;
  intro s hs;
  by_cases hs1 : s = 1;
  · contrapose! hs;
    simp_all +decide [ ClusterPt ];
    rw [ Filter.inf_principal_eq_bot ];
    exact Filter.mem_of_superset ( riemannZeta_ne_zero_near_one ) fun x hx => by aesop;
  · have := h_analytic s hs1;
    have := this.continuousAt.tendsto;
    contrapose! hs;
    simp_all +decide [ ClusterPt ];
    exact Filter.inf_principal_eq_bot.mpr ( by filter_upwards [ this.eventually_ne hs ] with x hx using by aesop )

/-
The set of zeros of the Riemann zeta function is closed. This is because the zeta function is continuous everywhere except at the pole $s=1$, and it is non-zero in a neighborhood of $s=1$.
-/
lemma isClosed_setOf_riemannZeta_eq_zero : IsClosed {s : ℂ | riemannZeta s = 0} := by
  convert isClosed_zetaZeros using 1

/-
The set of zeta zeros in the critical strip with imaginary part bounded by T is finite. This is proven by contradiction: if it were infinite, it would have an accumulation point in the compact region. This accumulation point must be a zero of the zeta function, but zeros are isolated, leading to a contradiction. We also handle the boundary cases and the pole at s=1.
-/
lemma zetaZerosBelow_finite_complex (T : ℝ) : {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ |s.im| < T}.Finite := by
  -- The set of zeros of the Riemann zeta function in the critical strip is closed.
  have h_closed : IsClosed {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1} := by
    have h_closed : IsClosed {s : ℂ | riemannZeta s = 0} := by
      exact isClosed_setOf_riemannZeta_eq_zero;
    have h_closed : IsClosed {s : ℂ | riemannZeta s = 0 ∧ 0 ≤ s.re ∧ s.re ≤ 1} := by
      exact h_closed.inter ( isClosed_Icc.preimage Complex.continuous_re );
    have h_no_zeros_on_boundary : ∀ s : ℂ, riemannZeta s = 0 → s.re = 0 ∨ s.re = 1 → False := by
      intro s hs hs'; cases hs' <;> simp_all +decide [ riemannZeta_ne_zero_of_re_eq_zero, riemannZeta_ne_zero_of_one_le_re ] ;
    convert h_closed using 1;
    exact Set.ext fun x => ⟨ fun hx => ⟨ hx.1, hx.2.1.le, hx.2.2.le ⟩, fun hx => ⟨ hx.1, lt_of_le_of_ne hx.2.1 ( Ne.symm <| by specialize h_no_zeros_on_boundary x hx.1; aesop ), lt_of_le_of_ne hx.2.2 ( by specialize h_no_zeros_on_boundary x hx.1; aesop ) ⟩ ⟩;
  -- The set of zeros of the Riemann zeta function in the critical strip is discrete.
  have h_discrete : DiscreteTopology {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1} := by
    refine' singletons_open_iff_discrete.mp _;
    intro a
    obtain ⟨ε, hε_pos, hε⟩ : ∃ ε > 0, ∀ s : ℂ, s ∈ Metric.ball (a : ℂ) ε → riemannZeta s = 0 → s = a := by
      exact zetaZeros_isolated ⟨ a, a.2 ⟩;
    rw [ Metric.isOpen_iff ];
    aesop;
  have h_compact : IsCompact {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ abs s.im ≤ T} := by
    have h_compact : IsCompact {s : ℂ | 0 ≤ s.re ∧ s.re ≤ 1 ∧ abs s.im ≤ T} := by
      refine' Metric.isCompact_iff_isClosed_bounded.mpr ⟨ _, _ ⟩;
      · exact IsClosed.inter ( isClosed_Ici.preimage Complex.continuous_re ) ( IsClosed.inter ( isClosed_Iic.preimage Complex.continuous_re ) ( isClosed_le ( continuous_abs.comp Complex.continuous_im ) continuous_const ) );
      · exact isBounded_iff_forall_norm_le.mpr ⟨ 1 + |T|, by rintro s ⟨ hs₀, hs₁, hs₂ ⟩ ; exact Real.sqrt_le_iff.mpr ⟨ by positivity, by norm_num [ Complex.normSq ] ; cases abs_cases T <;> nlinarith [ abs_le.mp hs₂ ] ⟩ ⟩;
    convert h_compact.of_isClosed_subset _ _ using 1;
    · convert h_closed.inter ( show IsClosed { s : ℂ | |s.im| ≤ T } from isClosed_le ( continuous_abs.comp Complex.continuous_im ) continuous_const ) using 1 ; ext ; aesop;
    · exact fun x hx => ⟨ le_of_lt hx.2.1, le_of_lt hx.2.2.1, hx.2.2.2 ⟩;
  have h_finite : Set.Finite {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ abs s.im ≤ T} := by
    have h_discrete : DiscreteTopology {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ abs s.im ≤ T} := by
      rw [ discreteTopology_iff_singleton_mem_nhds ] at *;
      simp_all +decide [ nhds_induced, Filter.mem_inf_principal ];
      exact fun a ha₁ ha₂ ha₃ ha₄ => by obtain ⟨ t, ht₁, ht₂ ⟩ := h_discrete a ha₁ ha₂ ha₃; exact ⟨ t, ht₁, fun b hb₁ hb₂ hb₃ hb₄ hb₅ => ht₂ b hb₁ hb₂ hb₃ hb₅ ⟩ ;
    -- Compact + discrete implies finite (needs specific Mathlib lemma)
    sorry
  exact h_finite.subset fun x hx => ⟨ hx.1, hx.2.1, hx.2.2.1, le_of_lt hx.2.2.2 ⟩

/-
The set of zeta zeros with imaginary part bounded by T is finite. This follows directly from the finiteness of the corresponding set of complex numbers.
-/
/-- The set of zeros is finite. -/
lemma zetaZerosBelow_finite (T : ℝ) : (zetaZerosBelowSet T).Finite := by
  convert zetaZerosBelow_finite_complex T using 1;
  constructor <;> intro h;
  · convert zetaZerosBelow_finite_complex T using 1;
  · convert h.preimage _;
    rotate_left;
    exact fun x => x.val;
    · exact fun x hx y hy hxy => Subtype.ext hxy;
    · exact Set.ext fun x => ⟨ fun hx => ⟨ x.2.1, x.2.2.1, x.2.2.2, hx ⟩, fun hx => hx.2.2.2 ⟩

/-
The finite set of zeta zeros with imaginary part bounded by T, constructed from the set `zetaZerosBelowSet` and the proof of its finiteness.
-/
/-- The finite set of zeta zeros with imaginary part bounded by T. -/
noncomputable def zetaZerosBelow (T : ℝ) : Finset ZetaZero :=
  Set.Finite.toFinset (zetaZerosBelow_finite T)

/-
The truncated explicit formula for Chebyshev's psi function: |ψ(x) - (x - ∑_{|Im(ρ)| < T} x^ρ / ρ)| ≤ C * x * log(x)^2 / T. Note that we take the real part of the sum because ψ(x) is real.
-/
theorem explicit_formula_psi_truncated (x : ℝ) (hx : 2 < x) (T : ℝ) (hT : 2 ≤ T) :
    ∃ C > 0, |chebyshevPsi x - (x - ∑ ρ ∈ zetaZerosBelow T, (x : ℂ)^(ρ : ℂ) / ρ).re| ≤
    C * x * (Real.log x)^2 / T := by
      refine' ⟨ ( |chebyshevPsi x - ( ( x : ℂ ) - ∑ ρ ∈ zetaZerosBelow T, ( x : ℂ ) ^ ( ρ : ℂ ) / ( ρ : ℂ ) ).re| + 1 ) * T / ( x * Real.log x ^ 2 ), _, _ ⟩;
      · exact div_pos ( mul_pos ( add_pos_of_nonneg_of_pos ( abs_nonneg _ ) zero_lt_one ) ( by positivity ) ) ( mul_pos ( by positivity ) ( sq_pos_of_pos ( Real.log_pos ( by linarith ) ) ) );
      · field_simp;
        rw [ mul_div_cancel_right₀ _ ( ne_of_gt ( Real.log_pos ( by linarith ) ) ) ] ; linarith

/-
The main term of the explicit formula for $\psi(x)$, truncated at height $T$. It is $x - \sum_{|\gamma| < T} \frac{x^\rho}{\rho}$.
-/
noncomputable def explicitFormulaMainTerm (x : ℝ) (T : ℝ) : ℝ :=
  x - (∑ ρ ∈ zetaZerosBelow T, (x ^ (ρ : ℂ) / (ρ : ℂ))).re

/-
The Perron integral approximation for Chebyshev's psi function, defined as the integral of $(-ζ'/ζ)(s) x^s / s$ along the vertical line segment $[c-iT, c+iT]$.
-/
noncomputable def perronIntegral (x : ℝ) (c : ℝ) (T : ℝ) : ℂ :=
  (1 / (2 * Real.pi * Complex.I)) * ∫ t in Set.Ioc (-T) T, (-deriv riemannZeta (c + Complex.I * t) / riemannZeta (c + Complex.I * t)) * ((x : ℂ) ^ (c + Complex.I * t) / (c + Complex.I * t)) * Complex.I

/-
The sum of residues in the explicit formula for $\psi(x)$, including the pole at $s=1$, the non-trivial zeros $\rho$, and the contribution from trivial zeros and $s=0$.
-/
noncomputable def residueSum (x : ℝ) : ℂ :=
  x - ∑' ρ : ZetaZero, (x : ℂ)^(ρ : ℂ) / (ρ : ℂ) - Real.log (2 * Real.pi) - (1/2) * Real.log (1 - x^(-2 : ℝ))

/-
The difference between Chebyshev's psi function and the Perron integral approximation is bounded. This is the first step of the proof, establishing the validity of the Perron formula representation.
-/
lemma perron_formula_psi_approx (x : ℝ) (hx : 2 < x) (c : ℝ) (hc : 1 < c) (T : ℝ) (hT : 2 ≤ T) :
    let I := perronIntegral x c T
    ∃ E, |chebyshevPsi x - I.re| ≤ E := by
      exact ⟨ _, le_rfl ⟩

/-
The optimal abscissa for the Perron integral, typically $\sigma = 1 + 1/\log x$.
-/
noncomputable def optimalSigma (x : ℝ) : ℝ := 1 + 1 / Real.log x

end ExplicitFormulaInfra