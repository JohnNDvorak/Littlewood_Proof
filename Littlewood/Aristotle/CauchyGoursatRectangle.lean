/-
Cauchy-Goursat theorem for rectangular contours.

Defines rectBoundary, closedRect, openRect, rectIntegral, and segment integrals.
Proves cauchy_goursat_rectangle_segments (sum of segments = 0),
rectIntegral_eq_sum_segments, and cauchy_goursat_rectangle.

Generated by Aristotle (Harmonic), integrated with type matching.
UUID: be289de8-5500-4944-9aa9-406c249036be

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace CauchyGoursatRect

open Complex Set MeasureTheory Topology

noncomputable def rectBoundary (a b c d : ℝ) : ℝ → ℂ := fun t =>
  if t ≤ 1 then ⟨a + t * (b - a), c⟩                    -- bottom: t ∈ [0,1]
  else if t ≤ 2 then ⟨b, c + (t - 1) * (d - c)⟩        -- right: t ∈ [1,2]
  else if t ≤ 3 then ⟨b - (t - 2) * (b - a), d⟩        -- top: t ∈ [2,3]
  else ⟨a, d - (t - 3) * (d - c)⟩                       -- left: t ∈ [3,4]

def closedRect (a b c d : ℝ) : Set ℂ :=
  {z : ℂ | a ≤ z.re ∧ z.re ≤ b ∧ c ≤ z.im ∧ z.im ≤ d}

def openRect (a b c d : ℝ) : Set ℂ :=
  {z : ℂ | a < z.re ∧ z.re < b ∧ c < z.im ∧ z.im < d}

noncomputable def rectIntegral (f : ℂ → ℂ) (a b c d : ℝ) : ℂ :=
  ∫ t in Icc (0:ℝ) 4, f (rectBoundary a b c d t) * deriv (rectBoundary a b c d) t

noncomputable def bottomIntegral (f : ℂ → ℂ) (a b c : ℝ) : ℂ :=
  ∫ x in Icc a b, f ⟨x, c⟩

noncomputable def rightIntegral (f : ℂ → ℂ) (b c d : ℝ) : ℂ :=
  ∫ y in Icc c d, f ⟨b, y⟩ * I

noncomputable def topIntegral (f : ℂ → ℂ) (a b d : ℝ) : ℂ :=
  ∫ x in Icc a b, f ⟨b - x + a, d⟩ * (-1)

noncomputable def leftIntegral (f : ℂ → ℂ) (a c d : ℝ) : ℂ :=
  ∫ y in Icc c d, f ⟨a, d - y + c⟩ * (-I)

theorem cauchy_goursat_rectangle_segments (f : ℂ → ℂ) (a b c d : ℝ)
    (hab : a < b) (hcd : c < d)
    (hf : DifferentiableOn ℂ f (closedRect a b c d)) :
    bottomIntegral f a b c + rightIntegral f b c d +
    topIntegral f a b d + leftIntegral f a c d = 0 := by
  unfold bottomIntegral rightIntegral topIntegral leftIntegral
  norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab.le, ← intervalIntegral.integral_of_le hcd.le ]
  have h_cauchy : (∫ x in a..b, f (x + c * Complex.I)) - (∫ x in a..b, f (x + d * Complex.I)) + Complex.I * (∫ y in c..d, f (b + y * Complex.I)) - Complex.I * (∫ y in c..d, f (a + y * Complex.I)) = 0 := by
    have := @Complex.integral_boundary_rect_eq_zero_of_differentiable_on_off_countable
    convert this f ( a + c * Complex.I ) ( b + d * Complex.I ) ∅ ( by norm_num ) _ _ using 1 <;> norm_num
    · refine' hf.continuousOn.mono _
      exact fun x hx => ⟨ by simpa [ hab.le ] using hx.1.1, by simpa [ hab.le ] using hx.1.2, by simpa [ hcd.le ] using hx.2.1, by simpa [ hcd.le ] using hx.2.2 ⟩
    · simp_all +decide [ min_eq_left hab.le, max_eq_right hab.le, min_eq_left hcd.le, max_eq_right hcd.le ]
      refine' fun x hx => hf.differentiableAt ( _ )
      refine' Filter.mem_of_superset ( IsOpen.mem_nhds _ _ ) _
      exact { z : ℂ | a < z.re ∧ z.re < b ∧ c < z.im ∧ z.im < d }
      · exact isOpen_Ioi.preimage Complex.continuous_re |> IsOpen.inter <| isOpen_Iio.preimage Complex.continuous_re |> IsOpen.inter <| isOpen_Ioi.preimage Complex.continuous_im |> IsOpen.inter <| isOpen_Iio.preimage Complex.continuous_im
      · exact ⟨ hx.1.1, hx.1.2, hx.2.1, hx.2.2 ⟩
      · exact fun z hz => ⟨ hz.1.le, hz.2.1.le, hz.2.2.1.le, hz.2.2.2.le ⟩
  convert h_cauchy using 1 ; norm_num [ Complex.mk_eq_add_mul_I ] ; ring
  congr! 1
  · norm_num [ add_comm, add_left_comm, add_assoc ]
    convert intervalIntegral.integral_comp_sub_left _ ( c + d ) using 3 <;> push_cast <;> ring
  · norm_num [ add_comm, add_left_comm, add_assoc ]
    convert intervalIntegral.integral_comp_sub_left _ ( a + b ) using 3 <;> ring
    push_cast; ring

lemma rectBoundary_eq_on_Icc_0_1 (a b c d : ℝ) :
    ∀ t ∈ Icc 0 1, rectBoundary a b c d t = ⟨a + t * (b - a), c⟩ := by
  exact fun t ht => if_pos ht.2

lemma deriv_rectBoundary_on_Ioo_0_1 (a b c d : ℝ) :
    ∀ t ∈ Ioo 0 1, deriv (rectBoundary a b c d) t = b - a := by
  intros t ht
  have h_deriv : deriv (fun t => rectBoundary a b c d t) t = deriv (fun t => ⟨a + t * (b - a), c⟩) t := by
    refine' Filter.EventuallyEq.deriv_eq _
    filter_upwards [ Ioo_mem_nhds ht.1 ht.2 ] with x hx using if_pos hx.2.le
  simp_all +decide [ Complex.mk_eq_add_mul_I ]
  erw [ Complex.ofRealCLM.deriv ] ; norm_num

lemma integral_segment_1_change_vars (f : ℂ → ℂ) (a b c : ℝ) (hab : a ≤ b) :
    ∫ t in Icc 0 1, f ⟨a + t * (b - a), c⟩ * (b - a) = bottomIntegral f a b c := by
  cases eq_or_lt_of_le hab <;> unfold bottomIntegral <;> simp_all +decide [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ]
  rw [ intervalIntegral.integral_comp_mul_right ( fun x => f ⟨ a + x, c ⟩ ) ] <;> norm_num [ mul_comm, sub_ne_zero.2 ( by linarith : ( b : ℝ ) ≠ a ) ]
  rw [ ← mul_assoc, mul_inv_cancel₀ ( sub_ne_zero_of_ne <| by norm_cast; linarith ), one_mul, intervalIntegral.integral_comp_add_left fun x => f ⟨ x, c ⟩ ] ; norm_num

lemma integral_segment_1_eq_bottom (f : ℂ → ℂ) (a b c d : ℝ) (hab : a ≤ b)
    (hf : ContinuousOn f (closedRect a b c d)) :
    ∫ t in Icc 0 1, f (rectBoundary a b c d t) * deriv (rectBoundary a b c d) t = bottomIntegral f a b c := by
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Ioc_eq_integral_Ioo ]
  have h_eq_almost_everywhere : ∀ᵐ t ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Ioo 0 1), f (rectBoundary a b c d t) * deriv (rectBoundary a b c d) t = f ⟨a + t * (b - a), c⟩ * (b - a) := by
    filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with t ht
    congr 1
    · exact congr_arg f ( by rw [ show rectBoundary a b c d t = ⟨ a + t * ( b - a ), c ⟩ by exact if_pos ht.2.le ] )
    · convert deriv_rectBoundary_on_Ioo_0_1 a b c d t ht using 1
  convert MeasureTheory.integral_congr_ae h_eq_almost_everywhere using 1
  convert integral_segment_1_change_vars f a b c hab |> Eq.symm using 1
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Ioc_eq_integral_Ioo ]

lemma rectBoundary_eq_on_Icc_1_2 (a b c d : ℝ) :
    ∀ t ∈ Icc 1 2, rectBoundary a b c d t = ⟨b, c + (t - 1) * (d - c)⟩ := by
  intro t ht
  unfold rectBoundary
  cases eq_or_lt_of_le ht.1 <;> cases eq_or_lt_of_le ht.2 <;> aesop

lemma deriv_rectBoundary_on_Ioo_1_2 (a b c d : ℝ) :
    ∀ t ∈ Ioo 1 2, deriv (rectBoundary a b c d) t = (d - c) * I := by
  intro t ht
  convert HasDerivAt.deriv ( HasDerivAt.congr_of_eventuallyEq _ ?_ ) using 1
  exact fun t => b + ( c + ( t - 1 ) * ( d - c ) ) * Complex.I
  · convert HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( HasDerivAt.sub ( hasDerivAt_id' t |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ( hasDerivAt_const _ _ ) ) ) ( hasDerivAt_const _ _ ) ) using 1 ; norm_num
  · filter_upwards [ Ioo_mem_nhds ht.1 ht.2 ] with u hu
    unfold rectBoundary; norm_num [ Complex.ext_iff, hu.1.le, hu.2.le ]
    split_ifs <;> norm_num ; linarith [ hu.1, hu.2 ]

lemma integral_segment_2_change_vars (f : ℂ → ℂ) (b c d : ℝ) (hcd : c ≤ d) :
    ∫ t in Icc 1 2, f ⟨b, c + (t - 1) * (d - c)⟩ * (d - c) * I = rightIntegral f b c d := by
  unfold rightIntegral; rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num [ hcd ]
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hcd ]
  cases eq_or_ne ( d - c ) 0 <;> simp_all +decide [ mul_assoc, mul_comm, mul_left_comm, sub_eq_iff_eq_add ]
  rw [ intervalIntegral.integral_comp_sub_right fun x => f { re := b, im := c + ( d - c ) * x } ] ; norm_num
  rw [ intervalIntegral.integral_comp_mul_left ( fun x => f { re := b, im := c + x } ) ] <;> norm_num [ sub_ne_zero.mpr ‹_› ]
  rw [ ← mul_assoc, mul_inv_cancel₀ ( sub_ne_zero_of_ne <| by norm_cast ), one_mul, intervalIntegral.integral_comp_add_left fun x => f { re := b, im := x } ] ; norm_num

lemma integral_segment_2_eq_right (f : ℂ → ℂ) (a b c d : ℝ) (hcd : c ≤ d)
    (hf : ContinuousOn f (closedRect a b c d)) :
    ∫ t in Icc 1 2, f (rectBoundary a b c d t) * deriv (rectBoundary a b c d) t = rightIntegral f b c d := by
  have h_rectBoundary_1_2 : ∀ t ∈ Set.Ioo 1 2, rectBoundary a b c d t = ⟨b, c + (t - 1) * (d - c)⟩ :=
    fun t ht => rectBoundary_eq_on_Icc_1_2 a b c d t ⟨ ht.1.le, ht.2.le ⟩
  have h_deriv_1_2 : ∀ t ∈ Set.Ioo 1 2, deriv (rectBoundary a b c d) t = (d - c) * Complex.I :=
    deriv_rectBoundary_on_Ioo_1_2 a b c d
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Ioc_eq_integral_Ioo ]
  rw [ MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun t ht => by rw [ h_rectBoundary_1_2 t ht, h_deriv_1_2 t ht ] ]
  rw [ ← MeasureTheory.integral_Ioc_eq_integral_Ioo, ← intervalIntegral.integral_of_le ] <;> norm_num
  convert integral_segment_2_change_vars f b c d hcd using 1
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num [ mul_assoc ]

lemma rectBoundary_eq_on_Icc_2_3 (a b c d : ℝ) :
    ∀ t ∈ Icc 2 3, rectBoundary a b c d t = ⟨b - (t - 2) * (b - a), d⟩ := by
  intros t ht
  simp [rectBoundary, ht]
  split_ifs <;> norm_num [ Complex.ext_iff ] <;> try linarith [ ht.1, ht.2 ]
  norm_num [ show t = 2 by linarith [ ht.1, ht.2 ] ]

lemma deriv_rectBoundary_on_Ioo_2_3 (a b c d : ℝ) :
    ∀ t ∈ Ioo 2 3, deriv (rectBoundary a b c d) t = -(b - a) := by
  intro t ht
  convert HasDerivAt.deriv ( HasDerivAt.congr_of_eventuallyEq _ ?_ ) using 1
  exact fun t => ⟨ b - ( t - 2 ) * ( b - a ), d ⟩
  · rw [ hasDerivAt_iff_tendsto ]
    norm_num [ Complex.normSq, Complex.norm_def ]
    ring_nf
    norm_num
  · filter_upwards [ Ioo_mem_nhds ht.1 ht.2 ] with u hu
    unfold rectBoundary
    norm_num [Complex.ext_iff, hu.1.le, hu.2.le]
    split_ifs <;> norm_num <;> linarith [hu.1, hu.2]

lemma integral_segment_3_change_vars (f : ℂ → ℂ) (a b d : ℝ) (hab : a ≤ b) :
    ∫ t in Icc 2 3, f ⟨b - (t - 2) * (b - a), d⟩ * (-(b - a)) = topIntegral f a b d := by
  by_cases h : a = b <;> simp_all +decide [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ]
  · unfold topIntegral; aesop
  · rw [ ← intervalIntegral.integral_of_le ]
    · have h_sub : ∀ {g : ℝ → ℂ}, ∫ t in (2 : ℝ)..3, g t = ∫ u in (0 : ℝ)..1, g (u + 2) := by
        norm_num [ intervalIntegral.integral_comp_add_right ]
      rw [ h_sub ] ; norm_num [ topIntegral ] ; ring
      rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab ] ; norm_num [ sub_eq_add_neg, add_comm, add_left_comm, add_assoc ] ; ring
      rw [ show ( ∫ x in a..b, f ⟨ b + ( a - x ), d ⟩ ) = ( ∫ x in ( 0 : ℝ )..1, f ⟨ b + ( a - ( a + x * ( b - a ) ) ), d ⟩ ) * ( b - a ) from ?_ ] ; norm_num [ mul_comm ] ; ring
      · ac_rfl
      · rw [ mul_comm, intervalIntegral.integral_comp_mul_right fun x => f { re := b + ( a - ( a + x ) ), im := d } ] <;> norm_num [ sub_ne_zero.mpr h ]
        · rw [ ← mul_assoc, mul_inv_cancel₀ ( sub_ne_zero_of_ne <| mod_cast Ne.symm h ), one_mul ] ; convert intervalIntegral.integral_comp_sub_right _ _ using 3 <;> ring
        · cases lt_or_gt_of_ne h <;> linarith
    · norm_num

lemma integral_segment_3_eq_top (f : ℂ → ℂ) (a b c d : ℝ) (hab : a ≤ b)
    (hf : ContinuousOn f (closedRect a b c d)) :
    ∫ t in Icc 2 3, f (rectBoundary a b c d t) * deriv (rectBoundary a b c d) t = topIntegral f a b d := by
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num [ topIntegral ]
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ]
  · convert integral_segment_3_change_vars f a b d hab using 1
    · rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, intervalIntegral.integral_of_le ]
      · rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo, MeasureTheory.integral_Ioc_eq_integral_Ioo ]
        refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun t ht => _
        rw [ show deriv ( rectBoundary a b c d ) t = - ( b - a ) from _ ]
        · rw [ show rectBoundary a b c d t = ⟨ b - ( t - 2 ) * ( b - a ), d ⟩ from _ ]
          exact if_neg ( by linarith [ ht.1, ht.2 ] ) |> fun h => h.trans ( if_neg ( by linarith [ ht.1, ht.2 ] ) |> fun h => h.trans ( if_pos ( by linarith [ ht.1, ht.2 ] ) ) )
        · convert deriv_rectBoundary_on_Ioo_2_3 a b c d t ⟨ by linarith [ ht.1 ], by linarith [ ht.2 ] ⟩ using 1
      · norm_num
    · unfold topIntegral; ring
      rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hab ] ; congr ; ext ; ring
  · linarith

lemma rectBoundary_eq_on_Icc_3_4 (a b c d : ℝ) :
    ∀ t ∈ Icc 3 4, rectBoundary a b c d t = ⟨a, d - (t - 3) * (d - c)⟩ := by
  unfold rectBoundary
  intro t ht; split_ifs <;> norm_num [ Complex.ext_iff ] <;> try linarith [ ht.1, ht.2 ]
  norm_num [ show t = 3 by linarith [ ht.1, ht.2 ] ]

lemma deriv_rectBoundary_on_Ioo_3_4 (a b c d : ℝ) :
    ∀ t ∈ Ioo 3 4, deriv (rectBoundary a b c d) t = -(d - c) * I := by
  unfold rectBoundary
  intro t ht
  convert HasDerivAt.deriv ( HasDerivAt.congr_of_eventuallyEq _ ?_ ) using 1
  exact fun t => a + ( d - ( t - 3 ) * ( d - c ) ) * Complex.I
  · convert HasDerivAt.add ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( HasDerivAt.sub ( hasDerivAt_const _ _ ) ( HasDerivAt.mul ( HasDerivAt.sub ( hasDerivAt_id' t |> HasDerivAt.ofReal_comp ) ( hasDerivAt_const _ _ ) ) ( hasDerivAt_const _ _ ) ) ) ( hasDerivAt_const _ _ ) ) using 1 ; norm_num
  · filter_upwards [ Ioo_mem_nhds ht.1 ht.2 ] with x hx using by rw [ if_neg ( by linarith [ hx.1 ] ), if_neg ( by linarith [ hx.1, hx.2 ] ), if_neg ( by linarith [ hx.1, hx.2 ] ) ] ; simp +decide [ Complex.ext_iff ]

lemma integral_segment_4_change_vars (f : ℂ → ℂ) (a c d : ℝ) (hcd : c ≤ d) :
    ∫ t in Icc 3 4, f ⟨a, d - (t - 3) * (d - c)⟩ * (-(d - c) * I) = leftIntegral f a c d := by
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ] <;> norm_num
  have h_subst : ∫ x in (3 : ℝ)..4, f ⟨a, d - (x - 3) * (d - c)⟩ * (d - c) = ∫ u in (c)..d, f ⟨a, d - u + c⟩ := by
    by_cases h : d - c = 0 <;> simp_all +decide [ intervalIntegral.integral_comp_sub_mul fun x => f ⟨ a, d - x + c ⟩ ]
    · norm_num [ sub_eq_zero.mp h ]
    · rw [ intervalIntegral.integral_comp_sub_right fun x => f ⟨ a, d - x * ( d - c ) ⟩ ] ; norm_num [ h ]
      rw [ intervalIntegral.integral_comp_mul_right ( fun x => f ⟨ a, d - x ⟩ ) ] <;> norm_num [ h ]
      rw [ inv_mul_eq_div, div_mul_cancel₀ _ ( mod_cast h ) ]
      convert intervalIntegral.integral_comp_add_right _ c using 3 <;> ring
  simp_all +decide [ leftIntegral, mul_assoc, mul_comm, mul_left_comm, ← intervalIntegral.integral_of_le ]
  rw [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le hcd ] ; norm_num [ ← mul_assoc, ← h_subst ] ; ring

lemma integral_segment_4_eq_left (f : ℂ → ℂ) (a b c d : ℝ) (hcd : c ≤ d)
    (hf : ContinuousOn f (closedRect a b c d)) :
    ∫ t in Icc 3 4, f (rectBoundary a b c d t) * deriv (rectBoundary a b c d) t = leftIntegral f a c d := by
  convert integral_segment_4_change_vars f a c d hcd using 1
  norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, MeasureTheory.integral_Ioc_eq_integral_Ioo ]
  refine' MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun t ht => _
  rw [ show deriv ( rectBoundary a b c d ) t = ( - ( d - c ) * Complex.I ) from ( deriv_rectBoundary_on_Ioo_3_4 a b c d ) t ⟨ by linarith [ ht.1 ], by linarith [ ht.2 ] ⟩ ] ; rw [ show rectBoundary a b c d t = ⟨ a, d - ( t - 3 ) * ( d - c ) ⟩ from ( rectBoundary_eq_on_Icc_3_4 a b c d ) t ⟨ by linarith [ ht.1 ], by linarith [ ht.2 ] ⟩ ] ; ring

noncomputable def rectIntegrand (f : ℂ → ℂ) (a b c d : ℝ) (t : ℝ) : ℂ :=
  f (rectBoundary a b c d t) * deriv (rectBoundary a b c d) t

lemma continuousOn_rectBoundary_0_1 (a b c d : ℝ) :
    ContinuousOn (rectBoundary a b c d) (Icc 0 1) := by
  refine' ContinuousOn.congr _ _
  exact fun t => ⟨ a + t * ( b - a ), c ⟩
  · exact Continuous.continuousOn ( by rw [ show ( fun t : ℝ => { re := a + t * ( b - a ), im := c } : ℝ → ℂ ) = fun t : ℝ => ( a + t * ( b - a ) ) + c * Complex.I by funext t; simp +decide [ Complex.ext_iff ] ] ; continuity )
  · exact fun t ht => rectBoundary_eq_on_Icc_0_1 a b c d t ht

lemma maps_rectBoundary_0_1 (a b c d : ℝ) (hab : a ≤ b) (hcd : c ≤ d) :
    MapsTo (rectBoundary a b c d) (Icc 0 1) (closedRect a b c d) := by
  intros t ht
  simp [rectBoundary, closedRect]
  split_ifs <;> simp_all +decide [ Complex.ext_iff ]
  constructor <;> nlinarith

lemma maps_rectBoundary_1_2 (a b c d : ℝ) (hab : a ≤ b) (hcd : c ≤ d) :
    MapsTo (rectBoundary a b c d) (Icc 1 2) (closedRect a b c d) := by
  unfold Set.MapsTo rectBoundary closedRect
  simp +zetaDelta at *
  intros x hx₁ hx₂; split_ifs <;> exact ⟨ by nlinarith, by nlinarith, by nlinarith, by nlinarith ⟩

lemma continuousOn_rectBoundary_1_2 (a b c d : ℝ) :
    ContinuousOn (rectBoundary a b c d) (Icc 1 2) := by
  apply_rules [ ContinuousOn.if, continuousOn_pi ]
  all_goals norm_num [ frontier, Set.Iic_def, Set.Ioi_def ] at *
  all_goals norm_num [ Complex.mk_eq_add_mul_I ] at *
  any_goals intros; subst_vars; norm_num at *
  · exact Continuous.continuousOn ( by continuity )
  · fun_prop
  · fun_prop
  · fun_prop

lemma maps_rectBoundary_2_3 (a b c d : ℝ) (hab : a ≤ b) (hcd : c ≤ d) :
    MapsTo (rectBoundary a b c d) (Icc 2 3) (closedRect a b c d) := by
  intros t ht
  simp [rectBoundary, closedRect]
  split_ifs <;> norm_num
  · linarith [ ht.1, ht.2 ]
  · exact ⟨ hab, mul_nonneg ( by linarith [ ht.1 ] ) ( by linarith [ ht.1 ] ), by nlinarith [ ht.1, ht.2 ] ⟩
  · exact ⟨ by nlinarith [ ht.1, ht.2 ], by nlinarith [ ht.1, ht.2 ], hcd ⟩
  · linarith [ ht.2 ]

lemma continuousOn_rectBoundary_2_3 (a b c d : ℝ) :
    ContinuousOn (rectBoundary a b c d) (Icc 2 3) := by
  have h_eq : ∀ t ∈ Set.Icc 2 3, rectBoundary a b c d t = ⟨b - (t - 2) * (b - a), d⟩ :=
    rectBoundary_eq_on_Icc_2_3 a b c d
  refine' ContinuousOn.congr _ h_eq
  norm_num [ Complex.mk_eq_add_mul_I ]
  exact Continuous.continuousOn ( by continuity )

lemma maps_rectBoundary_3_4 (a b c d : ℝ) (hab : a ≤ b) (hcd : c ≤ d) :
    MapsTo (rectBoundary a b c d) (Icc 3 4) (closedRect a b c d) := by
  exact fun t ht => ⟨ by unfold rectBoundary; split_ifs <;> nlinarith [ ht.1, ht.2 ], by unfold rectBoundary; split_ifs <;> nlinarith [ ht.1, ht.2 ], by unfold rectBoundary; split_ifs <;> nlinarith [ ht.1, ht.2 ], by unfold rectBoundary; split_ifs <;> nlinarith [ ht.1, ht.2 ] ⟩

lemma continuousOn_rectBoundary_3_4 (a b c d : ℝ) :
    ContinuousOn (rectBoundary a b c d) (Icc 3 4) := by
  refine' ContinuousOn.congr _ fun x hx => _
  exact fun x => a + ( d - ( x - 3 ) * ( d - c ) ) * Complex.I
  · exact Continuous.continuousOn ( by continuity )
  · convert rectBoundary_eq_on_Icc_3_4 a b c d x hx using 1
    norm_num [ Complex.ext_iff ]

lemma integrable_segment_1 (f : ℂ → ℂ) (a b c d : ℝ) (hab : a ≤ b) (hcd : c ≤ d)
    (hf : ContinuousOn f (closedRect a b c d)) :
    IntegrableOn (rectIntegrand f a b c d) (Icc 0 1) := by
  have h_eq : ∀ t ∈ Set.Ioo 0 1, rectIntegrand f a b c d t = f (rectBoundary a b c d t) * (b - a) :=
    fun t ht => congr_arg _ ( deriv_rectBoundary_on_Ioo_0_1 a b c d t ht )
  have h_integrable : MeasureTheory.IntegrableOn (fun t => f (rectBoundary a b c d t) * (b - a)) (Set.Icc 0 1) := by
    apply_rules [ ContinuousOn.integrableOn_Icc ]
    apply_rules [ ContinuousOn.mul, continuousOn_const ]
    refine' hf.comp _ _
    · exact continuousOn_rectBoundary_0_1 a b c d
    · exact maps_rectBoundary_0_1 a b c d hab hcd
  refine' h_integrable.congr _
  rw [ Filter.EventuallyEq, MeasureTheory.ae_restrict_iff' ] <;> norm_num
  filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton 0 ), MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton 1 ) ] with x hx₀ hx₁ using fun hx₂ hx₃ => Eq.symm ( h_eq x ⟨ lt_of_le_of_ne hx₂ ( Ne.symm hx₀ ), lt_of_le_of_ne hx₃ hx₁ ⟩ )

lemma integrable_segment_2 (f : ℂ → ℂ) (a b c d : ℝ) (hab : a ≤ b) (hcd : c ≤ d)
    (hf : ContinuousOn f (closedRect a b c d)) :
    IntegrableOn (rectIntegrand f a b c d) (Icc 1 2) := by
  have h_integrable : MeasureTheory.IntegrableOn (fun t => f (rectBoundary a b c d t) * (d - c) * Complex.I) (Set.Icc 1 2) := by
    apply_rules [ ContinuousOn.integrableOn_Icc ]
    refine' ContinuousOn.mul ( ContinuousOn.mul ( hf.comp _ _ ) continuousOn_const ) continuousOn_const
    · exact continuousOn_rectBoundary_1_2 a b c d
    · exact maps_rectBoundary_1_2 a b c d hab hcd
  have h_eq : ∀ᵐ t ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc 1 2), rectIntegrand f a b c d t = f (rectBoundary a b c d t) * (d - c) * Complex.I := by
    rw [ MeasureTheory.ae_restrict_iff' ] <;> norm_num
    filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.1 ( MeasureTheory.measure_singleton 1 ), MeasureTheory.measure_eq_zero_iff_ae_notMem.1 ( MeasureTheory.measure_singleton 2 ) ] with x hx₁ hx₂
    intro h1 h2
    unfold rectIntegrand
    rw [ deriv_rectBoundary_on_Ioo_1_2 a b c d x ⟨ lt_of_le_of_ne h1 ( Ne.symm hx₁ ), lt_of_le_of_ne h2 hx₂ ⟩ ]
    ring
  generalize_proofs at *
  rw [ MeasureTheory.IntegrableOn, MeasureTheory.integrable_congr h_eq ] ; aesop

lemma integrable_segment_3 (f : ℂ → ℂ) (a b c d : ℝ) (hab : a ≤ b) (hcd : c ≤ d)
    (hf : ContinuousOn f (closedRect a b c d)) :
    IntegrableOn (rectIntegrand f a b c d) (Icc 2 3) := by
  have h_integrable_proxy : MeasureTheory.IntegrableOn (fun t => f (rectBoundary a b c d t) * (-(b - a))) (Set.Icc 2 3) := by
    have h_cont : ContinuousOn (fun t => f (rectBoundary a b c d t)) (Set.Icc 2 3) := by
      refine' hf.comp _ _
      · exact continuousOn_rectBoundary_2_3 a b c d
      · exact maps_rectBoundary_2_3 a b c d hab hcd
    exact ContinuousOn.integrableOn_Icc ( h_cont.mul continuousOn_const )
  refine' h_integrable_proxy.congr _
  have h_deriv_const : ∀ᵐ t ∂MeasureTheory.MeasureSpace.volume.restrict (Set.Ioo 2 3), deriv (rectBoundary a b c d) t = -(b - a) := by
    filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioo ] with t ht using by simpa using deriv_rectBoundary_on_Ioo_2_3 a b c d t ht
  have h_deriv_const' : ∀ᵐ t ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc 2 3), deriv (rectBoundary a b c d) t = -(b - a) := by
    rw [ MeasureTheory.Measure.restrict_congr_set MeasureTheory.Ioo_ae_eq_Icc ] at h_deriv_const ; aesop
  filter_upwards [ h_deriv_const' ] with t ht using by unfold rectIntegrand; aesop

lemma integrable_segment_4 (f : ℂ → ℂ) (a b c d : ℝ) (hab : a ≤ b) (hcd : c ≤ d)
    (hf : ContinuousOn f (closedRect a b c d)) :
    IntegrableOn (rectIntegrand f a b c d) (Icc 3 4) := by
  have h_eq : ∀ᵐ t ∂MeasureTheory.Measure.restrict MeasureTheory.volume (Set.Icc 3 4), rectIntegrand f a b c d t = f (rectBoundary a b c d t) * (-(d - c) * Complex.I) := by
    have h_eq_ioo : ∀ t ∈ Set.Ioo 3 4, rectIntegrand f a b c d t = f (rectBoundary a b c d t) * (-(d - c) * Complex.I) := by
      intros t ht
      have h_deriv : deriv (rectBoundary a b c d) t = -(d - c) * Complex.I :=
        deriv_rectBoundary_on_Ioo_3_4 a b c d t ⟨ by linarith [ ht.1 ], by linarith [ ht.2 ] ⟩
      exact h_deriv ▸ rfl
    rw [ MeasureTheory.ae_restrict_iff' ] <;> norm_num
    filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton 3 ), MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton 4 ) ] with x hx₁ hx₂ using fun hx₃ hx₄ => by rw [ h_eq_ioo x ⟨ lt_of_le_of_ne hx₃ ( Ne.symm hx₁ ), lt_of_le_of_ne hx₄ hx₂ ⟩ ] ; ring
  have h_cont : ContinuousOn (fun t => f (rectBoundary a b c d t) * (-(d - c) * Complex.I)) (Set.Icc 3 4) := by
    refine' ContinuousOn.mul _ continuousOn_const
    refine' hf.comp _ _
    · exact continuousOn_rectBoundary_3_4 a b c d
    · exact maps_rectBoundary_3_4 a b c d hab hcd
  refine' MeasureTheory.Integrable.congr _ _
  exacts [ fun t => f ( rectBoundary a b c d t ) * ( - ( d - c ) * Complex.I ), h_cont.integrableOn_Icc, h_eq.mono fun t ht => ht.symm ]

theorem rectIntegral_eq_sum_segments (f : ℂ → ℂ) (a b c d : ℝ)
    (hab : a < b) (hcd : c < d)
    (hf : ContinuousOn f (closedRect a b c d)) :
    rectIntegral f a b c d = bottomIntegral f a b c + rightIntegral f b c d + topIntegral f a b d + leftIntegral f a c d := by
  have h_integral_split : rectIntegral f a b c d = (∫ t in (Set.Icc 0 1), rectIntegrand f a b c d t) + (∫ t in (Set.Icc 1 2), rectIntegrand f a b c d t) + (∫ t in (Set.Icc 2 3), rectIntegrand f a b c d t) + (∫ t in (Set.Icc 3 4), rectIntegrand f a b c d t) := by
    unfold rectIntegral
    norm_num [ MeasureTheory.integral_Icc_eq_integral_Ioc, ← intervalIntegral.integral_of_le ]
    have h_split : ∫ t in (0 : ℝ)..4, rectIntegrand f a b c d t = (∫ t in (0 : ℝ)..1, rectIntegrand f a b c d t) + (∫ t in (1 : ℝ)..2, rectIntegrand f a b c d t) + (∫ t in (2 : ℝ)..3, rectIntegrand f a b c d t) + (∫ t in (3 : ℝ)..4, rectIntegrand f a b c d t) := by
      have h_integrable : MeasureTheory.IntegrableOn (rectIntegrand f a b c d) (Set.Icc 0 4) := by
        have h_integrable : MeasureTheory.IntegrableOn (rectIntegrand f a b c d) (Set.Icc 0 1) ∧ MeasureTheory.IntegrableOn (rectIntegrand f a b c d) (Set.Icc 1 2) ∧ MeasureTheory.IntegrableOn (rectIntegrand f a b c d) (Set.Icc 2 3) ∧ MeasureTheory.IntegrableOn (rectIntegrand f a b c d) (Set.Icc 3 4) := by
          exact ⟨ integrable_segment_1 f a b c d hab.le hcd.le hf, integrable_segment_2 f a b c d hab.le hcd.le hf, integrable_segment_3 f a b c d hab.le hcd.le hf, integrable_segment_4 f a b c d hab.le hcd.le hf ⟩
        convert h_integrable.1.union h_integrable.2.1 |> MeasureTheory.IntegrableOn.union <| h_integrable.2.2.1.union h_integrable.2.2.2 using 1 ; norm_num [ Set.Icc_union_Icc ]
      rw [ intervalIntegral.integral_add_adjacent_intervals, intervalIntegral.integral_add_adjacent_intervals, intervalIntegral.integral_add_adjacent_intervals ] <;> apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ]
      all_goals exact h_integrable.mono_set ( by norm_num [ Set.Icc_subset_Icc ] )
    exact h_split
  rw [ h_integral_split ]
  congr! 1
  · congr! 1
    · congr! 1
      · convert integral_segment_1_eq_bottom f a b c d hab.le ( hf.mono _ ) using 1
        exact Set.Subset.rfl
      · convert integral_segment_2_eq_right f a b c d hcd.le hf using 1
    · convert integral_segment_3_eq_top f a b c d hab.le hf using 1
  · convert integral_segment_4_eq_left f a b c d hcd.le hf using 1

theorem cauchy_goursat_rectangle (f : ℂ → ℂ) (a b c d : ℝ)
    (hab : a < b) (hcd : c < d)
    (hf : DifferentiableOn ℂ f (closedRect a b c d)) :
    rectIntegral f a b c d = 0 := by
  rw [rectIntegral_eq_sum_segments f a b c d hab hcd hf.continuousOn]
  exact cauchy_goursat_rectangle_segments f a b c d hab hcd hf

end CauchyGoursatRect
