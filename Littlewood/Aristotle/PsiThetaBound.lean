/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 271a4549-df4f-47a3-b320-a3e8dfbfc3f6

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the Chebyshev functions psi(x) and theta(x) and prove that their difference is bounded by O(sqrt(x)). Specifically, we show that |psi(x) - theta(x)| <= 10 * sqrt(x) for x >= 2. The proof decomposes psi(x) - theta(x) into a sum of theta(x^(1/k)) for k >= 2, bounds each term using theta(y) <= 2y, and then bounds the resulting sum.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace PsiThetaBound

/-
psi(x) is the sum of the von Mangoldt function for n <= x.
-/
noncomputable def psi (x : ℝ) : ℝ :=
  (Finset.range (Nat.floor x + 1)).sum (fun n => ArithmeticFunction.vonMangoldt n)

/-
theta(x) is the sum of log(p) for primes p <= x.
-/
noncomputable def theta (x : ℝ) : ℝ :=
  ((Finset.range (Nat.floor x + 1)).filter Nat.Prime).sum (fun p => Real.log p)

/-
theta_nat n is the sum of log p for primes p <= n.
-/
noncomputable def theta_nat (n : ℕ) : ℝ :=
  ((Finset.range (n + 1)).filter Nat.Prime).sum (fun p => Real.log p)

/-
theta_nat n is equal to the natural logarithm of the primorial of n.
-/
lemma theta_nat_eq_log_primorial (n : ℕ) : theta_nat n = Real.log (primorial n) := by
  unfold theta_nat primorial;
  rw [ Nat.cast_prod, Real.log_prod ] ; aesop

/-
theta_nat n is bounded by n * log 4.
-/
lemma theta_nat_le_two_mul (n : ℕ) : theta_nat n ≤ n * Real.log 4 := by
  -- We have theta_nat n = log(primorial n).
  have h_theta_nat_eq_log_primorial (n : ℕ) : theta_nat n = Real.log (primorial n) := by
    exact theta_nat_eq_log_primorial n;
  rw [ h_theta_nat_eq_log_primorial, ← Real.log_pow ];
  gcongr ; norm_cast;
  · induction n <;> simp +decide [ *, primorial ];
    exact fun i hi hi' => Nat.Prime.pos hi';
  · -- By definition of $primorial$, we know that $primorial n \leq 4^n$.
    have h_primorial_le_4_pow : ∀ n : ℕ, primorial n ≤ 4 ^ n := by
      exact fun n => primorial_le_4_pow n;
    exact_mod_cast h_primorial_le_4_pow n

/-
theta(x) is equal to theta_nat(floor(x)).
-/
lemma theta_eq_theta_nat_floor (x : ℝ) : theta x = theta_nat (Nat.floor x) := by
  rfl

/-
theta(x) is bounded by 2x for x >= 2.
-/
lemma theta_le_two_mul (x : ℝ) (hx : 2 ≤ x) : theta x ≤ 2 * x := by
  -- By definition of $theta$, we know that $theta(x) = theta_nat (Nat.floor x)$.
  have h_theta_eq_theta_nat_floor : theta x = theta_nat (Nat.floor x) := by
    exact theta_eq_theta_nat_floor x;
  -- By definition of $theta_nat$, we know that $theta_nat (Nat.floor x) \leq Nat.floor x * (Real.log 4)$.
  have h_theta_nat_le_floor_mul_log4 : theta_nat (Nat.floor x) ≤ Nat.floor x * (Real.log 4) := by
    exact le_trans ( theta_nat_le_two_mul _ ) ( mul_le_mul_of_nonneg_left ( show Real.log 4 ≤ Real.log 4 by norm_num ) ( Nat.cast_nonneg _ ) );
  exact h_theta_eq_theta_nat_floor.symm ▸ le_trans h_theta_nat_le_floor_mul_log4 ( by have := Nat.floor_le ( show 0 ≤ x by linarith ) ; nlinarith [ show ( Real.log 4 : ℝ ) ≤ 2 by rw [ show ( 4 : ℝ ) = 2 ^ 2 by norm_num, Real.log_pow ] ; norm_num; linarith [ Real.log_le_sub_one_of_pos zero_lt_two ] ] )

/-
psi(x) is equal to the sum over primes p <= x of (number of powers of p <= x) * log p.
-/
lemma psi_eq_sum_log_p_mul_count (x : ℝ) :
    psi x = ∑ p ∈ (Finset.range (Nat.floor x + 1)).filter Nat.Prime, (Nat.log p (Nat.floor x)) * Real.log p := by
      -- By definition of psi, we can split the sum into sums over prime powers.
      have h_split : psi x = ∑ p ∈ Finset.filter Nat.Prime (Finset.range (Nat.floor x + 1)), ∑ k ∈ Finset.Ico 1 (Nat.log p (Nat.floor x) + 1), Real.log p := by
        -- By definition of psi, we can rewrite the sum as a double sum over primes and their powers.
        have h_double_sum : ∀ n : ℕ, ∑ k ∈ Finset.range (n + 1), (ArithmeticFunction.vonMangoldt k) = ∑ p ∈ Finset.filter Nat.Prime (Finset.range (n + 1)), ∑ v ∈ Finset.Ico 1 (Nat.log p n + 1), (ArithmeticFunction.vonMangoldt (p ^ v)) := by
          intro n
          have h_double_sum : Finset.filter (fun k => ArithmeticFunction.vonMangoldt k ≠ 0) (Finset.range (n + 1)) = Finset.biUnion (Finset.filter Nat.Prime (Finset.range (n + 1))) (fun p => Finset.image (fun v => p ^ v) (Finset.Ico 1 (Nat.log p n + 1))) := by
            ext k
            simp only [Finset.mem_filter, Finset.mem_range, Finset.mem_biUnion, Finset.mem_image, Finset.mem_Ico]
            constructor
            · intro ⟨hk_lt, hk_ne⟩
              have hk_pp : IsPrimePow k := by
                contrapose! hk_ne
                simp [ArithmeticFunction.vonMangoldt_apply, hk_ne]
              obtain ⟨p, e, hp, he, rfl⟩ := hk_pp
              have hp' : Nat.Prime p := hp.irreducible
              have hpge : 1 ≤ p := le_of_lt hp'.one_lt
              refine ⟨p, ⟨?_, hp'⟩, e, ⟨he, ?_⟩, rfl⟩
              · calc p ≤ p ^ e := le_self_pow₀ hpge he.ne'
                  _ < n + 1 := hk_lt
              · suffices h : e ≤ Nat.log p n by omega
                by_contra hc; push_neg at hc
                have h1 : n < p ^ (Nat.log p n + 1) := Nat.lt_pow_succ_log_self hp'.one_lt n
                have h2 : p ^ (Nat.log p n + 1) ≤ p ^ e := Nat.pow_le_pow_right hp'.pos hc
                omega
            · intro ⟨p, ⟨hp_lt, hp⟩, e, ⟨he_lo, he_hi⟩, hpe⟩
              subst hpe
              have hplt : 1 < p := hp.one_lt
              have hne : n ≠ 0 := by omega
              have hle : e ≤ Nat.log p n := by omega
              constructor
              · have := Nat.pow_le_of_le_log hne hle; omega
              · rw [ArithmeticFunction.vonMangoldt_apply,
                     if_pos (hp.isPrimePow.pow (show e ≠ 0 by omega)),
                     Nat.pow_minFac (show e ≠ 0 by omega), hp.minFac_eq]
                exact ne_of_gt (Real.log_pos (show (1 : ℝ) < (p : ℝ) by exact_mod_cast hplt))
          have h_double_sum : ∑ k ∈ Finset.range (n + 1), (ArithmeticFunction.vonMangoldt k) = ∑ k ∈ Finset.biUnion (Finset.filter Nat.Prime (Finset.range (n + 1))) (fun p => Finset.image (fun v => p ^ v) (Finset.Ico 1 (Nat.log p n + 1))), (ArithmeticFunction.vonMangoldt k) := by
            rw [ ← h_double_sum, Finset.sum_filter_of_ne ] ; aesop;
          rw [ h_double_sum, Finset.sum_biUnion ];
          · exact Finset.sum_congr rfl fun p hp => by rw [ Finset.sum_image ( by intros a ha b hb hab; exact Nat.pow_right_injective ( Nat.Prime.one_lt ( Finset.mem_filter.mp hp |>.2 ) ) hab ) ] ;
          · intros p hp q hq hpq; simp_all +decide [ Finset.disjoint_left ] ;
            intro a x hx₁ hx₂ hx₃ y hy₁ hy₂ hy₃; subst_vars; have := Nat.Prime.dvd_of_dvd_pow hp.2 ( hy₃.symm ▸ dvd_pow_self _ ( by linarith ) ) ; simp_all +decide [ Nat.prime_dvd_prime_iff_eq ] ;
        -- Apply the lemma h_double_sum to x and then simplify the inner sum to Real.log p.
        have h_inner_sum : ∀ p : ℕ, Nat.Prime p → ∀ v : ℕ, 1 ≤ v → ArithmeticFunction.vonMangoldt (p ^ v) = Real.log p := by
          simp +contextual [ ArithmeticFunction.vonMangoldt ];
          intro p hp v hv; rw [ if_pos ] <;> norm_num [ hp.isPrimePow.pow ( by linarith ) ] ;
          rw [ Nat.pow_minFac ] ; aesop;
          linarith;
        convert h_double_sum ⌊x⌋₊ using 1;
        exact Finset.sum_congr rfl fun p hp => Finset.sum_congr rfl fun v hv => h_inner_sum p ( Finset.mem_filter.mp hp |>.2 ) v ( Finset.mem_Ico.mp hv |>.1 ) ▸ rfl;
      aesop

/-
The sum of theta(x^(1/k)) is equal to the sum over primes p of floor(log_p x) * log p.
-/
lemma sum_theta_eq_sum_log_p_mul_count (x : ℝ) (hx : 2 ≤ x) :
    ∑ k ∈ Finset.Icc 1 (Nat.floor (Real.logb 2 x)), theta (x ^ (1 / k : ℝ)) =
    ∑ p ∈ (Finset.range (Nat.floor x + 1)).filter Nat.Prime, (Nat.log p (Nat.floor x)) * Real.log p := by
      -- Let's expand the sum $\sum_{k=1}^{\lfloor \log_2 x \rfloor} \theta(x^{1/k})$ using the definition of $\theta$.
      have h_expand : ∑ k ∈ Finset.Icc 1 (Nat.floor (Real.logb 2 x)), theta (x^(1/(k:ℝ))) = ∑ p ∈ (Finset.range (Nat.floor x + 1)).filter Nat.Prime, (∑ k ∈ Finset.Icc 1 (Nat.floor (Real.logb 2 x)), if p ≤ x^(1/(k:ℝ)) then Real.log p else 0) := by
        rw [ Finset.sum_comm, Finset.sum_congr rfl ];
        intro k hk;
        rw [ show ( Finset.filter Nat.Prime ( Finset.range ( ⌊x⌋₊ + 1 ) ) ) = Finset.filter Nat.Prime ( Finset.range ( ⌊x ^ ( 1 / ( k : ℝ ) ) ⌋₊ + 1 ) ) ∪ Finset.filter Nat.Prime ( Finset.Ico ( ⌊x ^ ( 1 / ( k : ℝ ) ) ⌋₊ + 1 ) ( ⌊x⌋₊ + 1 ) ) from ?_, Finset.sum_union ] <;> norm_num;
        · rw [ Finset.sum_congr rfl fun i hi => if_pos <| le_trans ( Nat.cast_le.mpr <| Finset.mem_range_succ_iff.mp <| Finset.mem_filter.mp hi |>.1 ) <| Nat.floor_le <| by positivity, Finset.sum_congr rfl fun i hi => if_neg <| by exact not_le_of_gt <| Nat.lt_of_floor_lt <| Finset.mem_Ico.mp ( Finset.mem_filter.mp hi |>.1 ) |>.1 ] ; aesop;
        · exact Finset.disjoint_left.mpr fun p hp₁ hp₂ => by linarith [ Finset.mem_range.mp ( Finset.mem_filter.mp hp₁ |>.1 ), Finset.mem_Ico.mp ( Finset.mem_filter.mp hp₂ |>.1 ) ] ;
        · rw [ ← Finset.filter_union, Finset.range_eq_Ico, Finset.Ico_union_Ico_eq_Ico ] <;> norm_num;
          exact Nat.floor_mono <| le_trans ( Real.rpow_le_rpow_of_exponent_le ( by linarith ) <| inv_le_one_of_one_le₀ <| mod_cast Finset.mem_Icc.mp hk |>.1 ) <| by norm_num;
      -- For each prime $p \leq x$, the inner sum $\sum_{k=1}^{\lfloor \log_2 x \rfloor} \mathbf{1}_{p \leq x^{1/k}}$ counts the number of $k$ such that $p^k \leq x$, which is exactly $\lfloor \log_p x \rfloor$.
      have h_inner_sum : ∀ p ∈ (Finset.range (Nat.floor x + 1)).filter Nat.Prime, (∑ k ∈ Finset.Icc 1 (Nat.floor (Real.logb 2 x)), if p ≤ x^(1/(k:ℝ)) then 1 else 0) = Nat.log p (Nat.floor x) := by
        intro p hp
        have h_k : ∀ k ∈ Finset.Icc 1 (Nat.floor (Real.logb 2 x)), (if p ≤ x^(1/(k:ℝ)) then 1 else 0) = (if k ≤ Nat.log p (Nat.floor x) then 1 else 0) := by
          intro k hk; split_ifs <;> norm_num at *;
          · -- If $p^k > x$, then $x^{1/k} < p$, contradicting $p \leq x^{1/k}$.
            have h_contra : x < p^k := by
              have h_contra : ⌊x⌋₊ < p^k := by
                exact Nat.lt_pow_of_log_lt hp.2.one_lt ‹_›;
              exact lt_of_lt_of_le ( Nat.lt_floor_add_one x ) ( mod_cast h_contra );
            exact not_le.mpr h_contra ( by exact le_trans ( pow_le_pow_left₀ ( by positivity ) ‹ ( p : ℝ ) ≤ x ^ ( k : ℝ ) ⁻¹ › _ ) ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ), inv_mul_cancel₀ ( by norm_cast; linarith ), Real.rpow_one ] ) );
          · -- If $x^{1/k} < p$, then raising both sides to the power of $k$ gives $x < p^k$.
            have h_exp : x < p^k := by
              exact lt_of_le_of_lt ( by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ), inv_mul_cancel₀ ( by norm_cast; linarith ), Real.rpow_one ] ) ( pow_lt_pow_left₀ ‹_› ( by positivity ) ( by linarith ) );
            exact not_le.mpr h_exp <| le_trans ( mod_cast Nat.pow_le_of_le_log ( by linarith [ Nat.floor_pos.mpr <| show 1 ≤ x by linarith ] ) <| by linarith ) <| Nat.floor_le <| by positivity;
        rw [ Finset.sum_congr rfl h_k ];
        simp +zetaDelta at *;
        rw [ show { x_1 ∈ Finset.Icc 1 ⌊Real.logb 2 x⌋₊ | x_1 ≤ Nat.log p ⌊x⌋₊ } = Finset.Icc 1 ( Nat.log p ⌊x⌋₊ ) from ?_ ];
        · norm_num;
        · ext; simp [Finset.inter_filter, Finset.mem_Icc];
          intro hk₁ hk₂; refine' le_trans hk₁ _;
          refine Nat.le_floor ?_;
          rw [ Real.le_logb_iff_rpow_le ] <;> norm_cast;
          · refine' le_trans _ ( Nat.floor_le ( by positivity ) );
            exact_mod_cast Nat.pow_log_le_self p ( Nat.ne_of_gt <| Nat.floor_pos.mpr <| by linarith ) |> le_trans ( pow_le_pow_left₀ ( by norm_num ) ( Nat.Prime.two_le hp.2 ) _ );
          · linarith;
      simp_all +decide [ Finset.sum_ite ];
      exact Finset.sum_congr rfl fun p hp => by rw [ h_inner_sum p ( Nat.lt_succ_iff.mp ( Finset.mem_range.mp ( Finset.mem_filter.mp hp |>.1 ) ) ) ( Finset.mem_filter.mp hp |>.2 ) ] ;

/-
psi(x) is equal to the sum of theta(x^(1/k)) for k from 1 to floor(log2(x)).
-/
lemma psi_eq_sum_theta (x : ℝ) (hx : 2 ≤ x) :
    psi x = ∑ k ∈ Finset.Icc 1 (Nat.floor (Real.logb 2 x)), theta (x ^ (1 / k : ℝ)) := by
      rw [ psi_eq_sum_log_p_mul_count, sum_theta_eq_sum_log_p_mul_count ];
      linarith

/-
psi(x) - theta(x) is the sum of theta(x^(1/k)) for k from 2 to floor(log2(x)).
-/
lemma psi_sub_theta_eq_sum_k_ge_2 (x : ℝ) (hx : 2 ≤ x) :
    psi x - theta x = ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), theta (x ^ (1 / k : ℝ)) := by
      convert congr_arg ( fun y => y - theta x ) ( psi_eq_sum_theta x hx ) using 1;
      erw [ Finset.sum_Ico_eq_sub _ _, Finset.sum_Ico_eq_sub _ _ ] <;> norm_num;
      · norm_num [ Finset.sum_range_succ ] ; ring;
      · exact Nat.succ_le_succ ( Nat.floor_pos.mpr ( by rw [ Real.le_logb_iff_rpow_le ] <;> norm_num <;> linarith ) )

/-
The sum of theta(x^(1/k)) is bounded by the sum of 2 * x^(1/k).
-/
lemma sum_theta_le_sum_two_mul_pow (x : ℝ) (hx : 2 ≤ x) :
    ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), theta (x ^ (1 / k : ℝ)) ≤
    ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), 2 * x ^ (1 / k : ℝ) := by
      refine Finset.sum_le_sum fun k hk => ?_;
      -- Since $k \geq 2$, we have $x^{1/k} \geq 2^{1/k} \geq 1$. Therefore, we can apply the bound $\theta(y) \leq 2y$ for $y \geq 2$.
      have h_y_ge_2 : 2 ≤ x ^ (1 / (k : ℝ)) := by
        norm_num +zetaDelta at *;
        rw [ Real.le_rpow_inv_iff_of_pos ] <;> norm_cast <;> try linarith;
        rw [ Nat.le_floor_iff ( Real.logb_nonneg ( by norm_num ) ( by linarith ) ), Real.le_logb_iff_rpow_le ] at * <;> norm_cast at * ; linarith;
        linarith;
      exact le_trans ( theta_le_two_mul _ h_y_ge_2 ) ( by nlinarith )

/-
The sum of x^(1/k) for k from 3 to floor(log2 x) is bounded by log2(x) * x^(1/3).
-/
lemma sum_pow_le_log_mul_pow_third (x : ℝ) (hx : 2 ≤ x) :
    ∑ k ∈ Finset.Icc 3 (Nat.floor (Real.logb 2 x)), x ^ (1 / k : ℝ) ≤ (Real.logb 2 x) * x ^ (1 / 3 : ℝ) := by
      -- The number of terms in the sum is bounded by $\log_2 x$, and each term is bounded by $x^{1/3}$.
      have h_num_terms : Finset.card (Finset.Icc 3 (Nat.floor (Real.logb 2 x))) ≤ Real.logb 2 x := by
        simp +zetaDelta at *;
        exact le_trans ( Nat.cast_le.mpr ( Nat.sub_le _ _ ) ) ( Nat.floor_le ( Real.logb_nonneg ( by norm_num ) ( by linarith ) ) );
      -- Each term in the sum is bounded by $x^{1/3}$.
      have h_term_bound : ∀ k ∈ Finset.Icc 3 (Nat.floor (Real.logb 2 x)), x ^ (1 / (k : ℝ)) ≤ x ^ (1 / 3 : ℝ) := by
        exact fun k hk => Real.rpow_le_rpow_of_exponent_le ( by linarith ) ( by gcongr ; norm_cast ; linarith [ Finset.mem_Icc.mp hk ] );
      exact le_trans ( Finset.sum_le_sum h_term_bound ) ( by simpa using mul_le_mul_of_nonneg_right h_num_terms <| Real.rpow_nonneg ( by positivity ) _ )

/-
log2(x) * x^(1/3) is bounded by 4 * sqrt(x) for x >= 2.
-/
lemma log2_x_mul_x_pow_third_le_four_mul_sqrt_x (x : ℝ) (hx : 2 ≤ x) :
    (Real.logb 2 x) * x ^ (1 / 3 : ℝ) ≤ 4 * x ^ (1 / 2 : ℝ) := by
      -- Let $y = x^{1/6}$. Since $x \geq 2$, we have $y \geq 2^{1/6} > 1$.
      set y : ℝ := x ^ (1 / 6 : ℝ)
      have hy : y ≥ 1 := by
        exact Real.one_le_rpow ( by linarith ) ( by norm_num );
      -- We need to show that $6 \log_2(y) \leq 4y$.
      have h_log : 6 * Real.logb 2 y ≤ 4 * y := by
        -- We'll use that $Real.logb 2 y \leq Real.logb 2 e * (y / e)$ for $y \geq 1$.
        have h_logb : Real.logb 2 y ≤ Real.logb 2 (Real.exp 1) * (y / Real.exp 1) := by
          rw [ Real.logb, Real.logb, Real.log_exp ];
          rw [ div_mul_eq_mul_div, div_le_div_iff_of_pos_right ( Real.log_pos one_lt_two ) ];
          have := Real.log_le_sub_one_of_pos ( by positivity : 0 < y / Real.exp 1 );
          rw [ Real.log_div ( by positivity ) ( by positivity ), Real.log_exp ] at this ; linarith;
        norm_num [ Real.logb ] at *;
        -- We'll use that $Real.log 2 \approx 0.693$ and $Real.exp 1 \approx 2.718$ to simplify the inequality.
        have h_approx : (Real.log 2)⁻¹ * (1 / Real.exp 1) ≤ 2 / 3 := by
          rw [ inv_mul_eq_div, div_le_iff₀ ] <;> norm_num;
          · have := Real.exp_one_gt_d9.le ; norm_num1 at * ; have := Real.log_two_gt_d9 ; norm_num1 at * ; nlinarith [ mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos 1 ) ) ];
          · positivity;
        ring_nf at *; nlinarith;
      rw [ show x ^ ( 1 / 2 : ℝ ) = y ^ 3 by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ) ] ; norm_num, show x ^ ( 1 / 3 : ℝ ) = y ^ 2 by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ) ] ; norm_num ] ; rw [ show Real.logb 2 x = 6 * Real.logb 2 y by rw [ show x = y ^ 6 by rw [ ← Real.rpow_natCast, ← Real.rpow_mul ( by positivity ) ] ; norm_num ] ; rw [ Real.logb, Real.logb, Real.log_pow ] ; ring ] ; nlinarith

/-
There exists a constant C > 0 (specifically C=10) such that |psi(x) - theta(x)| <= C * sqrt(x) for all x >= 2.
-/
theorem psi_theta_bound : ∃ C > 0, ∀ x ≥ 2, |psi x - theta x| ≤ C * Real.sqrt x := by
  refine' ⟨ 10, by norm_num, fun x hx => _ ⟩;
  -- By combining the results from the previous steps, we can conclude that |psi x - theta x| ≤ 10 * sqrt x.
  have h_combined : psi x - theta x ≤ 2 * x ^ (1 / 2 : ℝ) + 8 * x ^ (1 / 2 : ℝ) := by
    have h_combined : psi x - theta x ≤ 2 * x ^ (1 / 2 : ℝ) + ∑ k ∈ Finset.Icc 3 (Nat.floor (Real.logb 2 x)), 2 * x ^ (1 / k : ℝ) := by
      have h_bound : psi x - theta x ≤ ∑ k ∈ Finset.Icc 2 (Nat.floor (Real.logb 2 x)), 2 * x ^ (1 / k : ℝ) := by
        convert sum_theta_le_sum_two_mul_pow x hx using 1;
        convert psi_sub_theta_eq_sum_k_ge_2 x hx using 1;
      refine le_trans h_bound ?_;
      by_cases h : ⌊Real.logb 2 x⌋₊ ≥ 3;
      · rw [ Finset.Icc_eq_cons_Ioc ( by linarith ), Finset.sum_cons ] ; aesop;
      · interval_cases _ : ⌊Real.logb 2 x⌋₊ <;> norm_num;
        · positivity;
        · positivity;
    -- Using the bound on the sum, we get:
    have h_sum_bound : ∑ k ∈ Finset.Icc 3 (Nat.floor (Real.logb 2 x)), 2 * x ^ (1 / k : ℝ) ≤ 2 * (Real.logb 2 x) * x ^ (1 / 3 : ℝ) := by
      have h_sum_bound : ∑ k ∈ Finset.Icc 3 (Nat.floor (Real.logb 2 x)), x ^ (1 / k : ℝ) ≤ (Real.logb 2 x) * x ^ (1 / 3 : ℝ) := by
        convert sum_pow_le_log_mul_pow_third x hx using 1;
      simpa only [ mul_assoc, Finset.mul_sum _ _ _ ] using mul_le_mul_of_nonneg_left h_sum_bound zero_le_two;
    linarith [ log2_x_mul_x_pow_third_le_four_mul_sqrt_x x hx ];
  rw [ abs_of_nonneg ] <;> norm_num [ ← Real.sqrt_eq_rpow ] at *;
  · linarith;
  · refine' le_trans _ ( Finset.sum_le_sum_of_subset_of_nonneg _ _ );
    rotate_left;
    exact Finset.filter Nat.Prime ( Finset.range ( ⌊x⌋₊ + 1 ) );
    · exact Finset.filter_subset _ _;
    · exact fun _ _ _ => by rw [ ArithmeticFunction.vonMangoldt_apply ] ; positivity;
    · refine' Finset.sum_le_sum fun p hp => _;
      rw [ ArithmeticFunction.vonMangoldt_apply_prime ] ; aesop
end PsiThetaBound
