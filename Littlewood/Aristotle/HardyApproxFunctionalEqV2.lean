/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 721a165a-915f-4192-92c1-e4194a136bdb

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: supporting lemmas for the approximate functional equation.
Uses local definitions independent of HardyApproxFunctionalEq.lean.
NOT imported by any bridge — serves as reference material.

Contains:
- hardySum_bound: ‖S_N(t)‖ ≤ C_S * t^{1/4} (PROVED, 0 sorries)
- hardyZ_norm_eq: ‖Z(t)‖ = ‖ζ(1/2+it)‖ (PROVED)
- hardy_algebraic_bound: pointwise |Z|² lower bound (1 sorry)
- hardy_error_integral_bound: error integral is O(T) (1 sorry)
- HardyConjectureData: clean axiom bundle for pointwise AFE

NOTE: The main `approx_functional_eq` in this file is VACUOUSLY TRUE
(uses k=1, C=1 and shows RHS ≤ 0 ≤ LHS). It does NOT close the project sorry.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.HardyApproxV2

/-- Riemann-Siegel theta function -/
noncomputable def hardyTheta (t : ℝ) : ℝ :=
  Complex.arg (Complex.Gamma (1/4 + t/2 * Complex.I)) - t/2 * Real.log Real.pi

/-- Hardy Z-function: Z(t) = exp(iθ(t)) · ζ(1/2 + it) -/
noncomputable def hardyZ (t : ℝ) : ℂ :=
  Complex.exp (Complex.I * hardyTheta t) * riemannZeta (1/2 + t * Complex.I)

/-- Partial Dirichlet sum S_N(t) = Σ_{n=1}^{N} n^{-1/2-it} -/
noncomputable def hardySum (N : ℕ) (t : ℝ) : ℂ :=
  ∑ n ∈ Finset.range N, (n + 1 : ℂ)^(-(1/2 : ℂ) - t * Complex.I)

/-- The natural cutoff N(t) = ⌊√(t/2π)⌋ -/
noncomputable def hardyN (t : ℝ) : ℕ := Nat.floor (Real.sqrt (t / (2 * Real.pi)))

/-- The norm of Z(t) equals the norm of ζ(1/2+it). -/
lemma hardyZ_norm_eq (t : ℝ) : ‖hardyZ t‖ = ‖riemannZeta (1/2 + t * Complex.I)‖ := by
  convert norm_mul _ _ using 2 ; norm_num [ Complex.norm_exp ];
  infer_instance

/-- The partial Dirichlet sum is bounded by O(t^{1/4}).
    Uses ∑_{n=1}^N n^{-1/2} ≤ 2√N and N(t) ≤ √(t/2π). -/
lemma hardySum_bound : ∃ C_S > 0, ∀ t : ℝ, t ≥ 1 → ‖hardySum (hardyN t) t‖ ≤ C_S * t ^ (1/4 : ℝ) := by
  have h_sum_bound : ∀ t : ℝ, t ≥ 1 → ‖hardySum (hardyN t) t‖ ≤ ∑ n ∈ Finset.range (hardyN t), (n + 1 : ℝ)^(-(1/2 : ℝ)) := by
    intro t ht; convert norm_sum_le _ _ using 2 ; norm_num [ Complex.norm_exp, Complex.norm_cpow_of_ne_zero, Nat.cast_add_one_ne_zero ] ;
    norm_cast ; norm_num [ Complex.arg ];
  have h_sum_bound_sqrt : ∀ N : ℕ, N ≥ 1 → ∑ n ∈ Finset.range N, (n + 1 : ℝ)^(-(1/2 : ℝ)) ≤ 2 * Real.sqrt N := by
    intros N hN; induction' hN with N hN ih <;> norm_num [ Finset.sum_range_succ ] at *;
    rw [ Real.rpow_neg ( by positivity ) ];
    rw [ ← Real.sqrt_eq_rpow ];
    nlinarith [ sq_nonneg ( Real.sqrt ( N:ℝ ) - Real.sqrt ( N+1 ) ), Real.mul_self_sqrt ( show ( N:ℝ ) ≥ 0 by positivity ), Real.mul_self_sqrt ( show ( N+1:ℝ ) ≥ 0 by positivity ), inv_pos.mpr ( Real.sqrt_pos.mpr ( show ( N+1:ℝ ) > 0 by positivity ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ( show ( N+1:ℝ ) > 0 by positivity ) ) ) ];
  use 2 * (2 * Real.pi) ^ (-1 / 4 : ℝ);
  refine' ⟨ by positivity, fun t ht => le_trans ( h_sum_bound t ht ) ( le_trans ( if h : hardyN t ≥ 1 then h_sum_bound_sqrt _ h else by interval_cases hardyN t ; norm_num ) _ ) ⟩ ; norm_num [ Real.sqrt_eq_rpow ];
  have h_floor_sqrt : (hardyN t : ℝ) ≤ Real.sqrt (t / (2 * Real.pi)) := by
    exact Nat.floor_le <| Real.sqrt_nonneg _;
  convert mul_le_mul_of_nonneg_left ( Real.rpow_le_rpow ( by positivity ) h_floor_sqrt ( by positivity : ( 0 : ℝ ) ≤ 1 / 2 ) ) zero_le_two using 1 ; ring;
  norm_num [ ← Real.sqrt_eq_rpow, Real.sqrt_mul, Real.pi_pos.le, ne_of_gt Real.pi_pos ] ; ring;
  norm_num [ Real.sqrt_eq_rpow, ← Real.rpow_mul, ← Real.rpow_neg, Real.pi_pos.le ] ; ring;
  rw [ ← Real.rpow_mul ( by positivity ) ] ; norm_num [ mul_assoc, mul_comm, mul_left_comm, Real.rpow_neg, Real.pi_pos.le ] ; ring;
  exact Or.inl ( by rw [ ← mul_inv, Real.mul_rpow ( by positivity ) ( by positivity ) ] )

/-- Algebraic lower bound for |Z(t)|² from the approximate functional equation.
    Given |Z(t) - 2·Re(W)| ≤ ε, derives |Z(t)|² ≥ 2|S|² + 2·Re(e^{2iθ}·S²) - 4ε|S|. -/
lemma hardy_algebraic_bound {C₁ : ℝ} (hC₁ : C₁ > 0) (t : ℝ) (ht : t ≥ 1)
  (h_approx : ‖hardyZ t - 2 * (hardySum (hardyN t) t * Complex.exp (Complex.I * hardyTheta t)).re‖ ≤ C₁ * t ^ (-(1/4 : ℝ))) :
  ‖hardyZ t‖^2 ≥ 2 * ‖hardySum (hardyN t) t‖^2 + 2 * (Complex.exp (2 * Complex.I * hardyTheta t) * (hardySum (hardyN t) t)^2).re - 4 * C₁ * t^(-(1/4 : ℝ)) * ‖hardySum (hardyN t) t‖ := by
    set W := hardySum (hardyN t) t * Complex.exp (Complex.I * hardyTheta t) with hW;
    set E := hardyZ t - 2 * W.re with hE;
    have hE_bound : ‖E‖ ≤ C₁ * t ^ (-(1 / 4 : ℝ)) := by
      exact h_approx
    have h_triangle : ‖hardyZ t‖ ^ 2 ≥ (2 * ‖W.re‖) ^ 2 - 2 * (2 * ‖W.re‖) * ‖E‖ + ‖E‖ ^ 2 := by
      have h_triangle : ‖hardyZ t‖ ^ 2 = ‖2 * W.re + E‖ ^ 2 := by
        rw [ hE, add_sub_cancel ];
      have h_triangle : ‖2 * W.re + E‖ ^ 2 ≥ (2 * ‖W.re‖ - ‖E‖) ^ 2 := by
        have h_triangle : ‖2 * W.re + E‖ ≥ |2 * ‖W.re‖ - ‖E‖| := by
          field_simp;
          convert abs_norm_sub_norm_le ( 2 * ( W.re : ℂ ) ) ( -E ) using 1 ; norm_num;
          ring;
        simpa using pow_le_pow_left₀ ( abs_nonneg _ ) h_triangle 2;
      linarith [ sq_nonneg ( ‖W.re‖ - ‖E‖ ) ];
    have hW_re : (2 * ‖W.re‖) ^ 2 = 2 * ‖hardySum (hardyN t) t‖ ^ 2 + 2 * (Complex.exp (2 * Complex.I * hardyTheta t) * hardySum (hardyN t) t ^ 2).re := by
      -- Identity: 4·Re(z)² = 2·|z|² + 2·Re(z²) for any z ∈ ℂ
      -- Applied to z = W = S·exp(iθ), with |W| = |S| and W² = exp(2iθ)·S².
      have h_lhs : (2 * ‖W.re‖) ^ 2 = 4 * W.re ^ 2 := by
        rw [Real.norm_eq_abs]; ring_nf; rw [sq_abs]
      have h_norm_eq : ‖W‖ = ‖hardySum (hardyN t) t‖ := by
        rw [hW, norm_mul, Complex.norm_exp, show (Complex.I * ↑(hardyTheta t)).re = 0 from by
          simp [Complex.mul_re, Complex.I_re, Complex.ofReal_im], Real.exp_zero, mul_one]
      have h_norm_sq : ‖hardySum (hardyN t) t‖ ^ 2 = Complex.normSq W := by
        rw [← h_norm_eq, sq, Complex.norm_mul_self_eq_normSq]
      have h_sq_re : (Complex.exp (2 * Complex.I * ↑(hardyTheta t)) * hardySum (hardyN t) t ^ 2).re = (W ^ 2).re := by
        suffices h : Complex.exp (2 * Complex.I * ↑(hardyTheta t)) * hardySum (hardyN t) t ^ 2 = W ^ 2 by rw [h]
        rw [hW, mul_pow, sq (Complex.exp _), ← Complex.exp_add]
        have : Complex.I * ↑(hardyTheta t) + Complex.I * ↑(hardyTheta t) = 2 * Complex.I * ↑(hardyTheta t) := by ring
        rw [this]; ring
      have h_sq_re2 : (W ^ 2).re = W.re ^ 2 - W.im ^ 2 := by
        simp [sq, Complex.mul_re]
      have h_normSq : (Complex.normSq W : ℝ) = W.re ^ 2 + W.im ^ 2 := by
        simp [Complex.normSq_apply, sq]
      rw [h_lhs, h_norm_sq, h_sq_re, h_sq_re2, h_normSq]; ring
    have hW_re_le : ‖W.re‖ ≤ ‖hardySum (hardyN t) t‖ := by
      calc ‖W.re‖ = |W.re| := Real.norm_eq_abs _
        _ ≤ ‖W‖ := Complex.abs_re_le_norm W
        _ = ‖hardySum (hardyN t) t‖ := by
            rw [hW, norm_mul, Complex.norm_exp, show (Complex.I * ↑(hardyTheta t)).re = 0 from by
              simp [Complex.mul_re, Complex.I_re, Complex.ofReal_im], Real.exp_zero, mul_one]
    nlinarith [ norm_nonneg ( hardySum ( hardyN t ) t ), norm_nonneg E ]

/-- The error term integral is bounded by O(T). -/
lemma hardy_error_integral_bound {C₁ : ℝ} (hC₁ : C₁ > 0) :
  ∃ C_err > 0, ∀ᶠ (T : ℝ) in Filter.atTop,
    ∫ t in Set.Icc 1 T, 4 * C₁ * t ^ (-(1/4 : ℝ)) * ‖hardySum (hardyN t) t‖ ≤ C_err * T := by
      obtain ⟨C_S, hC_S_pos, hC_S⟩ : ∃ C_S > 0, ∀ t : ℝ, t ≥ 1 → ‖hardySum (hardyN t) t‖ ≤ C_S * t ^ (1/4 : ℝ) :=
        hardySum_bound
      have h_integrand_bound : ∀ t : ℝ, t ≥ 1 → 4 * C₁ * t ^ (-(1/4 : ℝ)) * ‖hardySum (hardyN t) t‖ ≤ 4 * C₁ * C_S := by
        intro t ht; convert mul_le_mul_of_nonneg_left ( hC_S t ht ) ( show ( 0 : ℝ ) ≤ 4 * C₁ * t ^ ( - ( 1 / 4 : ℝ ) ) by positivity ) using 1 ; ring;
        norm_num [ mul_assoc, ← Real.rpow_add ( by positivity : 0 < t ) ];
      refine' ⟨ 4 * C₁ * C_S, by positivity, _ ⟩ ; filter_upwards [ Filter.eventually_gt_atTop 1 ] with T hT ; refine' le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ <;> norm_num [ hT.le ];
      refine' fun t => 4 * C₁ * C_S;
      · exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun t ht => mul_nonneg ( mul_nonneg ( mul_nonneg zero_le_four hC₁.le ) ( Real.rpow_nonneg ( by linarith [ ht.1 ] ) _ ) ) ( norm_nonneg _ ) );
      · exact Continuous.integrableOn_Icc ( by continuity );
      · exact Filter.eventually_inf_principal.mpr ( Filter.Eventually.of_forall fun t ht => h_integrand_bound t ht.1 );
      · norm_num [ mul_comm, hT.le ];
        nlinarith [ mul_pos hC₁ hC_S_pos ]

/-- Predicate for the pointwise approximate functional equation. -/
def IsApproximateFunctionalEq (C₁ : ℝ) : Prop :=
  C₁ > 0 ∧ ∀ t : ℝ, t ≥ 1 →
    ‖hardyZ t - 2 * (hardySum (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) t * Complex.exp (Complex.I * hardyTheta t)).re‖
      ≤ C₁ * t ^ (-(1/4 : ℝ))

/-- Predicate for the bound on the oscillatory integral term. -/
def IsOscillatoryBound (C_osc : ℝ) : Prop :=
  ∀ᶠ (T : ℝ) in Filter.atTop,
    ‖∫ t in Set.Icc 1 T, (Complex.exp (2 * Complex.I * hardyTheta t) * (hardySum (hardyN t) t)^2).re‖ ≤ C_osc * T

/-- Structure bundling the deep number-theoretic assumptions:
    the approximate functional equation and the oscillatory integral bound. -/
structure HardyConjectureData where
  C₁ : ℝ
  hC₁_pos : C₁ > 0
  h_approx : ∀ t : ℝ, t ≥ 1 → ‖hardyZ t - 2 * (hardySum (hardyN t) t * Complex.exp (Complex.I * hardyTheta t)).re‖ ≤ C₁ * t ^ (-(1/4 : ℝ))
  C_osc : ℝ
  h_osc : ∀ᶠ (T : ℝ) in Filter.atTop, ‖∫ t in Set.Icc 1 T, (Complex.exp (2 * Complex.I * hardyTheta t) * (hardySum (hardyN t) t)^2).re‖ ≤ C_osc * T

end Aristotle.HardyApproxV2
