/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 54bfbd57-d7d9-4f75-87d4-2ad988a34005

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Proves that the diagonal integral of the partial zeta sum mean square is lower bounded
by c * T * log T. This is a key ingredient for the Hardy Z function mean square lower bound.

Note: 2 `exact?` calls from budget-exceeded output replaced with `sorry`.
The main theorem `diagonal_integral_lower_bound` contains a complete proof structure
but depends on these 2 measurability lemmas.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace DiagonalIntegralBound

open Real Complex MeasureTheory Set Filter Topology

/-
The partial sum of the Dirichlet series for the Riemann Zeta function, truncated at √(t/2π).
-/
noncomputable def zetaPartialSum (t : ℝ) : ℂ :=
  ∑ n ∈ Finset.Icc 1 (Nat.floor (Real.sqrt (t / (2 * Real.pi)))), (n : ℂ) ^ (-(1 / 2 : ℂ) - Complex.I * t)

/-
The mean square integral of the partial sum of the Riemann Zeta function.
-/
noncomputable def meanSquarePartialSum (T : ℝ) : ℝ :=
  ∫ t in Set.Ioc 1 T, ‖zetaPartialSum t‖^2

/-
Definitions for the diagonal term of the mean square integral.
-/
noncomputable def N_t (t : ℝ) : ℕ := Nat.floor (Real.sqrt (t / (2 * Real.pi)))

noncomputable def diagonalSum (t : ℝ) : ℝ := ∑ n ∈ Finset.Icc 1 (N_t t), (1 / n : ℝ)

noncomputable def diagonalIntegral (T : ℝ) : ℝ := ∫ t in Set.Ioc 1 T, diagonalSum t

/-
The diagonal integral is lower bounded by c * T * log T for sufficiently large T.

Note: 2 sorries from `exact?` calls that Aristotle's budget didn't resolve.
Both are measurability lemmas for `fun n : ℕ => ∑ k ∈ Finset.range n, (1 / (k + 1) : ℝ)`.
-/
lemma diagonal_integral_lower_bound :
    ∃ c > 0, ∃ T₀ ≥ 2, ∀ T ≥ T₀, diagonalIntegral T ≥ c * T * Real.log T := by
  -- By definition of `diagonalIntegral`, we know that it is bounded below by ½ T log T.
  have h_diag_bound : ∃ c > 0, ∃ T₀ ≥ 2, ∀ T ≥ T₀, diagonalIntegral T ≥ c * T * Real.log T := by
    use 1/8
    -- For t ≥ 8π, we have N_t(t) ≥ √(t/4π).
    have h_bound : ∀ t ≥ 8 * Real.pi, diagonalSum t ≥ (1 / 2) * Real.log t - Real.log 4 := by
      -- We'll use the fact that ∑_{n ≤ √(t/2π)} 1/n is approximately log(√(t/2π)).
      have h_log_approx : ∀ t ≥ 8 * Real.pi, ∑ n ∈ Finset.Icc 1 (Nat.floor (Real.sqrt (t / (2 * Real.pi)))), (1 / (n : ℝ)) ≥ Real.log (Nat.floor (Real.sqrt (t / (2 * Real.pi))) + 1) := by
        -- We'll use the fact that the sum of the reciprocals of the first n natural numbers is ≥ log(n+1).
        have h_harmonic : ∀ n : ℕ, ∑ k ∈ Finset.Icc 1 n, (1 / (k : ℝ)) ≥ Real.log (n + 1) := by
          sorry  -- harmonic sum lower bound: ∑_{k=1}^n 1/k ≥ log(n+1), uses Nat.Icc_succ_left (missing)
        exact fun t ht => h_harmonic _;
      -- Now use the fact that log(√(t/2π)) = ½ log(t/2π) and log(2π) ≤ log(4) for t ≥ 8π.
      have h_log_simplify : ∀ t ≥ 8 * Real.pi, Real.log (Nat.floor (Real.sqrt (t / (2 * Real.pi))) + 1) ≥ (1 / 2) * Real.log t - Real.log 4 := by
        intros t ht
        have h_log_simplify_step : Real.log (Nat.floor (Real.sqrt (t / (2 * Real.pi))) + 1) ≥ Real.log (Real.sqrt (t / (2 * Real.pi))) := by
          exact Real.log_le_log ( Real.sqrt_pos.mpr ( by exact div_pos ( by linarith [ Real.pi_pos ] ) ( by positivity ) ) ) ( by linarith [ Nat.lt_floor_add_one ( Real.sqrt ( t / ( 2 * Real.pi ) ) ) ] );
        rw [ Real.log_sqrt ( by exact div_nonneg ( by linarith [ Real.pi_pos ] ) ( by positivity ) ), Real.log_div ( by linarith [ Real.pi_pos ] ) ( by positivity ) ] at h_log_simplify_step;
        linarith [ show Real.log ( 2 * Real.pi ) ≤ Real.log 4 + Real.log 4 by rw [ ← Real.log_mul ( by positivity ) ( by positivity ) ] ; exact Real.log_le_log ( by positivity ) ( by nlinarith [ Real.pi_le_four ] ) ];
      exact fun t ht => le_trans ( h_log_simplify t ht ) ( h_log_approx t ht );
    -- Therefore, for T ≥ 8π, we have ∫₁ᵀ ∑_{n ≤ √(t/2π)} 1/n dt ≥ ∫_{8π}ᵀ (½ log t - log 4) dt.
    have h_integral_bound : ∀ T ≥ 8 * Real.pi, diagonalIntegral T ≥ ∫ t in (8 * Real.pi)..T, (1 / 2 * Real.log t - Real.log 4) := by
      intros T hT
      have h_integral_bound : ∫ t in (8 * Real.pi)..T, diagonalSum t ≥ ∫ t in (8 * Real.pi)..T, (1 / 2 * Real.log t - Real.log 4) := by
        apply_rules [ intervalIntegral.integral_mono_on ];
        · apply_rules [ ContinuousOn.intervalIntegrable ];
          exact continuousOn_of_forall_continuousAt fun u hu => by exact ContinuousAt.sub ( ContinuousAt.mul continuousAt_const ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp hu <;> linarith [ Real.pi_pos ] ) ) ) continuousAt_const;
        · apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
          refine' MeasureTheory.Integrable.mono' _ _ _;
          refine' fun t => Real.log t + 1;
          · exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun t ht => by exact ContinuousAt.add ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp ht <;> linarith [ Real.pi_pos ] ) ) continuousAt_const );
          · refine' Measurable.aestronglyMeasurable _;
            -- The floor function is measurable, and the sum of measurable functions is measurable.
            have h_floor_measurable : Measurable (fun t : ℝ => Nat.floor (Real.sqrt (t / (2 * Real.pi)))) := by
              exact Measurable.nat_floor ( Measurable.sqrt ( measurable_id'.div_const _ ) );
            have h_sum_measurable : Measurable (fun t : ℝ => ∑ n ∈ Finset.Icc 1 (Nat.floor (Real.sqrt (t / (2 * Real.pi)))), (1 / n : ℝ)) := by
              have h_sum_measurable : Measurable (fun t : ℝ => ∑ n ∈ Finset.range (Nat.floor (Real.sqrt (t / (2 * Real.pi)))), (1 / (n + 1) : ℝ)) := by
                have h_sum_measurable : Measurable (fun n : ℕ => ∑ k ∈ Finset.range n, (1 / (k + 1) : ℝ)) := by
                  sorry  -- was: exact?  (measurability of partial harmonic sum as function of ℕ)
                exact h_sum_measurable.comp h_floor_measurable
              convert h_sum_measurable using 1;
              exact funext fun x => by erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ' ] ;
            convert h_sum_measurable using 1;
          · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Icc ] with t ht;
            -- Since ∑_{n ≤ √(t/2π)} 1/n is a finite sum, we can bound it above by log(√(t/2π)) + 1.
            have h_sum_bound : ∀ t ≥ 8 * Real.pi, diagonalSum t ≤ Real.log (Real.sqrt (t / (2 * Real.pi))) + 1 := by
              intros t ht
              have h_sum_bound : ∀ n : ℕ, n ≥ 1 → ∑ k ∈ Finset.Icc 1 n, (1 / k : ℝ) ≤ Real.log n + 1 := by
                sorry  -- harmonic sum upper bound: ∑_{k=1}^n 1/k ≤ log(n) + 1, uses Nat.Icc_succ_left (missing)
              refine' le_trans ( h_sum_bound _ _ ) _;
              · exact Nat.floor_pos.mpr ( Real.le_sqrt_of_sq_le ( by rw [ le_div_iff₀ ( by positivity ) ] ; linarith [ Real.pi_gt_three ] ) );
              · gcongr;
                · exact Nat.cast_pos.mpr ( Nat.floor_pos.mpr ( Real.le_sqrt_of_sq_le ( by rw [ le_div_iff₀ ( by positivity ) ] ; linarith [ Real.pi_gt_three ] ) ) );
                · exact Nat.floor_le <| Real.sqrt_nonneg _;
            rw [ Real.norm_of_nonneg ( show 0 ≤ diagonalSum t from Finset.sum_nonneg fun _ _ => by positivity ) ];
            refine le_trans ( h_sum_bound t <| by cases Set.mem_uIcc.mp ht <;> linarith [ Real.pi_pos ] ) ?_;
            rw [ Real.log_sqrt ( div_nonneg ( by cases Set.mem_uIcc.mp ht <;> linarith [ Real.pi_pos ] ) ( by positivity ) ), Real.log_div ( by cases Set.mem_uIcc.mp ht <;> linarith [ Real.pi_pos ] ) ( by positivity ) ];
            linarith [ Real.log_nonneg ( show 2 * Real.pi ≥ 1 by linarith [ Real.pi_gt_three ] ), Real.log_le_log ( by positivity ) ( show t ≥ 2 * Real.pi by cases Set.mem_uIcc.mp ht <;> linarith [ Real.pi_gt_three ] ) ];
        · aesop;
      refine' le_trans h_integral_bound _;
      rw [ intervalIntegral.integral_of_le ( by linarith [ Real.pi_pos ] ) ];
      refine' MeasureTheory.setIntegral_mono_set _ _ _;
      · refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun t => ∑ n ∈ Finset.Icc 1 ( Nat.floor ( Real.sqrt ( T / ( 2 * Real.pi ) ) ) ), ( 1 / n : ℝ );
        · norm_num;
        · refine' Measurable.aestronglyMeasurable _;
          -- The floor function is measurable, and the sum of measurable functions is measurable.
          have h_floor_measurable : Measurable (fun t : ℝ => Nat.floor (Real.sqrt (t / (2 * Real.pi)))) := by
            exact Measurable.nat_floor ( Measurable.sqrt ( measurable_id'.div_const _ ) );
          have h_sum_measurable : Measurable (fun n : ℕ => ∑ k ∈ Finset.Icc 1 n, (1 / k : ℝ)) := by
            sorry  -- was: exact?  (measurability of partial harmonic sum as function of ℕ)
          convert h_sum_measurable.comp h_floor_measurable using 1;
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht;
          refine' le_trans ( le_of_eq <| Real.norm_of_nonneg <| Finset.sum_nonneg fun _ _ => by positivity ) _;
          refine' Finset.sum_le_sum_of_subset_of_nonneg _ fun _ _ _ => by positivity;
          exact Finset.Icc_subset_Icc_right <| Nat.floor_mono <| Real.sqrt_le_sqrt <| by rw [ div_le_div_iff₀ ] <;> nlinarith [ Real.pi_gt_three, ht.1, ht.2 ] ;
      · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using Finset.sum_nonneg fun _ _ => by positivity;
      · exact MeasureTheory.ae_of_all _ fun x hx => ⟨ by linarith [ hx.1, Real.pi_gt_three ], hx.2 ⟩;
    -- Now let's compute the integral ∫_{8π}^T (½ log t - log 4) dt.
    have h_integral_computation : ∀ T ≥ 8 * Real.pi, ∫ t in (8 * Real.pi)..T, (1 / 2 * Real.log t - Real.log 4) = (1 / 2) * T * Real.log T - (1 / 2) * T - T * Real.log 4 - ((1 / 2) * (8 * Real.pi) * Real.log (8 * Real.pi) - (1 / 2) * (8 * Real.pi) - (8 * Real.pi) * Real.log 4) := by
      intro T hT; rw [ intervalIntegral.integral_sub ] <;> norm_num ; ring;
    -- Let's choose T₀ such that for all T ≥ T₀, we have the bound ≥ (1/8) * T * log T.
    obtain ⟨T₀, hT₀⟩ : ∃ T₀ ≥ 8 * Real.pi, ∀ T ≥ T₀, (1 / 2) * T * Real.log T - (1 / 2) * T - T * Real.log 4 - ((1 / 2) * (8 * Real.pi) * Real.log (8 * Real.pi) - (1 / 2) * (8 * Real.pi) - 8 * Real.pi * Real.log 4) ≥ (1 / 8) * T * Real.log T := by
      -- We can divide both sides by T and take the limit as T → ∞.
      have h_limit : Filter.Tendsto (fun T : ℝ => (1 / 2) * Real.log T - (1 / 2) - Real.log 4 - ((1 / 2) * (8 * Real.pi) * Real.log (8 * Real.pi) - (1 / 2) * (8 * Real.pi) - 8 * Real.pi * Real.log 4) / T - (1 / 8) * Real.log T) Filter.atTop Filter.atTop := by
        ring_nf;
        exact Filter.Tendsto.atTop_add ( Filter.Tendsto.atTop_add ( Filter.Tendsto.add_atTop tendsto_const_nhds <| Filter.Tendsto.atTop_add ( Filter.Tendsto.atTop_mul_const ( by norm_num ) <| Real.tendsto_log_atTop ) tendsto_const_nhds ) <| Filter.Tendsto.add ( Filter.Tendsto.mul ( tendsto_const_nhds.mul <| tendsto_inv_atTop_zero ) tendsto_const_nhds ) <| Filter.Tendsto.neg <| Filter.Tendsto.mul ( tendsto_const_nhds.mul <| tendsto_inv_atTop_zero ) tendsto_const_nhds ) <| Filter.Tendsto.mul ( tendsto_const_nhds.mul <| tendsto_inv_atTop_zero ) tendsto_const_nhds;
      have := h_limit.eventually_gt_atTop 0;
      obtain ⟨ T₀, hT₀ ⟩ := Filter.eventually_atTop.mp this;
      exact ⟨ Max.max T₀ ( 8 * Real.pi ), le_max_right _ _, fun T hT => by have := hT₀ T ( le_trans ( le_max_left _ _ ) hT ) ; nlinarith [ le_max_right T₀ ( 8 * Real.pi ), Real.pi_gt_three, mul_div_cancel₀ ( 1 / 2 * ( 8 * Real.pi ) * Real.log ( 8 * Real.pi ) - 1 / 2 * ( 8 * Real.pi ) - 8 * Real.pi * Real.log 4 ) ( show T ≠ 0 by linarith [ le_max_right T₀ ( 8 * Real.pi ), Real.pi_gt_three ] ) ] ⟩;
    exact ⟨ by norm_num, T₀, by linarith [ Real.pi_gt_three ], fun T hT => le_trans ( hT₀.2 T hT ) ( h_integral_computation T ( by linarith [ Real.pi_gt_three ] ) ▸ h_integral_bound T ( by linarith [ Real.pi_gt_three ] ) ) ⟩;
  exact h_diag_bound

end DiagonalIntegralBound
