/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4f63b39a-2b35-41dc-b057-61fff102f04b

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: Van der Corput integration-by-parts infrastructure.
NOT imported by any bridge — serves as reference material for closing
the HardyFirstMomentUpperHyp sorry.

Contains (all PROVED, 0 sorries):
- van_der_corput_deriv_aux: derivative of exp(if(x))/if'(x)
- van_der_corput_inv_deriv_continuous: continuity of 1/(if'(t))
- van_der_corput_deriv_inv_deriv_formula: derivative of 1/(if'(t))
- contDiffOn_deriv_of_contDiffOn_2: C^2 => C^1 derivative

Budget was reached; the final van der Corput bound (oscillatory integral
bounded by variation of 1/f') is not assembled here.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.VanDerCorput

/-
Derivative identity for Van der Corput's lemma.
-/
lemma van_der_corput_deriv_aux {f : ℝ → ℝ} {t : ℝ}
    (hf : DifferentiableAt ℝ f t)
    (hf' : DifferentiableAt ℝ (deriv f) t)
    (h_ne : deriv f t ≠ 0) :
    deriv (fun x => Complex.exp (f x * Complex.I) / (Complex.I * deriv f x)) t =
    Complex.exp (f t * Complex.I) +
    Complex.exp (f t * Complex.I) * deriv (fun x => 1 / (Complex.I * deriv f x)) t := by
  convert HasDerivAt.deriv ( HasDerivAt.div ( HasDerivAt.comp t ( Complex.hasDerivAt_exp _ ) ( HasDerivAt.mul ( HasDerivAt.ofReal_comp ( hf.hasDerivAt ) ) ( hasDerivAt_const _ _ ) ) ) ( HasDerivAt.mul ( hasDerivAt_const _ _ ) ( HasDerivAt.ofReal_comp ( hf'.hasDerivAt ) ) ) _ ) using 1;
  · erw [ deriv_div ] <;> norm_num [ h_ne, hf', hf, Complex.ext_iff, sq, mul_assoc, mul_comm, mul_left_comm ] ; ring;
    · erw [ HasDerivAt.deriv ( HasDerivAt.ofReal_comp ( hf'.hasDerivAt ) ) ] ; norm_num [ Complex.exp_re, Complex.exp_im, sq, mul_assoc, mul_left_comm, h_ne ] ; ring_nf ; aesop;
    · exact DifferentiableAt.const_mul ( Complex.ofRealCLM.differentiableAt.comp _ hf' ) _;
  · simp +zetaDelta at *;
    assumption

/-
Continuity of 1/(i f'(t)).
-/
lemma van_der_corput_inv_deriv_continuous {f : ℝ → ℝ} {a b : ℝ} (hab : a ≤ b)
    (hf : ContDiffOn ℝ 2 f (Set.Icc a b))
    (hf' : ∀ t ∈ Set.Icc a b, deriv f t ≠ 0) :
    ContinuousOn (fun t => 1 / (Complex.I * deriv f t)) (Set.Icc a b) := by
  refine' ContinuousOn.div continuousOn_const _ _;
  · have h_cont : ContinuousOn (deriv f) (Set.Icc a b) := by
      have := hf.continuousOn_derivWithin;
      by_cases h : a = b <;> simp_all +decide [ UniqueDiffOn ];
      refine' this ( fun x hx₁ hx₂ => _ ) |> fun h => h.congr fun x hx => _;
      · exact uniqueDiffOn_Icc ( by contrapose! h; linarith ) x ⟨ hx₁, hx₂ ⟩;
      · rw [ derivWithin ];
        rw [ fderivWithin_eq_fderiv ];
        · rfl;
        · exact uniqueDiffOn_Icc ( by linarith [ show a < b from lt_of_le_of_ne hab ‹_› ] ) x hx;
        · exact differentiableAt_of_deriv_ne_zero ( hf' x hx.1 hx.2 );
    exact ContinuousOn.mul continuousOn_const <| Complex.continuous_ofReal.comp_continuousOn h_cont;
  · aesop

/-
Formula for the derivative of 1/(i f'(t)).
-/
lemma van_der_corput_deriv_inv_deriv_formula {f : ℝ → ℝ} {a b : ℝ} {t : ℝ}
    (hab : a < b)
    (hf : ContDiffOn ℝ 2 f (Set.Icc a b))
    (hf' : ∀ x ∈ Set.Icc a b, deriv f x ≠ 0)
    (ht : t ∈ Set.Ioo a b) :
    deriv (fun t => 1 / (Complex.I * deriv f t)) t =
    - (Complex.I * deriv (deriv f) t) / (Complex.I * deriv f t)^2 := by
  convert HasDerivAt.deriv ( HasDerivAt.div ( hasDerivAt_const _ _ ) ( HasDerivAt.const_mul Complex.I <| HasDerivAt.ofReal_comp <| hasDerivAt_deriv_iff.mpr _ ) _ ) using 1 <;> norm_num [ hf' _ <| Set.mem_Icc.mpr <| Set.Ioo_subset_Icc_self ht ];
  have h_diff : ContDiffOn ℝ 1 (deriv f) (Set.Ioo a b) := by
    apply_rules [ ContDiffOn.deriv_of_isOpen ] <;> norm_num [ hab ];
    exacts [ hf.mono <| Set.Ioo_subset_Icc_self, isOpen_Ioo, by norm_num ];
  exact h_diff.differentiableOn (by norm_num) |> DifferentiableOn.differentiableAt <| Ioo_mem_nhds ht.1 ht.2

/-
If f is C^2, then f' is C^1.
-/
lemma contDiffOn_deriv_of_contDiffOn_2 {f : ℝ → ℝ} {s : Set ℝ} (hs : IsOpen s)
    (hf : ContDiffOn ℝ 2 f s) :
    ContDiffOn ℝ 1 (deriv f) s := by
  exact hf.deriv_of_isOpen hs ( by norm_num )

end Aristotle.VanDerCorput
