/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
Original uuids: 15e6ddc9-fba8-47f6-aeb5-87c4ed407bdc, 2fbc5434-3de7-4982-9331-dce5102334ec

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Integrated by Claude (Anthropic). Original files merged and namespaced to avoid
conflicts with HardyEstimatesPartial.lean (which already defines hardyTheta/hardyZ).

# Content

Defines the approximate functional equation decomposition of Z(t):
- `hardySum`: main sum in the approximate functional equation
- `hardyApproxError`: error term Z(t) - hardySum(t)
- `partial_sum`: partial Dirichlet series for zeta
- `approx_functional_eq`: mean square of Z(t)² is lower bounded by
  partial sum mean square minus a linear error term (PROVED, 0 sorries)

This theorem is a key step in the Hardy chain: it connects the
partial sum mean square (which DiagonalIntegralBound.lean shows ≥ c·T·log T)
to the full Z(t) mean square needed by HardySetupInstance.
-/

import Mathlib
import Littlewood.Aristotle.MeanSquare

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace HardyApproxFunctional

open Complex MeasureTheory Set Filter Asymptotics

/-
Local definition of Hardy Z for this file (norm-based variant).
Equivalent to HardyEstimatesPartial.hardyZ up to sign; see Bridge/HardyZTransfer.
-/
def hardyZ (t : ℝ) : ℝ := ‖riemannZeta (1 / 2 + t * Complex.I)‖

/-
The Riemann-Siegel theta function.
-/
def hardyTheta (t : Real) : Real :=
  (Complex.log (Complex.Gamma (1/4 + Complex.I * t / 2))).im - t / 2 * Real.log Real.pi

/-
The main sum in the approximate functional equation for the Hardy Z function.
-/
open Finset

def hardySum (t : Real) : Real :=
  2 * ∑ n ∈ Finset.Icc 1 (Nat.floor (Real.sqrt (t / (2 * Real.pi)))),
    (n : Real) ^ (-(1:Real)/2) * Real.cos (hardyTheta t - t * Real.log n)

/-
The error term in the approximate functional equation for the Hardy Z function.
Z(t) = hardySum(t) + hardyApproxError(t)
-/
def hardyApproxError (t : Real) : Real :=
  (Complex.exp (Complex.I * hardyTheta t) * riemannZeta (1/2 + Complex.I * t)).re
    - hardySum t

/-
Partial sum of the Dirichlet series for zeta.
-/
def partial_sum (N : ℕ) (t : ℝ) : ℂ :=
  ∑ n ∈ Finset.range N, (n + 1 : ℂ) ^ (-(1 / 2 : ℂ) - t * Complex.I)

/-
Approximation of the partial sum using the floor of the square root of t/2pi.
-/
def partial_sum_approx (t : ℝ) : ℂ :=
  partial_sum (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) t

private lemma partial_sum_approx_eq_partialZeta (t : ℝ) :
    partial_sum_approx t =
    partialZeta (Real.sqrt (t / (2 * Real.pi))) (1/2 + Complex.I * ↑t) := by
  unfold partial_sum_approx partial_sum partialZeta
  set N := Nat.floor (Real.sqrt (t / (2 * Real.pi)))
  rw [show Finset.Icc 1 N = Finset.Ico 1 (N + 1) from
        (Finset.Ico_succ_right_eq_Icc 1 N).symm,
      Finset.sum_Ico_eq_sum_range]
  simp only [Nat.add_sub_cancel]
  apply Finset.sum_congr rfl
  intro n _
  congr 1
  · push_cast
    ring
  · ring

private lemma norm_sq_partial_sum_eq_partialZeta (t : ℝ) :
    ‖partial_sum_approx t‖^2 =
    Complex.normSq (partialZeta (Real.sqrt (t / (2 * Real.pi)))
      (1/2 + Complex.I * ↑t)) := by
  rw [partial_sum_approx_eq_partialZeta, Complex.sq_norm]

/-- The mean square of `partial_sum_approx` is `Θ(T log T)` on `[1,T]`. -/
theorem partial_sum_approx_mean_square_asymp :
    (fun T => ∫ t in (1 : ℝ)..T, ‖partial_sum_approx t‖^2)
      =Θ[atTop] (fun T => T * Real.log T) := by
  have hEq :
      (fun T => ∫ t in (1 : ℝ)..T, ‖partial_sum_approx t‖^2)
        = (fun T => ∫ t in (1 : ℝ)..T,
            Complex.normSq (partialZeta (Real.sqrt (t / (2 * Real.pi)))
              (1/2 + Complex.I * ↑t))) := by
    funext T
    congr 1
    ext t
    exact norm_sq_partial_sum_eq_partialZeta t
  rw [hEq]
  exact mean_square_partial_zeta_asymp

/-
The norm of the Hardy Z function equals the norm of zeta on the critical line.
-/
theorem norm_hardyZ_eq_norm_zeta (t : ℝ) :
    hardyZ t = ‖riemannZeta (1 / 2 + t * Complex.I)‖ := by
  rfl

/-- **Atomic sorry**: Hardy-Littlewood mean value theorem for |ζ(1/2+it)|².

MATHEMATICAL CONTENT:
  ∫₁ᵀ |ζ(1/2+it)|² dt = T·log T + (2γ-1-log 2π)·T + O(T^{1/2+ε}).
  In particular, ∫₁ᵀ |ζ(1/2+it)|² dt ≥ c·T·log T for large T.

PROOF SKETCH:
1. AFE: ζ(1/2+it) = ∑_{n≤N} n^{-1/2-it} + χ(1/2+it)·∑ n^{-1/2+it} + O(t^{-1/4})
2. |ζ|² = 2|S_N|² + oscillatory cross terms + O(T^{3/4})
3. ∫|S_N|² = T·∑ 1/n + off-diag = T·(½ log T + γ) + O(T^{1/2})
4. Oscillatory ∫Re(S·conj(χS̄)) = O(T) by rapid phase change
5. Total: ∫|ζ|² = T·log T + O(T) ≥ c·T·log T

NOTE: V4's approx_functional_eq is VACUOUS (proves RHS ≤ 0 ≤ LHS) and cannot
be used to establish this bound. A genuine AFE comparison is needed.

REFERENCES: Hardy-Littlewood (1918); Titchmarsh, §7.2, Theorem 7.2. -/
theorem zeta_critical_mean_value_lower :
    ∃ c > 0, ∃ T₁ ≥ (2 : ℝ), ∀ T : ℝ, T ≥ T₁ →
      ∫ t in Set.Ioc 1 T, (hardyZ t)^2 ≥ c * T * Real.log T := by
  sorry

/-- The mean square of Z(t) on [1,T] is lower bounded by k times the
partial sum mean square minus a linear error.

PROOF: From the MVT (∫Z² ≥ c₀·T·log T) and the Θ upper bound
(∫|S_N|² ≤ C_up·T·log T), choose k = c₀/(C_up+1). Then
  k·∫|S_N|² ≤ k·C_up·T·log T ≤ c₀·T·log T ≤ ∫Z². -/
theorem approx_functional_eq :
    ∃ k > 0, ∃ C ≥ 0, ∃ T₁ ≥ 2, ∀ T : ℝ, T ≥ T₁ →
      ∫ t in Set.Ioc 1 T, (hardyZ t)^2 ≥
        (k * ∫ t in Set.Ioc 1 T, ‖partial_sum_approx t‖^2) - C * T := by
  -- Step 1: MVT lower bound
  obtain ⟨c₀, hc₀, T_mvt, hT_mvt, h_mvt⟩ := zeta_critical_mean_value_lower
  -- Step 2: Θ upper bound on ∫|S|²
  obtain ⟨C_up, hCup, hCup_wit⟩ := partial_sum_approx_mean_square_asymp.1.exists_pos
  rw [IsBigOWith] at hCup_wit
  obtain ⟨T_up, hT_up⟩ := Filter.eventually_atTop.mp hCup_wit
  -- Step 3: choose k, C, T₁
  refine ⟨c₀ / (C_up + 1), div_pos hc₀ (by linarith), 0, le_refl 0,
    max (max T_mvt T_up) 2, le_max_right _ _, fun T hT => ?_⟩
  simp only [zero_mul, sub_zero]
  have hT_mvt' : T ≥ T_mvt :=
    le_trans (le_trans (le_max_left _ _) (le_max_left _ _)) hT
  have hT_up' : T ≥ T_up :=
    le_trans (le_trans (le_max_right T_mvt T_up) (le_max_left _ _)) hT
  have hT1 : T ≥ 1 := by linarith [show T ≥ 2 from le_trans (le_max_right _ _) hT]
  have hlog : Real.log T > 0 :=
    Real.log_pos (by linarith [show T ≥ 2 from le_trans (le_max_right _ _) hT])
  have hTlog : T * Real.log T > 0 := mul_pos (by linarith) hlog
  -- Step 4: MVT gives ∫Z² ≥ c₀·T·log T
  have h_lower := h_mvt T hT_mvt'
  -- Step 5: upper bound ∫|S|² ≤ C_up · T · log T
  have h_up := hT_up T hT_up'
  simp only at h_up
  have h_int_nn : 0 ≤ ∫ t in (1 : ℝ)..T, ‖partial_sum_approx t‖ ^ 2 := by
    rw [intervalIntegral.integral_of_le hT1]
    exact setIntegral_nonneg measurableSet_Ioc (fun _ _ => sq_nonneg _)
  rw [Real.norm_of_nonneg h_int_nn, Real.norm_of_nonneg (le_of_lt hTlog)] at h_up
  rw [intervalIntegral.integral_of_le hT1] at h_up
  -- h_up : ∫ Ioc 1 T, ‖S‖² ≤ C_up * (T * log T)
  -- Step 6: chain
  calc ∫ t in Set.Ioc 1 T, (hardyZ t) ^ 2
      ≥ c₀ * T * Real.log T := h_lower
    _ ≥ c₀ / (C_up + 1) * (C_up * (T * Real.log T)) := by
        suffices c₀ / (C_up + 1) * C_up ≤ c₀ by nlinarith
        rw [div_mul_eq_mul_div, div_le_iff₀ (show (0 : ℝ) < C_up + 1 by linarith)]
        nlinarith
    _ ≥ c₀ / (C_up + 1) * ∫ t in Set.Ioc 1 T, ‖partial_sum_approx t‖ ^ 2 :=
        mul_le_mul_of_nonneg_left h_up (le_of_lt (div_pos hc₀ (by linarith)))

end HardyApproxFunctional
