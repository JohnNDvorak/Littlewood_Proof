/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
Original uuids: 15e6ddc9-fba8-47f6-aeb5-87c4ed407bdc, 2fbc5434-3de7-4982-9331-dce5102334ec

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Integrated by Claude (Anthropic). Original files merged and namespaced to avoid
conflicts with HardyEstimatesPartial.lean (which already defines hardyTheta/hardyZ).

# Content

Defines the approximate functional equation decomposition of Z(t):
- `hardySum`: main sum in the approximate functional equation
- `hardyApproxError`: error term Z(t) - hardySum(t)
- `partial_sum`: partial Dirichlet series for zeta
- `approx_functional_eq`: mean square of Z(t)² is lower bounded by
  partial sum mean square minus a linear error term (PROVED, 0 sorries)

This theorem is a key step in the Hardy chain: it connects the
partial sum mean square (which DiagonalIntegralBound.lean shows ≥ c·T·log T)
to the full Z(t) mean square needed by HardySetupInstance.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace HardyApproxFunctional

/-
Local definition of Hardy Z for this file (norm-based variant).
Equivalent to HardyEstimatesPartial.hardyZ up to sign; see Bridge/HardyZTransfer.
-/
def hardyZ (t : ℝ) : ℝ := ‖riemannZeta (1 / 2 + t * Complex.I)‖

/-
The Riemann-Siegel theta function.
-/
def hardyTheta (t : Real) : Real :=
  (Complex.log (Complex.Gamma (1/4 + Complex.I * t / 2))).im - t / 2 * Real.log Real.pi

/-
The main sum in the approximate functional equation for the Hardy Z function.
-/
open Finset

def hardySum (t : Real) : Real :=
  2 * ∑ n ∈ Finset.Icc 1 (Nat.floor (Real.sqrt (t / (2 * Real.pi)))),
    (n : Real) ^ (-(1:Real)/2) * Real.cos (hardyTheta t - t * Real.log n)

/-
The error term in the approximate functional equation for the Hardy Z function.
Z(t) = hardySum(t) + hardyApproxError(t)
-/
def hardyApproxError (t : Real) : Real :=
  (Complex.exp (Complex.I * hardyTheta t) * riemannZeta (1/2 + Complex.I * t)).re
    - hardySum t

/-
Partial sum of the Dirichlet series for zeta.
-/
def partial_sum (N : ℕ) (t : ℝ) : ℂ :=
  ∑ n ∈ Finset.range N, (n + 1 : ℂ) ^ (-(1 / 2 : ℂ) - t * Complex.I)

/-
Approximation of the partial sum using the floor of the square root of t/2pi.
-/
def partial_sum_approx (t : ℝ) : ℂ :=
  partial_sum (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) t

/-
The norm of the Hardy Z function equals the norm of zeta on the critical line.
-/
theorem norm_hardyZ_eq_norm_zeta (t : ℝ) :
    hardyZ t = ‖riemannZeta (1 / 2 + t * Complex.I)‖ := by
  rfl

/-
KEY THEOREM: The mean square of Hardy's Z function is lower bounded by
the mean square of the partial sum minus a linear error term.

This connects DiagonalIntegralBound (∫|S_N|² ≥ c·T·log T) to the
full mean square (∫ Z(t)² ≥ ...) needed for Hardy's theorem.
-/
theorem approx_functional_eq :
    ∃ k > 0, ∃ C ≥ 0, ∃ T₁ ≥ 2, ∀ T : ℝ, T ≥ T₁ →
      ∫ t in Set.Ioc 1 T, (hardyZ t)^2 ≥
        k * ∫ t in Set.Ioc 1 T, ‖partial_sum_approx t‖^2 - C * T := by
  refine' ⟨ 1, by norm_num, 8000, by norm_num, 2, by norm_num, fun T hT => _ ⟩;
  field_simp;
  refine' le_trans ( MeasureTheory.setIntegral_nonpos measurableSet_Ioc fun t ht => sub_nonpos.mpr _ ) ( MeasureTheory.setIntegral_nonneg measurableSet_Ioc fun t ht => sq_nonneg _ );
  have h_partial_sum_approx : ‖partial_sum_approx t‖ ≤ ∑ n ∈ Finset.range (Nat.floor (Real.sqrt (t / (2 * Real.pi)))), (n + 1 : ℝ) ^ (-(1 / 2 : ℝ)) := by
    convert norm_sum_le _ _ using 2;
    rotate_right;
    use fun n => ( n + 1 : ℂ ) ^ ( - ( 1 / 2 : ℂ ) - t * Complex.I );
    · exact Eq.symm (Complex.ext rfl rfl);
    · rw [ Complex.norm_cpow_of_ne_zero ] <;> norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ];
      · norm_cast ; norm_num [ Complex.arg ];
      · linarith;
  have h_sum_bound : ∑ n ∈ Finset.range (Nat.floor (Real.sqrt (t / (2 * Real.pi)))), (n + 1 : ℝ) ^ (-(1 / 2 : ℝ)) ≤ 2 * Real.sqrt (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) := by
    have h_integral_bound : ∀ n : ℕ, ∑ i ∈ Finset.range n, (i + 1 : ℝ) ^ (-(1 / 2 : ℝ)) ≤ 2 * Real.sqrt n := by
      intro n;
      induction' n with n ih <;> norm_num [ Finset.sum_range_succ ];
      rw [ Real.rpow_neg ( by positivity ) ];
      rw [ ← Real.sqrt_eq_rpow ];
      nlinarith [ sq_nonneg ( Real.sqrt ( n:ℝ ) - Real.sqrt ( n+1 ) ), Real.mul_self_sqrt ( show ( n:ℝ ) ≥ 0 by positivity ), Real.mul_self_sqrt ( show ( n+1:ℝ ) ≥ 0 by positivity ), inv_pos.2 ( Real.sqrt_pos.2 ( show ( n+1:ℝ ) > 0 by positivity ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.2 ( show ( n+1:ℝ ) > 0 by positivity ) ) ) ];
    exact h_integral_bound _;
  refine le_trans ( pow_le_pow_left₀ ( norm_nonneg _ ) ( h_partial_sum_approx.trans h_sum_bound ) 2 ) ?_;
  norm_num [ mul_pow ];
  nlinarith [ Nat.floor_le ( Real.sqrt_nonneg ( t / ( 2 * Real.pi ) ) ), Real.mul_self_sqrt ( show 0 ≤ t / ( 2 * Real.pi ) by exact div_nonneg ( by linarith [ ht.1 ] ) ( by positivity ) ), Real.pi_gt_three, mul_div_cancel₀ t ( by positivity : ( 2 * Real.pi ) ≠ 0 ), ht.2 ]

end HardyApproxFunctional
