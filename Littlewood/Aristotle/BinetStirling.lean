/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 20848760-c3b6-42f0-a1ab-ae95894bda0f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Riemann-Siegel theta function Œ∏(t) = arg(Œì(1/4 + it/2)) - (t/2) log œÄ.
-/
noncomputable def riemannSiegelTheta (t : ‚Ñù) : ‚Ñù :=
  Complex.arg (Complex.Gamma (1/4 + (t / 2) * Complex.I)) - (t / 2) * Real.log Real.pi

/-
Asymptotic behavior of log(1+z) - z near 0 is O(z^2).
-/
open Asymptotics Filter Complex Topology

lemma log_one_add_sub_self_asymptotic :
    (fun z : ‚ÑÇ => log (1 + z) - z) =O[ùìù 0] (fun z => z ^ 2) :=
  log_sub_self_isBigO

/-
Asymptotic behavior of log(1 + 1/(2it)) - 1/(2it) as t ‚Üí ‚àû is O(1/t^2).
-/
open Asymptotics Filter Complex Topology

lemma log_one_add_inv_im_asymptotic :
    (fun t : ‚Ñù => log (1 + 1 / (2 * I * t)) - 1 / (2 * I * t)) =O[atTop] (fun t => 1 / t ^ 2) := by
  -- Pointwise bound from norm_log_one_add_sub_self_le with z = 1/(2it)
  rw [Asymptotics.isBigO_iff]
  refine ‚ü®1, ?_‚ü©
  filter_upwards [Filter.eventually_ge_atTop (1 : ‚Ñù)] with t ht
  have ht_pos : (0 : ‚Ñù) < t := by linarith
  set z : ‚ÑÇ := 1 / (2 * I * ‚Üët) with hz_def
  -- ‚Äñz‚Äñ = 1/(2t)
  have hz_norm : ‚Äñz‚Äñ = 1 / (2 * t) := by
    simp only [hz_def, norm_div, norm_one, norm_mul, norm_mul,
               Complex.norm_two, Complex.norm_I, mul_one, Complex.norm_real,
               Real.norm_eq_abs, abs_of_pos ht_pos]
  have hz_lt : ‚Äñz‚Äñ < 1 := by
    rw [hz_norm, div_lt_one (by positivity : (0:‚Ñù) < 2 * t)]; linarith
  have hz_half : ‚Äñz‚Äñ ‚â§ 1 / 2 := by
    rw [hz_norm, div_le_div_iff‚ÇÄ (by positivity : (0:‚Ñù) < 2 * t) two_pos]; linarith
  -- Apply the pointwise bound: ‚Äñlog(1+z) - z‚Äñ ‚â§ ‚Äñz‚Äñ¬≤ * (1-‚Äñz‚Äñ)‚Åª¬π / 2
  have hbound := norm_log_one_add_sub_self_le hz_lt
  -- (1 - ‚Äñz‚Äñ)‚Åª¬π ‚â§ 2 since ‚Äñz‚Äñ ‚â§ 1/2
  have h_inv : (1 - ‚Äñz‚Äñ)‚Åª¬π ‚â§ 2 := by
    rw [inv_le_comm‚ÇÄ (by linarith [norm_nonneg z]) (by positivity)]
    linarith
  -- Chain: ‚Äñlog(1+z) - z‚Äñ ‚â§ ‚Äñz‚Äñ¬≤ ‚â§ 1/t¬≤ = 1 * ‚Äñ1/t¬≤‚Äñ
  calc ‚Äñlog (1 + z) - z‚Äñ
      ‚â§ ‚Äñz‚Äñ ^ 2 * (1 - ‚Äñz‚Äñ)‚Åª¬π / 2 := hbound
    _ ‚â§ ‚Äñz‚Äñ ^ 2 * 2 / 2 := by gcongr
    _ = ‚Äñz‚Äñ ^ 2 := by ring
    _ = (1 / (2 * t)) ^ 2 := by rw [hz_norm]
    _ ‚â§ (1 / t) ^ 2 := by
        apply pow_le_pow_left‚ÇÄ (by positivity)
        have : 1 / (2 * t) = 1 / 2 * (1 / t) := by ring
        rw [this]; linarith [div_pos one_pos ht_pos]
    _ = 1 / t ^ 2 := by rw [div_pow, one_pow]
    _ = 1 * ‚Äñ(1 : ‚Ñù) / t ^ 2‚Äñ := by
        rw [one_mul, Real.norm_eq_abs, abs_of_pos (div_pos one_pos (pow_pos ht_pos 2))]

/-
For large t, log(1/4 + it/2) = log(it/2) + log(1 + 1/(2it)).
-/
open Asymptotics Filter Complex Topology

lemma log_split_lemma :
    ‚àÄ·∂† (t : ‚Ñù) in atTop, log (1/4 + I * t / 2) = log (I * t / 2) + log (1 + 1 / (2 * I * t)) := by
  filter_upwards [Filter.eventually_ge_atTop (1 : ‚Ñù)] with t ht
  have ht_pos : (0 : ‚Ñù) < t := by linarith
  have ht_ne : (‚Üët : ‚ÑÇ) ‚â† 0 := ofReal_ne_zero.mpr (ne_of_gt ht_pos)
  have hIt_ne : (2 : ‚ÑÇ) * I * ‚Üët ‚â† 0 := mul_ne_zero (mul_ne_zero two_ne_zero I_ne_zero) ht_ne
  -- it/2 ‚â† 0
  have hx_ne : I * (‚Üët : ‚ÑÇ) / 2 ‚â† 0 :=
    div_ne_zero (mul_ne_zero I_ne_zero ht_ne) two_ne_zero
  -- 1/(2it) has Re = 0 and Im = -1/(2t)
  have h_inv_re : (1 / (2 * I * (‚Üët : ‚ÑÇ))).re = 0 := by
    rw [one_div, Complex.inv_re]
    have : (2 * I * (‚Üët : ‚ÑÇ)).re = 0 := by
      simp only [mul_re, I_re, I_im, ofReal_re, ofReal_im]; norm_num
    rw [this, zero_div]
  have h_inv_im : (1 / (2 * I * (‚Üët : ‚ÑÇ))).im = -(1 / (2 * t)) := by
    rw [one_div, Complex.inv_im]
    have h_im : (2 * I * (‚Üët : ‚ÑÇ)).im = 2 * t := by
      simp only [mul_im, mul_re, I_re, I_im, ofReal_re, ofReal_im]; norm_num
    have h_ns : Complex.normSq (2 * I * (‚Üët : ‚ÑÇ)) = (2 * t) ^ 2 := by
      simp only [map_mul, Complex.normSq_ofNat, Complex.normSq_I, mul_one,
                 Complex.normSq_ofReal]; ring
    rw [h_im, h_ns]
    have ht_ne' : (t : ‚Ñù) ‚â† 0 := ne_of_gt ht_pos
    field_simp
  have h_sum_re : (1 + 1 / (2 * I * (‚Üët : ‚ÑÇ))).re = 1 := by
    rw [add_re, one_re, h_inv_re, add_zero]
  -- 1 + 1/(2it) ‚â† 0 since Re = 1
  have hy_ne : (1 : ‚ÑÇ) + 1 / (2 * I * ‚Üët) ‚â† 0 := by
    intro h; rw [h] at h_sum_re; simp at h_sum_re
  -- Im(1 + 1/(2it)) = -1/(2t) < 0
  have h_sum_im : (1 + 1 / (2 * I * (‚Üët : ‚ÑÇ))).im < 0 := by
    rw [add_im, one_im, zero_add, h_inv_im]; linarith [div_pos one_pos (by positivity : (0:‚Ñù) < 2 * t)]
  -- arg(it/2) = œÄ/2
  have h_arg_x : arg (I * ‚Üët / 2) = Real.pi / 2 := by
    rw [show I * (‚Üët : ‚ÑÇ) / 2 = (‚Üë(t / 2 : ‚Ñù) : ‚ÑÇ) * I from by push_cast; ring]
    rw [arg_real_mul I (show (0 : ‚Ñù) < t / 2 from by positivity)]
    exact arg_I
  -- arg(1 + 1/(2it)) < 0, and > -œÄ
  have h_arg_y_neg : arg (1 + 1 / (2 * I * (‚Üët : ‚ÑÇ))) < 0 := arg_neg_iff.mpr h_sum_im
  -- arg sum ‚àà (-œÄ, œÄ]
  have h_arg_sum : arg (I * ‚Üët / 2) + arg (1 + 1 / (2 * I * (‚Üët : ‚ÑÇ))) ‚àà Set.Ioc (-Real.pi) Real.pi := by
    rw [h_arg_x]
    exact ‚ü®by linarith [neg_pi_lt_arg (1 + 1 / (2 * I * (‚Üët : ‚ÑÇ))), Real.pi_pos],
           by linarith [Real.pi_pos]‚ü©
  -- Factor and apply log_mul
  have h_factor : (1/4 : ‚ÑÇ) + I * ‚Üët / 2 = (I * ‚Üët / 2) * (1 + 1 / (2 * I * ‚Üët)) := by
    field_simp; ring
  rw [h_factor]
  exact Complex.log_mul hx_ne hy_ne h_arg_sum

/-
Asymptotic expansion of log(1/4 + it/2) is log(t/2) + i*pi/2 - i/(2t) + O(1/t^2).
-/
open Asymptotics Filter Complex Topology

lemma log_quarter_plus_it_half_asymptotic :
    (fun t : ‚Ñù => log (1/4 + I * t / 2) - (log (t / 2) + I * (Real.pi / 2) - I / (2 * t)))
    =O[atTop] (fun t => 1 / t ^ 2) := by
  -- The LHS is eventually equal to log(1+1/(2it)) - 1/(2it)
  have h_evt : ‚àÄ·∂† (t : ‚Ñù) in atTop,
      log (1/4 + I * ‚Üët / 2) - (log (‚Üët / 2) + I * (‚ÜëReal.pi / 2) - I / (2 * ‚Üët)) =
      log (1 + 1 / (2 * I * ‚Üët)) - 1 / (2 * I * ‚Üët) := by
    filter_upwards [log_split_lemma, Filter.eventually_ge_atTop (1 : ‚Ñù)] with t h_split ht
    have ht_pos : (0 : ‚Ñù) < t := by linarith
    have ht_ne : (‚Üët : ‚ÑÇ) ‚â† 0 := ofReal_ne_zero.mpr (ne_of_gt ht_pos)
    -- log(it/2) = Real.log(t/2) + (œÄ/2)*I
    have h_log_it : log (I * ‚Üët / 2) = ‚Üë(Real.log (t / 2)) + ‚ÜëReal.pi / 2 * I := by
      rw [show I * (‚Üët : ‚ÑÇ) / 2 = ‚Üë(t / 2 : ‚Ñù) * I from by push_cast; ring]
      rw [log_ofReal_mul (by positivity : (0:‚Ñù) < t / 2) I_ne_zero, log_I]
    -- I/(2t) = -(1/(2it))
    have h_inv : I / (2 * (‚Üët : ‚ÑÇ)) = -(1 / (2 * I * ‚Üët)) := by
      have : (2 : ‚ÑÇ) * I * ‚Üët ‚â† 0 := mul_ne_zero (mul_ne_zero two_ne_zero I_ne_zero) ht_ne
      have : (2 : ‚ÑÇ) * ‚Üët ‚â† 0 := mul_ne_zero two_ne_zero ht_ne
      field_simp; rw [I_sq]
    rw [h_split, h_log_it]
    rw [show (‚Üët : ‚ÑÇ) / 2 = ‚Üë(t / 2 : ‚Ñù) from by push_cast; ring]
    rw [(Complex.ofReal_log (le_of_lt (by positivity : (0:‚Ñù) < t / 2))).symm]
    rw [h_inv]; ring
  exact log_one_add_inv_im_asymptotic.congr' (h_evt.mono fun _ h => h.symm)
    (Filter.Eventually.of_forall fun _ => rfl)

/-
The imaginary part of the Stirling approximation term has the asymptotic expansion (t/2) log(t/2) - t/2 - pi/8 + O(1/t).
-/
open Asymptotics Filter Complex Topology

noncomputable def stirlingApprox (t : ‚Ñù) : ‚ÑÇ :=
  (1/4 + I * t / 2 - 1/2) * log (1/4 + I * t / 2) - (1/4 + I * t / 2) + (1/2) * log (2 * Real.pi)

lemma stirling_approx_im_asymptotic :
    (fun t => (stirlingApprox t).im - ((t / 2) * Real.log (t / 2) - t / 2 - Real.pi / 8)) =O[atTop] (fun t => 1 / t) := by
  obtain ‚ü®C‚ÇÄ, hC‚ÇÄ‚ü© := log_quarter_plus_it_half_asymptotic.bound
  apply Asymptotics.IsBigO.of_bound (C‚ÇÄ + 1)
  filter_upwards [hC‚ÇÄ, Filter.eventually_ge_atTop (1 : ‚Ñù)] with t hEt ht
  have ht_pos : (0 : ‚Ñù) < t := by linarith
  have ht_ne : (t : ‚Ñù) ‚â† 0 := ne_of_gt ht_pos
  -- Abbreviations
  set s : ‚ÑÇ := 1/4 + I * ‚Üët / 2
  set coeff : ‚ÑÇ := s - 1/2
  set L : ‚ÑÇ := ‚Üë(Real.log (t / 2)) + I * (‚ÜëReal.pi / 2) - I / (2 * ‚Üët)
  set E : ‚ÑÇ := Complex.log s - L
  -- Express coeff in canonical ‚Üëa + ‚Üëb * I form for re/im extraction
  have h_coeff_form : coeff = ‚Üë(-1/4 : ‚Ñù) + ‚Üë(t/2) * I := by
    simp only [coeff, s]; push_cast; ring
  have h_s_form : s = ‚Üë(1/4 : ‚Ñù) + ‚Üë(t/2) * I := by
    simp only [s]; push_cast; ring
  have h_L_form : L = ‚Üë(Real.log (t / 2)) + ‚Üë(Real.pi / 2 - 1 / (2 * t)) * I := by
    simp only [L]; push_cast; field_simp; ring
  -- Re/Im of coeff
  have h_coeff_re : coeff.re = -1/4 := by
    rw [h_coeff_form, add_re, ofReal_re, mul_re, ofReal_re, ofReal_im, I_re, I_im]; ring
  have h_coeff_im : coeff.im = t / 2 := by
    rw [h_coeff_form, add_im, ofReal_im, mul_im, ofReal_re, ofReal_im, I_re, I_im]; ring
  -- Im of s
  have h_s_im : s.im = t / 2 := by
    rw [h_s_form, add_im, ofReal_im, mul_im, ofReal_re, ofReal_im, I_re, I_im]; ring
  -- Re/Im of L
  have h_L_re : L.re = Real.log (t / 2) := by
    rw [h_L_form, add_re, ofReal_re, mul_re, ofReal_re, ofReal_im, I_re, I_im]; ring
  have h_L_im : L.im = Real.pi / 2 - 1 / (2 * t) := by
    rw [h_L_form, add_im, ofReal_im, mul_im, ofReal_re, ofReal_im, I_re, I_im]; ring
  -- Convert Complex.log(‚Üët/2) = ‚Üë(Real.log(t/2)) for matching with hEt
  have h_log_cv : log ((‚Üët : ‚ÑÇ) / 2) = ‚Üë(Real.log (t / 2)) := by
    rw [show (‚Üët : ‚ÑÇ) / 2 = ‚Üë(t / 2 : ‚Ñù) from by push_cast; ring]
    exact (ofReal_log (le_of_lt (by positivity : (0:‚Ñù) < t / 2))).symm
  -- The key algebraic identity
  have h_diff : (stirlingApprox t).im - ((t / 2) * Real.log (t / 2) - t / 2 - Real.pi / 8) =
      1 / (8 * t) + (coeff * E).im := by
    have h_log_2pi : log ((2 : ‚ÑÇ) * ‚ÜëReal.pi) = ‚Üë(Real.log (Real.pi * 2)) := by
      rw [show (2 : ‚ÑÇ) * ‚ÜëReal.pi = ‚Üë(Real.pi * 2 : ‚Ñù) from by push_cast; ring]
      exact (ofReal_log (by positivity : (0:‚Ñù) ‚â§ Real.pi * 2)).symm
    have h_stir_eq : stirlingApprox t = coeff * Complex.log s - s +
        (1/2) * ‚Üë(Real.log (Real.pi * 2)) := by
      unfold stirlingApprox; simp only [coeff, s]; rw [h_log_2pi]
    have h_log_eq : Complex.log s = L + E := by simp only [E]; ring
    -- Express (stirlingApprox t).im in terms of pieces
    have h1 : (stirlingApprox t).im = (coeff * L).im + (coeff * E).im - s.im := by
      rw [h_stir_eq, h_log_eq, mul_add]
      have : ((1/2 : ‚ÑÇ) * ‚Üë(Real.log (Real.pi * 2))).im = 0 := by
        rw [show (1/2 : ‚ÑÇ) * ‚Üë(Real.log (Real.pi * 2)) =
          ‚Üë((1/2 : ‚Ñù) * Real.log (Real.pi * 2)) from by push_cast; ring]
        exact ofReal_im _
      simp only [add_im, sub_im, this, add_zero]
    -- Compute (coeff * L).im via mul_im
    have h2 : (coeff * L).im =
        (-1/4) * (Real.pi / 2 - 1 / (2 * t)) + (t / 2) * Real.log (t / 2) := by
      rw [mul_im, h_coeff_re, h_coeff_im, h_L_re, h_L_im]
    rw [h1, h2, h_s_im]; ring
  -- Bound: |1/(8t) + Im(coeff*E)| ‚â§ (C‚ÇÄ+1) * |1/t|
  rw [h_diff, Real.norm_eq_abs, Real.norm_eq_abs]
  -- |(coeff * E).im| ‚â§ ‚Äñcoeff‚Äñ * ‚ÄñE‚Äñ
  have h_imE : |(coeff * E).im| ‚â§ ‚Äñcoeff‚Äñ * ‚ÄñE‚Äñ :=
    le_trans (Complex.abs_im_le_norm _) (norm_mul_le coeff E)
  -- ‚Äñcoeff‚Äñ ‚â§ t
  have h_coeff_norm : ‚Äñcoeff‚Äñ ‚â§ t := by
    rw [h_coeff_form]
    have h1 : ‚Äñ(‚Üë(-1/4 : ‚Ñù) : ‚ÑÇ)‚Äñ = 1/4 := by
      rw [norm_real, Real.norm_eq_abs]; norm_num
    have h2 : ‚Äñ(‚Üë(t/2 : ‚Ñù) : ‚ÑÇ) * I‚Äñ = t/2 := by
      rw [norm_mul, norm_real, Complex.norm_I, mul_one, Real.norm_eq_abs,
          abs_of_pos (by positivity : (0:‚Ñù) < t/2)]
    calc ‚Äñ‚Üë(-1/4 : ‚Ñù) + ‚Üë(t/2) * I‚Äñ
        ‚â§ ‚Äñ(‚Üë(-1/4 : ‚Ñù) : ‚ÑÇ)‚Äñ + ‚Äñ‚Üë(t/2 : ‚Ñù) * I‚Äñ := norm_add_le _ _
      _ = 1/4 + t/2 := by rw [h1, h2]
      _ ‚â§ t := by linarith
  -- ‚ÄñE‚Äñ ‚â§ C‚ÇÄ/t¬≤
  have h_E_bound : ‚ÄñE‚Äñ ‚â§ C‚ÇÄ / t ^ 2 := by
    have h_E_eq : ‚ÄñE‚Äñ = ‚Äñlog s - (log (‚Üët / 2) + I * (‚ÜëReal.pi / 2) - I / (2 * ‚Üët))‚Äñ := by
      congr 1; simp only [E, L, h_log_cv]
    rw [h_E_eq]
    calc ‚Äñlog s - (log (‚Üët / 2) + I * (‚ÜëReal.pi / 2) - I / (2 * ‚Üët))‚Äñ
        ‚â§ C‚ÇÄ * ‚Äñ(1 : ‚Ñù) / t ^ 2‚Äñ := hEt
      _ = C‚ÇÄ / t ^ 2 := by
          rw [Real.norm_eq_abs, abs_of_pos (by positivity : (0:‚Ñù) < 1 / t ^ 2)]; ring
  -- Combine
  calc |1 / (8 * t) + (coeff * E).im|
      ‚â§ |1 / (8 * t)| + |(coeff * E).im| := abs_add_le _ _
    _ ‚â§ 1 / (8 * t) + ‚Äñcoeff‚Äñ * ‚ÄñE‚Äñ :=
        add_le_add (le_of_eq (abs_of_pos (by positivity))) h_imE
    _ ‚â§ 1 / (8 * t) + t * (C‚ÇÄ / t ^ 2) := by gcongr
    _ = 1 / (8 * t) + C‚ÇÄ / t := by congr 1; field_simp
    _ ‚â§ 1 / t + C‚ÇÄ / t := by
        have : 1 / (8 * t) ‚â§ 1 / t := one_div_le_one_div_of_le ht_pos (by linarith)
        linarith
    _ = (C‚ÇÄ + 1) * (1 / t) := by ring
    _ = (C‚ÇÄ + 1) * |1 / t| := by rw [abs_of_pos (by positivity)]

/-
Definitions of the Binet integrand and Binet integral.
-/
open Asymptotics Filter Complex Topology

noncomputable def binetIntegrand (t : ‚Ñù) : ‚Ñù :=
  (1 / 2 - 1 / t + 1 / (Real.exp t - 1)) / t

noncomputable def binetIntegral (z : ‚ÑÇ) : ‚ÑÇ :=
  ‚à´ t in Set.Ioi 0, binetIntegrand t * Complex.exp (-t * z)

/-
The limit of the Binet integrand as t approaches 0 from the right is 1/12.
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_limit_zero :
    Tendsto binetIntegrand (ùìù[>] 0) (ùìù (1 / 12)) := by
  -- Strategy: show |binetIntegrand t - 1/12| ‚â§ t for 0 < t ‚â§ 1 using Taylor bounds.
  -- Key identity: binetIntegrand t - 1/12 = G/(12t¬≤(e^t-1)) where
  -- G = (6t-t¬≤-12)(e^t-1)+12t = (6t-t¬≤-12)¬∑R + t‚Å¥/2 - t‚Åµ/6
  -- with R = e^t - 1 - t - t¬≤/2 - t¬≥/6 (4th-order Taylor remainder).
  -- Bound: |G| ‚â§ t‚Å¥ and 12t¬≤(e^t-1) ‚â• 12t¬≥, so the ratio ‚â§ t/12 ‚â§ t.
  rw [Metric.tendsto_nhdsWithin_nhds]
  intro Œµ hŒµ
  refine ‚ü®min 1 Œµ, by positivity, fun t ht_mem ht_dist => ?_‚ü©
  simp only [Set.mem_Ioi] at ht_mem
  rw [Real.dist_eq, sub_zero, abs_of_pos ht_mem] at ht_dist
  rw [Real.dist_eq]
  have ht1 : t ‚â§ 1 := le_of_lt (lt_of_lt_of_le ht_dist (min_le_left _ _))
  have htŒµ : t < Œµ := lt_of_lt_of_le ht_dist (min_le_right _ _)
  have ht_pos : (0 : ‚Ñù) < t := ht_mem
  have ht_ne : t ‚â† 0 := ne_of_gt ht_pos
  have hexp_sub_pos : 0 < Real.exp t - 1 := by linarith [Real.add_one_le_exp t]
  have hexp_sub_ne : Real.exp t - 1 ‚â† 0 := ne_of_gt hexp_sub_pos
  -- Suffices: |binetIntegrand t - 1/12| ‚â§ t < Œµ
  suffices h : |binetIntegrand t - 1 / 12| ‚â§ t by linarith
  -- Taylor remainder: R = exp t - (1 + t + t¬≤/2 + t¬≥/6)
  set R := Real.exp t - (1 + t + t ^ 2 / 2 + t ^ 3 / 6) with hR_def
  -- Evaluate ‚àë i in range 4, t^i/i!
  have h_sum4 : ‚àë i ‚àà Finset.range 4, t ^ i / ‚Üë(Nat.factorial i) =
      1 + t + t ^ 2 / 2 + t ^ 3 / 6 := by
    simp only [Finset.sum_range_succ, Finset.sum_range_zero, Nat.factorial]
    push_cast; ring
  -- R ‚â• 0 (Taylor partial sums are lower bounds for exp)
  have hR_nonneg : 0 ‚â§ R := by
    rw [hR_def, sub_nonneg, ‚Üê h_sum4]
    exact Real.sum_le_exp_of_nonneg (le_of_lt ht_pos) 4
  -- R ‚â§ 5t‚Å¥/96 (Taylor remainder upper bound)
  have hR_upper : R ‚â§ 5 / 96 * t ^ 4 := by
    have h_bound := Real.exp_bound (show |t| ‚â§ 1 by rwa [abs_of_pos ht_pos])
      (show (0 : ‚Ñï) < 4 by norm_num)
    rw [h_sum4, abs_of_pos ht_pos] at h_bound
    have hR_abs : |R| ‚â§ t ^ 4 * (Nat.succ 4 / (‚Üë(Nat.factorial 4) * 4)) := h_bound
    rw [abs_of_nonneg hR_nonneg] at hR_abs
    convert hR_abs using 1
    simp [Nat.factorial]; ring
  -- Algebraic identity: binetIntegrand t - 1/12 = G/(12t¬≤(e^t-1))
  have h_diff : binetIntegrand t - 1 / 12 =
      ((6 * t - t ^ 2 - 12) * (Real.exp t - 1) + 12 * t) /
        (12 * t ^ 2 * (Real.exp t - 1)) := by
    unfold binetIntegrand; field_simp; ring
  -- Rewrite G = (6t-t¬≤-12)¬∑R + t‚Å¥/2 - t‚Åµ/6
  have h_G_eq : (6 * t - t ^ 2 - 12) * (Real.exp t - 1) + 12 * t =
      (6 * t - t ^ 2 - 12) * R + (t ^ 4 / 2 - t ^ 5 / 6) := by
    rw [show Real.exp t - 1 = t + t ^ 2 / 2 + t ^ 3 / 6 + R from by rw [hR_def]; ring]
    ring
  rw [h_diff, h_G_eq]
  -- Goal: |G / (12t¬≤(e^t-1))| ‚â§ t
  rw [abs_div, abs_of_pos (show (0:‚Ñù) < 12 * t ^ 2 * (Real.exp t - 1) by positivity),
      div_le_iff‚ÇÄ (show (0:‚Ñù) < 12 * t ^ 2 * (Real.exp t - 1) by positivity)]
  -- Goal: |G| ‚â§ t * (12t¬≤(e^t-1))
  -- Bound |G| ‚â§ t‚Å¥
  have h_coeff_neg : 6 * t - t ^ 2 - 12 ‚â§ 0 := by nlinarith [sq_nonneg t]
  have h_G_upper : (6 * t - t ^ 2 - 12) * R + (t ^ 4 / 2 - t ^ 5 / 6) ‚â§ t ^ 4 := by
    have : (6 * t - t ^ 2 - 12) * R ‚â§ 0 :=
      mul_nonpos_of_nonpos_of_nonneg h_coeff_neg hR_nonneg
    nlinarith [pow_nonneg (le_of_lt ht_pos) 4, pow_nonneg (le_of_lt ht_pos) 5]
  have h_G_lower : -(t ^ 4) ‚â§ (6 * t - t ^ 2 - 12) * R + (t ^ 4 / 2 - t ^ 5 / 6) := by
    have h_ge : -12 ‚â§ 6 * t - t ^ 2 - 12 := by nlinarith
    have h_prod := mul_le_mul_of_nonneg_right h_ge hR_nonneg
    -- h_prod : -12 * R ‚â§ (6*t - t^2 - 12) * R
    have h_Rbd := mul_le_mul_of_nonpos_left hR_upper (show (-12 : ‚Ñù) ‚â§ 0 by norm_num)
    -- h_Rbd : -12 * (5/96 * t^4) ‚â§ -12 * R, i.e., -(5/8)*t^4 ‚â§ -12*R
    nlinarith [pow_nonneg (le_of_lt ht_pos) 4]
  -- Conclude: |G| ‚â§ t‚Å¥ ‚â§ t * (12t¬≤(e^t-1))
  have h_G_abs : |(6 * t - t ^ 2 - 12) * R + (t ^ 4 / 2 - t ^ 5 / 6)| ‚â§ t ^ 4 :=
    abs_le.mpr ‚ü®h_G_lower, h_G_upper‚ü©
  have h_exp_ge_t : t ‚â§ Real.exp t - 1 := by linarith [Real.add_one_le_exp t]
  have h_rhs : t ^ 4 ‚â§ t * (12 * t ^ 2 * (Real.exp t - 1)) := by
    have := mul_le_mul_of_nonneg_left h_exp_ge_t (show (0:‚Ñù) ‚â§ 12 * t ^ 2 by positivity)
    nlinarith [pow_nonneg (le_of_lt ht_pos) 4]
  linarith

/-
The limit of the Binet integrand as t approaches infinity is 0.
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_limit_infinity :
    Tendsto binetIntegrand atTop (ùìù 0) := by
  -- binetIntegrand t = (1/2 - 1/t + 1/(e^t-1))/t ‚Üí (1/2)/‚àû = 0
  -- Strategy: bound |binetIntegrand t| ‚â§ 3/t for t ‚â• 1, and 3/t ‚Üí 0
  rw [Metric.tendsto_atTop]
  intro Œµ hŒµ
  refine ‚ü®max 1 (3 / Œµ), fun t ht => ?_‚ü©
  rw [Real.dist_eq, sub_zero]
  have ht1 : (1 : ‚Ñù) ‚â§ t := le_trans (le_max_left 1 (3 / Œµ)) ht
  have ht_pos : (0 : ‚Ñù) < t := lt_of_lt_of_le one_pos ht1
  -- Bound the numerator of binetIntegrand
  have h_exp_pos : Real.exp t - 1 > 0 := by
    have := Real.add_one_le_exp t
    linarith [Real.exp_pos t]
  have h_inv_t : 0 ‚â§ 1 / t := by positivity
  have h_inv_t_le : 1 / t ‚â§ 1 := by rw [div_le_one ht_pos]; linarith
  have h_inv_exp : 0 < 1 / (Real.exp t - 1) := by positivity
  have h_inv_exp_le : 1 / (Real.exp t - 1) ‚â§ 1 := by
    rw [div_le_one h_exp_pos]
    have := Real.add_one_le_exp t
    linarith
  have h_num_abs : |1 / 2 - 1 / t + 1 / (Real.exp t - 1)| ‚â§ 3 / 2 := by
    apply abs_le.mpr
    constructor
    ¬∑ linarith
    ¬∑ linarith
  unfold binetIntegrand
  rw [abs_div, abs_of_pos ht_pos]
  calc |1 / 2 - 1 / t + 1 / (Real.exp t - 1)| / t
      ‚â§ (3 / 2) / t := by gcongr
    _ < Œµ := by
        rw [div_lt_iff‚ÇÄ ht_pos]
        have h3e : 3 / Œµ ‚â§ t := le_trans (le_max_right 1 (3 / Œµ)) ht
        have h3 : 3 ‚â§ t * Œµ := (div_le_iff‚ÇÄ hŒµ).mp h3e
        linarith [mul_comm t Œµ]

/-
The Binet integrand is continuous on (0, ‚àû).
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_continuous :
    ContinuousOn binetIntegrand (Set.Ioi 0) := by
  unfold binetIntegrand
  refine ContinuousOn.div ?_ continuousOn_id (fun x hx => ne_of_gt hx)
  refine ContinuousOn.add ?_ ?_
  ¬∑ exact ContinuousOn.sub continuousOn_const (continuousOn_const.div continuousOn_id (fun x hx => ne_of_gt hx))
  ¬∑ refine ContinuousOn.div continuousOn_const ?_ ?_
    ¬∑ exact Real.continuous_exp.continuousOn.sub continuousOn_const
    ¬∑ intro x hx
      simp only [Set.mem_Ioi] at hx
      have : Real.exp x > 1 := Real.one_lt_exp_iff.mpr hx
      linarith

/-
The Binet integrand is differentiable on (0, ‚àû).
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_differentiable :
    DifferentiableOn ‚Ñù binetIntegrand (Set.Ioi 0) := by
  unfold binetIntegrand
  refine DifferentiableOn.div ?_ differentiableOn_id (fun x hx => ne_of_gt hx)
  refine DifferentiableOn.add ?_ ?_
  ¬∑ exact DifferentiableOn.sub (differentiableOn_const _)
      (DifferentiableOn.div (differentiableOn_const _) differentiableOn_id (fun x hx => ne_of_gt hx))
  ¬∑ refine DifferentiableOn.div (differentiableOn_const _) ?_ ?_
    ¬∑ exact differentiableOn_id.exp.sub (differentiableOn_const _)
    ¬∑ intro x hx
      simp only [Set.mem_Ioi] at hx
      have : Real.exp x > 1 := Real.one_lt_exp_iff.mpr hx
      linarith

/-
A function continuous on (0, infinity) with finite limits at 0 and infinity is bounded.
-/
open Asymptotics Filter Complex Topology

lemma bounded_of_continuous_limits {f : ‚Ñù ‚Üí ‚Ñù}
    (h_cont : ContinuousOn f (Set.Ioi 0))
    (h_zero : ‚àÉ L, Tendsto f (ùìù[>] 0) (ùìù L))
    (h_inf : ‚àÉ L, Tendsto f atTop (ùìù L)) :
    ‚àÉ M, ‚àÄ t ‚àà Set.Ioi 0, |f t| ‚â§ M := by
  obtain ‚ü®L‚ÇÄ, hL‚ÇÄ‚ü© := h_zero
  obtain ‚ü®Linf, hLinf‚ü© := h_inf
  -- Near 0
  obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ t ‚àà Set.Ioo 0 Œ¥, |f t| ‚â§ |L‚ÇÄ| + 1 := by
    have := Metric.tendsto_nhdsWithin_nhds.mp hL‚ÇÄ 1 one_pos
    obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© := this
    refine ‚ü®Œ¥, hŒ¥_pos, fun t ht => ?_‚ü©
    have := hŒ¥ ht.1 (by simp [abs_of_pos ht.1]; exact ht.2)
    rw [Real.dist_eq] at this
    have h_abs := abs_sub_abs_le_abs_sub (f t) L‚ÇÄ
    linarith
  -- Near infinity
  obtain ‚ü®T, hT_pos, hT‚ü© : ‚àÉ T > 0, ‚àÄ t ‚â• T, |f t| ‚â§ |Linf| + 1 := by
    have := Metric.tendsto_atTop.mp hLinf 1 one_pos
    obtain ‚ü®T, hT‚ü© := this
    refine ‚ü®max T 1, by positivity, fun t ht => ?_‚ü©
    have := hT t (le_trans (le_max_left _ _) ht)
    rw [Real.dist_eq] at this
    have h_abs := abs_sub_abs_le_abs_sub (f t) Linf
    linarith
  -- On compact middle region [Œ¥, T]
  have h_compact : IsCompact (Set.Icc Œ¥ T) := isCompact_Icc
  have h_cont_mid : ContinuousOn f (Set.Icc Œ¥ T) := h_cont.mono (fun x hx => by
    simp only [Set.mem_Ioi, Set.mem_Icc] at hx ‚ä¢; linarith)
  obtain ‚ü®M_mid, hM_mid‚ü© := h_compact.exists_bound_of_continuousOn h_cont_mid
  -- Combine bounds
  use max (|L‚ÇÄ| + 1) (max (|Linf| + 1) M_mid)
  intro t ht
  simp only [Set.mem_Ioi] at ht
  by_cases h1 : t < Œ¥
  ¬∑ exact le_trans (hŒ¥ t ‚ü®ht, h1‚ü©) (le_max_left _ _)
  ¬∑ by_cases h2 : t ‚â• T
    ¬∑ exact le_trans (hT t h2) (le_max_of_le_right (le_max_left _ _))
    ¬∑ have : t ‚àà Set.Icc Œ¥ T := ‚ü®not_lt.mp h1, le_of_lt (not_le.mp h2)‚ü©
      exact le_trans (hM_mid t this) (le_max_of_le_right (le_max_right _ _))

/-
The Binet integrand is bounded on (0, ‚àû).
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_bounded :
    ‚àÉ M, ‚àÄ t ‚àà Set.Ioi 0, |binetIntegrand t| ‚â§ M := by
  exact bounded_of_continuous_limits
    binet_integrand_continuous
    ‚ü®1/12, binet_integrand_limit_zero‚ü©
    ‚ü®0, binet_integrand_limit_infinity‚ü©

end
