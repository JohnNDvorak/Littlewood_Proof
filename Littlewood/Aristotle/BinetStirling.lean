/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 20848760-c3b6-42f0-a1ab-ae95894bda0f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The Riemann-Siegel theta function Œ∏(t) = arg(Œì(1/4 + it/2)) - (t/2) log œÄ.
-/
noncomputable def riemannSiegelTheta (t : ‚Ñù) : ‚Ñù :=
  Complex.arg (Complex.Gamma (1/4 + (t / 2) * Complex.I)) - (t / 2) * Real.log Real.pi

/-
Asymptotic behavior of log(1+z) - z near 0 is O(z^2).
-/
open Asymptotics Filter Complex Topology

lemma log_one_add_sub_self_asymptotic :
    (fun z : ‚ÑÇ => log (1 + z) - z) =O[ùìù 0] (fun z => z ^ 2) := by
  -- log(1+z) = z - z¬≤/2 + z¬≥/3 - ..., so log(1+z) - z = O(z¬≤) near 0
  -- Proof via HasDerivAt showing f(0) = 0 and f'(0) = 0
  sorry

/-
Asymptotic behavior of log(1 + 1/(2it)) - 1/(2it) as t ‚Üí ‚àû is O(1/t^2).
-/
open Asymptotics Filter Complex Topology

lemma log_one_add_inv_im_asymptotic :
    (fun t : ‚Ñù => log (1 + 1 / (2 * I * t)) - 1 / (2 * I * t)) =O[atTop] (fun t => 1 / t ^ 2) := by
  -- Follows from log_one_add_sub_self_asymptotic composed with z = 1/(2it) ‚Üí 0
  sorry

/-
For large t, log(1/4 + it/2) = log(it/2) + log(1 + 1/(2it)).
-/
open Asymptotics Filter Complex Topology

lemma log_split_lemma :
    ‚àÄ·∂† (t : ‚Ñù) in atTop, log (1/4 + I * t / 2) = log (I * t / 2) + log (1 + 1 / (2 * I * t)) := by
  -- For large t, 1/4 + it/2 = (it/2)(1 + 1/(2it)), then use log multiplicativity
  sorry

/-
Asymptotic expansion of log(1/4 + it/2) is log(t/2) + i*pi/2 - i/(2t) + O(1/t^2).
-/
open Asymptotics Filter Complex Topology

lemma log_quarter_plus_it_half_asymptotic :
    (fun t : ‚Ñù => log (1/4 + I * t / 2) - (log (t / 2) + I * (Real.pi / 2) - I / (2 * t)))
    =O[atTop] (fun t => 1 / t ^ 2) := by
  -- Follows from log_split_lemma, log(i*t/2) = log(t/2) + iœÄ/2, and
  -- log_one_add_inv_im_asymptotic
  sorry

/-
The imaginary part of the Stirling approximation term has the asymptotic expansion (t/2) log(t/2) - t/2 - pi/8 + O(1/t).
-/
open Asymptotics Filter Complex Topology

noncomputable def stirlingApprox (t : ‚Ñù) : ‚ÑÇ :=
  (1/4 + I * t / 2 - 1/2) * log (1/4 + I * t / 2) - (1/4 + I * t / 2) + (1/2) * log (2 * Real.pi)

lemma stirling_approx_im_asymptotic :
    (fun t => (stirlingApprox t).im - ((t / 2) * Real.log (t / 2) - t / 2 - Real.pi / 8)) =O[atTop] (fun t => 1 / t) := by
  -- The proof follows from the log expansion and careful tracking of imaginary parts
  sorry

/-
Definitions of the Binet integrand and Binet integral.
-/
open Asymptotics Filter Complex Topology

noncomputable def binetIntegrand (t : ‚Ñù) : ‚Ñù :=
  (1 / 2 - 1 / t + 1 / (Real.exp t - 1)) / t

noncomputable def binetIntegral (z : ‚ÑÇ) : ‚ÑÇ :=
  ‚à´ t in Set.Ioi 0, binetIntegrand t * Complex.exp (-t * z)

/-
The limit of the Binet integrand as t approaches 0 from the right is 1/12.
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_limit_zero :
    Tendsto binetIntegrand (ùìù[>] 0) (ùìù (1 / 12)) := by
  -- The Binet integrand B(t) = (1/2 - 1/t + 1/(e^t-1))/t
  -- has a removable singularity at t=0 with limit 1/12.
  -- This follows from the Taylor expansion e^t = 1 + t + t¬≤/2 + t¬≥/6 + ...
  -- giving B(t) = 1/12 + O(t) near 0.
  sorry

/-
The limit of the Binet integrand as t approaches infinity is 0.
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_limit_infinity :
    Tendsto binetIntegrand atTop (ùìù 0) := by
  -- binetIntegrand t = (1/2 - 1/t + 1/(e^t-1))/t ‚Üí (1/2)/‚àû = 0
  -- Strategy: bound |binetIntegrand t| ‚â§ 3/t for t ‚â• 1, and 3/t ‚Üí 0
  rw [Metric.tendsto_atTop]
  intro Œµ hŒµ
  refine ‚ü®max 1 (3 / Œµ), fun t ht => ?_‚ü©
  rw [Real.dist_eq, sub_zero]
  have ht1 : (1 : ‚Ñù) ‚â§ t := le_trans (le_max_left 1 (3 / Œµ)) ht
  have ht_pos : (0 : ‚Ñù) < t := lt_of_lt_of_le one_pos ht1
  -- Bound the numerator of binetIntegrand
  have h_exp_pos : Real.exp t - 1 > 0 := by
    have := Real.add_one_le_exp t
    linarith [Real.exp_pos t]
  have h_inv_t : 0 ‚â§ 1 / t := by positivity
  have h_inv_t_le : 1 / t ‚â§ 1 := by rw [div_le_one ht_pos]; linarith
  have h_inv_exp : 0 < 1 / (Real.exp t - 1) := by positivity
  have h_inv_exp_le : 1 / (Real.exp t - 1) ‚â§ 1 := by
    rw [div_le_one h_exp_pos]
    have := Real.add_one_le_exp t
    linarith
  have h_num_abs : |1 / 2 - 1 / t + 1 / (Real.exp t - 1)| ‚â§ 3 / 2 := by
    apply abs_le.mpr
    constructor
    ¬∑ linarith
    ¬∑ linarith
  unfold binetIntegrand
  rw [abs_div, abs_of_pos ht_pos]
  calc |1 / 2 - 1 / t + 1 / (Real.exp t - 1)| / t
      ‚â§ (3 / 2) / t := by gcongr
    _ < Œµ := by
        rw [div_lt_iff‚ÇÄ ht_pos]
        have h3e : 3 / Œµ ‚â§ t := le_trans (le_max_right 1 (3 / Œµ)) ht
        have h3 : 3 ‚â§ t * Œµ := (div_le_iff‚ÇÄ hŒµ).mp h3e
        linarith [mul_comm t Œµ]

/-
The Binet integrand is continuous on (0, ‚àû).
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_continuous :
    ContinuousOn binetIntegrand (Set.Ioi 0) := by
  unfold binetIntegrand
  refine ContinuousOn.div ?_ continuousOn_id (fun x hx => ne_of_gt hx)
  refine ContinuousOn.add ?_ ?_
  ¬∑ exact ContinuousOn.sub continuousOn_const (continuousOn_const.div continuousOn_id (fun x hx => ne_of_gt hx))
  ¬∑ refine ContinuousOn.div continuousOn_const ?_ ?_
    ¬∑ exact Real.continuous_exp.continuousOn.sub continuousOn_const
    ¬∑ intro x hx
      simp only [Set.mem_Ioi] at hx
      have : Real.exp x > 1 := Real.one_lt_exp_iff.mpr hx
      linarith

/-
The Binet integrand is differentiable on (0, ‚àû).
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_differentiable :
    DifferentiableOn ‚Ñù binetIntegrand (Set.Ioi 0) := by
  unfold binetIntegrand
  refine DifferentiableOn.div ?_ differentiableOn_id (fun x hx => ne_of_gt hx)
  refine DifferentiableOn.add ?_ ?_
  ¬∑ exact DifferentiableOn.sub (differentiableOn_const _)
      (DifferentiableOn.div (differentiableOn_const _) differentiableOn_id (fun x hx => ne_of_gt hx))
  ¬∑ refine DifferentiableOn.div (differentiableOn_const _) ?_ ?_
    ¬∑ exact differentiableOn_id.exp.sub (differentiableOn_const _)
    ¬∑ intro x hx
      simp only [Set.mem_Ioi] at hx
      have : Real.exp x > 1 := Real.one_lt_exp_iff.mpr hx
      linarith

/-
A function continuous on (0, infinity) with finite limits at 0 and infinity is bounded.
-/
open Asymptotics Filter Complex Topology

lemma bounded_of_continuous_limits {f : ‚Ñù ‚Üí ‚Ñù}
    (h_cont : ContinuousOn f (Set.Ioi 0))
    (h_zero : ‚àÉ L, Tendsto f (ùìù[>] 0) (ùìù L))
    (h_inf : ‚àÉ L, Tendsto f atTop (ùìù L)) :
    ‚àÉ M, ‚àÄ t ‚àà Set.Ioi 0, |f t| ‚â§ M := by
  obtain ‚ü®L‚ÇÄ, hL‚ÇÄ‚ü© := h_zero
  obtain ‚ü®Linf, hLinf‚ü© := h_inf
  -- Near 0
  obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© : ‚àÉ Œ¥ > 0, ‚àÄ t ‚àà Set.Ioo 0 Œ¥, |f t| ‚â§ |L‚ÇÄ| + 1 := by
    have := Metric.tendsto_nhdsWithin_nhds.mp hL‚ÇÄ 1 one_pos
    obtain ‚ü®Œ¥, hŒ¥_pos, hŒ¥‚ü© := this
    refine ‚ü®Œ¥, hŒ¥_pos, fun t ht => ?_‚ü©
    have := hŒ¥ ht.1 (by simp [abs_of_pos ht.1]; exact ht.2)
    rw [Real.dist_eq] at this
    have h_abs := abs_sub_abs_le_abs_sub (f t) L‚ÇÄ
    linarith
  -- Near infinity
  obtain ‚ü®T, hT_pos, hT‚ü© : ‚àÉ T > 0, ‚àÄ t ‚â• T, |f t| ‚â§ |Linf| + 1 := by
    have := Metric.tendsto_atTop.mp hLinf 1 one_pos
    obtain ‚ü®T, hT‚ü© := this
    refine ‚ü®max T 1, by positivity, fun t ht => ?_‚ü©
    have := hT t (le_trans (le_max_left _ _) ht)
    rw [Real.dist_eq] at this
    have h_abs := abs_sub_abs_le_abs_sub (f t) Linf
    linarith
  -- On compact middle region [Œ¥, T]
  have h_compact : IsCompact (Set.Icc Œ¥ T) := isCompact_Icc
  have h_cont_mid : ContinuousOn f (Set.Icc Œ¥ T) := h_cont.mono (fun x hx => by
    simp only [Set.mem_Ioi, Set.mem_Icc] at hx ‚ä¢; linarith)
  obtain ‚ü®M_mid, hM_mid‚ü© := h_compact.exists_bound_of_continuousOn h_cont_mid
  -- Combine bounds
  use max (|L‚ÇÄ| + 1) (max (|Linf| + 1) M_mid)
  intro t ht
  simp only [Set.mem_Ioi] at ht
  by_cases h1 : t < Œ¥
  ¬∑ exact le_trans (hŒ¥ t ‚ü®ht, h1‚ü©) (le_max_left _ _)
  ¬∑ by_cases h2 : t ‚â• T
    ¬∑ exact le_trans (hT t h2) (le_max_of_le_right (le_max_left _ _))
    ¬∑ have : t ‚àà Set.Icc Œ¥ T := ‚ü®not_lt.mp h1, le_of_lt (not_le.mp h2)‚ü©
      exact le_trans (hM_mid t this) (le_max_of_le_right (le_max_right _ _))

/-
The Binet integrand is bounded on (0, ‚àû).
-/
open Asymptotics Filter Complex Topology

lemma binet_integrand_bounded :
    ‚àÉ M, ‚àÄ t ‚àà Set.Ioi 0, |binetIntegrand t| ‚â§ M := by
  exact bounded_of_continuous_limits
    binet_integrand_continuous
    ‚ü®1/12, binet_integrand_limit_zero‚ü©
    ‚ü®0, binet_integrand_limit_infinity‚ü©

end
