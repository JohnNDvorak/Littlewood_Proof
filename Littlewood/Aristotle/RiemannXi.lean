/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 211af4fa-5253-483e-b370-ea6d251ba581

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
This module defines the Riemann Xi function `RiemannXi` using the entire function `completedRiemannZeta₀` to ensure it is well-defined and entire on the whole complex plane. It proves the functional equation `RiemannXi (1 - s) = RiemannXi s`, the fact that `RiemannXi` is entire, and its relation to `completedRiemannZeta` for `s ≠ 0, 1`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace RiemannXiModule

/-
Definition of the Riemann Xi function ξ(s) = 1/2 * s * (s-1) * Λ(s).
-/
noncomputable def xi (s : ℂ) : ℂ := (1 / 2) * s * (s - 1) * completedRiemannZeta s

/-
Functional equation for the Riemann Xi function: ξ(1-s) = ξ(s).
-/
theorem xi_one_sub (s : ℂ) : xi (1 - s) = xi s := by
  convert congr_arg _ ( completedRiemannZeta_one_sub s ) using 1 ; unfold xi ; ring

/-
Definition of the Riemann Xi function using the entire function Λ₀ to ensure it is well-defined and entire everywhere.
ξ(s) = 1/2 * s * (s-1) * Λ₀(s) + 1/2.
-/
noncomputable def RiemannXi (s : ℂ) : ℂ := (1 / 2) * s * (s - 1) * completedRiemannZeta₀ s + 1 / 2

/-
Functional equation for the Riemann Xi function: ξ(1-s) = ξ(s).
-/
theorem RiemannXi_one_sub (s : ℂ) : RiemannXi (1 - s) = RiemannXi s := by
  -- We have ξ(s) = (1/2)s(s-1)Λ₀(s) + 1/2.
  have h1 : RiemannXi s = (1 / 2) * s * (s - 1) * (completedRiemannZeta₀ s) + 1 / 2 := by
    exact?
  -- We also have ξ(1-s) = (1/2)(1-s)((1-s)-1)Λ₀(1-s) + 1/2.
  have h2 : RiemannXi (1 - s) = (1 / 2) * (1 - s) * ((1 - s) - 1) * (completedRiemannZeta₀ (1 - s)) + 1 / 2 := by
    exact?
  -- Using Λ₀(1-s) = Λ₀(s), we can rewrite ξ(1-s) in terms of ξ(s).
  have h3 : RiemannXi (1 - s) = (1 / 2) * (1 - s) * (-s) * (completedRiemannZeta₀ s) + 1 / 2 := by
    rw [h2];
    convert congr_arg ( fun x : ℂ => 1 / 2 * ( 1 - s ) * -s * x + 1 / 2 ) ( completedRiemannZeta₀_one_sub s ) using 1 ; ring!;
  -- Simplifying the expression for ξ(1-s), we get ξ(1-s) = (1/2)s(s-1)Λ₀(s) + 1/2.
  have h4 : RiemannXi (1 - s) = (1 / 2) * s * (s - 1) * (completedRiemannZeta₀ s) + 1 / 2 := by
    exact h3.trans ( by ring )
  -- Therefore, ξ(1-s) = ξ(s).
  rw [h4, h1]

/-
The Riemann Xi function is entire (differentiable on the whole complex plane).
-/
theorem differentiable_RiemannXi : Differentiable ℂ RiemannXi := by
  refine' Differentiable.add _ _;
  · exact Differentiable.mul ( Differentiable.mul ( Differentiable.mul ( differentiable_const _ ) differentiable_id ) ( differentiable_id.sub_const _ ) ) ( by
      exact? );
  · fun_prop

/-
Relation between RiemannXi and completedRiemannZeta for s ≠ 0, 1.
-/
theorem RiemannXi_eq_completedRiemannZeta (s : ℂ) (hs : s ≠ 0) (hs' : s ≠ 1) :
    RiemannXi s = (1 / 2) * s * (s - 1) * completedRiemannZeta s := by
      -- By definition of $RiemannXi$, we can rewrite the goal using the previous result.
      unfold RiemannXi
      rw [completedRiemannZeta_eq s]
      -- Goal: (1/2) * s * (s-1) * Λ₀(s) + 1/2 = (1/2) * s * (s-1) * (Λ₀(s) - 1/s - 1/(1-s))
      have h1 : s - 1 ≠ 0 := sub_ne_zero.mpr hs'
      have h2 : 1 - s ≠ 0 := sub_ne_zero.mpr (Ne.symm hs')
      field_simp
      ring

end RiemannXiModule