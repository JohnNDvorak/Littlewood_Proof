/-
Zero-free region infrastructure: 3+4cosθ+cos2θ≥0, ζ(1+it)≠0,
log-derivative Dirichlet series, 3-4-1 inequality for -ζ'/ζ,
(s-1)ζ(s) removable singularity, and -Re(ζ'/ζ(σ)) ≤ 1/(σ-1) + C.

Generated by Aristotle (Harmonic), integrated with type matching.
UUID: 912b4739-a1a7-4c97-a056-abb4699bf709

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ZeroFreeRegionV3

open Complex Real

lemma three_four_one (θ : ℝ) : 3 + 4 * Real.cos θ + Real.cos (2 * θ) ≥ 0 := by
  have h : 3 + 4 * Real.cos θ + Real.cos (2 * θ) = 2 * (1 + Real.cos θ)^2 := by
    rw [Real.cos_two_mul]
    ring
  rw [h]
  positivity

lemma zeta_ne_zero_on_one_line (t : ℝ) (ht : t ≠ 0) :
    riemannZeta (1 + I * t) ≠ 0 := by
  apply riemannZeta_ne_zero_of_one_le_re
  simp [Complex.re]

theorem zeta_ne_zero_re_eq_one (t : ℝ) (ht : |t| ≥ 1) :
    riemannZeta (1 + I * t) ≠ 0 := by
  have h_no_zeros : ∀ s : ℂ, s.re = 1 → s ≠ 1 → riemannZeta s ≠ 0 := by
    intros s hs_re hs_ne_one
    apply riemannZeta_ne_zero_of_one_le_re
    aesop
  exact h_no_zeros _ ( by norm_num ) ( by norm_num [ Complex.ext_iff ] ; rintro rfl; norm_num at ht )

lemma re_cpow_neg_s_eq (n : ℕ) (s : ℂ) (hn : n ≠ 0) :
    ((n : ℂ) ^ (-s)).re = (n : ℝ) ^ (-s.re) * Real.cos (s.im * Real.log n) := by
  norm_num [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ]
  simp +decide [ hn, Complex.exp_re, Complex.exp_im, Real.rpow_def_of_pos ( Nat.cast_pos.mpr <| Nat.pos_of_ne_zero hn ), mul_comm, Complex.log_re, Complex.log_im ]

lemma re_log_deriv_zeta_eq_sum (s : ℂ) (hs : 1 < s.re) :
    (-deriv riemannZeta s / riemannZeta s).re =
    ∑' n : ℕ, (ArithmeticFunction.vonMangoldt n : ℝ) * (n : ℝ) ^ (-s.re) * Real.cos (s.im * Real.log n) := by
  have h_sum : -deriv riemannZeta s / riemannZeta s = ∑' n : ℕ, (ArithmeticFunction.vonMangoldt n) * (n : ℂ) ^ (-s) := by
    field_simp
    have := @ArithmeticFunction.LSeries_vonMangoldt_eq_deriv_riemannZeta_div s ?_
    · convert this.symm using 1
      · ring
      · congr with ( _ | n ) <;> simp +decide [ div_eq_mul_inv, Complex.cpow_neg ]
    · linarith
  rw [ h_sum, Complex.re_tsum ]
  · refine' tsum_congr fun n => _
    by_cases hn : n = 0 <;> simp +decide [ hn, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ] ; ring
    rw [ Real.rpow_def_of_pos ( by positivity ) ] ; ring
  · have := @ArithmeticFunction.LSeriesSummable_vonMangoldt s
    simp_all +decide [ LSeriesSummable ]
    convert this using 1
    ext; simp +decide [ LSeries.term ]
    split_ifs <;> simp_all +decide [ div_eq_mul_inv, Complex.cpow_neg ]

lemma summable_vonMangoldt_mul_cos (σ t : ℝ) (hσ : 1 < σ) :
    Summable (fun n : ℕ => (ArithmeticFunction.vonMangoldt n : ℝ) * (n : ℝ) ^ (-σ) * Real.cos (t * Real.log n)) := by
  have h_abs : ∀ n : ℕ, |(ArithmeticFunction.vonMangoldt n : ℝ) * (n : ℝ) ^ (-σ) * Real.cos (t * Real.log n)| ≤ (ArithmeticFunction.vonMangoldt n : ℝ) * (n : ℝ) ^ (-σ) := by
    exact fun n => by rw [ abs_le ] ; constructor <;> nlinarith [ show 0 ≤ ( ArithmeticFunction.vonMangoldt n : ℝ ) * ( n : ℝ ) ^ ( -σ ) by exact mul_nonneg ( by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg ) ( by positivity ), abs_le.mp ( Real.abs_cos_le_one ( t * Real.log n ) ) ]
  have h_summable : Summable (fun n : ℕ => (ArithmeticFunction.vonMangoldt n : ℝ) * (n : ℝ) ^ (-σ)) := by
    have := @ArithmeticFunction.LSeriesSummable_vonMangoldt σ
    specialize this hσ
    convert Complex.reCLM.summable ( this ) using 2 ; norm_num [ LSeries.term ]
    split_ifs <;> simp_all +decide [ div_eq_mul_inv, Complex.cpow_neg ]
    norm_num [ Complex.normSq, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Complex.cpow_def ]
    split_ifs ; simp_all +decide [ Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im, Real.rpow_def_of_pos ]
    exact Or.inl ( by rw [ Real.rpow_def_of_pos ( by positivity ) ] ; rw [ ← Real.exp_neg ] ; ring )
  have h_comparison : Summable (fun n : ℕ => |(ArithmeticFunction.vonMangoldt n : ℝ) * (n : ℝ) ^ (-σ) * Real.cos (t * Real.log n)|) :=
    Summable.of_nonneg_of_le ( fun n => abs_nonneg _ ) h_abs h_summable
  exact h_comparison.of_abs

lemma norm_zeta_log_deriv_eq_sum (σ t : ℝ) (hσ : 1 < σ) :
    3 * (-deriv riemannZeta σ / riemannZeta σ).re +
    4 * (-deriv riemannZeta (σ + I * t) / riemannZeta (σ + I * t)).re +
    (-deriv riemannZeta (σ + I * (2 * t)) / riemannZeta (σ + I * (2 * t))).re =
    ∑' n : ℕ, (ArithmeticFunction.vonMangoldt n : ℝ) * (n : ℝ) ^ (-σ) * (3 + 4 * Real.cos (t * Real.log n) + Real.cos (2 * t * Real.log n)) := by
  have h_lhs : 3 * (-deriv riemannZeta σ / riemannZeta σ).re =
    ∑' n : ℕ, (ArithmeticFunction.vonMangoldt n) * (n : ℝ) ^ (-σ) * 3 * Real.cos (0 * Real.log n) ∧
    4 * (-deriv riemannZeta (σ + Complex.I * t) / riemannZeta (σ + Complex.I * t)).re =
    ∑' n : ℕ, (ArithmeticFunction.vonMangoldt n) * (n : ℝ) ^ (-σ) * 4 * Real.cos (t * Real.log n) ∧
    (-deriv riemannZeta (σ + Complex.I * (2 * t)) / riemannZeta (σ + Complex.I * (2 * t))).re =
    ∑' n : ℕ, (ArithmeticFunction.vonMangoldt n) * (n : ℝ) ^ (-σ) * Real.cos (2 * t * Real.log n) := by
      refine' ⟨ _, _, _ ⟩
      · convert congr_arg ( fun x : ℝ => 3 * x ) ( re_log_deriv_zeta_eq_sum ( σ : ℂ ) ?_ ) using 1 <;> norm_num [ mul_assoc, mul_comm, mul_left_comm, tsum_mul_left ]
        · rw [ ← tsum_mul_left ] ; congr ; ext n ; ring
        · sorry -- (σ : ℂ).re = σ > 1
      · convert congr_arg ( fun x : ℝ => 4 * x ) ( re_log_deriv_zeta_eq_sum ( σ + Complex.I * t ) ?_ ) using 1
        · rw [ ← tsum_mul_left ] ; congr ; ext n ; norm_num ; ring
        · aesop
      · convert re_log_deriv_zeta_eq_sum ( σ + Complex.I * ( 2 * t ) ) ( by simpa [ Complex.ext_iff ] using hσ ) using 1
        norm_num [ mul_assoc, mul_comm, mul_left_comm ]
  rw [ h_lhs.1, h_lhs.2.1, h_lhs.2.2, ← Summable.tsum_add, ← Summable.tsum_add ] ; congr ; ext n ; ring
  · norm_num
  · refine' Summable.add _ _
    · have := summable_vonMangoldt_mul_cos σ 0 hσ
      convert this.mul_right 3 using 2 ; ring
    · have := @summable_vonMangoldt_mul_cos σ t hσ
      convert this.mul_left 4 using 2 ; ring
  · convert summable_vonMangoldt_mul_cos σ ( 2 * t ) hσ using 1
  · convert Summable.mul_right 3 ( summable_vonMangoldt_mul_cos σ 0 hσ ) using 2 ; ring
  · have := @summable_vonMangoldt_mul_cos σ t hσ
    convert this.mul_left 4 using 2 ; ring

lemma norm_zeta_log_deriv_ineq (σ t : ℝ) (hσ : 1 < σ) :
    3 * (-deriv riemannZeta σ / riemannZeta σ).re +
    4 * (-deriv riemannZeta (σ + I * t) / riemannZeta (σ + I * t)).re +
    (-deriv riemannZeta (σ + I * (2 * t)) / riemannZeta (σ + I * (2 * t))).re ≥ 0 := by
  convert norm_zeta_log_deriv_eq_sum σ t hσ |> fun h => h.symm ▸ ( show ( ∑' n : ℕ, ( ArithmeticFunction.vonMangoldt n : ℝ ) * ( n : ℝ ) ^ ( -σ ) * ( 3 + 4 * Real.cos ( t * Real.log n ) + Real.cos ( 2 * t * Real.log n ) ) ) ≥ 0 from _ ) using 1 ; ring_nf at *
  refine' tsum_nonneg fun n => _
  have h_nonneg : 3 + 4 * Real.cos (t * Real.log n) + Real.cos (2 * t * Real.log n) ≥ 0 := by
    rw [ mul_assoc, Real.cos_two_mul ] ; nlinarith [ sq_nonneg ( Real.cos ( t * Real.log n ) + 1 ) ]
  rw [ show t * Real.log n * 2 = 2 * t * Real.log n by ring ] ; nlinarith [ show ( ArithmeticFunction.vonMangoldt n : ℝ ) * ( n : ℝ ) ^ ( -σ ) ≥ 0 by exact mul_nonneg ( by exact_mod_cast by { exact_mod_cast ( by { rw [ ArithmeticFunction.vonMangoldt_apply ] ; positivity } ) } ) ( by positivity ) ]

noncomputable def zetaResidueFunction (s : ℂ) : ℂ :=
  if s = 1 then 1 else (s - 1) * riemannZeta s

lemma continuousAt_zetaResidueFunction : ContinuousAt zetaResidueFunction 1 := by
  have h_cont : Filter.Tendsto (fun s : ℂ => (s - 1) * riemannZeta s) (nhdsWithin 1 {1}ᶜ) (nhds (1 : ℂ)) := by
    sorry -- tendsto_sub_one_mul_zeta
  rw [ Metric.tendsto_nhdsWithin_nhds ] at h_cont
  rw [ Metric.continuousAt_iff ]
  intro ε hε; rcases h_cont ε hε with ⟨ δ, hδ, H ⟩ ; use δ, hδ; intro x hx; by_cases hx' : x = 1 <;> simp_all +decide [ zetaResidueFunction ]

theorem analyticAt_zetaResidueFunction : AnalyticAt ℂ zetaResidueFunction 1 := by
  sorry

lemma deriv_zetaResidueFunction_eq {s : ℂ} (hs : s ≠ 1) :
    deriv zetaResidueFunction s = riemannZeta s + (s - 1) * deriv riemannZeta s := by
  convert HasDerivAt.deriv ( HasDerivAt.congr_of_eventuallyEq _ ?_ )
  exact fun z => ( z - 1 ) * riemannZeta z
  · convert HasDerivAt.mul ( HasDerivAt.sub ( hasDerivAt_id s ) ( hasDerivAt_const _ _ ) ) ( hasDerivAt_deriv_iff.mpr _ ) using 1
    · norm_num
    · exact differentiableAt_riemannZeta ( by aesop )
  · filter_upwards [ IsOpen.mem_nhds isOpen_ne hs ] with z hz using by unfold zetaResidueFunction; aesop

lemma log_deriv_zeta_eq_log_deriv_residue_sub_pole {s : ℂ} (hs : s ≠ 1) (hzeta : riemannZeta s ≠ 0) :
    deriv riemannZeta s / riemannZeta s = deriv zetaResidueFunction s / zetaResidueFunction s - 1 / (s - 1) := by
  have h_deriv_zetaResidueFunction : deriv zetaResidueFunction s = riemannZeta s + (s - 1) * deriv riemannZeta s :=
    sorry -- deriv_zetaResidueFunction_eq hs
  simp_all +decide [ div_eq_mul_inv, sub_mul, mul_add, add_mul, mul_assoc, mul_comm, mul_left_comm, zetaResidueFunction ]
  exact Or.inl ( by linear_combination mul_inv_cancel₀ ( sub_ne_zero_of_ne hs ) )

lemma log_deriv_residue_bounded_near_one :
    ∃ C : ℝ, ∀ σ : ℝ, 1 ≤ σ → σ ≤ 2 →
    |(deriv zetaResidueFunction σ / zetaResidueFunction σ).re| ≤ C := by
  sorry

lemma zeta_log_deriv_bound_near_one :
    ∃ C : ℝ, ∀ σ : ℝ, 1 < σ → σ ≤ 2 →
    (-deriv riemannZeta σ / riemannZeta σ).re ≤ 1 / (σ - 1) + C := by
  obtain ⟨C, hC⟩ := log_deriv_residue_bounded_near_one
  have h_log_deriv : ∀ σ : ℝ, 1 < σ → σ ≤ 2 → (-deriv riemannZeta (σ : ℂ) / riemannZeta (σ : ℂ)).re = 1 / (σ - 1) - (deriv zetaResidueFunction σ / zetaResidueFunction σ).re := by
    intros σ hσ₁ hσ₂
    have h_log_deriv : deriv riemannZeta (σ : ℂ) / riemannZeta (σ : ℂ) = deriv zetaResidueFunction (σ : ℂ) / zetaResidueFunction (σ : ℂ) - 1 / (σ - 1) := by
      apply log_deriv_zeta_eq_log_deriv_residue_sub_pole
      · norm_num [ Complex.ext_iff, hσ₁.ne' ]
      · sorry -- riemannZeta_ne_zero_of_one_le_re
    simp_all +decide [ neg_div, sub_eq_add_neg ]
    norm_num [ Complex.normSq, sq ]
  exact ⟨ C, fun σ hσ₁ hσ₂ => by linarith [ abs_le.mp ( hC σ hσ₁.le hσ₂ ), h_log_deriv σ hσ₁ hσ₂ ] ⟩

end ZeroFreeRegionV3
