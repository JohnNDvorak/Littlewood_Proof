/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: f789cf0e-9145-407f-80b4-80f3dd19d931

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: Stirling-type growth bounds for the Gamma function.
NOT imported by any bridge — serves as reference material for closing
the `gamma_growth` sorry in PhragmenLindelof.lean.

Contains (all PROVED, 0 sorries):
- complex_sin_growth: bounds for |sin(π(σ+it))| in vertical strips
- gamma_half_growth: |Γ(1/2+it)| ~ exp(-π|t|/2)
- gamma_zero_growth: |Γ(it)| ~ |t|^{-1/2} exp(-π|t|/2)
- gamma_step_up: inductive step Γ(σ+1+it) from Γ(σ+it)
- norm_Gamma_one_add_mul_I_of_ne_zero: |Γ(1+it)| = |t|·|Γ(it)|
- abs_mul_rpow_neg_half_eq_rpow_half: algebraic identity for |t|^{-1/2}

Budget was reached; the final assembly from gamma_half_growth + gamma_step_up
into the general `gamma_growth` statement is not done here.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.GammaGrowthBounds

/-
Bounds for |sin(pi(sigma + it))| in a vertical strip.
-/
lemma complex_sin_growth (a b : ℝ) (ha : 0 < a) (hab : a ≤ b) :
    ∃ (C₁ C₂ : ℝ), C₁ > 0 ∧ C₂ > 0 ∧
      ∀ (σ : ℝ), a ≤ σ → σ ≤ b →
        ∀ (t : ℝ), 1 ≤ |t| →
          C₁ * Real.exp (Real.pi * |t|) ≤ ‖Complex.sin (Real.pi * (σ + t * Complex.I))‖ ∧
          ‖Complex.sin (Real.pi * (σ + t * Complex.I))‖ ≤ C₂ * Real.exp (Real.pi * |t|) := by
            have h_bound : ∀ (σ t : ℝ), a ≤ σ ∧ σ ≤ b ∧ 1 ≤ |t| →
              ‖Complex.sin (Real.pi * (σ + t * Complex.I))‖ = Real.sqrt (Real.sin (Real.pi * σ) ^ 2 + Real.sinh (Real.pi * t) ^ 2) := by
                norm_num [ Complex.norm_def, Complex.normSq, Complex.exp_re, Complex.exp_im, Real.sinh_eq ];
                norm_num [ Complex.sin, Complex.exp_re, Complex.exp_im ] ; intros ; ring;
                norm_num [ Real.sin_sq, Real.cos_sq, mul_assoc, mul_left_comm, ← Real.exp_add ] ; ring;
            have h_sinh_bound : ∃ (C₁ C₂ : ℝ), C₁ > 0 ∧ C₂ > 0 ∧ ∀ (t : ℝ), 1 ≤ |t| → C₁ * Real.exp (Real.pi * |t|) ≤ Real.sqrt (Real.sinh (Real.pi * t) ^ 2) ∧ Real.sqrt (Real.sinh (Real.pi * t) ^ 2) ≤ C₂ * Real.exp (Real.pi * |t|) := by
              have h_sinh_bound : ∃ (C₁ C₂ : ℝ), C₁ > 0 ∧ C₂ > 0 ∧ ∀ (t : ℝ), 1 ≤ |t| → C₁ * Real.exp (Real.pi * |t|) ≤ |Real.sinh (Real.pi * t)| ∧ |Real.sinh (Real.pi * t)| ≤ C₂ * Real.exp (Real.pi * |t|) := by
                have h_sinh_bound : ∀ (t : ℝ), 1 ≤ |t| → Real.exp (Real.pi * |t|) / 4 ≤ |Real.sinh (Real.pi * t)| ∧ |Real.sinh (Real.pi * t)| ≤ Real.exp (Real.pi * |t|) / 2 := by
                  intro t ht; rw [ Real.sinh_eq ] ; cases abs_cases t <;> simp +decide [ * ] ; ring_nf ; norm_num [ Real.pi_pos ] ;
                  · constructor <;> rw [ abs_of_nonneg ] <;> nlinarith [ Real.pi_gt_three, Real.exp_pos ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_neg ( Real.pi * t ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * t ) ) ), Real.add_one_le_exp ( Real.pi * t ), Real.add_one_le_exp ( - ( Real.pi * t ) ) ];
                  · constructor <;> rw [ abs_of_nonpos ] <;> nlinarith [ Real.pi_pos, Real.exp_pos ( Real.pi * t ), Real.exp_pos ( - ( Real.pi * t ) ), Real.exp_neg ( Real.pi * t ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * t ) ) ), Real.add_one_le_exp ( Real.pi * t ), Real.add_one_le_exp ( - ( Real.pi * t ) ), Real.pi_gt_three.le, mul_le_mul_of_nonneg_left ht ( Real.pi_pos.le ) ];
                exact ⟨ 1 / 4, 1 / 2, by norm_num, by norm_num, fun t ht => ⟨ by linarith [ h_sinh_bound t ht ], by linarith [ h_sinh_bound t ht ] ⟩ ⟩;
              simpa only [ Real.sqrt_sq_eq_abs ] using h_sinh_bound;
            obtain ⟨C₁, C₂, hC₁_pos, hC₂_pos, hC₁C₂⟩ := h_sinh_bound;
            use C₁, C₂ + 1; simp [hC₁_pos, hC₂_pos]; (
            have h_combined : ∀ (σ t : ℝ), a ≤ σ ∧ σ ≤ b ∧ 1 ≤ |t| →
              Real.sqrt (Real.sin (Real.pi * σ) ^ 2 + Real.sinh (Real.pi * t) ^ 2) ≥ Real.sqrt (Real.sinh (Real.pi * t) ^ 2) ∧
              Real.sqrt (Real.sin (Real.pi * σ) ^ 2 + Real.sinh (Real.pi * t) ^ 2) ≤ Real.sqrt (Real.sinh (Real.pi * t) ^ 2) + 1 := by
                intros σ t hσt; exact ⟨ Real.sqrt_le_sqrt ( by nlinarith ), Real.sqrt_le_iff.mpr ⟨ by positivity, by nlinarith [ Real.sqrt_nonneg ( Real.sinh ( Real.pi * t ) ^ 2 ), Real.mul_self_sqrt ( show 0 ≤ Real.sinh ( Real.pi * t ) ^ 2 by positivity ), Real.sin_sq_le_one ( Real.pi * σ ) ] ⟩ ⟩ ;
            exact ⟨ by linarith, fun σ hσ₁ hσ₂ t ht => ⟨ by rw [ h_bound σ t ⟨ hσ₁, hσ₂, ht ⟩ ] ; linarith [ h_combined σ t ⟨ hσ₁, hσ₂, ht ⟩, hC₁C₂ t ht ], by rw [ h_bound σ t ⟨ hσ₁, hσ₂, ht ⟩ ] ; nlinarith [ h_combined σ t ⟨ hσ₁, hσ₂, ht ⟩, hC₁C₂ t ht, Real.add_one_le_exp ( Real.pi * |t| ), Real.pi_gt_three.le, abs_nonneg t ] ⟩ ⟩)

/-
Asymptotic bounds for |Γ(1/2 + it)|.
-/
lemma gamma_half_growth :
    ∃ (C₁ C₂ : ℝ), C₁ > 0 ∧ C₂ > 0 ∧
      ∀ (t : ℝ), 1 ≤ |t| →
        C₁ * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (1/2 + t * Complex.I)‖ ∧
        ‖Complex.Gamma (1/2 + t * Complex.I)‖ ≤ C₂ * Real.exp (-Real.pi * |t| / 2) := by
          have h_gamma_asymptotic : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ^ 2 = Real.pi / Real.cosh (Real.pi * |t|) := by
            have h_gamma_identity : ∀ t : ℝ, ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ^ 2 = Real.pi / Real.cosh (Real.pi * t) := by
              have h_gamma_sq : ∀ t : ℝ, ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ^ 2 = Real.pi / Real.cosh (Real.pi * t) := by
                intro t
                have h_gamma_eq : ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ^ 2 = Complex.Gamma (1 / 2 + t * Complex.I) * Complex.Gamma (1 / 2 - t * Complex.I) := by
                  have h_gamma_eq : Complex.Gamma (1 / 2 - t * Complex.I) = starRingEnd ℂ (Complex.Gamma (1 / 2 + t * Complex.I)) := by
                    convert Complex.Gamma_conj ( 1 / 2 + t * Complex.I ) using 2 ; ring;
                    norm_num [ Complex.ext_iff ];
                  rw [ h_gamma_eq, Complex.mul_conj, Complex.normSq_eq_norm_sq, Complex.ofReal_pow ]
                have := @Complex.Gamma_mul_Gamma_one_sub ( 1 / 2 + t * Complex.I );
                norm_num [ Complex.ext_iff, sq ] at *;
                convert this.1 using 1 <;> norm_num [ Complex.normSq, Complex.div_re, Complex.div_im, Complex.sin, Complex.exp_re, Complex.exp_im ] ; ring;
                · linarith;
                · norm_num [ Real.cosh_eq, mul_div ] ; ring;
                  field_simp
                  ring;
              assumption;
            intro t ht; cases abs_cases t <;> simp +decide [ * ] ;
            · convert h_gamma_identity t using 2 ; ring;
            · convert h_gamma_identity t using 1 ; ring;
          obtain ⟨C₁, C₂, hC₁⟩ : ∃ C₁ C₂ : ℝ, C₁ > 0 ∧ C₂ > 0 ∧ ∀ t : ℝ, 1 ≤ |t| → C₁ * Real.exp (-Real.pi * |t|) ≤ 1 / Real.cosh (Real.pi * |t|) ∧ 1 / Real.cosh (Real.pi * |t|) ≤ C₂ * Real.exp (-Real.pi * |t|) := by
            norm_num [ Real.cosh_eq ] at *;
            field_simp;
            refine' ⟨ 1 / 2, by norm_num, 2, by norm_num, fun t ht => ⟨ _, _ ⟩ ⟩ <;> ring_nf <;> norm_num [ ← Real.exp_add ];
            · nlinarith [ Real.exp_pos ( - ( |t| * Real.pi ) ), Real.exp_le_one_iff.mpr ( show - ( |t| * Real.pi ) ≤ 0 by nlinarith [ Real.pi_pos ] ) ];
            · positivity;
          have h_gamma_bound : ∀ t : ℝ, 1 ≤ |t| → Real.sqrt (Real.pi * C₁) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ∧ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ≤ Real.sqrt (Real.pi * C₂) * Real.exp (-Real.pi * |t| / 2) := by
            intro t ht
            have h_gamma_bound : Real.pi * C₁ * Real.exp (-Real.pi * |t|) ≤ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ^ 2 ∧ ‖Complex.Gamma (1 / 2 + t * Complex.I)‖ ^ 2 ≤ Real.pi * C₂ * Real.exp (-Real.pi * |t|) := by
              simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
              exact ⟨ by nlinarith [ hC₁.2.2 t ht, Real.pi_pos ], by nlinarith [ hC₁.2.2 t ht, Real.pi_pos ] ⟩;
            constructor <;> rw [ ← Real.sqrt_sq ( norm_nonneg _ ) ];
            · refine Real.le_sqrt_of_sq_le ?_;
              convert h_gamma_bound.1 using 1 ; rw [ mul_pow, Real.sq_sqrt <| mul_nonneg Real.pi_pos.le hC₁.1.le ] ; rw [ ← Real.exp_nat_mul ] ; ring;
            · rw [ Real.sqrt_le_iff ];
              exact ⟨ by positivity, by rw [ mul_pow, Real.sq_sqrt <| by nlinarith [ Real.pi_pos ] ] ; convert h_gamma_bound.2 using 1 ; rw [ ← Real.exp_nat_mul ] ; ring ⟩;
          exact ⟨ Real.sqrt ( Real.pi * C₁ ), Real.sqrt ( Real.pi * C₂ ), Real.sqrt_pos.mpr ( mul_pos Real.pi_pos hC₁.1 ), Real.sqrt_pos.mpr ( mul_pos Real.pi_pos hC₁.2.1 ), h_gamma_bound ⟩

/-
Asymptotic bounds for |Γ(it)|.
-/
lemma gamma_zero_growth :
    ∃ (C₁ C₂ : ℝ), C₁ > 0 ∧ C₂ > 0 ∧
      ∀ (t : ℝ), 1 ≤ |t| →
        C₁ * |t|^(-(1/2 : ℝ)) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (t * Complex.I)‖ ∧
        ‖Complex.Gamma (t * Complex.I)‖ ≤ C₂ * |t|^(-(1/2 : ℝ)) * Real.exp (-Real.pi * |t| / 2) := by
          have gamma_sq : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (t * Complex.I)‖ ^ 2 = Real.pi / (|t| * Real.sinh (Real.pi * |t|)) := by
            have h_gamma_sq : ∀ t : ℝ, t ≠ 0 → ‖Complex.Gamma (t * Complex.I)‖ ^ 2 = Real.pi / (|t| * Real.sinh (Real.pi * |t|)) := by
              intro t ht_nonzero
              have h_gamma_sq : ‖Complex.Gamma (t * Complex.I)‖^2 = Real.pi / (|t| * Real.sinh (Real.pi * |t|)) := by
                have h_gamma_eq : Complex.Gamma (t * Complex.I) * Complex.Gamma (-t * Complex.I) = Real.pi / (t * Real.sinh (Real.pi * t)) := by
                  have := @Complex.Gamma_mul_Gamma_one_sub ( t * Complex.I );
                  convert congr_arg ( fun x => x / ( -t * Complex.I ) ) this using 1 <;> ring;
                  · field_simp;
                    field_simp;
                    rw [ show ( 1 - Complex.I * t : ℂ ) = - ( Complex.I * t ) + 1 by ring, Complex.Gamma_add_one ] <;> ring;
                    · simp +decide [ mul_assoc, mul_comm, mul_left_comm, ht_nonzero ];
                    · norm_num [ ht_nonzero, Complex.ext_iff ];
                  · norm_num [ Complex.sin_mul_I ] ; ring;
                    norm_num [ Complex.sinh ]
                have h_gamma_conj : Complex.Gamma (-t * Complex.I) = starRingEnd ℂ (Complex.Gamma (t * Complex.I)) := by
                  convert Complex.Gamma_conj ( t * Complex.I ) using 2 ; norm_num [ Complex.ext_iff ];
                replace h_gamma_eq := congr_arg Complex.re h_gamma_eq; simp_all +decide [ Complex.normSq, Complex.sq_norm ] ;
                norm_cast;
                cases abs_cases t <;> simp +decide [ * ];
              exact h_gamma_sq;
            exact fun t ht => h_gamma_sq t <| by rintro rfl; norm_num at ht;
          have sinh_bound : ∃ C₁ C₂ : ℝ, C₁ > 0 ∧ C₂ > 0 ∧ ∀ t : ℝ, 1 ≤ |t| → C₁ * Real.exp (Real.pi * |t|) ≤ Real.sinh (Real.pi * |t|) ∧ Real.sinh (Real.pi * |t|) ≤ C₂ * Real.exp (Real.pi * |t|) := by
            norm_num [ Real.sinh_eq ];
            refine' ⟨ 1 / 4, by norm_num, 1, by norm_num, fun t ht => ⟨ _, _ ⟩ ⟩ <;> nlinarith [ Real.pi_gt_three, abs_nonneg t, Real.exp_pos ( Real.pi * |t| ), Real.exp_pos ( - ( Real.pi * |t| ) ), Real.exp_neg ( Real.pi * |t| ), mul_inv_cancel₀ ( ne_of_gt ( Real.exp_pos ( Real.pi * |t| ) ) ), Real.add_one_le_exp ( Real.pi * |t| ), Real.add_one_le_exp ( - ( Real.pi * |t| ) ) ];
          obtain ⟨C₁, C₂, hC₁_pos, hC₂_pos, hC₁C₂⟩ := sinh_bound;
          have gamma_bound : ∃ C₁' C₂' : ℝ, C₁' > 0 ∧ C₂' > 0 ∧ ∀ t : ℝ, 1 ≤ |t| → C₁' * |t| ^ (-(1 / 2 : ℝ)) * Real.exp (-Real.pi * |t| / 2) ≤ ‖Complex.Gamma (t * Complex.I)‖ ∧ ‖Complex.Gamma (t * Complex.I)‖ ≤ C₂' * |t| ^ (-(1 / 2 : ℝ)) * Real.exp (-Real.pi * |t| / 2) := by
            have gamma_sq_bound : ∃ C₁' C₂' : ℝ, C₁' > 0 ∧ C₂' > 0 ∧ ∀ t : ℝ, 1 ≤ |t| → C₁' * |t| ^ (-1 : ℝ) * Real.exp (-Real.pi * |t|) ≤ ‖Complex.Gamma (t * Complex.I)‖ ^ 2 ∧ ‖Complex.Gamma (t * Complex.I)‖ ^ 2 ≤ C₂' * |t| ^ (-1 : ℝ) * Real.exp (-Real.pi * |t|) := by
              use Real.pi / C₂, Real.pi / C₁;
              simp_all +decide [ Real.rpow_neg_one, div_eq_mul_inv ];
              refine' ⟨ Real.pi_pos, fun t ht => ⟨ _, _ ⟩ ⟩;
              · field_simp;
                rw [ Real.exp_neg ];
                rw [ inv_mul_eq_div, div_le_iff₀ ] <;> nlinarith [ hC₁C₂ t ht, Real.exp_pos ( Real.pi * |t| ) ];
              · rw [ Real.exp_neg ];
                field_simp;
                exact hC₁C₂ t ht |>.1;
            obtain ⟨ C₁', C₂', hC₁'_pos, hC₂'_pos, hC₁'C₂' ⟩ := gamma_sq_bound;
            have gamma_bound : ∀ t : ℝ, 1 ≤ |t| → Real.sqrt (C₁' * |t| ^ (-1 : ℝ) * Real.exp (-Real.pi * |t|)) ≤ ‖Complex.Gamma (t * Complex.I)‖ ∧ ‖Complex.Gamma (t * Complex.I)‖ ≤ Real.sqrt (C₂' * |t| ^ (-1 : ℝ) * Real.exp (-Real.pi * |t|)) := by
              exact fun t ht => ⟨ Real.sqrt_le_iff.mpr ⟨ by positivity, hC₁'C₂' t ht |>.1 ⟩, Real.le_sqrt_of_sq_le <| hC₁'C₂' t ht |>.2 ⟩;
            refine' ⟨ Real.sqrt C₁', Real.sqrt C₂', Real.sqrt_pos.mpr hC₁'_pos, Real.sqrt_pos.mpr hC₂'_pos, fun t ht => ⟨ _, _ ⟩ ⟩ <;> norm_num [ Real.sqrt_mul', hC₁'_pos.le, hC₂'_pos.le ] at *;
            · convert gamma_bound t ht |>.1 using 1 ; norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg ( by positivity : 0 ≤ |t| ) ] ; ring;
              rw [ Real.mul_rpow ( by positivity ) ( by positivity ), Real.mul_rpow ( by positivity ) ( by positivity ), Real.inv_rpow ( by positivity ), ← Real.exp_mul ] ; ring;
            · convert gamma_bound t ht |>.2 using 1 ; norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg ( by positivity : 0 ≤ |t| ) ] ; ring;
              rw [ Real.mul_rpow ( by positivity ) ( by positivity ), Real.mul_rpow ( by positivity ) ( by positivity ), Real.inv_rpow ( by positivity ), ← Real.exp_mul ] ; ring;
          exact gamma_bound

/-
Inductive step for Gamma upper bound.
-/
lemma gamma_step_up (σ : ℝ) (C : ℝ) (hC : 0 < C) :
    (∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma ((σ : ℂ) + t * Complex.I)‖ ≤ C * |t|^(σ - 1/2) * Real.exp (-Real.pi * |t| / 2)) →
    ∃ C', C' > 0 ∧ ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma ((σ : ℂ) + 1 + t * Complex.I)‖ ≤ C' * |t|^(σ + 1 - 1/2) * Real.exp (-Real.pi * |t| / 2) := by
      intro h;
      have h_recurrence : ∀ t : ℝ, 1 ≤ |t| → Complex.Gamma (σ + 1 + t * Complex.I) = (σ + t * Complex.I) * Complex.Gamma (σ + t * Complex.I) := by
        intro t ht;
        convert Complex.Gamma_add_one _ using 2 ; ring;
        swap;
        exact σ + t * Complex.I;
        by_cases h : ( σ : ℂ ) + t * Complex.I = 0 <;> simp_all +decide [ add_assoc, mul_comm ];
        · simp_all +decide [ Complex.ext_iff ];
          linarith;
        · ring;
      have h_bound : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (σ + 1 + t * Complex.I)‖ ≤ (|σ| + |t|) * C * |t| ^ (σ - 1 / 2) * Real.exp (-Real.pi * |t| / 2) := by
        intros t ht
        rw [h_recurrence t ht]
        have h_abs : ‖σ + t * Complex.I‖ ≤ |σ| + |t| := by
          convert norm_add_le ( σ : ℂ ) ( t * Complex.I ) using 1 ; norm_num [ Complex.normSq, Complex.norm_def ];
        simpa only [ mul_assoc, norm_mul ] using mul_le_mul h_abs ( h t ht ) ( by positivity ) ( by positivity );
      have h_factor : ∀ t : ℝ, 1 ≤ |t| → ‖Complex.Gamma (σ + 1 + t * Complex.I)‖ ≤ (|σ| + 1) * C * |t| ^ (σ + 1 - 1 / 2) * Real.exp (-Real.pi * |t| / 2) := by
        intro t ht; convert le_trans ( h_bound t ht ) _ using 1; ring;
        rw [ show ( 1 / 2 + σ : ℝ ) = ( -1 / 2 + σ ) + 1 by ring, Real.rpow_add_one ( by positivity ) ] ; ring_nf ; norm_num;
        exact mul_le_mul_of_nonneg_right ( le_mul_of_one_le_right ( by positivity ) ht ) ( by positivity );
      exact ⟨ ( |σ| + 1 ) * C, by positivity, h_factor ⟩

/-
Identity relating |Γ(1+it)| and |Γ(it)| for non-zero t.
-/
lemma norm_Gamma_one_add_mul_I_of_ne_zero (t : ℝ) (ht : t ≠ 0) :
    ‖Complex.Gamma (1 + t * Complex.I)‖ = |t| * ‖Complex.Gamma (t * Complex.I)‖ := by
      have h_gamma : Complex.Gamma (1 + t * Complex.I) = (t * Complex.I) * Complex.Gamma (t * Complex.I) := by
        rw [ add_comm, Complex.Gamma_add_one ] ; aesop;
      norm_num [ h_gamma, abs_mul ]

/-
Algebraic identity for powers of |t|.
-/
lemma abs_mul_rpow_neg_half_eq_rpow_half (t : ℝ) (ht : t ≠ 0) :
    |t| * |t| ^ (-(1/2 : ℝ)) = |t| ^ (1/2 : ℝ) := by
      rw [ ← Real.rpow_one_add' ] <;> norm_num [ ht ]

end Aristotle.GammaGrowthBounds
