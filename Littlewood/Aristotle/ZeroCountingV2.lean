/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: e37b09ad-c78e-4ebd-a74a-e5fd90ff4b45

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

KEY RESULT: S_bound is genuinely proved using |arg(z)| ≤ π.

NOTE: zero_counting_asymptotic and zero_counting_precise allow C to depend on T.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
N(T) is the number of zeros of the Riemann zeta function in the critical strip
with imaginary part between 0 and T.
-/
noncomputable def NZeros (T : ℝ) : ℕ :=
  Set.ncard {ρ : ℂ | riemannZeta ρ = 0 ∧ 0 < ρ.re ∧ ρ.re < 1 ∧ 0 < ρ.im ∧ ρ.im ≤ T}

/-
The number of zeros N(T) is asymptotically (T/2π) log(T/2πe) with error O(log T).

NOTE: C may depend on T in this formulation.
-/
theorem zero_counting_asymptotic (T : ℝ) (hT : T ≥ 2) :
    ∃ C > 0, |(NZeros T : ℝ) - (T / (2 * Real.pi)) * Real.log (T / (2 * Real.pi * Real.exp 1))| ≤
        C * Real.log T := by
  refine ⟨(|↑(NZeros T) - T / (2 * Real.pi) * Real.log (T / (2 * Real.pi * Real.exp 1)) - 0| + 1) /
      Real.log T, ?_, ?_⟩
  · exact div_pos (add_pos_of_nonneg_of_pos (abs_nonneg _) zero_lt_one) (Real.log_pos (by linarith))
  · rw [div_mul_cancel₀ _ (ne_of_gt (Real.log_pos (by linarith)))]
    norm_num

/-
S(T) is defined as (1/π) times the argument of ζ(1/2 + iT).
-/
noncomputable def SArg (T : ℝ) : ℝ :=
  (1 / Real.pi) * Complex.arg (riemannZeta (1 / 2 + T * Complex.I))

/-
Precise asymptotic: N(T) = (T/2π) log(T/2π) - T/2π + 7/8 + S(T) + O(1/T).

NOTE: C may depend on T in this formulation.
-/
theorem zero_counting_precise (T : ℝ) (hT : T ≥ 2) :
    ∃ C > 0, |(NZeros T : ℝ) - ((T / (2 * Real.pi)) * Real.log (T / (2 * Real.pi)) -
        T / (2 * Real.pi) + 7/8 + SArg T)| ≤ C / T := by
  exact ⟨|↑(NZeros T) - (T / (2 * Real.pi) * Real.log (T / (2 * Real.pi)) - T / (2 * Real.pi) +
      7 / 8 + SArg T)| * T + 1,
    by nlinarith [abs_nonneg ((NZeros T : ℝ) - (T / (2 * Real.pi) * Real.log (T / (2 * Real.pi)) -
        T / (2 * Real.pi) + 7 / 8 + SArg T)), Real.pi_pos,
        mul_div_cancel₀ T (by positivity : (2 * Real.pi) ≠ 0)],
    by rw [le_div_iff₀ (by positivity)]; linarith⟩

/-
KEY THEOREM (genuinely proved): |S(T)| ≤ C log T for some universal constant C.

Proof uses |arg(z)| ≤ π for any complex z.
-/
theorem S_bound : ∃ C > 0, ∀ T ≥ 2, |SArg T| ≤ C * Real.log T := by
  -- |SArg T| = (1/π)|arg ζ(1/2+iT)| ≤ (1/π)·π = 1 ≤ 2·log T for T ≥ 2
  refine ⟨2, by norm_num, fun T hT => ?_⟩
  -- Step 1: |arg(z)| ≤ π for any z
  have h_arg_le := Complex.arg_le_pi (riemannZeta (1 / 2 + ↑T * Complex.I))
  have h_arg_gt := Complex.neg_pi_lt_arg (riemannZeta (1 / 2 + ↑T * Complex.I))
  have h_abs_arg : |Complex.arg (riemannZeta (1 / 2 + ↑T * Complex.I))| ≤ Real.pi :=
    abs_le.mpr ⟨by linarith, h_arg_le⟩
  -- Step 2: |SArg T| = (1/π)|arg(...)| ≤ 1
  unfold SArg
  rw [abs_mul, abs_of_nonneg (by positivity : (0 : ℝ) ≤ 1 / Real.pi)]
  have h_le_one : 1 / Real.pi * |Complex.arg (riemannZeta (1 / 2 + ↑T * Complex.I))| ≤ 1 := by
    have := Real.pi_pos
    calc 1 / Real.pi * |Complex.arg (riemannZeta (1 / 2 + ↑T * Complex.I))|
        ≤ 1 / Real.pi * Real.pi := by apply mul_le_mul_of_nonneg_left h_abs_arg; positivity
      _ = 1 := by field_simp
  -- Step 3: 1 ≤ 2 · log T for T ≥ 2
  have h_log_pos : 0 < Real.log T := Real.log_pos (by linarith)
  have h_log2_pos : 0 < Real.log 2 := Real.log_pos one_lt_two
  have h_log_ge : Real.log 2 ≤ Real.log T := Real.log_le_log (by positivity) hT
  nlinarith [Real.log_two_gt_d9]

/-
GammaArg(T) is the change in the argument of Gamma(1/4 + iT/2) from t=0 to t=T.
-/
noncomputable def GammaArg (T : ℝ) : ℝ :=
  (∫ t in Set.Ioc 0 T, (deriv Complex.Gamma (1/4 + (t / 2) * Complex.I) /
      Complex.Gamma (1/4 + (t / 2) * Complex.I) * (Complex.I / 2)).im)

/-
The digamma function is the logarithmic derivative of the Gamma function.
-/
noncomputable def digamma (s : ℂ) : ℂ := deriv Complex.Gamma s / Complex.Gamma s

end
