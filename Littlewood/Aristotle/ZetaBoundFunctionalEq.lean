/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4a6ca827-4fe8-4176-a3a1-14e5b30d4b83

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
I have formalized and proved `zeta_bound_gt_one` (boundedness of ζ in the half-plane Re(s) ≥ 1+δ) and `zeta_eq_chi_mul` (the functional equation ζ(s) = χ(s)ζ(1-s)). However, I cannot prove `zeta_polynomial_growth_in_strip` because it relies on `gamma_growth` (Stirling's formula estimates for the complex Gamma function), which was listed as 'AVAILABLE' but is not present in the project or Mathlib. I attempted to prove `gamma_growth` but it timed out as it requires non-trivial asymptotic analysis not yet in Mathlib. Please provide the definition and proof of `gamma_growth`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 3200000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.ZetaBoundFunctionalEq
/-
The Riemann Zeta function is bounded in the half-plane Re(s) ≥ 1 + δ for any δ > 0.
-/
open Complex Filter Topology

lemma zeta_bound_gt_one (δ : ℝ) (hδ : 0 < δ) :
    ∃ C, ∀ s : ℂ, 1 + δ ≤ s.re → ‖riemannZeta s‖ ≤ C := by
      -- By definition of zeta function, � we� know that for Re(s) ≥ 1 + δ, we have |ζ(s)| ≤(1 + δ).
      have h_bound : ∀ s : ℂ, 1 + δ ≤ s.re → ‖riemannZeta s‖ ≤ ∑' n : ℕ, (1 : ℝ) / (n + 1) ^ (1 + δ) := by
        intro s hs
        have h_bound : ‖(riemannZeta s)‖ ≤ ∑' n : ℕ, (1 : ℝ) / (n + 1) ^ s.re := by
          -- By definition of � z�eta function, we know that for Re(s) � ≥� 1 + δ, we � have� |ζ(s)| � ≤' n : ℕ, (1 : ℝ) / (n + 1) ^ s.re.
          have h_bound : ‖riemannZeta s‖ ≤ ∑' n : ℕ, ‖(1 : ℂ) / (n + 1) ^ s‖ := by
            rw [ zeta_eq_tsum_one_div_nat_add_one_cpow ];
            · convert norm_tsum_le_tsum_norm _ ; norm_num;
              -- We'll use the fact that if the real part of $s$ is greater than 1, then the series $\sum_{n=1}^{\infty} \frac{1}{n^s}$ converges.
              have h_summable : Summable (fun n : ℕ => (1 : ℝ) / (n + 1) ^ (s.re)) := by
                exact_mod_cast summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_rpow.2 <| by linarith;
              convert h_summable using 1;
              ext; rw [ ← Complex.norm_cpow_eq_rpow_re_of_pos ( by positivity ) ] ; norm_num;
            · linarith;
          convert h_bound using 2 ; norm_num [ Complex.norm_cpow_of_ne_zero, Nat.cast_add_one_ne_zero ];
          norm_cast ; norm_num [ Complex.arg ];
        refine' le_trans h_bound ( Summable.tsum_le_tsum _ _ _ );
        · exact fun n => one_div_le_one_div_of_le ( by positivity ) ( Real.rpow_le_rpow_of_exponent_le ( by linarith ) hs );
        · simpa using summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_rpow.2 <| by linarith;
        · simpa using summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_rpow.2 <| by linarith;
      exact ⟨ _, h_bound ⟩

/-
The Riemann Zeta function satisfies the functional equation ζ(s) = χ(s)ζ(1-s) for s not a non-negative integer.
-/
open Complex Filter Topology

def chi_factor (s : ℂ) : ℂ := (2 : ℂ)^s * (Real.pi : ℂ)^(s-1) * sin (Real.pi * s / 2) * Gamma (1-s)

lemma zeta_eq_chi_mul (s : ℂ) (h_not_nat : ∀ n : ℕ, s ≠ n) :
    riemannZeta s = chi_factor s * riemannZeta (1-s) := by
      -- Apply the functional equation with $z = 1 - s$.
      have h_fun_eq : riemannZeta (1 - (1 - s)) = 2 * (2 * Real.pi) ^ (-(1 - s)) * Complex.Gamma (1 - s) * Complex.cos (Real.pi * (1 - s) / 2) * riemannZeta (1 - s) := by
        apply_rules [ riemannZeta_one_sub ];
        · exact fun n => fun h => h_not_nat ( n + 1 ) ( by push_cast; linear_combination' -h );
        · exact fun h => h_not_nat 0 <| by linear_combination' -h;
      convert h_fun_eq using 1 ; ring;
      unfold chi_factor; ring;
      rw [ Complex.cpow_def_of_ne_zero, Complex.cpow_def_of_ne_zero ] <;> norm_num;
      rw [ Complex.cpow_def_of_ne_zero ( by norm_num [ Real.pi_ne_zero ] ) ] ; norm_num [ Complex.sin_add, Complex.cos_add, mul_div ] ; ring;
      rw [ Complex.log_mul ( by norm_num [ Real.pi_ne_zero ] ) ( by norm_num ) ] ; ring;
      · norm_num [ Complex.exp_add, Complex.exp_sub, Complex.exp_neg, Complex.exp_log ] ; ring;
      · norm_num [ Complex.arg ];
        split_ifs <;> constructor <;> linarith [ Real.pi_pos ]
end Aristotle.ZetaBoundFunctionalEq
