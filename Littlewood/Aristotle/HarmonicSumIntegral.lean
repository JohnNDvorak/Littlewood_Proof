/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 18e602e6-ad31-44cd-a334-f3347b472f4c

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Harmonic sum integral asymptotics for mean square estimates.

KEY RESULTS (PROVED):
- N_truncation: floor(√(t/2π)) - truncation point for approximate functional equation
- harmonicSum: Σ_{k=0}^{n-1} 1/(k+1)
- harmonicSum_eq_harmonic: harmonicSum = Mathlib's harmonic
- harmonicSum_N_sub_half_log_isBigO: H_{N(t)} - (1/2)log(t) = O(1)
- integral_harmonicSum_sub_half_log_isBigO: ∫(H_{N(t)} - (1/2)log(t)) = O(T)
- integral_half_log_isTheta: ∫(1/2)log(t) = Θ(T log T)
- T_isLittleO_T_log_T: T = o(T log T)
- integral_harmonicSum_asymp: ∫H_{N(t)} = Θ(T log T)

This directly proves integral_harmonicSum_asymp which was a sorry in MeanSquare.lean!
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
N_truncation(t) is the truncation point defined as floor(sqrt(t / 2π))
-/
noncomputable def N_truncation (t : ℝ) : ℕ := Nat.floor (Real.sqrt (t / (2 * Real.pi)))

/-
harmonicSum n is the sum of 1/(k+1) for k from 0 to n-1.
-/
noncomputable def harmonicSum (n : ℕ) : ℝ := ∑ k ∈ Finset.range n, (1 : ℝ) / (k + 1)

/-
harmonicSum n is equal to the Mathlib harmonic number harmonic n.
-/
lemma harmonicSum_eq_harmonic (n : ℕ) : harmonicSum n = harmonic n := by
  -- By definition of harmonicSum, we can write it as the sum of 1/(k+1) for k from 0 to n-1.
  simp [harmonicSum, harmonic]

/-
The difference between harmonicSum(N_truncation(t)) and 0.5 * log(t) is bounded by a constant (is BigO of 1) as t goes to infinity.
-/
lemma harmonicSum_N_truncation_sub_half_log_isBigO :
    (fun t => harmonicSum (N_truncation t) - 2⁻¹ * Real.log t) =O[Filter.atTop] (fun _ => (1:ℝ)) := by
      -- We'll use that harmonicSum n is equal to log n plus a constant to bound the difference.
      have h_bound : Filter.Tendsto (fun t => harmonicSum (N_truncation t) - (1 / 2) * Real.log t) Filter.atTop (nhds ((Real.log (1 / Real.sqrt (2 * Real.pi))) + Real.eulerMascheroniConstant)) := by
        -- We'll use the fact that $H_n = \log n + \gamma + O(1/n)$ to bound the difference.
        have h_harmonic : Filter.Tendsto (fun n => harmonicSum n - Real.log n) Filter.atTop (nhds (Real.eulerMascheroniConstant)) := by
          -- Apply the known result that the difference between the harmonic series and the natural logarithm converges to the Euler-Mascheroni constant.
          have h_harmonic_log : Filter.Tendsto (fun n : ℕ => (∑ k ∈ Finset.range n, (1 / (k + 1 : ℝ))) - Real.log (n : ℝ)) Filter.atTop (nhds Real.eulerMascheroniConstant) := by
            have := Real.tendsto_harmonic_sub_log
            convert this using 2 ; norm_num [ harmonic ];
          convert h_harmonic_log using 1;
        -- We'll use the fact that $N_truncation(t) = \sqrt{t/2\pi} + O(1)$ to show that $\log N_truncation(t)$ is close to $(1/2) \log t$.
        have h_log_N : Filter.Tendsto (fun t => Real.log (N_truncation t) - (1 / 2) * Real.log t) Filter.atTop (nhds (Real.log (1 / Real.sqrt (2 * Real.pi)))) := by
          -- We'll use the fact that $Real.log (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) = Real.log (Real.sqrt (t / (2 * Real.pi))) + O(1 / Real.sqrt (t))$.
          have h_log_floor : Filter.Tendsto (fun t => Real.log (Nat.floor (Real.sqrt (t / (2 * Real.pi)))) - Real.log (Real.sqrt (t / (2 * Real.pi)))) Filter.atTop (nhds 0) := by
            -- We'll use the fact that $\log(\lfloor x \rfloor) - \log(x)$ tends to $0$ as $x$ tends to infinity.
            have h_log_floor : Filter.Tendsto (fun x : ℝ => Real.log (Nat.floor x) - Real.log x) Filter.atTop (nhds 0) := by
              have h_log_floor : Filter.Tendsto (fun x : ℝ => Real.log (Nat.floor x / x)) Filter.atTop (nhds 0) := by
                have h_log_floor : Filter.Tendsto (fun x : ℝ => (Nat.floor x : ℝ) / x) Filter.atTop (nhds 1) := by
                  rw [ Metric.tendsto_nhds ];
                  intro ε hε; filter_upwards [ Filter.eventually_gt_atTop 0, Filter.eventually_gt_atTop ( ε⁻¹ ) ] with x hx₁ hx₂ using abs_lt.mpr ⟨ by nlinarith [ Nat.floor_le hx₁.le, Nat.lt_floor_add_one x, mul_inv_cancel₀ hε.ne', div_mul_cancel₀ ( Nat.floor x : ℝ ) hx₁.ne' ], by nlinarith [ Nat.floor_le hx₁.le, Nat.lt_floor_add_one x, mul_inv_cancel₀ hε.ne', div_mul_cancel₀ ( Nat.floor x : ℝ ) hx₁.ne' ] ⟩ ;
                simpa using Filter.Tendsto.log h_log_floor;
              refine h_log_floor.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx using by rw [ Real.log_div ( Nat.cast_ne_zero.mpr <| Nat.ne_of_gt <| Nat.floor_pos.mpr hx.le ) ( by positivity ) ] );
            exact h_log_floor.comp <| Filter.tendsto_atTop_atTop.mpr fun x => ⟨ x ^ 2 * ( 2 * Real.pi ), fun t ht => Real.le_sqrt_of_sq_le <| by nlinarith [ Real.pi_pos, mul_div_cancel₀ t ( by positivity : ( 2 * Real.pi ) ≠ 0 ) ] ⟩;
          have h_log_sqrt : Filter.Tendsto (fun t => Real.log (Real.sqrt (t / (2 * Real.pi))) - (1 / 2) * Real.log t) Filter.atTop (nhds (Real.log (1 / Real.sqrt (2 * Real.pi)))) := by
            have h_log_sqrt : Filter.Tendsto (fun t => (1 / 2) * Real.log (t / (2 * Real.pi)) - (1 / 2) * Real.log t) Filter.atTop (nhds (Real.log (1 / Real.sqrt (2 * Real.pi)))) := by
              have h_log_sqrt : Filter.Tendsto (fun t => (1 / 2) * (Real.log t - Real.log (2 * Real.pi)) - (1 / 2) * Real.log t) Filter.atTop (nhds (Real.log (1 / Real.sqrt (2 * Real.pi)))) := by
                norm_num [ Real.log_div, Real.log_sqrt, Real.pi_pos.le ] ; ring_nf ; norm_num;
                rw [ Real.log_mul ( by positivity ) ( by positivity ), Real.log_mul ( by positivity ) ( by positivity ), Real.log_inv, Real.log_inv, Real.log_sqrt ( by positivity ), Real.log_sqrt ( by positivity ) ] ; ring;
              refine h_log_sqrt.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with t ht using by rw [ Real.log_div ( by positivity ) ( by positivity ) ] );
            exact h_log_sqrt.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with t ht using by rw [ Real.log_sqrt ( by positivity ) ] ; ring );
          convert h_log_floor.add h_log_sqrt using 2 <;> ring!;
        convert h_harmonic.comp ( show Filter.Tendsto ( fun t : ℝ => N_truncation t ) Filter.atTop Filter.atTop from ?_ ) |> Filter.Tendsto.add <| h_log_N using 2 <;> norm_num ; ring!;
        exact tendsto_nat_floor_atTop.comp <| Filter.tendsto_atTop_atTop.mpr fun x => ⟨ 2 * Real.pi * x ^ 2, fun t ht => Real.le_sqrt_of_sq_le <| by nlinarith [ Real.pi_gt_three, mul_div_cancel₀ t ( by positivity : ( 2 * Real.pi ) ≠ 0 ) ] ⟩;
      rw [ Asymptotics.isBigO_iff ];
      have := h_bound.abs;
      exact ⟨ _, this.eventually ( ge_mem_nhds <| lt_add_one _ ) |> fun h => h.mono fun x hx => by simpa using hx ⟩

/-
The integral from 1 to T of (harmonicSum(N_truncation(t)) - 0.5 * log(t)) is BigO of T as T goes to infinity.
-/
lemma integral_harmonicSum_sub_half_log_isBigO :
    (fun T => ∫ t in (1:ℝ)..T, (harmonicSum (N_truncation t) - 2⁻¹ * Real.log t)) =O[Filter.atTop] (fun T => T) := by
      -- By definition of $N_truncation$, we know that for $t \geq 1$, $|harmonicSum (N_truncation t) - 2⁻¹ * Real.log t| \leq C$ for some constant $C$.
      obtain ⟨C, hC⟩ : ∃ C, ∀ t ≥ 1, abs ((harmonicSum (N_truncation t)) - 2⁻¹ * Real.log t) ≤ C := by
        have := harmonicSum_N_truncation_sub_half_log_isBigO;
        norm_num [ Asymptotics.isBigO_iff' ] at this ⊢;
        -- Let $M$ be an upper bound for $|harmonicSum (N_truncation t) - 1 / 2 * Real.log t|$ on the interval $[1, a]$.
        obtain ⟨c, hc_pos, a, ha⟩ := this;
        have hM : ∃ M, ∀ t ∈ Set.Icc 1 a, |harmonicSum (N_truncation t) - 1 / 2 * Real.log t| ≤ M := by
          -- The set $\{harmonicSum (N_truncation t) - 1 / 2 * Real.log t \mid t \in [1, a]\}$ is bounded above since $harmonicSum (N_truncation t)$ is bounded and $Real.log t$ is continuous.
          have h_bounded_above : BddAbove (Set.image (fun t => harmonicSum (N_truncation t) - 1 / 2 * Real.log t) (Set.Icc 1 a)) := by
            -- The set $\{harmonicSum (N_truncation t) \mid t \in [1, a]\}$ is bounded above since $harmonicSum (N_truncation t)$ is bounded.
            have h_bounded_above_harmonic : BddAbove (Set.image (fun t => harmonicSum (N_truncation t)) (Set.Icc 1 a)) := by
              refine' ⟨ ∑ k ∈ Finset.range ( Nat.floor ( Real.sqrt ( a / ( 2 * Real.pi ) ) ) + 1 ), ( 1 : ℝ ) / ( k + 1 ), Set.forall_mem_image.2 fun t ht => _ ⟩;
              refine' le_trans ( Finset.sum_le_sum_of_subset_of_nonneg ( Finset.range_mono ( Nat.le_succ_of_le ( Nat.floor_mono <| Real.sqrt_le_sqrt <| div_le_div_of_nonneg_right ( show t ≤ a by linarith [ ht.2 ] ) <| by positivity ) ) ) fun _ _ _ => by positivity ) _;
              norm_num [ Finset.sum_range_succ ];
            exact ⟨ h_bounded_above_harmonic.choose + 1 / 2 * |Real.log a|, Set.forall_mem_image.2 fun x hx => by cases abs_cases ( Real.log a ) <;> nlinarith [ h_bounded_above_harmonic.choose_spec <| Set.mem_image_of_mem _ hx, Real.log_nonneg hx.1, Real.log_le_log ( by linarith [ hx.1 ] ) hx.2 ] ⟩;
          have h_bounded_below : BddBelow (Set.image (fun t => harmonicSum (N_truncation t) - 1 / 2 * Real.log t) (Set.Icc 1 a)) := by
            refine' ⟨ -Real.log a, Set.forall_mem_image.2 fun x hx => _ ⟩;
            linarith [ Real.log_nonneg hx.1, Real.log_le_log ( by linarith [ hx.1 ] ) hx.2, show 0 ≤ harmonicSum ( N_truncation x ) from Finset.sum_nonneg fun _ _ => by positivity ];
          exact ⟨ Max.max h_bounded_above.choose ( -h_bounded_below.choose ), fun t ht => abs_le.mpr ⟨ by linarith [ h_bounded_below.choose_spec <| Set.mem_image_of_mem _ ht, le_max_right h_bounded_above.choose ( -h_bounded_below.choose ) ], by linarith [ h_bounded_above.choose_spec <| Set.mem_image_of_mem _ ht, le_max_left h_bounded_above.choose ( -h_bounded_below.choose ) ] ⟩ ⟩;
        exact ⟨ Max.max c hM.choose, fun t ht => if h : t ≤ a then le_trans ( hM.choose_spec t ⟨ ht, h ⟩ ) ( le_max_right _ _ ) else le_trans ( ha t ( le_of_not_ge h ) ) ( le_max_left _ _ ) ⟩;
      -- Using the bound from hC, we can bound the integral.
      have h_integral_bound : ∀ T ≥ 1, abs (∫ t in (1:ℝ)..T, harmonicSum (N_truncation t) - 2⁻¹ * Real.log t) ≤ C * (T - 1) := by
        intro T hT;
        rw [ intervalIntegral.integral_of_le hT ];
        refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm ( _ : ℝ → ℝ ) ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
        exacts [ fun _ => C, Filter.Eventually.of_forall fun _ => norm_nonneg _, Continuous.integrableOn_Ioc ( by continuity ), Filter.eventually_of_mem ( MeasureTheory.ae_restrict_mem measurableSet_Ioc ) fun x hx => hC x hx.1.le, by simp +decide [ mul_comm, hT ] ];
      refine' Asymptotics.isBigO_iff.mpr _;
      exact ⟨ C, Filter.eventually_atTop.mpr ⟨ 1, fun x hx => le_trans ( h_integral_bound x hx ) ( mul_le_mul_of_nonneg_left ( by rw [ Real.norm_of_nonneg ] <;> linarith ) ( show 0 ≤ C by exact le_trans ( abs_nonneg _ ) ( hC 1 le_rfl ) ) ) ⟩ ⟩

/-
The integral of 0.5 * log(t) from 1 to T is asymptotically Θ(T log T).
-/
lemma integral_half_log_isTheta :
    (fun T => ∫ t in (1:ℝ)..T, 2⁻¹ * Real.log t) =Θ[Filter.atTop] (fun T => T * Real.log T) := by
      refine' ⟨ _, _ ⟩;
      · norm_num [ Asymptotics.isBigO_iff ];
        refine' ⟨ 1, 2, fun x hx => _ ⟩ ; rw [ abs_of_nonneg, abs_of_nonneg, abs_of_nonneg ] <;> nlinarith [ Real.log_inv x ▸ Real.log_le_sub_one_of_pos ( inv_pos.mpr ( show 0 < x by linarith ) ), Real.log_nonneg ( by linarith : ( 1 : ℝ ) ≤ x ), mul_inv_cancel₀ ( ne_of_gt ( show 0 < x by linarith ) ) ];
      · norm_num [ Filter.EventuallyEq, Filter.Eventually ];
        rw [ Asymptotics.isBigO_iff ];
        refine' ⟨ 8, Filter.eventually_atTop.2 ⟨ Real.exp 8, fun x hx => _ ⟩ ⟩ ; rw [ Real.norm_of_nonneg, Real.norm_of_nonneg ] <;> nlinarith [ Real.add_one_le_exp 8, Real.log_exp 8, Real.log_le_log ( by positivity ) hx, Real.log_nonneg ( show 1 ≤ x by linarith [ Real.add_one_le_exp 8, Real.log_exp 8, Real.log_le_log ( by positivity ) hx ] ) ]

/-
T is little-o of T * log(T) as T goes to infinity.
-/
lemma T_isLittleO_T_log_T :
    (fun T : ℝ => T) =o[Filter.atTop] (fun T => T * Real.log T) := by
      rw [ Asymptotics.isLittleO_iff_tendsto' ] <;> norm_num;
      · -- Simplifying the expression inside the limit.
        suffices h_simp : Filter.Tendsto (fun x : ℝ => 1 / Real.log x) Filter.atTop (nhds 0) by
          refine h_simp.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx using by rw [ ← div_div, div_self <| ne_of_gt <| zero_lt_one.trans hx ] );
        exact tendsto_const_nhds.div_atTop ( Real.tendsto_log_atTop );
      · exact ⟨ 2, by rintro b hb ( rfl | rfl | rfl ) <;> linarith ⟩

/-
The integral of the harmonic sum of the truncation function N_truncation(t) from 1 to T is asymptotically Θ(T log T).
-/
lemma integral_harmonicSum_asymp :
    (fun T => ∫ t in (1:ℝ)..T, harmonicSum (N_truncation t)) =Θ[Filter.atTop] (fun T => T * Real.log T) := by
      -- By transitivity, $f(T) = o(T \log T)$.
      have h_f_o : (fun T : ℝ => ∫ t in (1:ℝ)..T, (harmonicSum (N_truncation t) - 2⁻¹ * Real.log t)) =o[Filter.atTop] fun T => (T * Real.log T) := by
        -- Apply the theorem that states if a function is O(g) and g is o(h), then the function is o(h).
        have h_f_o : (fun T : ℝ => ∫ t in (1:ℝ)..T, (harmonicSum (N_truncation t) - 2⁻¹ * Real.log t)) =O[Filter.atTop] (fun T : ℝ => T) := by
          exact integral_harmonicSum_sub_half_log_isBigO
        exact h_f_o.trans_isLittleO ( T_isLittleO_T_log_T );
      -- The target integral is $f(T) + g(T)$.
      have h_target : (fun T : ℝ => ∫ t in (1:ℝ)..T, harmonicSum (N_truncation t)) = (fun T : ℝ => (∫ t in (1:ℝ)..T, (harmonicSum (N_truncation t) - 2⁻¹ * Real.log t)) + (∫ t in (1:ℝ)..T, 2⁻¹ * Real.log t)) := by
        ext T; rw [ intervalIntegral.integral_sub ] <;> norm_num;
        apply_rules [ MonotoneOn.intervalIntegrable ];
        intro t ht u hu htu; exact Finset.sum_le_sum_of_subset_of_nonneg ( Finset.range_mono <| Nat.floor_mono <| Real.sqrt_le_sqrt <| by gcongr ) fun _ _ _ => by positivity;
      convert h_f_o.add_isTheta ( integral_half_log_isTheta ) using 1

end
