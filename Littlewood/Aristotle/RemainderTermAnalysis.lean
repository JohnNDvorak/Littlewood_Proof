/-
This file was generated by Aristotle (https://aristotle.harmonic.fun).

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 59841ffd-d6d0-4079-964c-dd7edd4af409

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We prove that the remainder term R(x) in the decomposition of π(x) - li(x) is o(√x/log x), assuming the mean square bound for the Chebyshev psi function error term.

The main result is `integral_remainder_small_final`, which states:
  `remainder_term =o[atTop] (fun x => Real.sqrt x / Real.log x)`
under the hypothesis `h_mean_sq : (fun x => ∫ t in 2..x, |psi t - t|^2 / t^2) =O[atTop] Real.log`.

The proof follows the outline:
1. Use Cauchy-Schwarz for integrals (`integral_Ioc_cauchy_schwarz`) to bound `|R(x)|^2` by the product of `∫ |psi(t)-t|^2/t^2` and `∫ 1/log^4 t`.
2. Use the hypothesis `h_mean_sq` to bound the first integral by `O(log x)`.
3. Prove `integral_inv_log_pow_four_bound` to bound the second integral by `O(x/log^4 x)`.
4. Combine these to show `|R(x)|^2 = O(x/log^3 x)` (`remainder_sq_isBigO`).
5. Take square roots and use asymptotic algebra (`asymptotic_algebra_2`) to conclude `R(x) = o(√x/log x)`.

We defined `psi`, `li`, and `remainder_term` as requested.
Note: `integral_remainder_small` was declared with `sorry` in an intermediate step; the fully proven version is `integral_remainder_small_final`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 3200000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.RemainderTermAnalysis

/-
Chebyshev's psi function ψ(x) = ∑_{n ≤ x} Λ(n).
-/
noncomputable def psi (x : ℝ) : ℝ := ∑ n ∈ Finset.Icc 1 ⌊x⌋₊, ArithmeticFunction.vonMangoldt n

/-
The logarithmic integral function li(x) = ∫₂ˣ dt/log t.
-/
noncomputable def li (x : ℝ) : ℝ := ∫ t in 2..x, 1 / Real.log t

/-
The remainder term R(x) = ∫₂ˣ (ψ(t)-t)/(t·log²t) dt.
-/
noncomputable def remainder_term (x : ℝ) : ℝ := ∫ t in 2..x, (psi t - t) / (t * (Real.log t)^2)

/-
The integral of 1/log^4 t from 2 to x is O(x/log^4 x).
-/
open Real MeasureTheory Asymptotics Filter Topology

lemma integral_inv_log_pow_four_bound : (fun x => ∫ t in 2..x, 1 / (Real.log t) ^ 4) =O[atTop] (fun x => x / (Real.log x) ^ 4) := by
  -- Split the integral at $\sqrt{x}$.
  have h_split : ∀ x : ℝ, 4 ≤ x → ∫ t in (2 : ℝ)..x, 1 / (Real.log t)^4 = (∫ t in (2 : ℝ)..Real.sqrt x, 1 / (Real.log t)^4) + (∫ t in (Real.sqrt x)..x, 1 / (Real.log t)^4) := by
    intro x hx; rw [ intervalIntegral.integral_add_adjacent_intervals ] ; all_goals apply_rules [ ContinuousOn.intervalIntegrable ];
    · exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const ( ContinuousAt.pow ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp ht <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] ) ) _ ) ( pow_ne_zero _ <| ne_of_gt <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] );
    · exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const ( ContinuousAt.pow ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp ht <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] ) ) _ ) ( pow_ne_zero _ <| ne_of_gt <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] );
  -- First part: bounded by $\sqrt{x} \max_{t \in [2, \sqrt{x}]} \ �frac�{1}{\log^4 t} = \frac{\sqrt{x}}{\log^4 2} = o(x/\log^4 x)$.
  have h_first_part : ∀ x : ℝ, 4 ≤ x → (∫ t in (2 : ℝ)..Real.sqrt x, 1 / (Real.log t)^4) ≤ Real.sqrt x / (Real.log 2)^4 := by
    intros x hx
    have h_bound : ∀ t ∈ Set.Icc (2 : ℝ) (Real.sqrt x), 1 / (Real.log t)^4 ≤ 1 / (Real.log 2)^4 := by
      exact fun t ht => one_div_le_one_div_of_le ( pow_pos ( Real.log_pos <| by linarith [ ht.1 ] ) _ ) ( pow_le_pow_left₀ ( Real.log_nonneg <| by linarith [ ht.1 ] ) ( Real.log_le_log ( by linarith [ ht.1 ] ) ht.1 ) _ );
    refine' le_trans ( intervalIntegral.integral_mono_on _ _ _ h_bound ) _ <;> norm_num;
    · exact Real.le_sqrt_of_sq_le ( by linarith );
    · apply_rules [ ContinuousOn.intervalIntegrable ];
      exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.inv₀ ( ContinuousAt.pow ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp ht <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] ) ) _ ) ( pow_ne_zero _ <| ne_of_gt <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] );
    · ring_nf; norm_num;
      positivity;
  -- Second part: bounded by $(x-\sqrt{x}) \max_{t (� \�in [\sqrt{x}, x]} \frac{1}{\log^4 t} = \frac{x-\sqrt{x}}{\log^4 \sqrt{x}} = \frac{x-\sqrt{x}}{(\frac{1}{2}\log x)^4} \le 16 \frac{x}{\log^4 x}$.
  have h_second_part : ∀ x : ℝ, 4 ≤ x → (∫ t in (Real.sqrt x)..x, 1 / (Real.log t)^4) ≤ 16 * (x / (Real.log x)^4) := by
    -- For the second part, we use the fact that $\frac{1}{\log^4 t}$ is decreasing on $[\sqrt{x}, x]$.
    intros x hx
    have h_decreasing : ∀ t ∈ Set.Icc (Real.sqrt x) x, 1 / (Real.log t)^4 ≤ 1 / (Real.log (Real.sqrt x))^4 := by
      exact fun t ht => one_div_le_one_div_of_le ( pow_pos ( Real.log_pos <| Real.lt_sqrt_of_sq_lt <| by linarith ) _ ) <| pow_le_pow_left₀ ( Real.log_nonneg <| Real.le_sqrt_of_sq_le <| by linarith ) ( Real.log_le_log ( Real.sqrt_pos.mpr <| by linarith ) ht.1 ) _;
    refine' le_trans ( intervalIntegral.integral_mono_on _ _ _ h_decreasing ) _ <;> norm_num;
    · rw [ Real.sqrt_le_left ] <;> nlinarith;
    · apply_rules [ ContinuousOn.intervalIntegrable ];
      exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.inv₀ ( ContinuousAt.pow ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp ht <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] ) ) _ ) ( pow_ne_zero _ <| ne_of_gt <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> nlinarith [ Real.sqrt_nonneg x, Real.sq_sqrt ( show 0 ≤ x by linarith ) ] );
    · rw [ Real.log_sqrt ( by positivity ) ] ; ring_nf ; norm_num;
      positivity;
  refine' Asymptotics.IsBigO.of_bound 17 _;
  -- We'll use the fact that $\sqrt{x} / (\log 2)^4$ is $o(x / (\log x)^4)$.
  have h_sqrt : Filter.Tendsto (fun x : ℝ => Real.sqrt x / (Real.log 2)^4 / (x / (Real.log x)^4)) Filter.atTop (nhds 0) := by
    -- We can simplify the expression inside the limit.
    suffices h_simplify : Filter.Tendsto (fun x : ℝ => (Real.log x)^4 / (Real.sqrt x * (Real.log 2)^4)) Filter.atTop (nhds 0) by
      convert h_simplify using 2 ; norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
      rw [ ← Real.sqrt_div_self ] ; ring;
    -- We can use the fact that $\frac{(\log x)^4}{\sqrt{x}}$ tends to $0$ as $x$ tends to infinity.
    have h_log_sqrt : Filter.Tendsto (fun x : ℝ => (Real.log x)^4 / Real.sqrt x) Filter.atTop (nhds 0) := by
      -- Let $y = \log x$, therefore the expression becomes $\frac{y^4}{e^{y/2}}$.
      suffices h_log : Filter.Tendsto (fun y : ℝ => y^4 / Real.exp (y / 2)) Filter.atTop (nhds 0) by
        have := h_log.comp Real.tendsto_log_atTop;
        refine this.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Function.comp_apply, Real.sqrt_eq_rpow, Real.rpow_def_of_pos hx ] ; ring );
      -- Let $z = \frac{y}{2}$, therefore the expression becomes $\frac{(2z)^4}{e^z} = \frac{16z^4}{e^z}$.
      suffices h_z : Filter.Tendsto (fun z : ℝ => 16 * z^4 / Real.exp z) Filter.atTop (nhds 0) by
        convert h_z.comp ( Filter.tendsto_id.atTop_mul_const ( by norm_num : 0 < ( 2⁻¹ : ℝ ) ) ) using 2 ; norm_num ; ring;
      simpa [ Real.exp_neg, mul_div_assoc ] using Real.tendsto_pow_mul_exp_neg_atTop_nhds_zero 4 |> Filter.Tendsto.const_mul 16;
    simpa [ div_mul_eq_div_div ] using h_log_sqrt.div_const _;
  filter_upwards [ h_sqrt.eventually ( gt_mem_nhds <| show 0 < 1 / 16 by positivity ), Filter.eventually_ge_atTop 4 ] with x hx₁ hx₂ using by rw [ Real.norm_of_nonneg <| intervalIntegral.integral_nonneg ( by linarith ) fun t ht => one_div_nonneg.mpr <| pow_nonneg ( Real.log_nonneg <| by linarith [ ht.1 ] ) _, Real.norm_of_nonneg <| div_nonneg ( by linarith ) <| pow_nonneg ( Real.log_nonneg <| by linarith ) _ ] ; rw [ div_lt_iff₀ <| div_pos ( by linarith ) <| pow_pos ( Real.log_pos <| by linarith ) _ ] at hx₁ ; nlinarith [ h_split x hx₂, h_first_part x hx₂, h_second_part x hx₂, show 0 ≤ x / Real.log x ^ 4 from div_nonneg ( by linarith ) <| pow_nonneg ( Real.log_nonneg <| by linarith ) _ ] ;

/-
log x * (x / log^4 x) is O(x / log^3 x).
-/
open Real MeasureTheory Asymptotics Filter Topology

lemma asymptotic_algebra_1 : (fun x => Real.log x * (x / (Real.log x)^4)) =O[atTop] (fun x => x / (Real.log x)^3) := by
  rw [ Asymptotics.isBigO_iff ];
  refine' ⟨ 1, Filter.eventually_atTop.mpr ⟨ 2, fun x hx => _ ⟩ ⟩ ; norm_num [ mul_div, pow_succ ];
  rw [ div_le_div_iff₀ ] <;> ring_nf;
  · norm_num;
  · exact mul_pos ( sq_pos_of_pos ( Real.log_pos ( by linarith ) ) ) ( sq_pos_of_pos ( abs_pos.mpr ( ne_of_gt ( Real.log_pos ( by linarith ) ) ) ) );
  · exact mul_pos ( sq_pos_of_pos ( Real.log_pos ( by linarith ) ) ) ( abs_pos.mpr ( ne_of_gt ( Real.log_pos ( by linarith ) ) ) )

/-
sqrt(x / log^3 x) is o(sqrt(x) / log x).
-/
open Real MeasureTheory Asymptotics Filter Topology

lemma asymptotic_algebra_2 : (fun x => Real.sqrt (x / (Real.log x)^3)) =o[atTop] (fun x => Real.sqrt x / Real.log x) := by
  -- We can simplify the expression inside the square root.
  suffices h_simplify : Filter.Tendsto (fun x : ℝ => Real.sqrt (x / (Real.log x)^3) / (Real.sqrt x / Real.log x)) Filter.atTop (nhds 0) by
    rw [ Asymptotics.isLittleO_iff_tendsto' ];
    · convert h_simplify using 1;
    · filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx hx' using absurd hx' <| ne_of_gt <| div_pos ( Real.sqrt_pos.mpr <| by positivity ) <| Real.log_pos hx;
  -- Simplify the expression inside the limit.
  suffices h_simplify : Filter.Tendsto (fun x : ℝ => (Real.log x) / (Real.sqrt (Real.log x ^ 3))) Filter.atTop (nhds 0) by
    refine h_simplify.congr' ?_;
    filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx;
    field_simp [hx];
    rw [ Real.sqrt_div ( by positivity ), mul_div_assoc ];
  -- Simplify the expression inside the limit: $\frac{\log x}{\sqrt{(\log x)^3}} = \frac{1}{\sqrt{\log x}}$.
  suffices h_simplify : Filter.Tendsto (fun x : ℝ => 1 / Real.sqrt (Real.log x)) Filter.atTop (nhds 0) by
    refine h_simplify.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 1 ] with x hx using by rw [ show Real.log x ^ 3 = ( Real.log x ^ 2 ) * Real.log x by ring, Real.sqrt_mul ( by positivity ), Real.sqrt_sq ( by linarith [ Real.log_pos hx ] ) ] ; rw [ div_eq_div_iff ] <;> nlinarith [ Real.log_pos hx, Real.sqrt_nonneg ( Real.log x ), Real.sq_sqrt ( Real.log_nonneg hx.le ) ] );
  exact tendsto_const_nhds.div_atTop ( by simpa only [ Real.sqrt_eq_rpow ] using tendsto_rpow_atTop ( by norm_num ) |> Filter.Tendsto.comp <| Real.tendsto_log_atTop )

/-
If f^2 and g^2 are integrable, then f*g is integrable.
-/
open Real MeasureTheory Asymptotics Filter Topology

lemma integrable_mul_of_sq_integrable {a b : ℝ}
  {f g : ℝ → ℝ}
  (hf_meas : AEStronglyMeasurable f (volume.restrict (Set.Ioc a b)))
  (hg_meas : AEStronglyMeasurable g (volume.restrict (Set.Ioc a b)))
  (hf : MeasureTheory.IntegrableOn (fun t => f t ^ 2) (Set.Ioc a b) volume)
  (hg : MeasureTheory.IntegrableOn (fun t => g t ^ 2) (Set.Ioc a b) volume) :
  MeasureTheory.IntegrableOn (fun t => f t * g t) (Set.Ioc a b) volume := by
    refine' MeasureTheory.Integrable.mono' _ _ _;
    exacts [ fun t => f t ^ 2 + g t ^ 2, hf.add hg, hf_meas.mul hg_meas, Filter.Eventually.of_forall fun t => abs_le.mpr ⟨ by nlinarith only, by nlinarith only ⟩ ]

/-
Integral of |f*g| is bounded by product of L2 norms.
-/
open Real MeasureTheory Asymptotics Filter Topology

lemma integral_abs_mul_le_sqrt_mul_sqrt {a b : ℝ}
  {f g : ℝ → ℝ}
  (hf : MeasureTheory.IntegrableOn (fun t => f t ^ 2) (Set.Ioc a b) volume)
  (hg : MeasureTheory.IntegrableOn (fun t => g t ^ 2) (Set.Ioc a b) volume) :
  ∫ t in Set.Ioc a b, |f t * g t| ≤ Real.sqrt (∫ t in Set.Ioc a b, f t ^ 2) * Real.sqrt (∫ t in Set.Ioc a b, g t ^ 2) := by
    -- We apply `MeasureTheory.integral_mul_le_Lp_mul_Lq_of_nonneg` to `|f|` and `|g|`.
    have h_holder_apply : ∀ {p q : ℝ}, 1 ≤ p → 1 ≤ q → (1 / p) + (1 / q) = 1 →
        MeasureTheory.IntegrableOn (fun t => |f t|^p) (Set.Ioc a b) →
        MeasureTheory.IntegrableOn (fun t => |g t|^q) (Set.Ioc a b) →
        ∫ t in Set.Ioc a b, |f t| * |g t| ≤ (∫ t in Set.Ioc a b, |f t|^p) ^ (1 / p) * (∫ t in Set.Ioc a b, |g t|^q) ^ (1 / q) := by
          intros p q hp hq hpq hf hg;
          have := @MeasureTheory.integral_mul_norm_le_Lp_mul_Lq;
          convert this ( show p.HolderConjugate q from ?_ ) ( show MeasureTheory.MemLp ( fun t => |f t| ) ( ENNReal.ofReal p ) ( MeasureTheory.Measure.restrict MeasureTheory.volume ( Set.Ioc a b ) ) from ?_ ) ( show MeasureTheory.MemLp ( fun t => |g t| ) ( ENNReal.ofReal q ) ( MeasureTheory.Measure.restrict MeasureTheory.volume ( Set.Ioc a b ) ) from ?_ ) using 1;
          · norm_num;
          · norm_num;
          · constructor <;> norm_cast;
            · aesop;
            · positivity;
            · positivity;
          · constructor;
            · have := hf.aestronglyMeasurable;
              have := this.aemeasurable.pow_const ( 1 / p );
              simpa [ ← Real.rpow_mul ( abs_nonneg _ ), mul_inv_cancel₀ ( by positivity : ( p : ℝ ) ≠ 0 ) ] using this.aestronglyMeasurable;
            · rw [ MeasureTheory.eLpNorm_eq_lintegral_rpow_enorm ];
              · refine' ENNReal.rpow_lt_top_of_nonneg _ _;
                · positivity;
                · convert hf.2.ne using 1;
                  simp +decide [ Real.enorm_rpow_of_nonneg, abs_nonneg, hp.trans' ];
              · positivity;
              · norm_num;
          · constructor;
            · have := hg.aestronglyMeasurable;
              have : MeasureTheory.AEStronglyMeasurable (fun t => (|g t| ^ q) ^ (1 / q)) (MeasureTheory.MeasureSpace.volume.restrict (Set.Ioc a b)) := by
                exact this.aemeasurable.pow_const _ |> fun h => h.aestronglyMeasurable;
              simpa only [ ← Real.rpow_mul ( abs_nonneg _ ), mul_one_div_cancel ( by positivity : ( q : ℝ ) ≠ 0 ), Real.rpow_one ] using this;
            · rw [ MeasureTheory.eLpNorm_eq_lintegral_rpow_enorm ];
              · refine' ENNReal.rpow_lt_top_of_nonneg _ _;
                · positivity;
                · convert hg.2.ne using 1;
                  simp +decide [ Real.enorm_rpow_of_nonneg, abs_nonneg, Real.rpow_nonneg, show 0 ≤ q by positivity ];
              · positivity;
              · norm_num;
    specialize @h_holder_apply 2 2 ; norm_num at *;
    simpa only [ Real.sqrt_eq_rpow ] using h_holder_apply hf hg

/-
Cauchy-Schwarz inequality for integrals over (a, b] with measurability assumptions.
-/
open Real MeasureTheory Asymptotics Filter Topology

lemma integral_Ioc_cauchy_schwarz {a b : ℝ} (hab : a ≤ b)
  {f g : ℝ → ℝ}
  (hf_meas : AEStronglyMeasurable f (volume.restrict (Set.Ioc a b)))
  (hg_meas : AEStronglyMeasurable g (volume.restrict (Set.Ioc a b)))
  (hf : MeasureTheory.IntegrableOn (fun t => f t ^ 2) (Set.Ioc a b) volume)
  (hg : MeasureTheory.IntegrableOn (fun t => g t ^ 2) (Set.Ioc a b) volume) :
  (∫ t in Set.Ioc a b, f t * g t)^2 ≤ (∫ t in Set.Ioc a b, f t ^ 2) * (∫ t in Set.Ioc a b, g t ^ 2) := by
    -- Apply the Cauchy-Schwarz inequality for integrals.
    have cauchy_schwarz_inequality : (∫ t in (Set.Ioc a b), |f t * g t|) ^ 2 ≤ (∫ t in (Set.Ioc a b), f t ^ 2) * (∫ t in (Set.Ioc a b), g t ^ 2) := by
      have := @integral_abs_mul_le_sqrt_mul_sqrt a b f g hf hg;
      exact le_trans ( pow_le_pow_left₀ ( MeasureTheory.integral_nonneg fun _ => abs_nonneg _ ) this 2 ) ( by rw [ mul_pow, Real.sq_sqrt ( MeasureTheory.integral_nonneg fun _ => sq_nonneg _ ), Real.sq_sqrt ( MeasureTheory.integral_nonneg fun _ => sq_nonneg _ ) ] );
    exact le_trans ( by simpa [ sq_abs ] using pow_le_pow_left₀ ( abs_nonneg _ ) ( MeasureTheory.norm_integral_le_integral_norm ( f * g ) ) 2 ) cauchy_schwarz_inequality

/-
The square of the remainder term is bounded by the product of the integrals of the squared factors.
-/
open Real MeasureTheory Asymptotics Filter Topology

lemma remainder_sq_le_product_bound (x : ℝ) (hx : 2 ≤ x) :
  |remainder_term x|^2 ≤ (∫ t in 2..x, |psi t - t|^2 / t^2) * (∫ t in 2..x, 1 / (Real.log t)^4) := by
    -- Apply the Cauchy-Schwarz inequality with $f(t) = \frac{\psi(t) - t}{t}$ and $g(t) = \frac{1}{\log^2 t}$.
    have h_cauchy_schwarz : (∫ t in Set.Ioc 2 x, (psi t - t) / t * (1 / (Real.log t)^2))^2 ≤ (∫ t in Set.Ioc 2 x, ((psi t - t) / t)^2) * (∫ t in Set.Ioc 2 x, (1 / (Real.log t)^2)^2) := by
      apply integral_Ioc_cauchy_schwarz hx;
      · refine' MeasureTheory.AEStronglyMeasurable.mul _ _;
        · refine' Measurable.aestronglyMeasurable _;
          -- The function psi(t) is a sum of step functions, each of which is measurable.
          have h_psi_measurable : Measurable psi := by
            apply_rules [ Monotone.measurable, measurable_const ];
            intro x y hxy;
            exact Finset.sum_le_sum_of_subset_of_nonneg ( Finset.Icc_subset_Icc_right ( Nat.floor_mono hxy ) ) fun _ _ _ => by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg;
          exact h_psi_measurable.sub measurable_id;
        · exact measurable_inv.aestronglyMeasurable;
      · exact Measurable.aestronglyMeasurable ( by exact Measurable.div measurable_const ( by exact Measurable.pow_const ( Real.measurable_log ) _ ) );
      · -- The function $(\psi(t) - t) / t$ is bounded on $[2, x]$ because $\psi(t)$ is bounded by $t \log t$.
        have h_bounded : ∃ C : ℝ, ∀ t ∈ Set.Ioc 2 x, abs ((psi t - t) / t) ≤ C := by
          -- Since $\psi(t �)$� is bounded on $[2, x]$, the function $(\psi(t) - t) / t$ is also bounded on $[2, x]$. Use this fact.
          have h_bounded : ∃ C, ∀ t ∈ Set.Ioc 2 x, abs (psi t - t) ≤ C := by
            -- Since $\psi(t)$ is a sum of terms that are each bounded by $\log t$, we can bound $\psi(t)$ itself.
            have h_psi_bound : ∀ t ∈ Set.Ioc 2 x, psi t ≤ t * Real.log t := by
              intro t ht
              have h_psi_le : psi t ≤ ∑ n ∈ Finset.Icc 1 ⌊t⌋₊, Real.log n := by
                refine' Finset.sum_le_sum fun n hn => _;
                exact ArithmeticFunction.vonMangoldt_le_log
              refine le_trans h_psi_le ?_;
              refine' le_trans ( Finset.sum_le_sum fun i hi => Real.log_le_log ( Nat.cast_pos.mpr <| Finset.mem_Icc.mp hi |>.1 ) <| Nat.floor_le ( by linarith [ ht.1 ] ) |> le_trans ( Nat.cast_le.mpr <| Finset.mem_Icc.mp hi |>.2 ) ) _ ; norm_num;
              exact mul_le_mul_of_nonneg_right ( Nat.floor_le ( by linarith [ ht.1 ] ) ) ( Real.log_nonneg ( by linarith [ ht.1 ] ) );
            -- Since $\psi(t)$ is a sum of terms that are each bounded by $\log t$, we can bound $\psi(t)$ itself by $t \log t$.
            have h_psi_bound : ∀ t ∈ Set.Ioc 2 x, psi t ≥ 0 := by
              exact fun t ht => Finset.sum_nonneg fun i hi => by exact_mod_cast ArithmeticFunction.vonMangoldt_nonneg;
            use x * Real.log x + x;
            intro t ht; rw [ abs_le ] ; constructor <;> nlinarith [ ht.1, ht.2, h_psi_bound t ht, ‹∀ t ∈ Set.Ioc 2 x, psi t ≤ t * Real.log t› t ht, Real.log_nonneg ( by linarith [ ht.1 ] : ( 1 : ℝ ) ≤ t ), Real.log_le_log ( by linarith [ ht.1 ] ) ht.2 ] ;
          exact ⟨ h_bounded.choose, fun t ht => by rw [ abs_div ] ; exact div_le_self ( abs_nonneg _ ) ( by rw [ abs_of_nonneg ] <;> linarith [ ht.1 ] ) |> le_trans <| h_bounded.choose_spec t ht ⟩;
        refine' MeasureTheory.Integrable.mono' _ _ _;
        refine' fun t => h_bounded.choose ^ 2;
        · norm_num;
        · -- The function $(\psi(t) - t) / t$ is measurable because $\psi(t)$ is a sum of measurable functions.
          have h_measurable : Measurable (fun t : ℝ => psi t) := by
            apply_rules [ Monotone.measurable, measurable_const ];
            intro a b hab;
            exact Finset.sum_le_sum_of_subset_of_nonneg ( Finset.Icc_subset_Icc_right ( Nat.floor_mono hab ) ) fun _ _ _ => by exact ( by rw [ ArithmeticFunction.vonMangoldt_apply ] ; positivity ) ;
          field_simp;
          exact Measurable.aestronglyMeasurable ( by exact Measurable.mul ( Measurable.pow_const ( h_measurable.sub measurable_id' ) _ ) ( measurable_id'.pow_const _ |> Measurable.inv ) );
        · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioc ] with t ht using by simpa [ abs_div, div_pow ] using pow_le_pow_left₀ ( by positivity ) ( h_bounded.choose_spec t ht ) 2;
      · exact ContinuousOn.integrableOn_Icc ( by exact ContinuousOn.pow ( continuousOn_const.div ( ContinuousOn.pow ( Real.continuousOn_log.mono <| by norm_num ) _ ) fun t ht => ne_of_gt <| sq_pos_of_pos <| Real.log_pos <| by linarith [ ht.1 ] ) _ ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self;
    convert h_cauchy_schwarz using 1;
    · unfold remainder_term; rw [ intervalIntegral.integral_of_le ( by linarith ) ] ; norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ] ;
    · norm_num [ div_pow, ← intervalIntegral.integral_of_le hx ];
      exact Or.inl <| by congr; ext; ring;

/-
The remainder term R(x) is o(√x/log x), assuming the mean square bound on ψ(t)-t.
-/
open Real MeasureTheory Asymptotics Filter Topology

/-- The remainder term R(x) is o(√x/log x), assuming the mean square bound. -/
theorem integral_remainder_small
  (h_mean_sq : (fun x => ∫ t in 2..x, |psi t - t|^2 / t^2) =O[atTop] Real.log) :
  remainder_term =o[atTop] (fun x => Real.sqrt x / Real.log x) := by
    -- By the properties of integrals and powers, we can combine the bounds.
    have h_combined : (fun x => |remainder_term x| ^ 2) =O[atTop] (fun x => (Real.log x) * (x / (Real.log x) ^ 4)) := by
      have h_combined : (fun x => |remainder_term x| ^ 2) =O[atTop] (fun x => (∫ t in (2 : ℝ)..x, |psi t - t| ^ 2 / t ^ 2) * (∫ t in (2 : ℝ)..x, 1 / (Real.log t) ^ 4)) := by
        refine' Asymptotics.IsBigO.of_bound 1 _;
        filter_upwards [ Filter.eventually_gt_atTop 2 ] with x hx;
        convert remainder_sq_le_product_bound x hx.le using 1 ; norm_num [ abs_div, abs_mul ];
        rw [ one_mul, Real.norm_of_nonneg ( mul_nonneg ( intervalIntegral.integral_nonneg ( by linarith ) fun t ht => div_nonneg ( sq_nonneg _ ) ( sq_nonneg _ ) ) ( intervalIntegral.integral_nonneg ( by linarith ) fun t ht => one_div_nonneg.mpr ( pow_nonneg ( Real.log_nonneg ( by linarith [ ht.1 ] ) ) _ ) ) ) ];
      refine' h_combined.trans ( h_mean_sq.mul _ );
      exact integral_inv_log_pow_four_bound
    -- Taking square roots, $|R(x)| = O(\sqrt{x} / \log^{1.5} x)$.
    have h_sqrt : (fun x => |remainder_term x|) =O[atTop] (fun x => Real.sqrt (x / (Real.log x) ^ 3)) := by
      rw [ Asymptotics.isBigO_iff ] at *;
      obtain ⟨ c, hc ⟩ := h_combined; use Real.sqrt c; filter_upwards [ hc, Filter.eventually_gt_atTop 1 ] with x hx₁ hx₂; norm_num [ abs_of_nonneg, Real.sqrt_nonneg ] at *;
      rw [ ← Real.sqrt_mul' ];
      · convert Real.abs_le_sqrt hx₁ using 1 ; norm_num [ abs_of_pos, Real.log_pos hx₂ ] ; ring;
        rw [ abs_of_pos ( by positivity ) ] ; by_cases h : Real.log x = 0 <;> simp +decide [ h, show ( Real.log x ) ^ 4 = ( Real.log x ) ^ 3 * Real.log x by ring, mul_assoc, mul_comm, mul_left_comm ];
      · exact div_nonneg ( by positivity ) ( pow_nonneg ( Real.log_nonneg hx₂.le ) _ );
    -- Since $\sqrt{x / \log^3 x} = \sqrt{x} / \log^{1.5} x$, we can conclude that $|R(x)| = o(\sqrt{x} / \log x)$.
    have h_final : (fun x => |remainder_term x|) =o[atTop] (fun x => Real.sqrt x / Real.log x) := by
      refine' h_sqrt.trans_isLittleO _;
      convert asymptotic_algebra_2 using 1;
    simpa [Real.norm_eq_abs] using Asymptotics.IsLittleO.of_norm_left h_final

/-
The square of the remainder term is O(x/log^3 x).
-/
open Real MeasureTheory Asymptotics Filter Topology

lemma remainder_sq_isBigO
  (h_mean_sq : (fun x => ∫ t in 2..x, |psi t - t|^2 / t^2) =O[atTop] Real.log) :
  (fun x => |remainder_term x|^2) =O[atTop] (fun x => x / (Real.log x)^3) := by
    have h_log_sq : (fun x => |remainder_term x| ^ 2) =O[Filter.atTop] (fun x => (∫ t in (2 : ℝ)..x, |psi t - t| ^ 2 / t ^ 2) * (∫ t in (2 : ℝ)..x, 1 / (Real.log t) ^ 4)) := by
      refine' Asymptotics.IsBigO.of_bound 1 _;
      filter_upwards [ Filter.eventually_ge_atTop 2 ] with x hx;
      convert remainder_sq_le_product_bound x hx using 1 ; norm_num;
      rw [ one_mul, Real.norm_of_nonneg ( mul_nonneg ( intervalIntegral.integral_nonneg ( by linarith ) fun t ht => div_nonneg ( sq_nonneg _ ) ( sq_nonneg _ ) ) ( intervalIntegral.integral_nonneg ( by linarith ) fun t ht => one_div_nonneg.mpr ( pow_nonneg ( Real.log_nonneg ( by linarith [ ht.1 ] ) ) _ ) ) ) ];
    refine' h_log_sq.trans _;
    convert h_mean_sq.mul ( integral_inv_log_pow_four_bound ) using 1;
    grind

/-
The remainder term R(x) is o(√x/log x), assuming the mean square bound on ψ(t)-t.
-/
open Real MeasureTheory Asymptotics Filter Topology

/-- The remainder term R(x) is o(√x/log x), assuming the mean square bound. -/
theorem integral_remainder_small_final
  (h_mean_sq : (fun x => ∫ t in 2..x, |psi t - t|^2 / t^2) =O[atTop] Real.log) :
  remainder_term =o[atTop] (fun x => Real.sqrt x / Real.log x) := by
    convert integral_remainder_small h_mean_sq using 1

/-
The remainder term R(x) is o(√x/log x), assuming the mean square bound on ψ(t)-t.
-/
open Real MeasureTheory Asymptotics Filter Topology

/-- The remainder term R(x) is o(√x/log x), assuming the mean square bound. -/
theorem integral_remainder_small_proven
  (h_mean_sq : (fun x => ∫ t in 2..x, |psi t - t|^2 / t^2) =O[atTop] Real.log) :
  remainder_term =o[atTop] (fun x => Real.sqrt x / Real.log x) := by
    convert integral_remainder_small_final h_mean_sq using 1
end Aristotle.RemainderTermAnalysis
