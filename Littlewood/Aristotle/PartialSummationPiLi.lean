/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: bbb135f6-1efb-4311-8f54-1c75d6127acb

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Partial summation decomposition for π(x) - li(x).

KEY RESULTS:
- li_integration_by_parts: li(x) = x/log(x) - 2/log(2) + ∫ dt/log²(t)
- sum_vonMangoldt_div_log: Abel summation for Σ Λ(n)/log(n)
- partial_summation_decomposition: π(x) - li(x) = (ψ(x)-x)/log(x) + ∫(ψ(t)-t)/(t log²t) - T(x) + C
- primePowerCorrection_eq_sum: T(x) = Σ_{k≥2} π(x^{1/k})/k
- Various bounds on the prime power correction term

NOTE: This file uses local definitions of chebyshevPsi, primeCountingReal, li to be self-contained.
These may conflict with Basic/. Import this file separately if needed.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace PartialSummationPiLiModule

/-
Definitions of Chebyshev's Psi function, the prime counting function for real arguments, and the logarithmic integral.
-/
noncomputable def chebyshevPsi (x : ℝ) : ℝ :=
  ∑ n ∈ Finset.Icc 1 ⌊x⌋₊, ArithmeticFunction.vonMangoldt n

noncomputable def primeCountingReal (x : ℝ) : ℝ :=
  Nat.primeCounting ⌊x⌋₊

noncomputable def li (x : ℝ) : ℝ := ∫ t in (2)..x, 1 / Real.log t

/-
Definition of the prime power correction term T(x) = sum_{n <= x} (Lambda(n)/log n) - pi(x).
-/
noncomputable def primePowerCorrection (x : ℝ) : ℝ :=
  (∑ n ∈ Finset.Icc 1 ⌊x⌋₊, ArithmeticFunction.vonMangoldt n / Real.log n) - primeCountingReal x

/-
Integration by parts for li(x): li(x) = x/log(x) - 2/log(2) + int_2^x dt/log^2(t).
-/
theorem li_integration_by_parts (x : ℝ) (hx : 2 ≤ x) :
    li x = x / Real.log x - 2 / Real.log 2 + ∫ t in (2)..x, 1 / (Real.log t)^2 := by
      -- We'll use the fact that integration by parts gives us the expression we need.
      have h_parts : ∀ a b : ℝ, 2 ≤ a → a < b → (∫ t in a..b, (1 / Real.log t)) = (b / Real.log b) - (a / Real.log a) + ∫ t in a..b, (1 / Real.log t ^ 2 : ℝ) := by
        -- Applying integration by parts with $u = \frac{1}{\log t}$ and $dv = dt$, we get:
        have h_parts : ∀ a b : ℝ, 2 ≤ a → a < b → ∫ t in a..b, (1 / Real.log t) = (b / Real.log b) - (a / Real.log a) - ∫ t in a..b, t * (-1 / (t * Real.log t ^ 2)) := by
          intro a b ha hb; rw [ intervalIntegral.integral_mul_deriv_eq_deriv_mul ] <;> norm_num;
          any_goals intro x hx; exact hasDerivAt_id x;
          rotate_right;
          use fun x => ( Real.log x ) ⁻¹;
          · ring;
          · intro x hx; convert HasDerivAt.inv ( Real.hasDerivAt_log ( show x ≠ 0 by cases Set.mem_uIcc.mp hx <;> linarith ) ) ( ne_of_gt <| Real.log_pos <| show x > 1 by cases Set.mem_uIcc.mp hx <;> linarith ) using 1 ; ring;
          · norm_num;
          · apply_rules [ ContinuousOn.intervalIntegrable ];
            exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div ( continuousAt_const ) ( ContinuousAt.mul ( continuousAt_id ) ( ContinuousAt.pow ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp ht <;> linarith ) ) _ ) ) ( ne_of_gt ( mul_pos ( by cases Set.mem_uIcc.mp ht <;> linarith ) ( sq_pos_of_pos ( Real.log_pos ( by cases Set.mem_uIcc.mp ht <;> linarith ) ) ) ) );
        intro a b ha hb; rw [ h_parts a b ha hb ] ; norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
        refine' intervalIntegral.integral_congr fun t ht => by rw [ ← mul_assoc, mul_inv_cancel₀ ( by linarith [ Set.mem_Icc.mp ( by simpa [ hb.le ] using ht ) ] ), one_mul ];
      rcases eq_or_lt_of_le hx with rfl | hx <;> [ norm_num; exact h_parts _ _ le_rfl hx ];
      unfold li; norm_num;

/-
Abel summation applied to sum_{n <= x} Lambda(n)/log(n).
-/
theorem sum_vonMangoldt_div_log (x : ℝ) (hx : 2 ≤ x) :
    ∑ n ∈ Finset.Icc 1 ⌊x⌋₊, ArithmeticFunction.vonMangoldt n / Real.log n =
    chebyshevPsi x / Real.log x + ∫ t in (2)..x, chebyshevPsi t / (t * Real.log t ^ 2) := by
      -- Next, use integration by parts to rewrite the integral.
      suffices h_integral : ∫ t in (2)..x, chebyshevPsi t / (t * (Real.log t) ^ 2) = (∑ n ∈ Finset.Icc 1 ⌊x⌋₊, (ArithmeticFunction.vonMangoldt n) / (Real.log n)) - (chebyshevPsi x) / (Real.log x) by
        linarith;
      by_contra h_contra;
      -- Applying the definition of $chebyshevPsi$ to rewrite the integral.
      have h_integral : ∫ t in (2)..x, (chebyshevPsi t) / (t * (Real.log t)^2) = ∑ n ∈ Finset.Icc 1 ⌊x⌋₊, (ArithmeticFunction.vonMangoldt n) * (∫ t in (2)..x, (if n ≤ t then 1 / (t * (Real.log t)^2) else 0)) := by
        have h_integral : ∫ t in (2)..x, (chebyshevPsi t) / (t * (Real.log t)^2) = ∫ t in (2)..x, (∑ n ∈ Finset.Icc 1 ⌊x⌋₊, (ArithmeticFunction.vonMangoldt n) * (if n ≤ t then 1 else 0)) / (t * (Real.log t)^2) := by
          refine' intervalIntegral.integral_congr fun t ht => _;
          rw [ show ( Finset.Icc 1 ⌊x⌋₊ : Finset ℕ ) = Finset.Icc 1 ⌊t⌋₊ ∪ Finset.Icc ( ⌊t⌋₊ + 1 ) ⌊x⌋₊ from ?_, Finset.sum_union ] <;> norm_num;
          · rw [ Finset.sum_congr rfl fun i hi => if_pos <| Nat.floor_le ( by cases Set.mem_uIcc.mp ht <;> linarith ) |> le_trans ( Nat.cast_le.mpr <| Finset.mem_Icc.mp hi |>.2 ), Finset.sum_congr rfl fun i hi => if_neg <| Nat.lt_of_floor_lt ( Finset.mem_Icc.mp hi |>.1 ) |> not_le_of_gt ] ; aesop;
          · exact Finset.disjoint_left.mpr fun n hn₁ hn₂ => by linarith [ Finset.mem_Icc.mp hn₁, Finset.mem_Icc.mp hn₂ ] ;
          · exact Eq.symm ( Finset.Ico_union_Ico_eq_Ico ( by norm_num ) ( by cases Set.mem_uIcc.mp ht <;> linarith [ Nat.floor_mono ( by linarith : t ≤ x ) ] ) );
        rw [ h_integral ];
        simp +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, ← intervalIntegral.integral_const_mul ];
        rw [ intervalIntegral.integral_finset_sum ];
        intro n hn; apply_rules [ MeasureTheory.IntegrableOn.intervalIntegrable ];
        refine' MeasureTheory.Integrable.indicator _ _;
        · exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun t ht => by exact ContinuousAt.mul ( ContinuousAt.inv₀ continuousAt_id <| by cases Set.mem_uIcc.mp ht <;> linarith ) <| ContinuousAt.mul ( ContinuousAt.inv₀ ( ContinuousAt.pow ( Real.continuousAt_log <| by cases Set.mem_uIcc.mp ht <;> linarith ) _ ) <| ne_of_gt <| sq_pos_of_pos <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> linarith ) continuousAt_const );
        · exact measurableSet_Ici;
      -- Evaluating the inner integral $\int_{2}^{x} \frac{1}{t \log^2 t} \, dt$.
      have h_inner_integral : ∀ n ∈ Finset.Icc 1 ⌊x⌋₊, ∫ t in (2)..x, (if n ≤ t then 1 / (t * (Real.log t)^2) else 0) = (if 2 ≤ n then 1 / (Real.log n) - 1 / (Real.log x) else 1 / (Real.log 2) - 1 / (Real.log x)) := by
        intro n hn
        by_cases hn2 : 2 ≤ n;
        · -- Split the integral into two parts: from 2 to n and from n to x.
          have h_split_integral : ∫ t in (2)..x, (if n ≤ t then 1 / (t * (Real.log t)^2) else 0) = (∫ t in (n)..x, 1 / (t * (Real.log t)^2)) := by
            rw [ intervalIntegral.integral_of_le, intervalIntegral.integral_of_le ];
            · rw [ ← MeasureTheory.integral_indicator, ← MeasureTheory.integral_indicator ] <;> norm_num [ Set.indicator ];
              rw [ MeasureTheory.integral_congr_ae ];
              filter_upwards [ MeasureTheory.measure_eq_zero_iff_ae_notMem.mp ( MeasureTheory.measure_singleton ( n : ℝ ) ) ] with t ht;
              split_ifs <;> norm_num at *;
              · linarith [ ‹ ( n : ℝ ) < t → x < t › ( lt_of_le_of_ne ‹_› ( Ne.symm ht ) ) ];
              · linarith;
              · linarith [ ‹2 < t → x < t› ( by linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) ];
            · exact le_trans ( Nat.cast_le.mpr ( Finset.mem_Icc.mp hn |>.2 ) ) ( Nat.floor_le ( by positivity ) );
            · linarith;
          rw [ h_split_integral, intervalIntegral.integral_eq_sub_of_hasDerivAt ];
          rotate_right;
          use fun t => -1 / Real.log t;
          · rw [ if_pos hn2 ] ; ring;
          · intro t ht; convert HasDerivAt.div ( hasDerivAt_const _ _ ) ( Real.hasDerivAt_log ( show t ≠ 0 by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) ) ( ne_of_gt <| Real.log_pos <| show t > 1 by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) using 1 ; ring;
          · apply_rules [ ContinuousOn.intervalIntegrable ];
            exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.div continuousAt_const ( ContinuousAt.mul continuousAt_id <| ContinuousAt.pow ( Real.continuousAt_log <| by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) _ ) <| ne_of_gt <| mul_pos ( by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ) <| sq_pos_of_pos <| Real.log_pos <| by cases Set.mem_uIcc.mp ht <;> linarith [ show ( n : ℝ ) ≥ 2 by norm_cast ] ;
        · interval_cases n <;> norm_num at *;
          rw [ intervalIntegral.integral_congr fun t ht => if_pos <| by linarith [ Set.mem_Icc.mp <| by simpa [ hx ] using ht ] ];
          rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
          rotate_right;
          use fun t => - ( Real.log t ) ⁻¹;
          · ring;
          · intro t ht; convert HasDerivAt.neg ( HasDerivAt.inv ( Real.hasDerivAt_log ( show t ≠ 0 by cases Set.mem_uIcc.mp ht <;> linarith ) ) ( ne_of_gt ( Real.log_pos ( show t > 1 by cases Set.mem_uIcc.mp ht <;> linarith ) ) ) ) using 1 ; ring;
          · apply_rules [ ContinuousOn.intervalIntegrable ];
            exact continuousOn_of_forall_continuousAt fun t ht => ContinuousAt.mul ( ContinuousAt.inv₀ ( ContinuousAt.pow ( Real.continuousAt_log ( by cases Set.mem_uIcc.mp ht <;> linarith ) ) _ ) ( ne_of_gt ( sq_pos_of_pos ( Real.log_pos ( by cases Set.mem_uIcc.mp ht <;> linarith ) ) ) ) ) ( ContinuousAt.inv₀ ( continuousAt_id ) ( ne_of_gt ( by cases Set.mem_uIcc.mp ht <;> linarith ) ) );
      simp_all +decide [ div_eq_mul_inv, Finset.sum_mul _ _ _ ];
      refine' h_contra _;
      rw [ Finset.sum_congr rfl fun n hn => by rw [ h_inner_integral n ( Finset.mem_Icc.mp hn |>.1 ) ( Finset.mem_Icc.mp hn |>.2 ) ] ];
      unfold chebyshevPsi; norm_num [ Finset.sum_ite ] ; ring;
      rw [ show ( Finset.filter ( fun n => 2 ≤ n ) ( Finset.Icc 1 ⌊x⌋₊ ) ) = Finset.Icc 1 ⌊x⌋₊ \ { 1 } from ?_, show ( Finset.filter ( fun n => n < 2 ) ( Finset.Icc 1 ⌊x⌋₊ ) ) = { 1 } from ?_ ] <;> norm_num [ Finset.sum_sub_distrib, Finset.mul_sum _ _ _, Finset.sum_add_distrib ] ; ring;
      · rw [ Finset.sum_eq_sum_diff_singleton_add ( show 1 ∈ Finset.Icc 1 ⌊x⌋₊ from Finset.mem_Icc.mpr ⟨ by norm_num, Nat.floor_pos.mpr <| by linarith ⟩ ) ] ; ring;
        rw [ Finset.sum_eq_sum_diff_singleton_add ( show 1 ∈ Finset.Icc 1 ⌊x⌋₊ from Finset.mem_Icc.mpr ⟨ by norm_num, Nat.floor_pos.mpr <| by linarith ⟩ ) ] ; norm_num ; ring;
      · ext ( _ | _ | n ) <;> simp +arith +decide;
        linarith;
      · ext ( _ | _ | n ) <;> simp +arith +decide

/-
For a prime p and k >= 1, Lambda(p^k)/log(p^k) = 1/k.
-/
lemma vonMangoldt_div_log_prime_pow {p k : ℕ} (hp : p.Prime) (hk : k ≥ 1) :
    ArithmeticFunction.vonMangoldt (p ^ k) / Real.log (p ^ k) = 1 / k := by
      rw [ ArithmeticFunction.vonMangoldt ] ;
      simp +zetaDelta at *;
      rw [ if_pos ];
      · norm_num [ Nat.Prime.pow_minFac hp ( by linarith ), hp.ne_zero ];
        rw [ inv_eq_one_div, div_eq_div_iff ] <;> nlinarith [ Real.log_pos ( Nat.one_lt_cast.mpr hp.one_lt ), show ( k : ℝ ) ≥ 1 by norm_cast ];
      · exact hp.isPrimePow.pow ( by linarith )

/-
The sum of Lambda(n)/log(n) is equal to the sum over prime powers, since Lambda(n) is zero otherwise.
-/
theorem sum_vonMangoldt_eq_sum_prime_powers (x : ℝ) :
    ∑ n ∈ Finset.Icc 1 ⌊x⌋₊, ArithmeticFunction.vonMangoldt n / Real.log n =
    ∑ n ∈ (Finset.Icc 1 ⌊x⌋₊).filter IsPrimePow, ArithmeticFunction.vonMangoldt n / Real.log n := by
      rw [ Finset.sum_filter_of_ne ];
      intro n hn h;
      contrapose! h; simp_all +decide [ ArithmeticFunction.vonMangoldt_apply ] ;

/-
Uniqueness of prime power representation: p^k = q^l iff p=q and k=l for primes p, q and k, l >= 1.
-/
theorem prime_pow_inj {p q k l : ℕ} (hp : p.Prime) (hq : q.Prime) (hk : k ≥ 1) (hl : l ≥ 1) :
    p ^ k = q ^ l ↔ p = q ∧ k = l := by
      constructor;
      · intro h
        have hp_eq_q : p = q := by
          exact Nat.prime_dvd_prime_iff_eq hp hq |>.1 ( hp.dvd_of_dvd_pow <| h ▸ dvd_pow_self _ ( by linarith ) )
        have hk_eq_l : k = l := by
          apply_fun fun x => x.factorization q at h ; simp_all +decide [ hp.ne_zero, hq.ne_zero ]
        exact ⟨hp_eq_q, hk_eq_l⟩;
      · aesop

/-
Inequality equivalence: p^k <= x iff p <= x^(1/k) for p>=2, k>=1, x>=2.
-/
lemma prime_pow_le_iff_le_root (p k : ℕ) (x : ℝ) (hp : p ≥ 2) (hk : k ≥ 1) (hx : x ≥ 2) :
    (p : ℝ) ^ k ≤ x ↔ (p : ℝ) ≤ x ^ (1 / (k : ℝ)) := by
      rw [ Real.le_rpow_iff_log_le ] <;> norm_num;
      · rw [ inv_mul_eq_div, le_div_iff₀' ( by positivity ), ← Real.log_pow, Real.log_le_log_iff ( by positivity ) ( by positivity ) ];
      · linarith;
      · linarith

/-
Definition of the prime power correction sum T(x) = sum_{k>=2} pi(x^(1/k))/k.
-/
noncomputable def primePowerCorrectionSum (x : ℝ) : ℝ :=
  ∑ k ∈ Finset.Icc 2 ⌊Real.log x / Real.log 2⌋₊, (primeCountingReal (x ^ (1 / (k : ℝ))) / k)

/-
Sum of a constant c over primes p <= x^(1/k) is c * pi(x^(1/k)).
-/
theorem sum_prime_powers_fixed_k (x : ℝ) (k : ℕ) (hk : k ≥ 1) (c : ℝ) :
    ∑ p ∈ (Finset.Icc 1 ⌊x ^ (1 / (k : ℝ))⌋₊).filter Nat.Prime, c = c * primeCountingReal (x ^ (1 / (k : ℝ))) := by
      simp +decide [ mul_comm, primeCountingReal ];
      rw [ Nat.primeCounting ];
      rw [ Nat.primeCounting', Nat.count_eq_card_filter_range ];
      exact Or.inl ( congr_arg Finset.card ( by ext ( _ | p ) <;> aesop ) )

/-
Bound for the k=2 term: pi(sqrt(x))/2 <= sqrt(x)/2.
-/
theorem primePowerCorrectionSum_term_two_bound (x : ℝ) (hx : 0 ≤ x) :
    primeCountingReal (x ^ (1 / 2 : ℝ)) / 2 ≤ Real.sqrt x / 2 := by
      gcongr ; norm_num [ ← Real.sqrt_eq_rpow ];
      -- Apply the theorem that states π(n) ≤ n for any natural number n.
      have h_prime_counting_le : ∀ n : ℕ, Nat.primeCounting n ≤ n := by
        intro n; rw [ Nat.primeCounting ] ;
        rw [ Nat.primeCounting', Nat.count_eq_card_filter_range ];
        exact le_trans ( Finset.card_le_card ( show Finset.filter Nat.Prime ( Finset.range ( n + 1 ) ) ⊆ Finset.Ico 2 ( n + 1 ) from fun x hx => Finset.mem_Ico.mpr ⟨ Nat.Prime.two_le ( Finset.mem_filter.mp hx |>.2 ), Finset.mem_range.mp ( Finset.mem_filter.mp hx |>.1 ) ⟩ ) ) ( by simp +arith +decide );
      exact le_trans ( Nat.cast_le.mpr ( h_prime_counting_le _ ) ) ( Nat.floor_le ( Real.sqrt_nonneg _ ) )

end PartialSummationPiLiModule
