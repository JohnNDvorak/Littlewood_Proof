/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 577b5df6-5847-4f8b-a55b-ae0efd3534fa

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the Chebyshev function $\theta(x) = \sum_{p \le x} \log p$ and prove that $\theta(x) = O(x)$.
The proof follows Chebyshev's original method using the central binomial coefficient $C(2n, n) = \binom{2n}{n}$.
We show that $\prod_{n < p \le 2n} p$ divides $\binom{2n}{n}$, which implies $\theta(2n) - \theta(n) \le \log \binom{2n}{n} \le 2n \log 2$.
Summing this bound over powers of 2 yields $\theta(2^k) \le 2^{k+1} \log 2$, which extends to general $x$ by monotonicity.
We conclude that $\theta(x) \le (4 \log 2) x$ for $x \ge 1$.
-/

import Mathlib
import Littlewood.Aristotle.ThetaLinearBoundV2

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ThetaLinearBound

/-
Definition of the Chebyshev function theta(x) = sum_{p <= x} log p
-/
noncomputable def theta (x : ℝ) : ℝ := ∑ p ∈ Nat.primesBelow (⌊x⌋₊ + 1), Real.log p

/-
theta(x) is a non-decreasing function.
-/
lemma theta_mono {x y : ℝ} (h : x ≤ y) : theta x ≤ theta y := by
  unfold theta
  apply Finset.sum_le_sum_of_subset_of_nonneg
  · intro p hp
    simp only [Nat.primesBelow, Finset.mem_filter, Finset.mem_range] at hp ⊢
    exact ⟨Nat.lt_succ_of_le (Nat.le_of_lt_succ hp.1 |>.trans (Nat.floor_mono h)), hp.2⟩
  · intro p _ _
    exact Real.log_nonneg (Nat.one_le_cast.mpr (Nat.Prime.one_le (Nat.prime_of_mem_primesBelow ‹_›)))

/-
The central binomial coefficient C(2n, n) is at most 4^n.
-/
lemma centralBinom_le_four_pow (n : ℕ) : Nat.centralBinom n ≤ 4 ^ n := by
  -- By definition of binomial coefficients, we know that $(2n choose n) \leq 2^{2n}$.
  have h_binom : Nat.choose (2 * n) n ≤ 2 ^ (2 * n) := by
    rw [ ← Nat.sum_range_choose ] ; exact Finset.single_le_sum ( fun x _ => Nat.zero_le _ ) ( Finset.mem_range.mpr ( by linarith ) ) ;
  convert h_binom using 1 ; norm_num [ pow_mul ]

/-
The product of primes strictly between n and 2n divides the central binomial coefficient C(2n, n).
-/
lemma prod_primes_divides_centralBinom (n : ℕ) : ∏ p ∈ (Nat.primesBelow (2 * n + 1)) \ (Nat.primesBelow (n + 1)), p ∣ Nat.centralBinom n := by
  -- By definition of $C(2n, n)$, we know that every prime $p$ such that $n < p \leq 2n$ divides $C(2n, n)$.
  have h_div : ∀ p, Nat.Prime p → n < p → p ≤ 2 * n → p ∣ Nat.centralBinom n := by
    intros p pp _ _; haveI := Fact.mk pp; simp_all +decide [ ← ZMod.natCast_eq_zero_iff, Nat.centralBinom ];
    rw [ ZMod.natCast_eq_zero_iff ];
    apply_mod_cast pp.dvd_choose;
    · linarith;
    · omega;
    · grind;
  -- Since the primes in the set $\{p \in \mathbb{N} \mid n < p \leq 2n\}$ are distinct and each divides $C(2n, n)$, their product also divides $C(2n, n)$.
  have h_prod_div : ∀ s : Finset ℕ, (∀ p ∈ s, Nat.Prime p ∧ n < p ∧ p ≤ 2 * n) → s.prod id ∣ Nat.centralBinom n := by
    intros s hs
    induction' s using Finset.induction with p s ih;
    · norm_num;
    · simp_all +decide [ Finset.prod_insert ih ];
      refine' Nat.Coprime.mul_dvd_of_dvd_of_dvd _ _ _;
      · exact Nat.Coprime.prod_right fun x hx => hs.1.1.coprime_iff_not_dvd.mpr fun h => ih <| by have := Nat.prime_dvd_prime_iff_eq hs.1.1 ( hs.2 x hx |>.1 ) ; aesop;
      · exact h_div p hs.1.1 hs.1.2.1 hs.1.2.2;
      · assumption;
  convert h_prod_div _ _ using 1
  -- membership: p ∈ primesBelow sdiff → Prime ∧ n < p ∧ p ≤ 2n
  intro p hp
  have hp' := Finset.mem_sdiff.mp hp
  have ⟨hp_lt, hp_prime⟩ := Nat.mem_primesBelow.mp hp'.1
  have hp_not := hp'.2
  refine ⟨hp_prime, ?_, by omega⟩
  by_contra h
  push_neg at h
  exact hp_not (Nat.mem_primesBelow.mpr ⟨by omega, hp_prime⟩)

/-
The difference theta(2n) - theta(n) is at most 2n log 2.
-/
lemma theta_two_mul_sub_theta_le (n : ℕ) : theta (2 * n) - theta n ≤ 2 * n * Real.log 2 := by
  -- Use ThetaLinearBoundV2's sorry-free proof via definition equivalence
  rcases Nat.eq_zero_or_pos n with rfl | hn
  · simp [theta, Nat.primesBelow]
  · -- Bridge: theta(x) on ℝ = V2.theta on ℕ when x is a natural number
    have h_eq : ∀ m : ℕ, theta (m : ℝ) = ThetaLinearBoundV2.theta m := by
      intro m
      unfold theta ThetaLinearBoundV2.theta
      congr 1
      have : ⌊(m : ℝ)⌋₊ = m := Nat.floor_natCast m
      rw [this]
      ext p
      simp [Nat.primesBelow, Finset.mem_filter, Finset.mem_range]
    rw [show (2 * (n : ℝ)) = ((2 * n : ℕ) : ℝ) from by push_cast; ring]
    rw [h_eq, h_eq]
    have := ThetaLinearBoundV2.theta_two_mul_sub_theta_le n hn
    convert this using 1
    push_cast; ring

/-
theta(2^k) is at most 2^(k+1) log 2.
-/
lemma theta_pow_two_le (k : ℕ) : theta (2 ^ k) ≤ 2 ^ (k + 1) * Real.log 2 := by
  induction' k with k ih;
  · unfold theta;
    norm_num [ Nat.primesBelow ];
    positivity;
  · convert le_trans ( add_le_add ( theta_two_mul_sub_theta_le ( 2 ^ k ) ) ih ) _ using 1 ; ring;
    · norm_num [ theta ];
    · norm_num [ pow_succ' ] ; ring_nf ; norm_num

/-
theta(x) = O(x). Specifically, theta(x) <= (4 log 2) * x for x >= 1.
-/
theorem theta_le_linear : ∃ C > 0, ∀ x ≥ 1, theta x ≤ C * x := by
  -- Set $C$ to be $4 \log 2$.
  use 4 * Real.log 2;
  refine' ⟨ by positivity, _ ⟩;
  intro x hx
  obtain ⟨k, hk⟩ : ∃ k : ℕ, 2 ^ k ≤ x ∧ x < 2 ^ (k + 1) := by
    exact ⟨ ⌊Real.logb 2 x⌋₊, by have := Nat.floor_le ( Real.logb_nonneg one_lt_two hx ) ; rw [ Real.le_logb_iff_rpow_le ] at this <;> norm_cast at * ; linarith, by have := Nat.lt_floor_add_one ( Real.logb 2 x ) ; rw [ Real.logb_lt_iff_lt_rpow ] at this <;> norm_cast at * ; linarith ⟩;
  -- Using the bound on $\theta(2^k)$, we have $\theta(x) \leq \theta(2^{k+1}) \leq 2^{k+2} \log 2$.
  have h_theta_x_le : theta x ≤ 2 ^ (k + 2) * Real.log 2 := by
    refine' le_trans ( theta_mono hk.2.le ) _;
    exact theta_pow_two_le (k + 1);
  ring_nf at *; nlinarith [ Real.log_pos one_lt_two ] ;
end ThetaLinearBound
