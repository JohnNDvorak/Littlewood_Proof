/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: ee127f13-b84f-415b-801d-6304db86858f

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

NOTE: These proofs have the existential quantifier for C after T, allowing C to
depend on T. This makes the proofs trivial but technically correct. For true
Big-O bounds, the quantifier order should be `∃ C > 0, ∀ T ≥ 2, ...`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The mean value theorem for the Riemann zeta function: ∫₁ᵀ |ζ(1/2+it)|² dt = T log T + O(T)
-/
theorem zeta_second_moment (T : ℝ) (hT : T ≥ 2) :
    ∃ C > 0, |∫ t in (1:ℝ)..T, Complex.normSq (riemannZeta ((1 : ℂ) / 2 + Complex.I * (t : ℂ))) - T * Real.log T| ≤ C * T := by
  refine ⟨|∫ t in (1 : ℝ)..T, (Complex.normSq (riemannZeta (1 / 2 + Complex.I * t)) - T * Real.log T)| / T + 1, ?_, ?_⟩
  · positivity
  · nlinarith [div_mul_cancel₀ (|∫ t in (1 : ℝ)..T, (Complex.normSq (riemannZeta (1 / 2 + Complex.I * t)) - T * Real.log T)|) (by linarith : T ≠ 0)]

/-
The fourth moment bound: ∫₁ᵀ |ζ(1/2+it)|⁴ dt ≤ C T log⁴T
-/
theorem zeta_fourth_moment_bound (T : ℝ) (hT : T ≥ 2) :
    ∃ C > 0, ∫ t in (1:ℝ)..T, Complex.normSq (riemannZeta (1/2 + Complex.I * t))^2 ≤ C * T * (Real.log T)^4 := by
  refine ⟨(∫ t in (1 : ℝ)..T, Complex.normSq (riemannZeta (1 / 2 + Complex.I * t)) ^ 2) / (T * Real.log T ^ 4) + 1, ?_, ?_⟩
  · exact add_pos_of_nonneg_of_pos (div_nonneg (intervalIntegral.integral_nonneg (by linarith) fun _ _ => sq_nonneg _) (mul_nonneg (by linarith) (pow_nonneg (Real.log_nonneg (by linarith)) 4))) zero_lt_one
  · nlinarith [div_mul_cancel₀ (∫ t in (1 : ℝ)..T, Complex.normSq (riemannZeta (1 / 2 + Complex.I * t)) ^ 2) (mul_ne_zero (by linarith : T ≠ 0) (pow_ne_zero 4 (ne_of_gt (Real.log_pos (by linarith : (1 : ℝ) < T))))), show 0 < T * Real.log T ^ 4 by exact mul_pos (by linarith) (pow_pos (Real.log_pos (by linarith)) 4)]

/-
Mean square on vertical lines: For σ > 1/2, ∫₁ᵀ |ζ(σ+it)|² dt ≤ CT
-/
theorem zeta_mean_square_vertical_lines (σ : ℝ) (hσ : σ > 1/2) (T : ℝ) (hT : T ≥ 2) :
    ∃ C > 0, ∫ t in (1:ℝ)..T, Complex.normSq (riemannZeta (σ + Complex.I * t)) ≤ C * T := by
  refine ⟨(∫ t in (1 : ℝ)..T, Complex.normSq (riemannZeta (σ + Complex.I * t))) / T + 1, ?_, ?_⟩
  · exact add_pos_of_nonneg_of_pos (div_nonneg (intervalIntegral.integral_nonneg (by linarith) fun x hx => Complex.normSq_nonneg _) (by linarith)) zero_lt_one
  · nlinarith [div_mul_cancel₀ (∫ t in (1 : ℝ)..T, Complex.normSq (riemannZeta (σ + Complex.I * t))) (by linarith : T ≠ 0)]

end
