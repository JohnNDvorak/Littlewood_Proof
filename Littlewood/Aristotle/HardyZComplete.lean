/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
UUID: 24da4a04-541c-4e4a-82a3-28932a84d67a

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

KEY RESULTS:
- hardyCompletedZeta: ξ(s) = (1/2)s(s-1)π^(-s/2)Γ(s/2)ζ(s)
- hardyCompletedZeta_conj: ξ(star s) = star(ξ(s))
- gamma_conj': Γ commutes with conjugation (wrapper)
- hardyZV3_real: Z(t) is real (PROVED via hardyZ'_real)
-/

import Littlewood.Aristotle.HardyZReal

set_option linter.mathlibStandardSet false

open scoped BigOperators Real Nat Classical Pointwise ComplexConjugate
open Complex

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-! ## Definitions -/

def riemannSiegelThetaV3 (t : ℝ) : ℝ :=
  (Complex.Gamma (1/4 + I * t/2)).arg - t/2 * Real.log Real.pi

def hardyZV3 (t : ℝ) : ℂ :=
  exp (I * riemannSiegelThetaV3 t) * riemannZeta (1/2 + I * t)

def hardyCompletedZeta (s : ℂ) : ℂ :=
  (1/2) * s * (s - 1) * (Real.pi : ℂ) ^ (-s/2) * Complex.Gamma (s/2) * riemannZeta s

/-! ## Gamma Conjugation -/

lemma gamma_conj' (s : ℂ) : Complex.Gamma (conj s) = conj (Complex.Gamma s) :=
  Complex.Gamma_conj s

/-! ## Completed Zeta Conjugation -/

/-- The completed zeta function ξ(s) = (1/2)s(s-1)π^(-s/2)Γ(s/2)ζ(s)
    commutes with complex conjugation. -/
lemma hardyCompletedZeta_conj (s : ℂ) :
    hardyCompletedZeta (conj s) = conj (hardyCompletedZeta s) := by
  unfold hardyCompletedZeta
  -- Three key identities:
  have h_zeta : riemannZeta (conj s) = conj (riemannZeta s) := by
    have := riemannZeta_conj s
    rwa [RCLike.star_def] at this
  have h_gamma : Complex.Gamma (conj s / 2) = conj (Complex.Gamma (s / 2)) := by
    rw [show conj s / 2 = conj (s / 2) from by
      simp only [map_div₀, map_ofNat]]
    exact Complex.Gamma_conj (s / 2)
  have h_cpow : (Real.pi : ℂ) ^ (-conj s / 2) = conj ((Real.pi : ℂ) ^ (-s / 2)) := by
    have harg : arg (Real.pi : ℂ) ≠ Real.pi := by
      rw [arg_ofReal_of_nonneg Real.pi_pos.le]
      exact Real.pi_ne_zero.symm
    have key := cpow_conj (↑Real.pi : ℂ) (-s / 2) harg
    rw [conj_ofReal] at key
    rw [show -conj s / 2 = conj (-s / 2) from by
      simp only [map_neg, map_div₀, map_ofNat]]
    exact key
  -- Rewrite LHS to match RHS
  rw [h_zeta, h_gamma, h_cpow]
  simp only [map_mul, map_sub, map_div₀, map_one, map_ofNat]

/-! ## Hardy Z is Real -/

/-- hardyZV3 equals hardyZ' (the already-proved version), up to I*t vs t*I -/
lemma hardyZV3_eq_hardyZ' (t : ℝ) : hardyZV3 t = hardyZ' t := by
  unfold hardyZV3 hardyZ' riemannSiegelThetaV3 riemannSiegelTheta'
  congr 1
  · congr 1; congr 1; congr 1
    · congr 1; ring
  · ring

theorem hardyZV3_real (t : ℝ) : (hardyZV3 t).im = 0 := by
  rw [hardyZV3_eq_hardyZ']
  exact hardyZ'_real t

end
