/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 5d077535-63e8-4953-9867-3a303153047b

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

/-
The average value of a trigonometric polynomial with non-zero frequencies tends to 0 as T → ∞.
-/
lemma trigPoly_mean_zero (S : Finset ℝ) (c ph : ℝ → ℝ) (h_nonzero : ∀ γ ∈ S, γ ≠ 0) :
    Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ)) / T) Filter.atTop (nhds 0) := by
      have h_integral : ∀ γ ∈ S, Filter.Tendsto (fun T : ℝ => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ)) / T) Filter.atTop (nhds 0) := by
        intro γ hγ
        have h_sin : Filter.Tendsto (fun T => (Real.sin (γ * T + ph γ) - Real.sin (ph γ)) / (γ * T)) Filter.atTop (nhds 0) := by
          have h_sin_bounded : Filter.Tendsto (fun T => (Real.sin (γ * T + ph γ) - Real.sin (ph γ)) / T) Filter.atTop (nhds 0) := by
            exact squeeze_zero_norm ( fun T => by simpa using div_le_div_of_nonneg_right ( show |Real.sin ( γ * T + ph γ ) - Real.sin ( ph γ )| ≤ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( γ * T + ph γ ), Real.abs_sin_le_one ( ph γ ) ] ) ) ( abs_nonneg T ) ) ( tendsto_const_nhds.div_atTop ( tendsto_norm_atTop_atTop ) );
          convert h_sin_bounded.const_mul ( γ⁻¹ ) using 2 <;> ring;
        refine h_sin.congr' ?_ ; filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT ; rw [ ← intervalIntegral.integral_of_le hT.le ] ; simp +decide [ div_eq_inv_mul, intervalIntegral.integral_comp_mul_add, h_nonzero _ hγ ] ; ring;
      have h_sum_integral : ∀ T : ℝ, T > 0 → (∫ t in Set.Ioc 0 T, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ)) = ∑ γ ∈ S, c γ * (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ)) := by
        exact fun T hT => by rw [ MeasureTheory.integral_finset_sum _ fun γ hγ => Continuous.integrableOn_Ioc ( by exact Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) ] ; exact Finset.sum_congr rfl fun γ hγ => MeasureTheory.integral_const_mul _ _;
      rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT; rw [ h_sum_integral T hT, Finset.sum_div ] ) ];
      simpa [ mul_div_assoc ] using tendsto_finset_sum _ fun γ hγ => Filter.Tendsto.const_mul ( c γ ) ( h_integral γ hγ )

/-
A trigonometric polynomial with distinct positive frequencies is identically zero if and only if all its coefficients are zero.
-/
lemma trigPoly_zero_iff_coeffs_zero (S : Finset ℝ) (c ph : ℝ → ℝ)
    (h_distinct : (S : Set ℝ).Pairwise (· ≠ ·))
    (h_freq_pos : ∀ γ ∈ S, 0 < γ) :
    (∀ t, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ) = 0) ↔ ∀ γ ∈ S, c γ = 0 := by
      refine' ⟨ fun h γ hγ => _, _ ⟩;
      · have h_integral_zero : ∀ γ ∈ S, Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * (∑ δ ∈ S, c δ * Real.cos (δ * t + ph δ))) / T) Filter.atTop (nhds 0) := by
          aesop;
        have h_integral_zero_gamma : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) ^ 2 * c γ) / T) Filter.atTop (nhds 0) := by
          have h_integral_zero_gamma : ∀ δ ∈ S, δ ≠ γ → Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ) * c δ) / T) Filter.atTop (nhds 0) := by
            intro δ hδ hδγ
            have h_integral_zero_delta : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos ((γ + δ) * t + ph γ + ph δ)) / T) Filter.atTop (nhds 0) ∧ Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos ((γ - δ) * t + ph γ - ph δ)) / T) Filter.atTop (nhds 0) := by
              constructor;
              · have h_integral_zero_gamma : ∀ T > 0, ∫ t in Set.Ioc 0 T, Real.cos ((γ + δ) * t + ph γ + ph δ) = (Real.sin ((γ + δ) * T + ph γ + ph δ) - Real.sin (ph γ + ph δ)) / (γ + δ) := by
                  intro T hT; rw [ ← intervalIntegral.integral_of_le hT.le ] ; rw [ intervalIntegral.integral_comp_mul_add fun t => Real.cos ( t + ph δ ) ] <;> norm_num ; ring;
                  linarith [ h_freq_pos γ hγ, h_freq_pos δ hδ ];
                rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ h_integral_zero_gamma T hT ] ) ];
                have h_integral_zero_gamma : Filter.Tendsto (fun T => (Real.sin ((γ + δ) * T + ph γ + ph δ) - Real.sin (ph γ + ph δ)) / T) Filter.atTop (nhds 0) := by
                  exact squeeze_zero_norm ( fun T => by simpa using div_le_div_of_nonneg_right ( show |Real.sin ( ( γ + δ ) * T + ph γ + ph δ ) - Real.sin ( ph γ + ph δ )| ≤ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( ( γ + δ ) * T + ph γ + ph δ ), Real.abs_sin_le_one ( ph γ + ph δ ) ] ) ) ( abs_nonneg T ) ) ( tendsto_const_nhds.div_atTop ( tendsto_norm_atTop_atTop ) );
                convert h_integral_zero_gamma.div_const ( γ + δ ) using 2 <;> ring;
              · have h_integral_zero_gamma : ∀ T > 0, ∫ t in Set.Ioc 0 T, Real.cos ((γ - δ) * t + ph γ - ph δ) = (Real.sin ((γ - δ) * T + ph γ - ph δ) - Real.sin (ph γ - ph δ)) / (γ - δ) := by
                  intro T hT; rw [ ← intervalIntegral.integral_of_le hT.le ] ; rw [ intervalIntegral.integral_comp_mul_add ( fun t => Real.cos ( t - ph δ ) ) ] <;> norm_num ; ring;
                  exact sub_ne_zero_of_ne <| Ne.symm hδγ;
                rw [ Filter.tendsto_congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ h_integral_zero_gamma T hT ] ) ];
                exact squeeze_zero_norm ( fun T => by simpa using div_le_div_of_nonneg_right ( div_le_div_of_nonneg_right ( show |Real.sin ( ( γ - δ ) * T + ph γ - ph δ ) - Real.sin ( ph γ - ph δ )| ≤ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( ( γ - δ ) * T + ph γ - ph δ ), Real.abs_sin_le_one ( ph γ - ph δ ) ] ) ) ( abs_nonneg _ ) ) ( abs_nonneg _ ) ) ( tendsto_const_nhds.div_atTop Filter.tendsto_abs_atTop_atTop );
            have h_trig_identity : ∀ T : ℝ, ∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ) = (∫ t in Set.Ioc 0 T, Real.cos ((γ + δ) * t + ph γ + ph δ)) / 2 + (∫ t in Set.Ioc 0 T, Real.cos ((γ - δ) * t + ph γ - ph δ)) / 2 := by
              intro T; rw [ ← add_div, ← MeasureTheory.integral_add ];
              · rw [ ← MeasureTheory.integral_div ] ; congr ; ext t ; rw [ Real.cos_add_cos ] ; ring;
              · exact Continuous.integrableOn_Ioc ( Real.continuous_cos.comp <| by continuity );
              · exact Continuous.integrableOn_Ioc ( Real.continuous_cos.comp <| by continuity );
            simp_all +decide [ MeasureTheory.integral_mul_const ];
            convert Filter.Tendsto.add ( h_integral_zero_delta.1.mul_const ( c δ / 2 ) ) ( h_integral_zero_delta.2.mul_const ( c δ / 2 ) ) using 2 <;> ring;
          have h_integral_zero_gamma_sum : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, ∑ δ ∈ S.erase γ, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ) * c δ) / T) Filter.atTop (nhds 0) := by
            have h_integral_zero_gamma_sum : Filter.Tendsto (fun T => (∑ δ ∈ S.erase γ, ∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ) * c δ) / T) Filter.atTop (nhds 0) := by
              simpa [ Finset.sum_div _ _ _ ] using tendsto_finset_sum _ fun δ hδ => h_integral_zero_gamma δ ( Finset.mem_of_mem_erase hδ ) ( Finset.ne_of_mem_erase hδ );
            refine h_integral_zero_gamma_sum.congr' ?_;
            filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT;
            rw [ MeasureTheory.integral_finset_sum ];
            exact fun δ hδ => Continuous.integrableOn_Ioc ( by exact Continuous.mul ( Continuous.mul ( Real.continuous_cos.comp <| by continuity ) ( Real.continuous_cos.comp <| by continuity ) ) continuous_const );
          have h_integral_zero_gamma_sum : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * (∑ δ ∈ S, c δ * Real.cos (δ * t + ph δ)) - ∑ δ ∈ S.erase γ, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ) * c δ) / T) Filter.atTop (nhds 0) := by
            convert h_integral_zero γ hγ |> Filter.Tendsto.sub <| h_integral_zero_gamma_sum using 2 ; ring;
            · rw [ MeasureTheory.integral_sub ];
              · ring;
              · exact Continuous.integrableOn_Ioc ( by exact Continuous.mul ( Real.continuous_cos.comp <| by continuity ) <| continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) <| Real.continuous_cos.comp <| by continuity );
              · exact Continuous.integrableOn_Ioc ( by exact continuous_finset_sum _ fun _ _ => Continuous.mul ( Continuous.mul ( Real.continuous_cos.comp <| by continuity ) ( Real.continuous_cos.comp <| by continuity ) ) continuous_const );
            · norm_num;
          convert h_integral_zero_gamma_sum using 2 ; simp +decide [ Finset.sum_erase, hγ, sq, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ];
        have h_integral_zero_gamma_eval : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) ^ 2) * c γ / T) Filter.atTop (nhds 0) := by
          simpa only [ MeasureTheory.integral_mul_const ] using h_integral_zero_gamma;
        have h_integral_cos_sq : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) ^ 2) / T) Filter.atTop (nhds (1 / 2)) := by
          have h_integral_cos_sq_eval : Filter.Tendsto (fun T => (∫ t in (0 : ℝ)..T, Real.cos (γ * t + ph γ) ^ 2) / T) Filter.atTop (nhds (1 / 2)) := by
            have h_integral_cos_sq_eval : ∀ T : ℝ, ∫ t in (0 : ℝ)..T, Real.cos (γ * t + ph γ) ^ 2 = T / 2 + (Real.sin (2 * γ * T + 2 * ph γ) - Real.sin (2 * ph γ)) / (4 * γ) := by
              intro T; rw [ intervalIntegral.integral_comp_mul_add ( fun t => Real.cos t ^ 2 ) ] <;> norm_num ; ring;
              · rw [ show γ * T * 2 + ph γ * 2 = 2 * ( γ * T + ph γ ) by ring, show ph γ * 2 = 2 * ph γ by ring ] ; rw [ Real.sin_two_mul, Real.sin_two_mul ] ; rw [ mul_inv_cancel₀ ( ne_of_gt ( h_freq_pos γ hγ ) ) ] ; ring;
              · linarith [ h_freq_pos γ hγ ];
            -- The sin oscillation / (4γT) → 0 as T → ∞
            have h_sin_zero : Filter.Tendsto (fun T : ℝ => (Real.sin (2 * γ * T + 2 * ph γ) - Real.sin (2 * ph γ)) / (4 * γ * T)) Filter.atTop (nhds 0) := by
              rw [Metric.tendsto_atTop]
              intro ε hε
              have h4g : (0 : ℝ) < 4 * γ := by linarith [h_freq_pos γ hγ]
              refine ⟨2 / (4 * γ * ε) + 1, fun T hT => ?_⟩
              have hT_pos : (0 : ℝ) < T := lt_of_lt_of_le (by positivity) hT
              have h4gT : (0 : ℝ) < 4 * γ * T := mul_pos h4g hT_pos
              rw [Real.dist_eq, sub_zero, abs_div, abs_of_pos h4gT]
              have h_sin_bdd : |Real.sin (2 * γ * T + 2 * ph γ) - Real.sin (2 * ph γ)| ≤ 2 := by
                have h := norm_sub_le (Real.sin (2 * γ * T + 2 * ph γ)) (Real.sin (2 * ph γ))
                simp only [Real.norm_eq_abs] at h
                linarith [Real.abs_sin_le_one (2 * γ * T + 2 * ph γ), Real.abs_sin_le_one (2 * ph γ)]
              calc |Real.sin (2 * γ * T + 2 * ph γ) - Real.sin (2 * ph γ)| / (4 * γ * T)
                  ≤ 2 / (4 * γ * T) := by gcongr
                _ < ε := by
                  rw [div_lt_iff₀ h4gT, show ε * (4 * γ * T) = (4 * γ * ε) * T from by ring]
                  have h4ge := mul_pos h4g hε
                  calc (4 * γ * ε) * T ≥ (4 * γ * ε) * (2 / (4 * γ * ε) + 1) :=
                        mul_le_mul_of_nonneg_left hT h4ge.le
                    _ > 2 := by
                        rw [mul_add, mul_div_cancel₀ _ (ne_of_gt h4ge), mul_one]; linarith
            -- 1/2 + sin_diff/(4γT) → 1/2
            suffices h_lim : Filter.Tendsto (fun T : ℝ => (1 : ℝ) / 2 + (Real.sin (2 * γ * T + 2 * ph γ) - Real.sin (2 * ph γ)) / (4 * γ * T)) Filter.atTop (nhds (1 / 2)) by
              refine Filter.Tendsto.congr' ?_ h_lim
              filter_upwards [Filter.eventually_gt_atTop (0 : ℝ)] with T hT
              rw [h_integral_cos_sq_eval T]
              field_simp [ne_of_gt hT, ne_of_gt (h_freq_pos γ hγ)]
            simpa only [add_zero] using (tendsto_const_nhds (x := (1 : ℝ) / 2)).add h_sin_zero;
          exact h_integral_cos_sq_eval.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT using by rw [ intervalIntegral.integral_of_le hT.le ] );
        have := h_integral_zero_gamma_eval.sub ( h_integral_cos_sq.mul_const ( c γ ) ) ; ring_nf at *; aesop;
      · aesop

/-
Dirichlet's simultaneous approximation theorem: For any finite set S and N > 0, there exists 0 < t ≤ N^|S| such that for all α ∈ S, tα is within 1/N of an integer.
-/
lemma dirichlet_simultaneous_approx (S : Finset ℝ) (N : ℕ) (hN : N > 0) :
    ∃ t ∈ Finset.range (N ^ S.card + 1), t > 0 ∧ ∀ α ∈ S, ∃ k : ℤ, |↑t * α - k| < 1 / (N : ℝ) := by
      by_contra h_contra;
      obtain ⟨t1, t2, ht1t2, h_subcube⟩ : ∃ t1 t2 : ℕ, t1 < t2 ∧ t1 ∈ Finset.range (N ^ S.card + 1) ∧ t2 ∈ Finset.range (N ^ S.card + 1) ∧ ∀ α : S, |(t1 * α.val - ⌊t1 * α.val⌋ : ℝ) - (t2 * α.val - ⌊t2 * α.val⌋ : ℝ)| < 1 / N := by
        have h_pigeonhole : Finset.card (Finset.image (fun t : ℕ => fun α : S => ⌊(t * α.val - ⌊t * α.val⌋ : ℝ) * N⌋) (Finset.range (N ^ S.card + 1))) ≤ N ^ S.card := by
          refine' le_trans ( Finset.card_le_card <| Finset.image_subset_iff.mpr _ ) _;
          exact Finset.Icc ( 0 : S → ℤ ) ( fun _ => N - 1 );
          · simp +zetaDelta at *;
            exact fun x hx => ⟨ fun α => Int.floor_nonneg.mpr ( mul_nonneg ( Int.fract_nonneg _ ) ( Nat.cast_nonneg _ ) ), fun α => Int.le_sub_one_of_lt ( Int.floor_lt.mpr ( by norm_num; nlinarith [ Int.fract_lt_one ( ( x : ℝ ) * α ), show ( N : ℝ ) ≥ 1 by norm_cast ] ) ) ⟩;
          · erw [ Finset.card_map, Finset.card_pi ] ; aesop;
        obtain ⟨t1, t2, ht1t2, h_subcube⟩ : ∃ t1 t2 : ℕ, t1 < t2 ∧ t1 ∈ Finset.range (N ^ S.card + 1) ∧ t2 ∈ Finset.range (N ^ S.card + 1) ∧ (fun t : ℕ => fun α : S => ⌊(t * α.val - ⌊t * α.val⌋ : ℝ) * N⌋) t1 = (fun t : ℕ => fun α : S => ⌊(t * α.val - ⌊t * α.val⌋ : ℝ) * N⌋) t2 := by
          by_cases h_eq : ∀ t1 t2 : ℕ, t1 < t2 → t1 ∈ Finset.range (N ^ S.card + 1) → t2 ∈ Finset.range (N ^ S.card + 1) → (fun t : ℕ => fun α : S => ⌊(t * α.val - ⌊t * α.val⌋ : ℝ) * N⌋) t1 ≠ (fun t : ℕ => fun α : S => ⌊(t * α.val - ⌊t * α.val⌋ : ℝ) * N⌋) t2;
          · exact absurd h_pigeonhole ( by rw [ Finset.card_image_of_injOn fun t1 ht1 t2 ht2 h => le_antisymm ( not_lt.mp fun hlt => h_eq _ _ hlt ht2 ht1 h.symm ) ( not_lt.mp fun hlt => h_eq _ _ hlt ht1 ht2 h ) ] ; simp +arith +decide );
          · exact by push_neg at h_eq; exact h_eq;
        use t1, t2;
        simp_all +decide [ funext_iff, Int.floor_eq_iff ];
        intro a ha; rw [ abs_lt ] ; constructor <;> nlinarith [ h_subcube.2.2 a ha, Int.floor_le ( Int.fract ( ( t2 : ℝ ) * a ) * N ), Int.lt_floor_add_one ( Int.fract ( ( t2 : ℝ ) * a ) * N ), mul_inv_cancel₀ ( by positivity : ( N : ℝ ) ≠ 0 ) ] ;
      refine' h_contra ⟨ t2 - t1, _, _, _ ⟩ <;> norm_num at *;
      · omega;
      · linarith;
      · intro α hα; use ⌊ ( t2 : ℝ ) * α⌋ - ⌊ ( t1 : ℝ ) * α⌋; rw [ Nat.cast_sub ht1t2.le ] ; simp_all +decide [ abs_lt ] ;
        constructor <;> linarith [ Int.fract_add_floor ( ( t2 : ℝ ) * α ), Int.fract_add_floor ( ( t1 : ℝ ) * α ), h_subcube.2.2 α hα ]

/-
For any finite set of real numbers S and ε > 0, there exists T > M such that for all α ∈ S, Tα is within ε of an integer.
-/
lemma exists_near_integer_multiples (S : Finset ℝ) (ε : ℝ) (hε : 0 < ε) (M : ℝ) :
    ∃ T > M, ∀ α ∈ S, ∃ k : ℤ, |T * α - k| < ε := by
      obtain ⟨N, hN⟩ : ∃ N : ℕ, N > 0 ∧ (1 / (N : ℝ)) < ε / (|M| + 1) := by
        exact ⟨ ⌊ε⁻¹ * ( |M| + 1 ) ⌋₊ + 1, Nat.succ_pos _, by rw [ div_lt_iff₀ ] <;> push_cast <;> nlinarith [ Nat.lt_floor_add_one ( ε⁻¹ * ( |M| + 1 ) ), abs_nonneg M, mul_inv_cancel₀ hε.ne', mul_div_cancel₀ ( ε : ℝ ) ( by positivity : ( |M| + 1 : ℝ ) ≠ 0 ) ] ⟩;
      obtain ⟨t₀, ht₀⟩ : ∃ t₀ : ℕ, t₀ > 0 ∧ ∀ α ∈ S, ∃ k : ℤ, |(t₀ : ℝ) * α - k| < 1 / (N : ℝ) := by
        have := dirichlet_simultaneous_approx S N hN.1;
        aesop;
      set k := Nat.floor (|M| / (t₀ : ℝ)) + 1;
      use k * t₀;
      refine' ⟨ _, fun α hα => _ ⟩;
      · cases abs_cases M <;> push_cast [ k ] <;> nlinarith [ Nat.lt_floor_add_one ( |M| / t₀ ), show ( t₀ : ℝ ) ≥ 1 by exact_mod_cast ht₀.1, mul_div_cancel₀ ( |M| : ℝ ) ( show ( t₀ : ℝ ) ≠ 0 by exact_mod_cast ht₀.1.ne' ) ];
      · obtain ⟨ k₁, hk₁ ⟩ := ht₀.2 α hα;
        refine' ⟨ k₁ * k, _ ⟩;
        rw [ lt_div_iff₀ ] at * <;> norm_num at *;
        · rw [ inv_mul_lt_iff₀ ( by norm_cast; linarith ) ] at hN;
          rw [ show ( k : ℝ ) * t₀ * α - k₁ * k = k * ( t₀ * α - k₁ ) by ring ];
          rw [ abs_mul, abs_of_nonneg ( by positivity : ( 0 : ℝ ) ≤ k ) ];
          simp +zetaDelta at *;
          nlinarith [ Nat.floor_le ( show 0 ≤ |M| / ( t₀ : ℝ ) by positivity ), Nat.lt_floor_add_one ( |M| / ( t₀ : ℝ ) ), show ( t₀ : ℝ ) ≥ 1 by exact_mod_cast ht₀.1, mul_div_cancel₀ ( |M| : ℝ ) ( show ( t₀ : ℝ ) ≠ 0 by exact_mod_cast ht₀.1.ne' ), abs_nonneg ( ( t₀ : ℝ ) * α - k₁ ) ];
        · positivity;
        · linarith

/-
For any ε > 0 and M, there exists a translation τ > M such that the trigonometric polynomial is uniformly ε-close to its translate.
-/
lemma trigPoly_almost_periodic (S : Finset ℝ) (c ph : ℝ → ℝ)
    (ε : ℝ) (hε : 0 < ε) (M : ℝ) :
    ∃ τ > M, ∀ t, |(∑ γ ∈ S, c γ * Real.cos (γ * (t + τ) + ph γ)) - (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))| < ε := by
      obtain ⟨N, hN⟩ : ∃ N : ℕ, N > 0 ∧ (ε / (2 * Real.pi * (∑ γ ∈ S, |c γ| + 1))) > 1 / N := by
        exact ⟨ ⌊ε⁻¹ * ( 2 * Real.pi * ( ∑ γ ∈ S, |c γ| + 1 ) ) ⌋₊ + 1, Nat.succ_pos _, by rw [ gt_iff_lt ] ; rw [ div_lt_div_iff₀ ] <;> norm_num <;> nlinarith [ Nat.lt_floor_add_one ( ε⁻¹ * ( 2 * Real.pi * ( ∑ γ ∈ S, |c γ| + 1 ) ) ), inv_pos.2 hε, mul_inv_cancel₀ hε.ne', Real.pi_gt_three.le, show 0 < ( ∑ γ ∈ S, |c γ| + 1 ) from add_pos_of_nonneg_of_pos ( Finset.sum_nonneg fun _ _ => abs_nonneg _ ) zero_lt_one ] ⟩;
      obtain ⟨τ, hτ⟩ : ∃ τ > M, ∀ γ ∈ S, ∃ k : ℤ, |τ * γ - 2 * Real.pi * k| < 2 * Real.pi / N := by
        have := exists_near_integer_multiples ( S.image fun γ => γ / ( 2 * Real.pi ) ) ( 1 / N ) ( by exact one_div_pos.mpr ( Nat.cast_pos.mpr hN.1 ) ) M;
        simp_all +decide [ div_eq_inv_mul, mul_assoc, mul_left_comm, mul_comm ];
        obtain ⟨ τ, hτ₁, hτ₂ ⟩ := this; use τ; exact ⟨ hτ₁, fun γ hγ => by obtain ⟨ k, hk ⟩ := hτ₂ γ hγ; exact ⟨ k, by rw [ abs_lt ] at *; constructor <;> nlinarith [ Real.pi_pos, mul_inv_cancel_left₀ Real.pi_ne_zero ( τ * γ ), mul_inv_cancel_left₀ Real.pi_ne_zero ( k : ℝ ) ] ⟩ ⟩ ;
      use τ, hτ.left;
      have h_cos_diff : ∀ t : ℝ, ∀ γ ∈ S, |Real.cos (γ * (t + τ) + ph γ) - Real.cos (γ * t + ph γ)| ≤ 2 * Real.pi / N := by
        intros t γ hγ
        obtain ⟨k, hk⟩ := hτ.right γ hγ
        have h_cos_diff : |Real.cos (γ * (t + τ) + ph γ) - Real.cos (γ * t + ph γ)| ≤ |γ * τ - 2 * Real.pi * k| := by
          have h_cos_diff : |Real.cos (γ * (t + τ) + ph γ) - Real.cos (γ * t + ph γ)| ≤ |Real.sin ((γ * τ - 2 * Real.pi * k) / 2)| * 2 := by
            rw [ Real.cos_sub_cos ] ; ring_nf ; norm_num [ abs_mul ] ;
            norm_num [ mul_comm Real.pi, Real.sin_sub ];
            exact mul_le_of_le_one_left ( abs_nonneg _ ) ( Real.abs_sin_le_one _ );
          have h_sin_le : |Real.sin ((γ * τ - 2 * Real.pi * k) / 2)| ≤ |(γ * τ - 2 * Real.pi * k) / 2| := by
            -- |sin(x)| ≤ |x| by mean value theorem (sin is 1-Lipschitz, sin(0) = 0)
            have h_lip := Real.lipschitzWith_sin
            have := h_lip.dist_le_mul ((γ * τ - 2 * Real.pi * ↑k) / 2) 0
            simp [dist_zero_right] at this
            rwa [abs_div, abs_of_pos (by norm_num : (0:ℝ) < 2)]
          exact h_cos_diff.trans ( by rw [ abs_div, abs_two ] at *; linarith );
        exact h_cos_diff.trans ( by simpa only [ mul_comm ] using hk.le );
      have h_sum_cos_diff : ∀ t : ℝ, |∑ γ ∈ S, c γ * (Real.cos (γ * (t + τ) + ph γ) - Real.cos (γ * t + ph γ))| ≤ (∑ γ ∈ S, |c γ|) * (2 * Real.pi / N) := by
        exact fun t => le_trans ( Finset.abs_sum_le_sum_abs _ _ ) ( by simpa only [ Finset.sum_mul _ _ _ ] using Finset.sum_le_sum fun x hx => by rw [ abs_mul ] ; exact mul_le_mul_of_nonneg_left ( h_cos_diff t x hx ) ( abs_nonneg _ ) );
      simp_all +decide [ mul_sub ];
      exact fun t => lt_of_le_of_lt ( h_sum_cos_diff t ) ( by rw [ inv_eq_one_div, div_lt_div_iff₀ ] at hN <;> nlinarith [ Real.pi_pos, show ( N : ℝ ) ≥ 1 by exact_mod_cast hN.1, mul_div_cancel₀ ( 2 * Real.pi ) ( show ( N : ℝ ) ≠ 0 by exact_mod_cast hN.1.ne' ), show ( ∑ γ ∈ S, |c γ| ) ≥ 0 by exact Finset.sum_nonneg fun _ _ => abs_nonneg _ ] )

/-
If a trigonometric polynomial is eventually non-negative, it is non-negative everywhere.
-/
lemma trigPoly_nonneg_of_eventually_nonneg (S : Finset ℝ) (c ph : ℝ → ℝ)
    (h_nonneg : ∀ᶠ t in Filter.atTop, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ) ≥ 0) :
    ∀ t, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ) ≥ 0 := by
      intro t;
      by_contra h_negneg;
      obtain ⟨M, hM⟩ : ∃ M, ∀ t > M, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ)) ≥ 0 := by
        rw [ Filter.eventually_atTop ] at h_nonneg; obtain ⟨ M, hM ⟩ := h_nonneg; exact ⟨ M, fun t ht => hM t ht.le ⟩ ;
      obtain ⟨τ, hτ₁, hτ₂⟩ : ∃ τ > M - t, ∀ t', |(∑ γ ∈ S, c γ * Real.cos (γ * (t' + τ) + ph γ)) - (∑ γ ∈ S, c γ * Real.cos (γ * t' + ph γ))| < - (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ)) / 2 := by
        have := trigPoly_almost_periodic S c ph ( - ( ∑ γ ∈ S, c γ * Real.cos ( γ * t + ph γ ) ) / 2 ) ( by linarith ) ( M - t ) ; aesop;
      linarith [ abs_lt.mp ( hτ₂ t ), hM ( t + τ ) ( by linarith ) ]

/-
The mean square of a trigonometric polynomial with distinct positive frequencies converges to half the sum of the squared coefficients (Parseval's identity).
-/
lemma trigPoly_mean_square (S : Finset ℝ) (c ph : ℝ → ℝ)
    (h_distinct : (S : Set ℝ).Pairwise (· ≠ ·))
    (h_freq_pos : ∀ γ ∈ S, 0 < γ) :
    Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))^2) / T) Filter.atTop (nhds (∑ γ ∈ S, (c γ)^2 / 2)) := by
      have h_ortho : ∀ γ δ : ℝ, γ ≠ δ → γ > 0 → δ > 0 → Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ)) / T) Filter.atTop (nhds 0) := by
        intro γ δ hγδ hγ hδ
        have h_trig : ∀ T > 0, ∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ) = (1 / 2) * (∫ t in Set.Ioc 0 T, Real.cos ((γ + δ) * t + ph γ + ph δ)) + (1 / 2) * (∫ t in Set.Ioc 0 T, Real.cos ((γ - δ) * t + ph γ - ph δ)) := by
          intro T hT; rw [ ← mul_add, ← MeasureTheory.integral_add ];
          · rw [ ← MeasureTheory.integral_const_mul ] ; congr ; ext t ; rw [ Real.cos_add_cos ] ; ring;
          · exact Continuous.integrableOn_Ioc ( Real.continuous_cos.comp <| by continuity );
          · exact Continuous.integrableOn_Ioc ( Real.continuous_cos.comp <| by continuity );
        have h_cos_bound : ∀ T > 0, |∫ t in Set.Ioc 0 T, Real.cos ((γ + δ) * t + ph γ + ph δ)| ≤ 2 / (γ + δ) ∧ |∫ t in Set.Ioc 0 T, Real.cos ((γ - δ) * t + ph γ - ph δ)| ≤ 2 / |γ - δ| := by
          intro T hT_pos
          have h_cos_bound : ∀ ω : ℝ, ω ≠ 0 → ∀ T > 0, |∫ t in Set.Ioc 0 T, Real.cos (ω * t + (ph γ + ph δ))| ≤ 2 / |ω| := by
            intro ω hω T hT_pos; rw [ ← intervalIntegral.integral_of_le hT_pos.le ] ; rw [ intervalIntegral.integral_comp_mul_add ] <;> norm_num [ hω ];
            rw [ inv_mul_eq_div, div_le_div_iff_of_pos_right ( abs_pos.mpr hω ) ] ; exact abs_le.mpr ⟨ by linarith [ abs_le.mp ( Real.abs_sin_le_one ( ω * T + ( ph γ + ph δ ) ) ), abs_le.mp ( Real.abs_sin_le_one ( ph γ + ph δ ) ) ], by linarith [ abs_le.mp ( Real.abs_sin_le_one ( ω * T + ( ph γ + ph δ ) ) ), abs_le.mp ( Real.abs_sin_le_one ( ph γ + ph δ ) ) ] ⟩;
          have h_cos_bound : ∀ ω : ℝ, ω ≠ 0 → ∀ T > 0, |∫ t in Set.Ioc 0 T, Real.cos (ω * t + (ph γ - ph δ))| ≤ 2 / |ω| := by
            intros ω hω T hT_pos
            have h_cos_bound : |∫ t in Set.Ioc 0 T, Real.cos (ω * t + (ph γ - ph δ))| = |(1 / ω) * (Real.sin (ω * T + (ph γ - ph δ)) - Real.sin ((ph γ - ph δ)))| := by
              rw [ ← intervalIntegral.integral_of_le hT_pos.le, intervalIntegral.integral_comp_mul_add ] <;> norm_num [ hω ];
            simp_all +decide [ abs_mul, abs_inv ];
            exact le_trans ( mul_le_mul_of_nonneg_left ( show |Real.sin ( ω * T + ( ph γ - ph δ ) ) - Real.sin ( ph γ - ph δ )| ≤ 2 by exact le_trans ( abs_sub _ _ ) ( by linarith [ Real.abs_sin_le_one ( ω * T + ( ph γ - ph δ ) ), Real.abs_sin_le_one ( ph γ - ph δ ) ] ) ) ( by positivity ) ) ( by ring_nf; norm_num );
          simp_all +decide [ add_assoc, sub_eq_add_neg ];
          exact ⟨ by simpa only [ abs_of_pos ( add_pos hγ hδ ) ] using ‹∀ ω : ℝ, ¬ω = 0 → ∀ T : ℝ, 0 < T → |∫ t in Set.Ioc 0 T, Real.cos ( ω * t + ( ph γ + ph δ ) )| ≤ 2 / |ω|› ( γ + δ ) ( by linarith ) T hT_pos, by simpa only [ abs_of_nonneg ( by linarith : 0 ≤ γ + δ ) ] using h_cos_bound ( γ + -δ ) ( by contrapose! hγδ; linarith ) T hT_pos ⟩;
        have h_limit_zero : Filter.Tendsto (fun T => (1 / 2) * (∫ t in Set.Ioc 0 T, Real.cos ((γ + δ) * t + ph γ + ph δ)) / T) Filter.atTop (nhds 0) ∧ Filter.Tendsto (fun T => (1 / 2) * (∫ t in Set.Ioc 0 T, Real.cos ((γ - δ) * t + ph γ - ph δ)) / T) Filter.atTop (nhds 0) := by
          constructor <;> refine' squeeze_zero_norm' _ _;
          use fun T => ( 1 / 2 ) * ( 2 / ( γ + δ ) ) / T;
          any_goals filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT; rw [ Real.norm_eq_abs, abs_div, abs_mul, abs_of_nonneg ( by positivity : ( 0 : ℝ ) ≤ 1 / 2 ) ];
          · gcongr <;> cases abs_cases T <;> cases abs_cases ( ∫ t in Set.Ioc 0 T, Real.cos ( ( γ + δ ) * t + ph γ + ph δ ) ) <;> nlinarith [ h_cos_bound T hT ];
          · exact tendsto_const_nhds.div_atTop Filter.tendsto_id;
          · exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ⟨ 1, fun T hT => by simpa [ abs_div, abs_mul ] using div_le_div_of_nonneg_right ( mul_le_mul_of_nonneg_left ( h_cos_bound T ( by linarith ) |>.2 ) ( by positivity ) ) ( by positivity ) ⟩ ) ( tendsto_const_nhds.div_atTop ( tendsto_norm_atTop_atTop ) );
        simpa using Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT; rw [ h_trig T hT ] ; ring ) ( h_limit_zero.1.add h_limit_zero.2 );
      have h_expand : ∀ T > 0, (∫ t in Set.Ioc 0 T, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ)) ^ 2) = ∑ γ ∈ S, ∑ δ ∈ S, c γ * c δ * (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ)) := by
        simp +decide only [mul_comm, pow_two, Finset.mul_sum _ _ _, mul_left_comm,
                    ← MeasureTheory.integral_const_mul];
        intro T hT; rw [ MeasureTheory.integral_finset_sum _ fun i hi => ?_ ] ; simp +decide only [mul_comm,
                                                                                            mul_assoc, mul_left_comm];
        · exact Finset.sum_congr rfl fun _ _ => by rw [ MeasureTheory.integral_finset_sum _ fun _ _ => Continuous.integrableOn_Ioc ( by exact Continuous.mul ( continuous_const ) ( Continuous.mul ( continuous_const ) ( Continuous.mul ( Real.continuous_cos.comp ( by continuity ) ) ( Real.continuous_cos.comp ( by continuity ) ) ) ) ) ] ; ac_rfl;
        · exact Continuous.integrableOn_Ioc ( by exact continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Continuous.mul ( continuous_const.mul ( Real.continuous_cos.comp ( by continuity ) ) ) ( Real.continuous_cos.comp ( by continuity ) ) ) );
      have h_sum_expand : ∀ γ ∈ S, Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) ^ 2) / T) Filter.atTop (nhds (1 / 2)) := by
        have h_cos_sq_integral : ∀ γ ∈ S, ∀ T > 0, (∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) ^ 2) = (T / 2) + (Real.sin (2 * γ * T + 2 * ph γ) - Real.sin (2 * ph γ)) / (4 * γ) := by
          intro γ hγ T hT; rw [ ← intervalIntegral.integral_of_le hT.le ] ; rw [ intervalIntegral.integral_comp_mul_add ( fun t => Real.cos t ^ 2 ) ] <;> norm_num ; ring;
          · rw [ show γ * T * 2 + ph γ * 2 = 2 * ( γ * T + ph γ ) by ring, show ph γ * 2 = 2 * ph γ by ring ] ; rw [ Real.sin_two_mul, Real.sin_two_mul ] ; norm_num [ ne_of_gt ( h_freq_pos γ hγ ) ] ; ring;
          · linarith [ h_freq_pos γ hγ ];
        have h_sin_term : ∀ γ ∈ S, Filter.Tendsto (fun T => (Real.sin (2 * γ * T + 2 * ph γ) - Real.sin (2 * ph γ)) / (4 * γ * T)) Filter.atTop (nhds 0) := by
          intro γ hγ;
          refine' squeeze_zero_norm' _ _;
          use fun T => 2 / ( 4 * γ * |T| );
          · norm_num +zetaDelta at *;
            exact ⟨ 1, fun T hT => by rw [ abs_of_nonneg ( by linarith [ h_freq_pos γ hγ ] : 0 ≤ γ ) ] ; exact div_le_div_of_nonneg_right ( abs_le.mpr ⟨ by linarith [ Real.neg_one_le_sin ( 2 * γ * T + 2 * ph γ ), Real.sin_le_one ( 2 * γ * T + 2 * ph γ ), Real.neg_one_le_sin ( 2 * ph γ ), Real.sin_le_one ( 2 * ph γ ) ], by linarith [ Real.neg_one_le_sin ( 2 * γ * T + 2 * ph γ ), Real.sin_le_one ( 2 * γ * T + 2 * ph γ ), Real.neg_one_le_sin ( 2 * ph γ ), Real.sin_le_one ( 2 * ph γ ) ] ⟩ ) ( by exact mul_nonneg ( mul_nonneg zero_le_four ( le_of_lt ( h_freq_pos γ hγ ) ) ) ( abs_nonneg _ ) ) ⟩;
          · exact tendsto_const_nhds.div_atTop ( Filter.Tendsto.const_mul_atTop ( by linarith [ h_freq_pos γ hγ ] ) ( tendsto_norm_atTop_atTop ) );
        intro γ hγ; specialize h_sin_term γ hγ; refine' Filter.Tendsto.congr' _ ( by simpa using h_sin_term.const_add ( 1 / 2 : ℝ ) ) ; filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT; rw [ h_cos_sq_integral γ hγ T hT ] ; ring_nf; norm_num [ hT.ne' ] ;
      have h_sum_limit : Filter.Tendsto (fun T => ∑ γ ∈ S, ∑ δ ∈ S, c γ * c δ * ((∫ t in Set.Ioc 0 T, Real.cos (γ * t + ph γ) * Real.cos (δ * t + ph δ)) / T)) Filter.atTop (nhds (∑ γ ∈ S, ∑ δ ∈ S, c γ * c δ * if γ = δ then 1 / 2 else 0)) := by
        refine' tendsto_finset_sum _ fun γ hγ => tendsto_finset_sum _ fun δ hδ => _;
        by_cases h : γ = δ <;> simp_all +decide [ sq ];
        · exact Filter.Tendsto.mul tendsto_const_nhds ( h_sum_expand δ hδ );
        · simpa using Filter.Tendsto.const_mul ( c γ * c δ ) ( h_ortho γ δ h ( h_freq_pos γ hγ ) ( h_freq_pos δ hδ ) );
      simp_all +decide [ ← mul_div_assoc, ← Finset.sum_div ];
      exact Filter.Tendsto.congr' ( by filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT; rw [ h_expand T hT ] ) ( h_sum_limit.trans ( by simp +decide [ div_eq_mul_inv, pow_two, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] ) )

/-
If a trigonometric polynomial with distinct positive frequencies is non-negative everywhere, it must be identically zero.
-/
lemma trigPoly_eq_zero_of_nonneg_everywhere (S : Finset ℝ) (c ph : ℝ → ℝ)
    (h_freq_pos : ∀ γ ∈ S, 0 < γ)
    (h_distinct : (S : Set ℝ).Pairwise (· ≠ ·))
    (h_nonneg : ∀ t, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ) ≥ 0) :
    ∀ t, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ) = 0 := by
      have h_mean_zero : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))) / T) Filter.atTop (nhds 0) := by
        have h_mean_zero : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, (∑ γ ∈ S, (c γ) * (Real.cos (γ * t + (ph γ))))) / T) Filter.atTop (nhds 0) := by
          have h_nonzero : ∀ γ ∈ S, γ ≠ 0 := by
            exact fun γ hγ => ne_of_gt <| h_freq_pos γ hγ
          convert trigPoly_mean_zero S c ph h_nonzero using 1;
        convert h_mean_zero using 1;
      have h_mean_square : Filter.Tendsto (fun T => (∫ t in Set.Ioc 0 T, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))^2) / T) Filter.atTop (nhds (∑ γ ∈ S, (c γ)^2 / 2)) := by
        apply_rules [ trigPoly_mean_square ];
      have h_mean_square_le : ∀ T > 0, (∫ t in Set.Ioc 0 T, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))^2) / T ≤ (∫ t in Set.Ioc 0 T, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))) / T * (∑ γ ∈ S, |c γ|) := by
        intros T hT_pos
        have h_integral_le : ∫ t in Set.Ioc 0 T, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))^2 ≤ (∫ t in Set.Ioc 0 T, (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))) * (∑ γ ∈ S, |c γ|) := by
          rw [ ← MeasureTheory.integral_mul_const ];
          refine' MeasureTheory.setIntegral_mono_on _ _ measurableSet_Ioc fun t ht => _;
          · exact Continuous.integrableOn_Ioc ( by exact Continuous.pow ( continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) _ );
          · exact Continuous.integrableOn_Ioc ( by exact Continuous.mul ( continuous_finset_sum _ fun _ _ => Continuous.mul ( continuous_const ) ( Real.continuous_cos.comp ( by continuity ) ) ) continuous_const );
          · rw [ sq ];
            exact mul_le_mul_of_nonneg_left ( Finset.sum_le_sum fun x hx => by cases abs_cases ( c x ) <;> nlinarith [ Real.neg_one_le_cos ( x * t + ph x ), Real.cos_le_one ( x * t + ph x ) ] ) ( h_nonneg t );
        rw [ div_mul_eq_mul_div ] ; gcongr;
      have h_sum_sq_zero : ∑ γ ∈ S, (c γ)^2 / 2 ≤ 0 := by
        exact le_of_tendsto_of_tendsto h_mean_square ( h_mean_zero.mul_const _ ) ( Filter.eventually_atTop.mpr ⟨ 1, fun T hT => h_mean_square_le T <| by positivity ⟩ ) |> le_trans <| by norm_num;
      have h_coeff_zero : ∀ γ ∈ S, c γ = 0 := by
        exact fun γ hγ => by contrapose! h_sum_sq_zero; exact lt_of_lt_of_le ( by positivity ) ( Finset.single_le_sum ( fun x _ => div_nonneg ( sq_nonneg ( c x ) ) zero_le_two ) hγ ) ;
      exact fun t => Finset.sum_eq_zero fun γ hγ => by rw [ h_coeff_zero γ hγ, MulZeroClass.zero_mul ] ;

/-
A non-trivial trigonometric polynomial with distinct positive frequencies must take a negative value.
-/
lemma trigPoly_not_nonneg_everywhere (S : Finset ℝ) (c ph : ℝ → ℝ)
    (h_nonempty : S.Nonempty)
    (h_nonzero : ∀ γ ∈ S, c γ ≠ 0)
    (h_distinct : (S : Set ℝ).Pairwise (· ≠ ·))
    (h_freq_pos : ∀ γ ∈ S, 0 < γ) :
    ∃ t, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ) < 0 := by
      by_contra h_contra;
      have h_trig_poly_zero : ∀ t, ∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ) = 0 := by
        apply trigPoly_eq_zero_of_nonneg_everywhere S c ph h_freq_pos h_distinct;
        aesop;
      have h_coeff_zero : ∀ γ ∈ S, c γ = 0 := by
        apply (trigPoly_zero_iff_coeffs_zero S c ph h_distinct h_freq_pos).mp h_trig_poly_zero;
      exact h_nonzero _ h_nonempty.choose_spec ( h_coeff_zero _ h_nonempty.choose_spec )

/-
Schmidt's oscillation lemma (finite sum version): If f(x) = x + x^{1/2} P(log x) + o(x^{1/2}) where P is a non-trivial trigonometric polynomial, then f(x) - x changes sign infinitely often.
-/
theorem schmidt_oscillation_lemma_finite
    {f : ℝ → ℝ} {S : Finset ℝ} (hS_nonempty : S.Nonempty) (hS_pos : ∀ γ ∈ S, 0 < γ)
    (c : ℝ → ℝ) (ph : ℝ → ℝ) (hc_nonzero : ∀ γ ∈ S, c γ ≠ 0)
    (h_distinct : (S : Set ℝ).Pairwise (· ≠ ·))
    (h_rep : Asymptotics.IsLittleO Filter.atTop (fun x => f x - (x + ∑ γ ∈ S, c γ * x^(1/2:ℝ) * Real.cos (γ * Real.log x + ph γ))) (fun x => x^(1/2:ℝ))) :
    (∀ M, ∃ x > M, f x - x > 0) ∧ (∀ M, ∃ x > M, f x - x < 0) := by
      obtain ⟨t₀, ht₀⟩ : ∃ t₀ : ℝ, ∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ) < 0 := by
        exact trigPoly_not_nonneg_everywhere S c ph hS_nonempty hc_nonzero h_distinct hS_pos
      have h_periodic : ∀ M : ℝ, ∃ τ > M, |∑ γ ∈ S, c γ * Real.cos (γ * (t₀ + τ) + ph γ) - ∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ)| < -∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ) / 2 := by
        intro M
        obtain ⟨τ, hτ₁, hτ₂⟩ : ∃ τ > M, ∀ t : ℝ, |(∑ γ ∈ S, c γ * Real.cos (γ * (t + τ) + ph γ)) - (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))| < -∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ) / 2 := by
          convert trigPoly_almost_periodic S c ph ( -∑ γ ∈ S, c γ * Real.cos ( γ * t₀ + ph γ ) / 2 ) ( by linarith [ show ∑ γ ∈ S, c γ * Real.cos ( γ * t₀ + ph γ ) / 2 < 0 from by simpa only [ ← Finset.sum_div _ _ _ ] using div_neg_of_neg_of_pos ht₀ zero_lt_two ] ) M using 1;
        exact ⟨ τ, hτ₁, hτ₂ t₀ ⟩;
      have h_exp_periodic : ∀ M : ℝ, ∃ x > Real.exp M, |∑ γ ∈ S, c γ * Real.cos (γ * Real.log x + ph γ) - ∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ)| < -∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ) / 2 := by
        exact fun M => by rcases h_periodic ( M - t₀ ) with ⟨ τ, hτ₁, hτ₂ ⟩ ; exact ⟨ Real.exp ( t₀ + τ ), by linarith [ Real.exp_lt_exp.2 ( by linarith : M < t₀ + τ ) ], by simpa [ mul_comm ] using hτ₂ ⟩ ;
      have h_o_one : ∀ δ > 0, ∃ M : ℝ, ∀ x > M, |(f x - (x + ∑ γ ∈ S, c γ * x ^ (1 / 2 : ℝ) * Real.cos (γ * Real.log x + ph γ))) / x ^ (1 / 2 : ℝ)| < δ := by
        rw [ Asymptotics.isLittleO_iff_tendsto' ] at h_rep <;> norm_num at *;
        · exact fun δ hδ => by rcases Metric.tendsto_atTop.mp h_rep δ hδ with ⟨ M, hM ⟩ ; exact ⟨ M, fun x hx => by simpa [ abs_div ] using hM x hx.le ⟩ ;
        · exact ⟨ 1, fun x hx hx' => absurd hx' <| ne_of_gt <| Real.rpow_pos_of_pos ( zero_lt_one.trans_le hx ) _ ⟩;
      have h_neg : ∀ M : ℝ, ∃ x > M, f x - x < 0 := by
        intro M
        obtain ⟨x, hx₁, hx₂⟩ := h_exp_periodic M
        obtain ⟨M', hM'⟩ := h_o_one (-∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ) / 4) (by
        norm_num [ ← Finset.sum_div _ _ _ ] at * ; linarith);
        obtain ⟨x', hx'₁, hx'₂⟩ := h_exp_periodic (Max.max M M');
        refine' ⟨ x', _, _ ⟩ <;> norm_num at *;
        · linarith [ le_max_left M M', le_max_right M M', Real.add_one_le_exp ( Max.max M M' ) ];
        · have := hM' x' ( lt_trans ( lt_of_le_of_lt ( le_max_right _ _ ) ( by linarith [ Real.add_one_le_exp ( Max.max M M' ) ] ) ) hx'₁ );
          rw [ abs_lt ] at this;
          rw [ lt_div_iff₀ ( Real.rpow_pos_of_pos ( by linarith [ Real.exp_pos ( Max.max M M' ) ] ) _ ), div_lt_iff₀ ( Real.rpow_pos_of_pos ( by linarith [ Real.exp_pos ( Max.max M M' ) ] ) _ ) ] at this;
          norm_num [ ← Finset.sum_div _ _ _, ← Finset.sum_mul ] at *;
          norm_num [ ← Real.sqrt_eq_rpow, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _ ] at *;
          norm_num [ ← mul_assoc, ← Finset.sum_mul _ _ _ ] at *;
          nlinarith [ abs_lt.mp hx'₂, Real.sqrt_nonneg x', Real.mul_self_sqrt ( show 0 ≤ x' by linarith [ Real.exp_pos ( Max.max M M' ) ] ) ];
      obtain ⟨t₀, ht₀⟩ : ∃ t₀ : ℝ, ∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ) > 0 := by
        contrapose! ht₀;
        have := trigPoly_eq_zero_of_nonneg_everywhere S ( fun γ => -c γ ) ( fun γ => ph γ ) ( fun γ hγ => by linarith [ hS_pos γ hγ ] ) h_distinct ( fun t => by simpa using neg_nonneg.mpr ( ht₀ t ) ) ; aesop;
      have h_periodic_pos : ∀ M : ℝ, ∃ τ > M, |∑ γ ∈ S, c γ * Real.cos (γ * (t₀ + τ) + ph γ) - ∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ)| < ∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ) / 2 := by
        intros M
        obtain ⟨τ, hτ₁, hτ₂⟩ : ∃ τ > M, ∀ t, |(∑ γ ∈ S, c γ * Real.cos (γ * (t + τ) + ph γ)) - (∑ γ ∈ S, c γ * Real.cos (γ * t + ph γ))| < (∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ)) / 2 := by
          exact trigPoly_almost_periodic S c ph ( ( ∑ γ ∈ S, c γ * Real.cos ( γ * t₀ + ph γ ) ) / 2 ) ( half_pos ht₀ ) M |> fun ⟨ τ, hτ₁, hτ₂ ⟩ => ⟨ τ, hτ₁, fun t => hτ₂ t ⟩;
        exact ⟨ τ, hτ₁, by simpa only [ Finset.sum_div _ _ _ ] using hτ₂ t₀ ⟩;
      have h_exp_periodic_pos : ∀ M : ℝ, ∃ x > Real.exp M, |∑ γ ∈ S, c γ * Real.cos (γ * Real.log x + ph γ) - ∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ)| < ∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ) / 2 := by
        exact fun M => by obtain ⟨ τ, hτ₁, hτ₂ ⟩ := h_periodic_pos ( M - t₀ ) ; exact ⟨ Real.exp ( t₀ + τ ), by linarith [ Real.exp_lt_exp.mpr ( by linarith : M < t₀ + τ ) ], by simpa [ mul_comm ] using hτ₂ ⟩ ;
      have h_pos : ∀ M : ℝ, ∃ x > M, f x - x > 0 := by
        intro M
        obtain ⟨x, hx₁, hx₂⟩ := h_exp_periodic_pos (max M 1)
        obtain ⟨M', hM'⟩ := h_o_one ( (∑ γ ∈ S, c γ * Real.cos (γ * t₀ + ph γ)) / 4 ) (by
        linarith);
        obtain ⟨x', hx'₁, hx'₂⟩ := h_exp_periodic_pos (max M' (max M 1))
        use x';
        have := hM' x' ( by linarith [ Real.add_one_le_exp ( Max.max M' ( Max.max M 1 ) ), le_max_left M' ( Max.max M 1 ), le_max_right M' ( Max.max M 1 ), le_max_left M 1, le_max_right M 1 ] ) ; norm_num [ abs_lt ] at *;
        rw [ lt_div_iff₀ ( Real.rpow_pos_of_pos ( by linarith [ Real.exp_pos ( Max.max M' ( Max.max M 1 ) ) ] ) _ ), div_lt_iff₀ ( Real.rpow_pos_of_pos ( by linarith [ Real.exp_pos ( Max.max M' ( Max.max M 1 ) ) ] ) _ ) ] at this;
        norm_num [ ← Finset.sum_div _ _ _ ] at *;
        exact ⟨ by linarith [ Real.add_one_le_exp ( Max.max M' ( Max.max M 1 ) ), le_max_left M' ( Max.max M 1 ), le_max_right M' ( Max.max M 1 ), le_max_left M 1, le_max_right M 1 ], by nlinarith [ Real.rpow_pos_of_pos ( show 0 < x' by linarith [ Real.exp_pos ( Max.max M' ( Max.max M 1 ) ) ] ) ( 1 / 2 : ℝ ), show ( ∑ γ ∈ S, c γ * x' ^ ( 1 / 2 : ℝ ) * Real.cos ( γ * Real.log x' + ph γ ) ) = x' ^ ( 1 / 2 : ℝ ) * ∑ γ ∈ S, c γ * Real.cos ( γ * Real.log x' + ph γ ) by rw [ Finset.mul_sum _ _ _ ] ; exact Finset.sum_congr rfl fun _ _ => by ring ] ⟩;
      exact ⟨ h_pos, h_neg ⟩

/-
Renaming the finite version of Schmidt's oscillation lemma for clarity.
-/
theorem schmidt_oscillation_lemma_finite_set
    {f : ℝ → ℝ} {S : Finset ℝ} (hS_nonempty : S.Nonempty) (hS_pos : ∀ γ ∈ S, 0 < γ)
    (c : ℝ → ℝ) (ph : ℝ → ℝ) (hc_nonzero : ∀ γ ∈ S, c γ ≠ 0)
    (h_distinct : (S : Set ℝ).Pairwise (· ≠ ·))
    (h_rep : Asymptotics.IsLittleO Filter.atTop (fun x => f x - (x + ∑ γ ∈ S, c γ * x^(1/2:ℝ) * Real.cos (γ * Real.log x + ph γ))) (fun x => x^(1/2:ℝ))) :
    (∀ M, ∃ x > M, f x - x > 0) ∧ (∀ M, ∃ x > M, f x - x < 0) := by
      exact schmidt_oscillation_lemma_finite hS_nonempty hS_pos c ph hc_nonzero h_distinct h_rep

end
