/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 4fde7caa-4c09-47f1-9e93-076895cd6ba7

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: proves psi_oscillation_implies_pi_li_oscillation with 0 sorries.
Uses local definitions (chebyshevPsi, chebyshevTheta, li, pi_sub_li_error) that
are independent of the project's definitions in Littlewood.Basic.*. This file is
NOT imported by any bridge or CriticalAssumptions — it serves as a reference proof.

The theorem shows: if ψ(x) - x has unbounded oscillations (∀ C, ∃ᶠ x, ψ(x) - x > C√x)
and R(x) = O(√x/log x), then π(x) - li(x) changes sign infinitely often.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.PsiOscillationPiLi

/-
Definition of Chebyshev Psi function: ψ(x) = Σ_{n < ⌊x⌋} Λ(n).
-/
noncomputable def chebyshevPsi (x : ℝ) : ℝ := ∑ n ∈ Finset.range ⌊x⌋.toNat, ArithmeticFunction.vonMangoldt n

/-
Definitions of Chebyshev Theta and Logarithmic Integral li(x).
-/
noncomputable def chebyshevTheta (x : ℝ) : ℝ := ∑ p ∈ (Finset.range ⌊x⌋.toNat).filter Nat.Prime, Real.log p

noncomputable def li (x : ℝ) : ℝ := ∫ t in (2)..x, 1 / Real.log t

/-
Definition of the error term R(x) = π(x) - li(x) - (ψ(x) - x)/log(x).
-/
noncomputable def pi_sub_li_error (x : ℝ) : ℝ :=
  (Nat.primeCounting ⌊x⌋.toNat : ℝ) - li x - (chebyshevPsi x - x) / Real.log x

/-
Helper lemma: If ψ(x) - x > C√x and |R(x)| ≤ K√x/log x with C > K, then π(x) > li(x).
-/
lemma pi_sub_li_pos_of_psi_pos {x C K : ℝ} (hx : 1 < x)
    (h_psi : chebyshevPsi x - x > C * Real.sqrt x)
    (h_err : |pi_sub_li_error x| ≤ K * Real.sqrt x / Real.log x)
    (h_CK : K < C) :
    (Nat.primeCounting ⌊x⌋.toNat : ℝ) - li x > 0 := by
  have h_R : pi_sub_li_error x = (Nat.primeCounting ⌊x⌋.toNat : ℝ) - li x - (chebyshevPsi x - x) / Real.log x := by
    rfl;
  nlinarith [ abs_le.mp h_err, show 0 < Real.sqrt x / Real.log x from div_pos ( Real.sqrt_pos.mpr <| by positivity ) ( Real.log_pos hx ), show 0 < Real.sqrt x by positivity, show 0 < Real.log x by exact Real.log_pos hx, mul_div_cancel₀ ( K * Real.sqrt x ) ( ne_of_gt <| Real.log_pos hx ), mul_div_cancel₀ ( C * Real.sqrt x ) ( ne_of_gt <| Real.log_pos hx ), mul_div_cancel₀ ( chebyshevPsi x - x ) ( ne_of_gt <| Real.log_pos hx ) ]

/-
Helper lemma: If ψ(x) - x < -C√x and |R(x)| ≤ K√x/log x with C > K, then π(x) < li(x).
-/
lemma pi_sub_li_neg_of_psi_neg {x C K : ℝ} (hx : 1 < x)
    (h_psi : chebyshevPsi x - x < -C * Real.sqrt x)
    (h_err : |pi_sub_li_error x| ≤ K * Real.sqrt x / Real.log x)
    (h_CK : K < C) :
    (Nat.primeCounting ⌊x⌋.toNat : ℝ) - li x < 0 := by
  have h_R : (Nat.primeCounting ⌊x⌋.toNat : ℝ) - li x = (chebyshevPsi x - x) / Real.log x + pi_sub_li_error x := by
    unfold pi_sub_li_error; ring;
  rw [ h_R, div_add', div_lt_iff₀ ] <;> nlinarith [ abs_le.mp h_err, Real.sqrt_nonneg x, Real.sq_sqrt <| show 0 ≤ x by positivity, Real.log_pos hx, mul_div_cancel₀ ( K * Real.sqrt x ) <| ne_of_gt <| Real.log_pos hx ]

/-
Lemma: If ψ(x) - x has arbitrarily large positive oscillations and the error term is bounded, then π(x) > li(x) frequently.
-/
lemma oscillation_transfer_pos
    (h_psi_pos : ∀ C : ℝ, ∃ᶠ x in Filter.atTop, chebyshevPsi x - x > C * Real.sqrt x)
    (h_bound : ∃ K : ℝ, ∀ᶠ x in Filter.atTop, |pi_sub_li_error x| ≤ K * Real.sqrt x / Real.log x) :
    ∃ᶠ x in Filter.atTop, (Nat.primeCounting ⌊x⌋.toNat : ℝ) > li x := by
  obtain ⟨K, hK⟩ := h_bound
  obtain ⟨C, hC⟩ : ∃ C : ℝ, C > K ∧ ∀ᶠ x in Filter.atTop, |pi_sub_li_error x| ≤ K * Real.sqrt x / Real.log x := by
    exact ⟨ K + 1, by linarith, hK ⟩;
  have h_inf : ∃ᶠ x in Filter.atTop, 1 < x ∧ chebyshevPsi x - x > C * Real.sqrt x ∧ |pi_sub_li_error x| ≤ K * Real.sqrt x / Real.log x := by
    have h_inf : ∃ᶠ x in Filter.atTop, 1 < x ∧ chebyshevPsi x - x > C * Real.sqrt x := by
      exact Filter.Frequently.and_eventually ( h_psi_pos C ) ( Filter.eventually_gt_atTop 1 ) |> fun h => h.mono fun x hx => ⟨ hx.2, hx.1 ⟩ ;
    exact h_inf.and_eventually ( hC.2.and ( Filter.eventually_gt_atTop 1 ) ) |> fun h => h.mono fun x hx => ⟨ hx.1.1, hx.1.2, hx.2.1 ⟩;
  exact h_inf.mono fun x hx => by linarith [ hx.2.1, hx.2.2, pi_sub_li_pos_of_psi_pos hx.1 hx.2.1 hx.2.2 ( by linarith ) ] ;

/-
Lemma: If ψ(x) - x has arbitrarily large negative oscillations and the error term is bounded, then π(x) < li(x) frequently.
-/
lemma oscillation_transfer_neg
    (h_psi_neg : ∀ C : ℝ, ∃ᶠ x in Filter.atTop, chebyshevPsi x - x < -C * Real.sqrt x)
    (h_bound : ∃ K : ℝ, ∀ᶠ x in Filter.atTop, |pi_sub_li_error x| ≤ K * Real.sqrt x / Real.log x) :
    ∃ᶠ x in Filter.atTop, (Nat.primeCounting ⌊x⌋.toNat : ℝ) < li x := by
  obtain ⟨K, hK⟩ := h_bound
  set C := K + 1;
  have h_psi_neg_C : ∃ᶠ x in Filter.atTop, chebyshevPsi x - x < -C * Real.sqrt x := by
    exact h_psi_neg C;
  have h_frequent : ∃ᶠ x in Filter.atTop, chebyshevPsi x - x < -C * Real.sqrt x ∧ |pi_sub_li_error x| ≤ K * Real.sqrt x / Real.log x ∧ 1 < x := by
    exact h_psi_neg_C.and_eventually ( hK.and ( Filter.eventually_gt_atTop 1 ) ) |> fun h => h.mono fun x hx => ⟨ hx.1, hx.2.1, hx.2.2 ⟩;
  refine' h_frequent.mono _;
  intro x hx; have := pi_sub_li_neg_of_psi_neg hx.2.2 hx.1 hx.2.1 ( by linarith ) ; linarith;

/-
Theorem: If ψ(x) - x has arbitrarily large oscillations of order √x in both directions, and the error term R(x) is O(√x/log x), then π(x) - li(x) changes sign infinitely often.
-/
theorem psi_oscillation_implies_pi_li_oscillation
    (h_bound : Asymptotics.IsBigO Filter.atTop pi_sub_li_error (fun x => Real.sqrt x / Real.log x))
    (h_psi_pos : ∀ C : ℝ, ∃ᶠ x in Filter.atTop, chebyshevPsi x - x > C * Real.sqrt x)
    (h_psi_neg : ∀ C : ℝ, ∃ᶠ x in Filter.atTop, chebyshevPsi x - x < -C * Real.sqrt x) :
    (∃ᶠ x in Filter.atTop, (Nat.primeCounting ⌊x⌋.toNat : ℝ) > li x) ∧
    (∃ᶠ x in Filter.atTop, (Nat.primeCounting ⌊x⌋.toNat : ℝ) < li x) := by
  obtain ⟨K, hK⟩ : ∃ K : ℝ, ∀ᶠ x in Filter.atTop, |pi_sub_li_error x| ≤ K * (Real.sqrt x / Real.log x) := by
    simp_all +decide [ Asymptotics.isBigO_iff ];
    exact ⟨ h_bound.choose, Max.max h_bound.choose_spec.choose 2, fun x hx => by simpa only [ abs_of_nonneg ( Real.sqrt_nonneg x ), abs_of_nonneg ( Real.log_nonneg ( show x ≥ 1 by linarith [ le_max_left h_bound.choose_spec.choose 2, le_max_right h_bound.choose_spec.choose 2 ] ) ) ] using h_bound.choose_spec.choose_spec x ( le_trans ( le_max_left _ _ ) hx ) ⟩;
  apply And.intro;
  · apply oscillation_transfer_pos;
    · assumption;
    · exact ⟨ K, by simpa only [ mul_div_assoc ] using hK ⟩;
  · apply oscillation_transfer_neg;
    · assumption;
    · exact ⟨ K, hK.mono fun x hx => by simpa only [ mul_div_assoc ] using hx ⟩

end Aristotle.PsiOscillationPiLi
