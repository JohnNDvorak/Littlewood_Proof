/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 1ec1d4d1-013f-43df-9b20-fa08fc8c0191

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Standalone file: Integral representation infrastructure for the Riemann zeta function.
NOT imported by any bridge — serves as reference material.

Contains:
- zeta_bound_Re_2: |ζ(2+it)| ≤ |ζ(2)| (PROVED)
- integral_bound: ∫_{>1} |{x}·x^{-s-1}| ≤ 2 for Re(s)=1/2 (PROVED)
- norm_zetaIntegralTerm_le: |∫ {x}x^{-s-1}| ≤ 1/Re(s) (PROVED)
- integral_floor_term: ∫_{(n,n+1]} ⌊x⌋·x^{-s-1} (PROVED)
- sum_telescoping_zeta: telescoping sum for ζ(s) (PROVED)
- integral_floor_eq_sum: integral decomposition (3 exact?)
- zeta_eq_s_mul_integral_floor: ζ(s) = s·∫ ⌊x⌋·x^{-s-1} (PROVED modulo above)
- integral_cpow_neg_s_eq_one_div_s_sub_one: ∫_1^∞ x^{-s} = 1/(s-1) (PROVED)
- integrable_floor_mul_cpow: integrability (PROVED)
- zeta_eq_integral_rep_of_one_lt_re: ζ(s) = s/(s-1) - s·∫{x}x^{-s-1} (PROVED modulo above)
- integrable_log_mul_fract_mul_cpow: log·{x}·x^{-s-1} integrable (PROVED)

Originally had 1 sorry (exact? timeout at line 150); CLOSED by Claude Code with `exact hs`.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 1600000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace Aristotle.ZetaIntegralRep

/-
The magnitude of the Riemann Zeta function on the line Re(s) = 2 is bounded by the magnitude of ζ(2).
-/
theorem zeta_bound_Re_2 (t : ℝ) : ‖riemannZeta (2 + t * Complex.I)‖ ≤ ‖riemannZeta 2‖ := by
  have h_def : riemannZeta (2 + t * Complex.I) = ∑' n : ℕ, (1 : ℂ) / (n + 1) ^ (2 + t * Complex.I) := by
    convert zeta_eq_tsum_one_div_nat_add_one_cpow _ using 1;
    norm_num [ Complex.ext_iff ];
  have h_sum : ∑' n : ℕ, (1 : ℂ) / (n + 1) ^ (2 + t * Complex.I) = ∑' n : ℕ, (1 : ℂ) / (n + 1) ^ 2 * (1 : ℂ) / ((n + 1) ^ (t * Complex.I)) := by
    refine' tsum_congr fun n => _;
    rw [ Complex.cpow_add ] <;> norm_cast ; norm_num ; ring;
  have h_norm : ‖∑' n : ℕ, (1 : ℂ) / (n + 1) ^ 2 * (1 : ℂ) / ((n + 1) ^ (t * Complex.I))‖ ≤ ∑' n : ℕ, ‖(1 : ℂ) / (n + 1) ^ 2 * (1 : ℂ) / ((n + 1) ^ (t * Complex.I))‖ := by
    convert norm_tsum_le_tsum_norm _ ; norm_num;
    norm_num [ Complex.norm_cpow_of_ne_zero, Nat.cast_add_one_ne_zero ];
    norm_cast ; norm_num [ Complex.arg ];
    simpa using summable_nat_add_iff 1 |>.2 <| Real.summable_one_div_nat_pow.2 one_lt_two;
  have h_norm_eq : ∑' n : ℕ, ‖(1 : ℂ) / (n + 1) ^ 2 * (1 : ℂ) / ((n + 1) ^ (t * Complex.I))‖ = ∑' n : ℕ, (1 : ℝ) / (n + 1) ^ 2 := by
    norm_num [ Complex.norm_exp, Complex.norm_cpow_of_ne_zero, Nat.cast_add_one_ne_zero ];
    norm_cast ; norm_num [ Complex.arg ];
  have h_riemann_zeta_2 : riemannZeta 2 = ∑' n : ℕ, (1 : ℂ) / (n + 1) ^ 2 := by
    rw [ zeta_eq_tsum_one_div_nat_add_one_cpow ] ; norm_num;
    norm_num;
  convert h_norm.trans _;
  · grind;
  · rw [ h_norm_eq, h_riemann_zeta_2 ];
    convert le_abs_self _;
    convert Complex.norm_real _;
    norm_num [ Complex.ofReal_tsum ]

/-
The magnitude of the integral of the fractional part of x times x^(-s-1) from 1 to infinity is bounded by 2 when Re(s) = 1/2.
-/
theorem integral_bound {s : ℂ} (hs : s.re = 1 / 2) :
    ‖∫ (x : ℝ) in Set.Ioi 1, ((x : ℂ) - (Int.floor x : ℂ)) * (x : ℂ) ^ (-s - 1)‖ ≤ 2 := by
  have h_bound : ∀ x : ℝ, 1 < x → ‖((x : ℂ) - (⌊x⌋ : ℂ)) * (x : ℂ) ^ (-s - 1)‖ ≤ x ^ (-3 / 2 : ℝ) := by
    intros x hx
    have : ‖((x : ℂ) - (⌊x⌋ : ℂ))‖ ≤ 1 := by
      norm_cast; exact abs_le.mpr ⟨ by linarith [ Int.floor_le x ], by linarith [ Int.lt_floor_add_one x ] ⟩ ;
    have : ‖(x : ℂ) ^ (-s - 1)‖ = x ^ (-s.re - 1 : ℝ) := by
      rw [ Complex.norm_cpow_eq_rpow_re_of_pos ] <;> norm_num ; linarith
    simp [this, hs] at *; (
    exact le_trans ( mul_le_of_le_one_left ( by positivity ) ‹_› ) ( by norm_num ));
  refine' le_trans ( MeasureTheory.norm_integral_le_integral_norm _ ) ( le_trans ( MeasureTheory.integral_mono_of_nonneg _ _ _ ) _ );
  refine' fun x => x ^ ( -3 / 2 : ℝ );
  · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
  · exact ( integrableOn_Ioi_rpow_of_lt ( by norm_num ) ( by norm_num ) );
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using h_bound x hx;
  · rw [ integral_Ioi_rpow_of_lt ] <;> norm_num

/-
The magnitude of the integral term is bounded by 1/Re(s) for Re(s) > 0.
-/
noncomputable def zetaIntegralTerm (s : ℂ) : ℂ :=
  ∫ x in Set.Ioi (1 : ℝ), ((x : ℂ) - (Int.floor x : ℂ)) * (x : ℂ) ^ (-s - 1)

theorem norm_zetaIntegralTerm_le {s : ℂ} (hs : 0 < s.re) :
    ‖zetaIntegralTerm s‖ ≤ 1 / s.re := by
  have h_integral_term_bound : ‖∫ (x : ℝ) in Set.Ioi 1, ((x : ℂ) - (Int.floor x : ℂ)) * (x : ℂ) ^ (-s - 1)‖ ≤ ∫ (x : ℝ) in Set.Ioi 1, ‖((x : ℂ) - (Int.floor x : ℂ)) * (x : ℂ) ^ (-s - 1)‖ := by
    exact MeasureTheory.norm_integral_le_integral_norm _;
  have h_integrand_bound : ∀ x : ℝ, x > 1 → ‖((x : ℂ) - (Int.floor x : ℂ)) * (x : ℂ) ^ (-s - 1)‖ ≤ (x : ℝ) ^ (-s.re - 1) := by
    intro x hx; rw [ Complex.cpow_def_of_ne_zero ( by norm_cast; linarith ) ] ; norm_num [ Complex.norm_exp ] ; ring_nf; norm_cast; norm_num;
    norm_num [ Complex.log_re, Complex.log_im, Real.rpow_def_of_pos ( zero_lt_one.trans hx ) ];
    norm_num [ Complex.arg ] ; ring_nf;
    exact le_trans ( mul_le_of_le_one_left ( Real.exp_nonneg _ ) ( abs_le.mpr ⟨ by linarith [ Int.fract_nonneg x ], by linarith [ Int.fract_lt_one x ] ⟩ ) ) ( Real.exp_le_exp.mpr ( by split_ifs <;> nlinarith [ Real.log_pos hx ] ) );
  have h_integral_bound : ∫ (x : ℝ) in Set.Ioi 1, (x : ℝ) ^ (-s.re - 1) = 1 / s.re := by
    rw [ integral_Ioi_rpow_of_lt ] <;> norm_num [ hs ];
    linarith;
  refine' le_trans h_integral_term_bound ( h_integral_bound ▸ MeasureTheory.integral_mono_of_nonneg _ _ _ );
  · exact Filter.Eventually.of_forall fun x => norm_nonneg _;
  · exact ( by contrapose! h_integral_bound; rw [ MeasureTheory.integral_undef h_integral_bound ] ; norm_num; positivity );
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using h_integrand_bound x hx

/-
The integral of floor(x) * x^(-s-1) over (n, n+1] is n * (n^(-s) - (n+1)^(-s)) / s.
-/
theorem integral_floor_term (n : ℕ) (hn : 1 ≤ n) (s : ℂ) (hs : s ≠ 0) :
    ∫ x in Set.Ioc (n : ℝ) (n + 1), (Int.floor x : ℂ) * (x : ℂ) ^ (-s - 1) =
    (n : ℂ) * ((n : ℂ) ^ (-s) - (n + 1 : ℂ) ^ (-s)) / s := by
  have h_floor_eq : ∫ x in Set.Ioc (n : ℝ) (n + 1), (Int.floor x) * (x : ℂ) ^ (-s - 1) = n * ∫ x in Set.Ioc (n : ℝ) (n + 1), (x : ℂ) ^ (-s - 1) := by
    rw [ MeasureTheory.integral_Ioc_eq_integral_Ioo, MeasureTheory.integral_Ioc_eq_integral_Ioo ];
    rw [ ← MeasureTheory.integral_const_mul ] ; exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioo fun x hx => by norm_num [ show ⌊x⌋ = n by exact Int.floor_eq_iff.mpr ⟨ by norm_num; linarith [ hx.1 ], by norm_num; linarith [ hx.2 ] ⟩ ] ; ;
  have h_integral : ∫ x in Set.Ioc (n : ℝ) (n + 1), (x : ℂ) ^ (-s - 1) = ((n + 1 : ℂ) ^ (-s) - (n : ℂ) ^ (-s)) / (-s) := by
    rw [ ← intervalIntegral.integral_of_le, integral_cpow ] <;> norm_num [ hs ];
    exact Or.inr fun h => by linarith;
  exact h_floor_eq.trans $ h_integral.symm ▸ by ring;

/-
The sum of n * (n^(-s) - (n+1)^(-s)) converges to the Riemann Zeta function for Re(s) > 1.
-/
theorem sum_telescoping_zeta {s : ℂ} (hs : 1 < s.re) :
    HasSum (fun n : ℕ => (n : ℂ) * ((n : ℂ) ^ (-s) - (n + 1 : ℂ) ^ (-s))) (riemannZeta s) := by
  have h_partial_sum : ∀ N : ℕ, ∑ n ∈ Finset.Icc 1 N, (n : ℂ) * ((n : ℂ) ^ (-s) - ((n : ℂ) + 1) ^ (-s)) = ∑ n ∈ Finset.Icc 1 N, (n : ℂ) ^ (-s) - (N : ℂ) * ((N + 1 : ℂ) ^ (-s)) := by
    intro N; induction N <;> simp_all +decide [ Finset.sum_Ioc_succ_top, (Nat.succ_eq_succ ▸ Finset.Icc_succ_left_eq_Ioc) ] ; ring;
  have h_limit : Filter.Tendsto (fun N : ℕ => ∑ n ∈ Finset.Icc 1 N, (n : ℂ) ^ (-s)) Filter.atTop (nhds (riemannZeta s)) ∧ Filter.Tendsto (fun N : ℕ => (N : ℂ) * ((N + 1 : ℂ) ^ (-s))) Filter.atTop (nhds 0) := by
    constructor;
    · have h_series_conv : Filter.Tendsto (fun N : ℕ => ∑ n ∈ Finset.range N, (n + 1 : ℂ) ^ (-s)) Filter.atTop (nhds (riemannZeta s)) := by
        convert ( Summable.hasSum <| show Summable _ from ?_ ) |> HasSum.tendsto_sum_nat using 1;
        rw [ zeta_eq_tsum_one_div_nat_add_one_cpow ];
        congr! 1;
        · norm_num [ Complex.cpow_neg ];
        · exact hs
        · have h_summable : Summable (fun n : ℕ => (n : ℂ) ^ (-s)) := by
            refine' .of_norm _;
            have := Real.summable_nat_rpow_inv.mpr hs;
            convert this using 1;
            ext; rw [ ← Complex.ofReal_natCast ] ; rw [ Complex.norm_cpow_eq_rpow_re_of_nonneg ] <;> norm_num;
            · rw [ Real.rpow_neg ( Nat.cast_nonneg _ ) ];
            · linarith;
          exact_mod_cast h_summable.comp_injective Nat.succ_injective;
      exact h_series_conv.congr fun N => by erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ' ] ;
    · have h_bound : ∀ N : ℕ, N ≥ 1 → ‖(N : ℂ) * ((N + 1 : ℂ) ^ (-s))‖ ≤ (N : ℝ) ^ (1 - s.re) := by
        intro N hN; norm_num [ Complex.norm_cpow_of_ne_zero, show ( N : ℂ ) + 1 ≠ 0 from Nat.cast_add_one_ne_zero _ ];
        norm_cast ; norm_num [ Real.rpow_sub ];
        rw [ Real.rpow_sub ] <;> norm_num <;> try linarith;
        rw [ Real.rpow_neg ( by positivity ) ];
        exact mul_le_mul_of_nonneg_left ( inv_anti₀ ( by positivity ) ( by gcongr ; linarith ) ) ( by positivity );
      exact squeeze_zero_norm' ( Filter.eventually_atTop.mpr ⟨ 1, h_bound ⟩ ) ( by simpa using tendsto_rpow_neg_atTop ( by linarith : 0 < s.re - 1 ) |> Filter.Tendsto.comp <| tendsto_natCast_atTop_atTop );
  have h_limit : Filter.Tendsto (fun N : ℕ => ∑ n ∈ Finset.range (N + 1), (n : ℂ) * ((n : ℂ) ^ (-s) - ((n : ℂ) + 1) ^ (-s))) Filter.atTop (nhds (riemannZeta s)) := by
    convert h_limit.1.sub h_limit.2 using 2 <;> norm_num [ Finset.sum_range_succ' ];
    erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ', h_partial_sum ];
    convert h_partial_sum ‹_› using 1 <;> norm_cast ; norm_num [ Finset.sum_range_succ' ];
    · erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ' ];
    · erw [ Finset.sum_Ico_eq_sub _ _ ] <;> norm_num [ Finset.sum_range_succ' ];
  rw [ hasSum_iff_tendsto_nat_of_summable_norm ];
  · rwa [ ← Filter.tendsto_add_atTop_iff_nat ];
  · have h_bound : ∃ C : ℝ, ∀ n : ℕ, 1 ≤ n → ‖(n : ℂ) * ((n : ℂ) ^ (-s) - ((n : ℂ) + 1) ^ (-s))‖ ≤ C * (n : ℝ) ^ (-s.re) := by
      have h_bound : ∃ C : ℝ, ∀ n : ℕ, 1 ≤ n → ‖((n : ℂ) ^ (-s) - ((n : ℂ) + 1) ^ (-s))‖ ≤ C * (n : ℝ) ^ (-s.re - 1) := by
        have h_bound : ∃ C : ℝ, ∀ n : ℕ, 1 ≤ n → ‖((n : ℂ) ^ (-s) - ((n : ℂ) + 1) ^ (-s))‖ ≤ C * (n : ℝ) ^ (-s.re - 1) := by
          have h_integral_bound : ∀ n : ℕ, 1 ≤ n → ‖((n : ℂ) ^ (-s) - ((n : ℂ) + 1) ^ (-s))‖ ≤ ∫ x in (n : ℝ)..((n : ℝ) + 1), ‖s‖ * x ^ (-s.re - 1) := by
            intros n hn
            have h_integral_bound : ‖((n : ℂ) ^ (-s) - ((n : ℂ) + 1) ^ (-s))‖ ≤ ∫ x in (n : ℝ)..((n : ℝ) + 1), ‖deriv (fun x : ℂ => x ^ (-s)) x‖ := by
              have h_integral_bound : ‖((n : ℂ) ^ (-s) - ((n : ℂ) + 1) ^ (-s))‖ = ‖∫ x in (n : ℝ)..((n : ℝ) + 1), deriv (fun x : ℂ => x ^ (-s)) x‖ := by
                rw [ intervalIntegral.integral_eq_sub_of_hasDerivAt ];
                rotate_right;
                use fun x => x ^ (-s);
                · norm_num [ norm_sub_rev ];
                · intro x hx;
                  convert HasDerivAt.comp x ( hasDerivAt_deriv_iff.mpr <| show DifferentiableAt ℂ ( fun x : ℂ => x ^ ( -s ) ) ( x : ℂ ) from ?_ ) ( hasDerivAt_id x |> HasDerivAt.ofReal_comp ) using 1;
                  · norm_num;
                  · exact DifferentiableAt.cpow ( differentiableAt_id ) ( differentiableAt_const _ ) ( by norm_num; cases Set.mem_uIcc.mp hx <;> linarith [ show ( n : ℝ ) ≥ 1 by norm_cast ] );
                · apply_rules [ ContinuousOn.intervalIntegrable ];
                  refine' ContinuousOn.congr _ _;
                  use fun x => -s * x ^ (-s - 1 : ℂ);
                  · exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.mul continuousAt_const <| ContinuousAt.cpow ( Complex.continuous_ofReal.continuousAt ) continuousAt_const <| Or.inl <| by norm_cast; cases Set.mem_uIcc.mp hx <;> linarith [ show ( n : ℝ ) ≥ 1 by norm_cast ] ;
                  · intro x hx; simp +decide [ show x ≠ 0 from by cases Set.mem_uIcc.mp hx <;> linarith [ show ( n : ℝ ) ≥ 1 by norm_cast ] ] ;
                    rw [ deriv_cpow_const ] <;> norm_num;
                    cases Set.mem_uIcc.mp hx <;> linarith [ show ( n : ℝ ) ≥ 1 by norm_cast ];
              convert intervalIntegral.norm_integral_le_integral_norm _ using 1;
              norm_num;
            refine' le_trans h_integral_bound ( intervalIntegral.integral_mono_on _ _ _ _ );
            · norm_num;
            · apply_rules [ ContinuousOn.intervalIntegrable ];
              refine' ContinuousOn.norm _;
              refine' ContinuousOn.congr _ _;
              use fun x => -s * x ^ (-s - 1 : ℂ);
              · exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.mul continuousAt_const <| ContinuousAt.cpow ( Complex.continuous_ofReal.continuousAt ) continuousAt_const <| Or.inl <| by norm_cast; cases Set.mem_uIcc.mp hx <;> linarith [ show ( n : ℝ ) ≥ 1 by norm_cast ] ;
              · intro x hx; simp +decide [ show x ≠ 0 from by cases Set.mem_uIcc.mp hx <;> linarith [ show ( n : ℝ ) ≥ 1 by norm_cast ] ] ;
                rw [ deriv_cpow_const ] <;> norm_num;
                cases Set.mem_uIcc.mp hx <;> linarith [ show ( n : ℝ ) ≥ 1 by norm_cast ];
            · apply_rules [ ContinuousOn.intervalIntegrable ];
              exact continuousOn_of_forall_continuousAt fun x hx => ContinuousAt.mul continuousAt_const ( ContinuousAt.rpow continuousAt_id continuousAt_const <| Or.inl <| by cases Set.mem_uIcc.mp hx <;> linarith [ show ( n : ℝ ) ≥ 1 by norm_cast ] );
            · intro x hx; rw [ deriv_cpow_const ] <;> norm_num;
              · rw [ Complex.norm_cpow_eq_rpow_re_of_pos ( by linarith [ hx.1, show ( n : ℝ ) ≥ 1 by norm_cast ] ) ] ; norm_num;
              · linarith [ hx.1, show ( n : ℝ ) ≥ 1 by norm_cast ]
          refine' ⟨ ‖s‖, fun n hn => le_trans ( h_integral_bound n hn ) _ ⟩;
          rw [ intervalIntegral.integral_of_le ( by norm_num ) ];
          rw [ MeasureTheory.integral_const_mul, ← intervalIntegral.integral_of_le ] <;> norm_num;
          rw [ intervalIntegral.integral_of_le ( by norm_num ) ];
          exact mul_le_mul_of_nonneg_left ( le_trans ( MeasureTheory.setIntegral_mono_on ( by exact ContinuousOn.integrableOn_Icc ( by exact continuousOn_of_forall_continuousAt fun x hx => by exact ContinuousAt.rpow ( continuousAt_id ) continuousAt_const <| Or.inl <| by linarith [ hx.1, show ( n : ℝ ) ≥ 1 by norm_cast ] ) |> fun h => h.mono_set <| Set.Ioc_subset_Icc_self ) ( by exact Continuous.integrableOn_Ioc <| by continuity ) measurableSet_Ioc fun x hx => show x ^ ( -s.re - 1 ) ≤ ( n : ℝ ) ^ ( -s.re - 1 ) from by rw [ Real.rpow_le_rpow_iff_of_neg ] <;> linarith [ hx.1, hx.2, show ( n : ℝ ) ≥ 1 by norm_cast ] ) <| by norm_num ) <| by positivity;
        exact h_bound;
      obtain ⟨ C, hC ⟩ := h_bound; use C; intro n hn; rw [ norm_mul ] ; specialize hC n hn; simp_all +decide [ Real.rpow_add, Real.rpow_sub ] ;
      convert mul_le_mul_of_nonneg_left hC ( Nat.cast_nonneg n ) using 1 ; ring;
      rw [ show ( -s.re : ℝ ) = -1 - s.re + 1 by ring, Real.rpow_add ] <;> norm_num <;> linarith;
    obtain ⟨ C, hC ⟩ := h_bound;
    rw [ ← summable_nat_add_iff 1 ];
    exact Summable.of_nonneg_of_le ( fun n => norm_nonneg _ ) ( fun n => hC _ le_add_self ) ( Summable.mul_left _ <| by simpa using summable_nat_add_iff 1 |>.2 <| Real.summable_nat_rpow.2 <| by linarith )

/-
The integral of x^(-s) from 1 to infinity is 1/(s-1) for Re(s) > 1.
-/
theorem integral_cpow_neg_s_eq_one_div_s_sub_one {s : ℂ} (hs : 1 < s.re) :
    ∫ x in Set.Ioi (1 : ℝ), (x : ℂ) ^ (-s) = 1 / (s - 1) := by
  have h_integral : ∫ x in Set.Ioi (1 : ℝ), (x : ℂ) ^ (-s) = ∫ x in Set.Ioi (1 : ℝ), Complex.exp (-s * Complex.log x) := by
    exact MeasureTheory.setIntegral_congr_fun measurableSet_Ioi fun x hx => by rw [ Complex.cpow_def_of_ne_zero ( Complex.ofReal_ne_zero.mpr <| ne_of_gt <| zero_lt_one.trans hx.out ), mul_comm ] ;
  have h_integral_lim : Filter.Tendsto (fun b : ℝ => ∫ x in (1 : ℝ)..b, Complex.exp (-s * Complex.log x)) Filter.atTop (nhds (∫ x in Set.Ioi (1 : ℝ), Complex.exp (-s * Complex.log x))) := by
    apply_rules [ MeasureTheory.intervalIntegral_tendsto_integral_Ioi ];
    · have h_integrable : MeasureTheory.IntegrableOn (fun x : ℝ => Real.exp (-s.re * Real.log x)) (Set.Ioi (1 : ℝ)) := by
        have h_integrable : MeasureTheory.IntegrableOn (fun x : ℝ => x ^ (-s.re)) (Set.Ioi (1 : ℝ)) := by
          rw [ integrableOn_Ioi_rpow_iff ] <;> linarith;
        exact h_integrable.congr_fun ( fun x hx => by rw [ Real.rpow_def_of_pos ( zero_lt_one.trans hx.out ) ] ; ring ) measurableSet_Ioi;
      refine' h_integrable.norm.mono' _ _;
      · refine' Measurable.aestronglyMeasurable _;
        fun_prop;
      · simp [Complex.norm_exp];
        norm_num [ Filter.eventually_inf_principal, Complex.log_re, Complex.log_im ];
        filter_upwards [ ] with x hx using by rw [ Complex.arg_ofReal_of_nonneg ( by positivity ) ] ; ring_nf; norm_num;
    · exact Filter.tendsto_id;
  have h_integral_eval : ∀ b : ℝ, 1 ≤ b → ∫ x in (1 : ℝ)..b, Complex.exp (-s * Complex.log x) = (1 / (1 - s)) * (b^(1 - s) - 1) := by
    intro b hb
    have : ∀ x ∈ Set.Icc (1 : ℝ) b, Complex.exp (-s * Complex.log x) = x ^ (-s) := by
      intro x hx; rw [ Complex.cpow_def_of_ne_zero ( by norm_cast; linarith [ hx.1 ] ) ] ; ring;
    rw [ intervalIntegral.integral_congr fun x hx => this x <| by simpa [ hb ] using hx ];
    rw [ integral_cpow ] <;> norm_num [ hb ];
    · grind;
    · exact Or.inr ( by rintro rfl; norm_num at hs );
  have h_integral_limit : Filter.Tendsto (fun b : ℝ => (1 / (1 - s)) * (b^(1 - s) - 1)) Filter.atTop (nhds ((1 / (1 - s)) * (0 - 1))) := by
    refine' Filter.Tendsto.mul tendsto_const_nhds _;
    refine' Filter.Tendsto.sub _ tendsto_const_nhds;
    rw [ tendsto_zero_iff_norm_tendsto_zero ];
    have h_lim : Filter.Tendsto (fun b : ℝ => Real.rpow b (1 - s.re)) Filter.atTop (nhds 0) := by
      simpa using tendsto_rpow_neg_atTop ( by linarith : 0 < s.re - 1 );
    refine' h_lim.congr' _;
    filter_upwards [ Filter.eventually_gt_atTop 0 ] with x hx using by rw [ Complex.norm_cpow_eq_rpow_re_of_pos hx ] ; norm_num;
  convert tendsto_nhds_unique h_integral_lim ( h_integral_limit.congr' <| by filter_upwards [ Filter.eventually_ge_atTop 1 ] with b hb using h_integral_eval b hb ▸ rfl ) using 1 ; ring;
  rw [ ← inv_neg ] ; ring

/-
The function floor(x) * x^(-s-1) is integrable on (1, infinity) for Re(s) > 1.
-/
theorem integrable_floor_mul_cpow {s : ℂ} (hs : 1 < s.re) :
    MeasureTheory.IntegrableOn (fun x : ℝ => (Int.floor x : ℂ) * (x : ℂ) ^ (-s - 1)) (Set.Ioi 1) := by
  have h_bound : ∀ x : ℝ, 1 < x → ‖(Int.floor x : ℂ) * (x : ℂ) ^ (-s - 1)‖ ≤ x * x ^ (-s.re - 1) := by
    intro x hx; rw [ norm_mul, Complex.norm_cpow_eq_rpow_re_of_pos ( by positivity ) ] ; norm_num;
    exact mul_le_mul_of_nonneg_right ( by rw [ abs_of_nonneg ( by exact_mod_cast Int.floor_nonneg.mpr ( by positivity ) ) ] ; exact_mod_cast Int.floor_le x ) ( by positivity );
  have h_integrable_g : MeasureTheory.IntegrableOn (fun x : ℝ => x ^ (-s.re)) (Set.Ioi 1) := by
    rw [ integrableOn_Ioi_rpow_iff ] <;> linarith;
  refine' h_integrable_g.mono' _ _;
  · refine' Measurable.aestronglyMeasurable _;
    fun_prop;
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using le_trans ( h_bound x hx ) ( by rw [ ← Real.rpow_one_add' ] <;> norm_num <;> linarith [ hx.out ] )

/-
log(x) * |{x} * x^{-s-1}| is integrable on (1,∞) for Re(s) > 0.
-/
theorem integrable_log_mul_fract_mul_cpow {s : ℂ} (hs : 0 < s.re) :
    MeasureTheory.IntegrableOn (fun x : ℝ => Real.log x * ‖((x : ℂ) - (Int.floor x : ℂ)) * (x : ℂ) ^ (-s - 1)‖) (Set.Ioi 1) := by
  have h_bound : ∀ x : ℝ, x > 1 → Real.log x * ‖((x : ℂ) - (Int.floor x : ℂ)) * (x : ℂ) ^ (-s - 1)‖ ≤ Real.log x * x ^ (-s.re - 1) := by
    intro x hx
    have h_abs : ‖((x : ℂ) - (Int.floor x : ℂ)) * (x : ℂ) ^ (-s - 1)‖ ≤ x ^ (-s.re - 1) := by
      norm_num [ Complex.norm_cpow_eq_rpow_re_of_pos ( zero_lt_one.trans hx ) ];
      exact mul_le_of_le_one_left ( Real.rpow_nonneg ( by positivity ) _ ) ( mod_cast abs_le.mpr ⟨ by linarith [ Int.floor_le x ], by linarith [ Int.lt_floor_add_one x ] ⟩ );
    exact mul_le_mul_of_nonneg_left h_abs <| Real.log_nonneg hx.le;
  have h_integral_converges : MeasureTheory.IntegrableOn (fun x : ℝ => Real.log x * x ^ (-s.re - 1)) (Set.Ioi (1 : ℝ)) := by
    have h_compare : ∀ ε > 0, ∃ C > 0, ∀ x : ℝ, x ≥ 1 → Real.log x * x ^ (-s.re - 1) ≤ C * x ^ (-s.re - 1 + ε) := by
      intro ε hε_pos
      obtain ⟨C, hC_pos, hC⟩ : ∃ C > 0, ∀ x : ℝ, x ≥ 1 → Real.log x ≤ C * x ^ ε := by
        use 1 / ε, by positivity, fun x hx => by have := Real.log_le_sub_one_of_pos ( by positivity : 0 < x ^ ε ) ; rw [ Real.log_rpow ( by positivity ) ] at this; nlinarith [ mul_div_cancel₀ 1 hε_pos.ne', Real.rpow_pos_of_pos ( by positivity : 0 < x ) ε ] ;
      exact ⟨ C, hC_pos, fun x hx => by convert mul_le_mul_of_nonneg_right ( hC x hx ) ( Real.rpow_nonneg ( by linarith : 0 ≤ x ) ( -s.re - 1 ) ) using 1 ; rw [ Real.rpow_add ( by linarith ) ] ; ring ⟩;
    obtain ⟨ε, hε_pos, hε_lt⟩ : ∃ ε > 0, -s.re - 1 + ε < -1 := by
      exact ⟨ s.re / 2, half_pos hs, by linarith ⟩;
    obtain ⟨ C, hC_pos, hC ⟩ := h_compare ε hε_pos;
    have h_integral_converges : MeasureTheory.IntegrableOn (fun x : ℝ => C * x ^ (-s.re - 1 + ε)) (Set.Ioi (1 : ℝ)) := by
      exact ( integrableOn_Ioi_rpow_of_lt ( by linarith ) ( by linarith ) ) |> fun h => h.const_mul _;
    refine' h_integral_converges.mono' _ _;
    · exact Measurable.aestronglyMeasurable ( by exact Measurable.mul ( Real.measurable_log ) ( measurable_id.pow_const _ ) );
    · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using by rw [ Real.norm_of_nonneg ( mul_nonneg ( Real.log_nonneg hx.out.le ) ( Real.rpow_nonneg ( by linarith [ hx.out ] ) _ ) ) ] ; exact hC x hx.out.le;
  refine' h_integral_converges.mono' _ _;
  · refine' Measurable.aestronglyMeasurable _;
    fun_prop (disch := norm_num);
  · filter_upwards [ MeasureTheory.ae_restrict_mem measurableSet_Ioi ] with x hx using by rw [ Real.norm_of_nonneg ( mul_nonneg ( Real.log_nonneg hx.out.le ) ( norm_nonneg _ ) ) ] ; exact h_bound x hx.out;

end Aristotle.ZetaIntegralRep
