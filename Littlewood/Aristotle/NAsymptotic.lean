/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 3c172d7c-bb2b-4ae9-bdeb-3c87ade0e1ad

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the zero counting function N(T), the argument of zeta S(T), and the argument of Gamma on the critical line.
We then prove the asymptotic formula for N(T), N(T) = (T/2π) log(T/2πe) + O(log T), assuming the Riemann-von Mangoldt formula and Stirling's formula for the argument of Gamma, as well as the bound S(T) = O(log T).
These assumptions are stated as explicit hypotheses in the theorem `N_asymptotic`, as the necessary complex analysis infrastructure (argument principle, Stirling's formula for complex argument) is not fully available in the current environment.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ZetaZeroCount

/-
Number of zeros of zeta in the critical strip up to height T
-/
noncomputable def N (T : ℝ) : ℝ := (Set.ncard {s : ℂ | riemannZeta s = 0 ∧ 0 < s.re ∧ s.re < 1 ∧ 0 < s.im ∧ s.im ≤ T} : ℝ)

/-
Argument of zeta on the critical line
-/
noncomputable def S (T : ℝ) : ℝ := (1 / Real.pi) * Complex.arg (riemannZeta (1 / 2 + T * Complex.I))

/-
Argument of Gamma on the critical line
-/
noncomputable def argGamma (T : ℝ) : ℝ := Complex.arg (Complex.Gamma (1 / 4 + (T / 2) * Complex.I))

/-
The number of zeros N(T) satisfies N(T) = (T/2π) log(T/2πe) + O(log T).
-/
theorem N_asymptotic
  (h_S_bound : Asymptotics.IsBigO Filter.atTop S Real.log)
  (h_RVM : Asymptotics.IsBigO Filter.atTop (fun T => N T - ((1 / Real.pi) * argGamma T - (T / (2 * Real.pi)) * Real.log Real.pi + S T + 1)) (fun T => 1 / T))
  (h_Stirling : Asymptotics.IsBigO Filter.atTop (fun T => argGamma T - ((T / 2) * Real.log (T / 2) - T / 2 - Real.pi / 8)) (fun T => 1 / T)) :
  Asymptotics.IsBigO Filter.atTop (fun T => N T - (T / (2 * Real.pi)) * Real.log (T / (2 * Real.pi * Real.exp 1))) Real.log := by
  -- Substitute the asymptotic expansion of $\argGamma(T)$ into the expression.
  have h_subst : (fun T => N T - ((T / (2 * Real.pi)) * (Real.log (T / 2)) - (T / (2 * Real.pi)) - (1 / 8) - (T / (2 * Real.pi)) * (Real.log Real.pi) + S T + 1)) =O[Filter.atTop] (fun T => 1 / T) := by
    have h_subst : (fun T => (1 / Real.pi) * (argGamma T - (T / 2) * Real.log (T / 2) + T / 2 + Real.pi / 8)) =O[Filter.atTop] (fun T => 1 / T) := by
      convert h_Stirling.const_mul_left ( 1 / Real.pi ) using 2 ; ring;
    convert h_RVM.add h_subst using 2 ; ring_nf ; norm_num [ Real.pi_ne_zero ] ; ring_nf;
  -- Simplify the expression inside the absolute value.
  have h_simplify : (fun T => N T - ((T / (2 * Real.pi)) * (Real.log (T / (2 * Real.pi * Real.exp 1))) + S T + 7 / 8)) =O[Filter.atTop] (fun T => 1 / T) := by
    refine h_subst.congr' ?_ ?_;
    · filter_upwards [ Filter.eventually_gt_atTop 0 ] with T hT;
      rw [ show T / ( 2 * Real.pi * Real.exp 1 ) = ( T / 2 ) / Real.pi / Real.exp 1 by ring, Real.log_div ( by positivity ) ( by positivity ), Real.log_div ( by positivity ) ( by positivity ), Real.log_exp ] ; ring;
      rw [ Real.log_mul ( by positivity ) ( by positivity ), Real.log_mul ( by positivity ) ( by positivity ), Real.log_inv ] ; ring;
      simpa using by ring;
    · rfl;
  -- Since $S(T) = O(\log T)$, we can replace $S(T)$ with $O(\log T)$ in the expression.
  have h_replace : (fun T => N T - (T / (2 * Real.pi)) * (Real.log (T / (2 * Real.pi * Real.exp 1))) - S T - 7 / 8) =O[Filter.atTop] Real.log := by
    have h_replace : (fun T => N T - (T / (2 * Real.pi)) * (Real.log (T / (2 * Real.pi * Real.exp 1))) - S T - 7 / 8) =O[Filter.atTop] (fun T => 1 / T) := by
      convert h_simplify using 2 ; ring;
    refine' h_replace.trans _;
    norm_num [ Asymptotics.isBigO_iff ];
    exact ⟨ 1, Real.exp 1, fun x hx => by rw [ inv_eq_one_div, div_le_iff₀ ] <;> cases abs_cases x <;> cases abs_cases ( Real.log x ) <;> nlinarith [ Real.add_one_le_exp 1, Real.log_exp 1, Real.log_le_log ( by positivity ) hx ] ⟩;
  convert h_replace.add ( h_S_bound ) |> ( ·.add ( show ( fun T : ℝ => 7 / 8 ) =O[Filter.atTop] Real.log from ?_ ) ) using 2 ; ring;
  rw [ Asymptotics.isBigO_iff' ];
  exact ⟨ 7 / 8, by norm_num, Filter.eventually_atTop.mpr ⟨ Real.exp 1, fun x hx => by rw [ Real.norm_of_nonneg ( by norm_num ), Real.norm_of_nonneg ( Real.log_nonneg ( by linarith [ Real.add_one_le_exp 1 ] ) ) ] ; nlinarith [ Real.add_one_le_exp 1, Real.log_exp 1, Real.log_le_log ( by positivity ) hx ] ⟩ ⟩

end ZetaZeroCount