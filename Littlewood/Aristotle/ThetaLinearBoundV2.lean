/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 2df183fe-ab90-4144-a2df-33d43145f275

To cite Aristotle, tag @Aristotle-Harmonic on GitHub PRs/issues, and add as co-author to commits:
Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>
-/

/-
We define the Chebyshev function $\theta(n) = \sum_{p \le n} \log p$ and prove that $\theta(n) = O(n)$.
We first show that the product of primes $p$ with $n < p \le 2n$ divides $\binom{2n}{n}$.
From this, we deduce that $\theta(2n) - \theta(n) \le 2n \log 2$.
Finally, using strong induction, we prove that $\theta(n) \le (4 \log 2) n$ for all $n$.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 0
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace ThetaLinearBoundV2

/-
The Chebyshev function theta(n) is the sum of the natural logarithms of all prime numbers less than or equal to n.
-/
noncomputable def theta (n : ℕ) : ℝ := ∑ p ∈ (Finset.range (n + 1)).filter Nat.Prime, Real.log p

/-
The product of primes p such that n < p ≤ 2n divides the central binomial coefficient C(2n, n).
-/
theorem prod_primes_divides_centralBinom (n : ℕ) (hn : 0 < n) :
    (∏ p ∈ (Finset.Ioc n (2*n)).filter Nat.Prime, p) ∣ Nat.choose (2*n) n := by
      -- For prime p with n < p ≤ 2n:
      have h_divides : ∀ p ∈ Finset.filter Nat.Prime (Finset.Ioc n (2 * n)), p ∣ Nat.choose (2 * n) n := by
        norm_num +zetaDelta at *;
        -- The binomial coefficient (2n choose n) is divisible by p since p is a prime factor of (2n)! but not of (n!)^2.
        intro p hp1 hp2 hp3
        have h_div : p ∣ Nat.factorial (2 * n) ∧ ¬(p ∣ Nat.factorial n * Nat.factorial n) := by
          exact ⟨ Nat.dvd_factorial hp3.pos hp2, by rw [ Nat.Prime.dvd_mul hp3 ] ; exact fun h => by exact absurd ( h.resolve_right ( by rw [ Nat.Prime.dvd_factorial hp3 ] ; linarith ) ) ( by rw [ Nat.Prime.dvd_factorial hp3 ] ; linarith ) ⟩;
        simp_all +decide [ Nat.choose_eq_factorial_div_factorial ( show n ≤ 2 * n by linarith ), Nat.Prime.dvd_mul ];
        simp_all +decide [ two_mul, Nat.factorial_ne_zero ];
        refine' Nat.dvd_div_of_mul_dvd _;
        refine' Nat.Coprime.mul_dvd_of_dvd_of_dvd _ _ h_div.1;
        · exact Nat.Coprime.mul_left ( Nat.Coprime.symm <| hp3.coprime_iff_not_dvd.mpr h_div.2 ) ( Nat.Coprime.symm <| hp3.coprime_iff_not_dvd.mpr h_div.2 );
        · exact Nat.factorial_mul_factorial_dvd_factorial_add _ _ |> dvd_trans <| by simp +decide [ two_mul ] ;
      -- Since these primes are distinct, their product divides C(2n,n) by the properties of divisibility.
      have h_distinct_primes : ∀ s : Finset ℕ, (∀ p ∈ s, Nat.Prime p) → (∀ p ∈ s, p ∣ Nat.choose (2 * n) n) → (∏ p ∈ s, p) ∣ Nat.choose (2 * n) n := by
        intros s hs h_divides_s
        induction' s using Finset.induction with p s hs ih;
        · norm_num;
        · rw [ Finset.prod_insert ‹p∉s› ];
          exact Nat.Coprime.mul_dvd_of_dvd_of_dvd ( Nat.Coprime.prod_right fun q hq => by have := Nat.coprime_primes ( hs p ( Finset.mem_insert_self p s ) ) ( hs q ( Finset.mem_insert_of_mem hq ) ) ; aesop ) ( h_divides_s p ( Finset.mem_insert_self p s ) ) ( ih ( fun q hq => hs q ( Finset.mem_insert_of_mem hq ) ) ( fun q hq => h_divides_s q ( Finset.mem_insert_of_mem hq ) ) );
      exact h_distinct_primes _ ( fun p hp => Finset.mem_filter.mp hp |>.2 ) h_divides

/-
The difference between theta(2n) and theta(n) is at most 2n * log 2.
-/
theorem theta_two_mul_sub_theta_le (n : ℕ) (hn : 0 < n) :
    theta (2 * n) - theta n ≤ 2 * n * Real.log 2 := by
      -- Taking logs: θ(2n) - θ(n) ≤ log C(2n,n)
      have h_log : theta (2 * n) - theta n ≤ Real.log (Nat.choose (2 * n) n) := by
        -- By definition of theta, we have theta(2n) - theta(n) = sum_{p \le 2n} log p - sum_{p \le n} log p.
        have h_diff : theta (2 * n) - theta n = ∑ p ∈ (Finset.Ioc n (2 * n)).filter Nat.Prime, Real.log p := by
          -- By definition of theta, we can write theta(2n) - theta(n) as the sum of the logarithms of primes between n and 2n.
          have h_theta_diff : theta (2 * n) - theta n = ∑ p ∈ (Finset.Icc (n + 1) (2 * n)).filter Nat.Prime, Real.log p := by
            unfold theta;
            erw [ Finset.sum_filter, Finset.sum_filter, Finset.sum_filter ];
            erw [ Finset.sum_Ico_eq_sub _ _ ] ; linarith!;
          rwa [ show Finset.Icc (n + 1) (2 * n) = Finset.Ioc n (2 * n) from Finset.Icc_succ_left_eq_Ioc n (2 * n) ] at h_theta_diff;
        -- Since $\prod_{n < p \le 2n} p \le \binom{2n}{n}$, we have $\sum_{n < p \le 2n} \log p \le \log \binom{2n}{n}$.
        have h_prod_le : (∏ p ∈ (Finset.Ioc n (2 * n)).filter Nat.Prime, p : ℝ) ≤ Nat.choose (2 * n) n := by
          have h_prod_le : (∏ p ∈ (Finset.Ioc n (2 * n)).filter Nat.Prime, p : ℕ) ∣ Nat.choose (2 * n) n := by
            exact prod_primes_divides_centralBinom n hn;
          rw [ ← Nat.cast_prod ] ; exact_mod_cast Nat.le_of_dvd ( Nat.choose_pos ( by linarith ) ) h_prod_le;
        rw [ h_diff, ← Real.log_prod (fun x hx => Nat.cast_ne_zero.mpr <| Nat.Prime.ne_zero <| by aesop) ] ; exact Real.log_le_log ( Finset.prod_pos fun x hx => Nat.cast_pos.mpr <| Nat.Prime.pos <| by aesop ) h_prod_le;
      refine le_trans h_log ?_;
      rw [ ← Real.log_rpow, Real.log_le_log_iff ] <;> norm_cast <;> norm_num;
      · rw [ ← Nat.sum_range_choose ] ; exact Finset.single_le_sum ( fun x _ => Nat.zero_le _ ) ( Finset.mem_range.mpr ( by linarith ) );
      · exact Nat.choose_pos ( by linarith )

/-
There exists a constant C such that theta(n) ≤ C * n for all n.
-/
theorem theta_O_n : ∃ C, ∀ n, theta n ≤ C * n := by
  -- We have proved that theta(2n) - theta(n) ≤ 2n log 2.
  have h1 : ∀ n : ℕ, 0 < n → theta (2 * n) - theta n ≤ 2 * n * Real.log 2 := by
    exact fun n a => theta_two_mul_sub_theta_le n a;
  -- Let C = 4 log 2. We show theta(n) ≤ C n by strong induction on n.
  use 4 * Real.log 2;
  intro n
  induction' n using Nat.strong_induction_on with n ih;
  rcases Nat.even_or_odd' n with ⟨ k, rfl | rfl ⟩ <;> simp +arith +decide [ * ] at *;
  · rcases k with ( _ | k ) <;> norm_num at *;
    · exact Finset.sum_nonpos fun p hp => by aesop;
    · have := h1 ( k + 1 ) ( by linarith ) ; have := ih ( k + 1 ) ( by linarith ) ; norm_num at * ; nlinarith [ Real.log_pos one_lt_two ];
  · -- For the odd case, we use the fact that $\theta(2k+1) = \theta(2k) + \ln(2k+1)$ if $2k+1$ is prime, otherwise $\theta(2k+1) = \theta(2k)$.
    have h_odd : theta (2 * k + 1) ≤ theta (2 * k) + Real.log (2 * k + 1) := by
      unfold theta;
      norm_num [ Finset.sum_filter, Finset.sum_range_succ ];
      split_ifs <;> norm_num ; linarith [ Real.log_nonneg ( by linarith : ( 2 * k + 1 : ℝ ) ≥ 1 ) ];
    -- Since $\ln(2k+1) \leq \ln(2^{2k}) = 2k \ln(2)$ for $k \geq 1$, we have $\theta(2k+1) \leq \theta(2k) + 2k \ln(2)$.
    have h_log : Real.log (2 * k + 1) ≤ 2 * k * Real.log 2 := by
      rw [ ← Real.log_rpow, Real.log_le_log_iff ] <;> norm_cast <;> ring <;> norm_num;
      exact Nat.recOn k ( by norm_num ) fun n ihn => by norm_num [ Nat.pow_succ', Nat.pow_mul' ] at ihn ⊢ ; nlinarith;
    rcases k with ( _ | k ) <;> norm_num at *;
    · linarith [ Real.log_pos one_lt_two ];
    · have := h1 ( k + 1 ) ( by linarith ) ; have := ih ( k + 1 ) ( by linarith ) ; norm_num at * ; nlinarith [ Real.log_pos one_lt_two ] ;

end ThetaLinearBoundV2