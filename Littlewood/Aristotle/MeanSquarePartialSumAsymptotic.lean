/-
This file was generated by Aristotle.

Lean version: leanprover/lean4:v4.24.0
Mathlib version: f897ebcf72cd16f89ab4577d0c826cd14afaafc7
This project request had uuid: 63facf81-e73a-46a4-92a0-526c6c5f6539

Co-authored-by: Aristotle (Harmonic) <aristotle-harmonic@harmonic.fun>

Proves the mean square lower bound for the partial zeta sum with N = N(T) = ⌊√(T/2π)⌋.
This is a more refined version than MeanSquareLowerBound.lean, with detailed estimates
on the off-diagonal terms.

Main result: ∃ c > 0, ∃ T₁ ≥ 10, ∀ T ≥ T₁,
  ∫₁ᵀ |Σ_{n≤N(T)} n^{-1/2-it}|² dt ≥ c * T * log T

This is a KEY component for Hardy's theorem on the infinitude of zeros.
-/

import Mathlib

set_option linter.mathlibStandardSet false

open scoped BigOperators
open scoped Real
open scoped Nat
open scoped Classical
open scoped Pointwise

set_option maxHeartbeats 800000
set_option maxRecDepth 4000
set_option synthInstance.maxHeartbeats 20000
set_option synthInstance.maxSize 128

set_option relaxedAutoImplicit false
set_option autoImplicit false

noncomputable section

namespace MeanSquarePartialSumAsymptotic

open Complex Real Set Filter Topology MeasureTheory

/-
The partial sum of the Dirichlet series for the Riemann zeta function on the critical line, defined as the sum from n=1 to N of n^(-1/2 - it).
-/
def partialZetaSum (N : ℕ) (t : ℝ) : ℂ :=
  ∑ n ∈ Finset.range N, (n + 1 : ℂ) ^ (-(1/2 : ℂ) - Complex.I * t)

/-
N(T) is defined as the floor of sqrt(T / 2π).
-/
noncomputable def N_of_T (T : ℝ) : ℕ := Int.toNat (Int.floor (Real.sqrt (T / (2 * Real.pi))))

/-
The integral of the squared norm of the partial sum equals the diagonal term plus the off-diagonal terms. The diagonal term is (T-1) times the harmonic sum. The off-diagonal terms involve integrals of exponentials.
-/
lemma integral_norm_sq_partial_sum (N : ℕ) (T : ℝ) (hT : T ≥ 1) :
    ∫ t in Set.Ioc 1 T, ‖partialZetaSum N t‖^2 =
    (T - 1) * ∑ n ∈ Finset.range N, (1 : ℝ) / (n + 1) +
    ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, if n = m then 0 else
      (1 / Real.sqrt ((n + 1) * (m + 1))) * ∫ t in Set.Ioc 1 T, Complex.exp (Complex.I * t * Real.log ((m + 1) / (n + 1))) := by
  -- Expand the square of the sum to get the diagonal and off-diagonal terms.
  have h_expand : ∀ t ∈ Set.Ioc 1 T, ‖partialZetaSum N t‖^2 = ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (1 : ℂ) / Real.sqrt ((n + 1) : ℝ) / Real.sqrt ((m + 1) : ℝ) * Complex.exp (Complex.I * t * Real.log ((m + 1) / (n + 1))) := by
    intro t ht
    have h_expand : ‖partialZetaSum N t‖^2 = (∑ n ∈ Finset.range N, (1 : ℂ) / Real.sqrt ((n + 1) : ℝ) * Complex.exp (-Complex.I * t * Real.log (n + 1))) * (∑ m ∈ Finset.range N, (1 : ℂ) / Real.sqrt ((m + 1) : ℝ) * Complex.exp (Complex.I * t * Real.log (m + 1))) := by
      have h_expand : partialZetaSum N t = ∑ n ∈ Finset.range N, (1 : ℂ) / Real.sqrt ((n + 1) : ℝ) * Complex.exp (-Complex.I * t * Real.log (n + 1)) := by
        refine' Finset.sum_congr rfl fun n hn => _;
        rw [ Complex.cpow_def_of_ne_zero ( Nat.cast_add_one_ne_zero n ) ] ; norm_num ; ring;
        rw [ Complex.log ] ; norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im, Complex.log_re, Complex.log_im ] ; ring;
        norm_cast ; norm_num [ Real.sqrt_eq_rpow, Real.rpow_neg, Real.exp_neg, Real.exp_log ( by positivity : 0 < ( 1 + n : ℝ ) ) ] ; ring;
        norm_num [ Rat.divInt_eq_div, Real.rpow_def_of_pos ( by positivity : 0 < ( 1 + n : ℝ ) ) ] ; ring ; norm_num;
        exact ⟨ by rw [ ← Real.exp_neg ] ; ring, Or.inl <| by rw [ ← Real.exp_neg ] ⟩;
      have h_conj : ∑ m ∈ Finset.range N, (1 : ℂ) / Real.sqrt ((m + 1) : ℝ) * Complex.exp (Complex.I * t * Real.log (m + 1)) = starRingEnd ℂ (∑ n ∈ Finset.range N, (1 : ℂ) / Real.sqrt ((n + 1) : ℝ) * Complex.exp (-Complex.I * t * Real.log (n + 1))) := by
        norm_num [ Complex.ext_iff, Complex.exp_re, Complex.exp_im ];
      rw [ h_expand, h_conj, Complex.mul_conj, Complex.normSq_eq_norm_sq ] ; norm_cast;
    rw [ h_expand, Finset.sum_mul ];
    refine' Finset.sum_congr rfl fun i hi => _;
    rw [ Finset.mul_sum _ _ _ ] ; refine' Finset.sum_congr rfl fun j hj => _ ; rw [ Real.log_div ( by positivity ) ( by positivity ) ] ; ring;
    norm_num [ mul_assoc, mul_left_comm, ← Complex.exp_add ] ; ring;
    rw [ Complex.exp_add ] ; ring;
  -- By Fubini's theorem, we can interchange the order of summation and integration.
  have h_fubini : ∫ t in Set.Ioc 1 T, ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (1 : ℂ) / Real.sqrt ((n + 1) : ℝ) / Real.sqrt ((m + 1) : ℝ) * Complex.exp (Complex.I * t * Real.log ((m + 1) / (n + 1))) = ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, (1 : ℂ) / Real.sqrt ((n + 1) : ℝ) / Real.sqrt ((m + 1) : ℝ) * ∫ t in Set.Ioc 1 T, Complex.exp (Complex.I * t * Real.log ((m + 1) / (n + 1))) := by
    rw [ MeasureTheory.integral_finset_sum ];
    · exact Finset.sum_congr rfl fun _ _ => by rw [ MeasureTheory.integral_finset_sum _ fun _ _ => Continuous.integrableOn_Ioc <| by continuity ] ; exact Finset.sum_congr rfl fun _ _ => by rw [ MeasureTheory.integral_const_mul ] ;
    · exact fun _ _ => Continuous.integrableOn_Ioc ( by continuity );
  convert h_fubini using 1;
  · rw [ ← MeasureTheory.setIntegral_congr_fun measurableSet_Ioc h_expand ] ; norm_cast;
    exact integral_ofReal.symm;
  · norm_num [ Finset.sum_ite, Finset.filter_ne ];
    norm_num [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm, Finset.mul_sum _ _ _, Finset.sum_mul, Real.sqrt_mul ( add_nonneg ( Nat.cast_nonneg _ ) zero_le_one ) ];
    rw [ ← Finset.sum_add_distrib ] ; refine' Finset.sum_congr rfl fun i hi => _ ; rw [ Finset.sum_erase_eq_sub ( Finset.mem_range.mpr <| Finset.mem_range.mp hi ) ] ; ring;
    norm_num [ show ( i : ℝ ) * ( 1 + i : ℝ ) ⁻¹ + ( 1 + i : ℝ ) ⁻¹ = 1 by linarith [ mul_inv_cancel₀ ( by linarith : ( 1 + i : ℝ ) ≠ 0 ) ] ] ; ring;
    norm_cast ; norm_num [ show ( 1 + i : ℝ ) ≠ 0 by linarith, show ( 1 + i : ℝ ) ≥ 0 by linarith, Real.sq_sqrt <| show ( 0 : ℝ ) ≤ 1 + i by linarith, hT ] ; ring

/-
The sum of 1/(n+1) from n=0 to N-1 is at least log(N+1).
-/
lemma harmonic_sum_lower_bound (N : ℕ) :
    ∑ n ∈ Finset.range N, (1 : ℝ) / (n + 1) ≥ Real.log (N + 1) := by
  -- We can use the fact that $\sum_{n=1}^N \frac{1}{n}$ is greater than or equal to $\int_{1}^{N+1} \frac{1}{x} \, dx$.
  have h_integral_bound : ∑ n ∈ Finset.range N, (1 : ℝ) / (n + 1) ≥ ∑ n ∈ Finset.range N, (Real.log (n + 2) - Real.log (n + 1)) := by
    exact Finset.sum_le_sum fun i hi => by rw [ ← Real.log_div ( by positivity ) ( by positivity ) ] ; exact le_trans ( Real.log_le_sub_one_of_pos ( by positivity ) ) ( by ring_nf; nlinarith [ mul_inv_cancel₀ ( by positivity : ( 1 + i : ℝ ) ≠ 0 ) ] ) ;
  convert h_integral_bound using 1;
  exact Nat.recOn N ( by norm_num ) fun n ih => by norm_num [ add_assoc, Finset.sum_range_succ ] at * ; linarith

/-
The logarithm of N(T) + 1 is at least half the logarithm of T minus half the logarithm of 2π.
-/
lemma log_N_lower_bound (T : ℝ) (hT : T ≥ 10) :
    Real.log ((N_of_T T : ℝ) + 1) ≥ 0.5 * Real.log T - 0.5 * Real.log (2 * Real.pi) := by
  -- We use the inequality $N(T) \geq \sqrt{T/(2\pi)} - 1$ to derive the bound for $\log(N(T))$.
  have h_log_bound : Real.log (N_of_T T + 1) ≥ Real.log (Real.sqrt (T / (2 * Real.pi))) := by
    exact Real.log_le_log ( by positivity ) ( by exact le_of_lt ( Nat.lt_floor_add_one _ ) );
  convert h_log_bound using 1 ; rw [ Real.log_sqrt <| by positivity ] ; rw [ Real.log_div ( by positivity ) <| by positivity ] ; ring;

/-
The diagonal term is at least (1/20) * T * log T for T >= 10.
-/
lemma diagonal_lower (T : ℝ) (hT : T ≥ 10) :
    (T - 1) * ∑ n ∈ Finset.range (N_of_T T), (1 : ℝ) / (n + 1) ≥ (1/20) * T * Real.log T := by
  -- From harmonic_sum_lower_bound, sum >= log(N+1).
  have h_diag_term : (T - 1) * (∑ n ∈ Finset.range (N_of_T T), (1 : ℝ) / (n + 1)) ≥ (T - 1) * (Real.log (N_of_T T + 1)) := by
    exact mul_le_mul_of_nonneg_left ( harmonic_sum_lower_bound _ ) ( by linarith );
  -- From log_N_lower_bound, log(N+1) >= 0.5 log T - 0.5 log(2pi).
  have h_log_lower_bound : Real.log (N_of_T T + 1) ≥ 0.5 * Real.log T - 0.5 * Real.log (2 * Real.pi) := by
    exact log_N_lower_bound T hT;
  -- We'll use that $\log(2\pi) \approx 1.837877$.
  have h_log_approx : Real.log (2 * Real.pi) < 1.9 := by
    rw [ Real.log_lt_iff_lt_exp ] <;> norm_num;
    · -- We'll use that $e^{19/10} > 6.685$.
      have h_exp_approx : Real.exp (19 / 10) > 6.685 := by
        -- We can raise both sides to the power of 10 to remove the fraction.
        have h_exp_approx : Real.exp 19 > 6.685 ^ 10 := by
          have := Real.exp_one_gt_d9.le ; norm_num1 at * ; rw [ show Real.exp 19 = ( Real.exp 1 ) ^ 19 by rw [ ← Real.exp_nat_mul ] ; norm_num ] ; exact lt_of_lt_of_le ( by norm_num ) ( pow_le_pow_left₀ ( by positivity ) this _ );
        contrapose! h_exp_approx;
        exact le_trans ( by norm_num [ ← Real.exp_nat_mul ] ) ( pow_le_pow_left₀ ( by positivity ) h_exp_approx 10 );
      -- We'll use that $\pi \approx 3.14159$.
      have h_pi_approx : Real.pi < 3.1416 := by
        exact Real.pi_lt_d4;
      norm_num at * ; linarith;
    · positivity;
  -- We'll use that $\log T \geq \log 10$ for $T \geq 10$.
  have h_log_T_ge_log_10 : Real.log T ≥ Real.log 10 := by
    exact Real.log_le_log ( by norm_num ) hT;
  -- We'll use that $\log 10 \approx 2.3026$.
  have h_log_10_approx : Real.log 10 > 2.3 := by
    norm_num [ Real.log_lt_log ];
    rw [ div_lt_iff₀' ] <;> norm_num [ ← Real.log_rpow, Real.lt_log_iff_exp_lt ];
    have := Real.exp_one_lt_d9.le ; norm_num1 at * ; rw [ show Real.exp 23 = ( Real.exp 1 ) ^ 23 by rw [ ← Real.exp_nat_mul ] ; norm_num ] ; exact lt_of_le_of_lt ( pow_le_pow_left₀ ( by positivity ) this _ ) ( by norm_num );
  norm_num at * ; nlinarith

/-
The off-diagonal terms of the mean square of the partial zeta sum.
-/
def offDiagonalSum (N : ℕ) (T : ℝ) : ℂ :=
  ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, if n = m then 0 else
    (1 / Real.sqrt ((n + 1) * (m + 1))) * ∫ t in Set.Ioc 1 T, Complex.exp (Complex.I * t * Real.log ((m + 1) / (n + 1)))

/-
The integral of exp(i * t * log(m/n)) is bounded by 2 / |log(m/n)|.
-/
lemma integral_exp_log_bound (n m : ℕ) (hn : n > 0) (hm : m > 0) (hneq : n ≠ m) (T : ℝ) (hT : T ≥ 1) :
    ‖∫ t in Set.Ioc 1 T, Complex.exp (Complex.I * t * Real.log (m / n))‖ ≤ 2 / |Real.log (m / n)| := by
  -- The integral is of exp(i * t * log(m/n)) where lambda = log(m/n).
  have h_integral : ∫ t in Set.Ioc 1 T, Complex.exp (Complex.I * (t : ℂ) * (Real.log ((m : ℝ) / (n : ℝ)))) =
    (Complex.exp (Complex.I * (T : ℂ) * (Real.log ((m : ℝ) / (n : ℝ)))) - Complex.exp (Complex.I * (1 : ℂ) * (Real.log ((m : ℝ) / (n : ℝ))))) / (Complex.I * (Real.log ((m : ℝ) / (n : ℝ)))) := by
      -- The integral of $e^{i \lambda t}$ over $[1, T]$ is given by the fundamental theorem of calculus.
      have h_ftc : ∀ a b : ℝ, ∫ t in a..b, Complex.exp (Complex.I * (t : ℂ) * (Real.log ((m : ℝ) / (n : ℝ)))) =
        (Complex.exp (Complex.I * (b : ℂ) * (Real.log ((m : ℝ) / (n : ℝ)))) - Complex.exp (Complex.I * (a : ℂ) * (Real.log ((m : ℝ) / (n : ℝ))))) / (Complex.I * (Real.log ((m : ℝ) / (n : ℝ)))) := by
          intro a b;
          by_cases h : Real.log ( m / n ) = 0 <;> simp_all +decide [ div_eq_inv_mul ];
          · simp_all +decide [ ne_of_gt ];
            cases h <;> rw [ inv_mul_eq_div, div_eq_iff ] at * <;> norm_cast at * <;> aesop;
          · have := @integral_exp_mul_complex a b;
            convert @this ( Complex.I * Real.log ( ( n : ℝ ) ⁻¹ * m ) ) ( mul_ne_zero Complex.I_ne_zero <| mod_cast fun h' => h.2.1 <| by aesop ) using 1 <;> norm_num [ div_eq_inv_mul, mul_assoc, mul_comm, mul_left_comm ];
      rw [ ← intervalIntegral.integral_of_le ( by linarith ), h_ftc ] ; norm_num;
  simp_all +decide [ Complex.norm_exp ];
  gcongr;
  exact le_trans ( norm_sub_le _ _ ) ( by norm_num [ Complex.norm_exp ] )

/-
The sum of the upper bounds of the absolute values of the off-diagonal terms.
-/
def offDiagonalSumBound (N : ℕ) : ℝ :=
  ∑ n ∈ Finset.range N, ∑ m ∈ Finset.range N, if n = m then 0 else
    (1 / Real.sqrt ((n + 1) * (m + 1))) * (2 / |Real.log ((m + 1) / (n + 1))|)

/-
Each term in the off-diagonal sum is bounded by 4.
-/
lemma off_diagonal_term_bound (n m : ℕ) (hn : n ≠ m) :
    (1 / Real.sqrt ((n + 1) * (m + 1))) * (2 / |Real.log ((m + 1) / (n + 1))|) ≤ 4 := by
  -- Assume without loss of generality that $m > n$.
  suffices h_wlog : ∀ {n m : ℕ}, n < m → (1 / Real.sqrt ((n + 1) * (m + 1))) * (2 / |Real.log ((m + 1) / (n + 1))|) ≤ 4 by
    field_simp;
    cases lt_or_gt_of_ne hn <;> have := @h_wlog _ _ ‹_› <;> simp_all +decide [ div_eq_mul_inv, mul_assoc, mul_comm, mul_left_comm ];
    · convert mul_le_mul_of_nonneg_right ( h_wlog ‹_› ) ( Real.sqrt_nonneg ( ( n + 1 : ℝ ) * ( m + 1 ) ) ) using 1 ; ring;
      rw [ mul_inv_cancel_right₀ ( by positivity ) ];
    · rw [ show ( ( m : ℝ ) + 1 ) * ( ( n : ℝ ) + 1 ) ⁻¹ = ( ( n + 1 : ℝ ) * ( m + 1 : ℝ ) ⁻¹ ) ⁻¹ by group, Real.log_inv ] ; norm_num;
      nlinarith [ inv_pos.mpr ( Real.sqrt_pos.mpr ( by positivity : 0 < ( n + 1 : ℝ ) * ( m + 1 ) ) ), mul_inv_cancel₀ ( ne_of_gt ( Real.sqrt_pos.mpr ( by positivity : 0 < ( n + 1 : ℝ ) * ( m + 1 ) ) ) ), Real.sqrt_nonneg ( ( n + 1 : ℝ ) * ( m + 1 ) ), Real.mul_self_sqrt ( by positivity : 0 ≤ ( n + 1 : ℝ ) * ( m + 1 ) ) ];
  -- Let $m = n + k$ with $k \geq 1$.
  intro n m hnm
  obtain ⟨k, hk⟩ : ∃ k : ℕ, m = n + k ∧ 1 ≤ k := by
    exact ⟨ m - n, by rw [ Nat.add_sub_cancel' hnm.le ], Nat.sub_pos_of_lt hnm ⟩;
  -- Using the inequality $\log(1 + x) \geq \frac{x}{1 + x}$ for $x > 0$, we get $\log((n + k + 1) / (n + 1)) \geq \frac{k}{n + k + 1}$.
  have h_log_ineq : Real.log ((n + k + 1) / (n + 1)) ≥ k / (n + k + 1) := by
    have h_log_ineq : ∀ x : ℝ, 0 < x → Real.log (1 + x) ≥ x / (1 + x) := by
      exact fun x x_pos ↦ by rw [ ge_iff_le ] ; rw [ div_le_iff₀ ( by positivity ) ] ; nlinarith [ Real.log_inv ( 1 + x ), Real.log_le_sub_one_of_pos ( inv_pos.mpr ( by positivity : 0 < ( 1 + x ) ) ), mul_inv_cancel₀ ( by positivity : ( 1 + x ) ≠ 0 ) ] ;
    convert h_log_ineq ( k / ( n + 1 ) ) ( by exact div_pos ( Nat.cast_pos.mpr hk.2 ) ( by positivity ) ) using 1 <;> ring;
    · exact congrArg Real.log ( by linarith [ mul_inv_cancel₀ ( by linarith : ( 1 + n : ℝ ) ≠ 0 ) ] );
    · -- Simplifying the right-hand side:
      field_simp
      ring;
  -- Substitute the inequality $\log((n + k + 1) / (n + 1)) \geq \frac{k}{n + k + 1}$ into the expression.
  have h_subst : (1 / Real.sqrt ((n + 1) * (n + k + 1))) * (2 / (k / (n + k + 1))) ≤ 4 := by
    field_simp;
    rw [ div_le_iff₀ ( by norm_cast; linarith ) ];
    nlinarith only [ show ( k : ℝ ) ≥ 1 by norm_cast; linarith, show ( Real.sqrt ( ( n + 1 ) * ( n + k + 1 ) ) : ℝ ) ≥ n + 1 by exact Real.le_sqrt_of_sq_le ( by nlinarith only [ show ( k : ℝ ) ≥ 1 by norm_cast; linarith ] ), Real.mul_self_sqrt ( by positivity : 0 ≤ ( n + 1 : ℝ ) * ( n + k + 1 ) ) ];
  simp_all +decide [ abs_of_nonneg, Real.log_nonneg, add_assoc ];
  exact le_trans ( mul_le_mul_of_nonneg_left ( by rw [ abs_of_nonneg ( Real.log_nonneg <| by rw [ le_div_iff₀ <| by positivity ] ; linarith ) ] ; exact div_le_div_of_nonneg_left ( by positivity ) ( by positivity ) h_log_ineq ) <| by positivity ) h_subst

/-
The off-diagonal sum bound is at most 4 * N^2.
-/
lemma off_diagonal_sum_bound_le (N : ℕ) :
    offDiagonalSumBound N ≤ 4 * (N : ℝ)^2 := by
  exact le_trans ( Finset.sum_le_sum fun i hi => Finset.sum_le_sum fun j hj => show ( if i = j then 0 else 1 / Real.sqrt ( ( i + 1 ) * ( j + 1 ) ) * ( 2 / |Real.log ( ( j + 1 ) / ( i + 1 ) )| ) ) ≤ 4 by split_ifs <;> first | positivity | exact off_diagonal_term_bound _ _ <| by aesop ) <| by simp +decide [ mul_assoc, mul_comm, mul_left_comm, pow_two ] ;

/-
The norm of the off-diagonal sum is bounded by the sum of the bounds of its terms.
-/
lemma norm_off_diagonal_le_bound (N : ℕ) (T : ℝ) (hT : T ≥ 1) :
    ‖offDiagonalSum N T‖ ≤ offDiagonalSumBound N := by
  refine' le_trans ( norm_sum_le _ _ ) _;
  refine' le_trans ( Finset.sum_le_sum fun i hi => norm_sum_le _ _ ) _;
  refine' le_trans ( Finset.sum_le_sum fun i hi => Finset.sum_le_sum fun j hj => _ ) _;
  use fun i j => if i = j then 0 else ( 1 / Real.sqrt ( ( i + 1 ) * ( j + 1 ) ) ) * ( 2 / |Real.log ( ( j + 1 ) / ( i + 1 ) )| );
  · field_simp;
    split_ifs <;> simp_all +decide [ div_eq_mul_inv ];
    have := integral_exp_log_bound ( i + 1 ) ( j + 1 ) ( by positivity ) ( by positivity ) ( by simpa [ add_comm ] using ‹¬i = j› ) T hT ; simp_all +decide [ abs_of_nonneg, Real.sqrt_nonneg ];
    convert mul_le_mul_of_nonneg_right this ( inv_nonneg.2 ( Real.sqrt_nonneg _ ) ) using 1 ; ring;
  · exact le_rfl

/-
The off-diagonal sum is bounded by T.
-/
lemma off_diagonal_bound :
    ∃ C : ℝ, ∀ T : ℝ, T ≥ 10 → ‖offDiagonalSum (N_of_T T) T‖ ≤ C * T := by
  use 4 / ( 2 * Real.pi );
  intro T hT
  have h_bound : offDiagonalSumBound (N_of_T T) ≤ 4 * (Real.sqrt (T / (2 * Real.pi)))^2 := by
    -- Since $N_of_T T$ is the floor of $\sqrt{T/(2\pi)}$, we have $(N_of_T T)^2 \leq T/(2\pi)$.
    have h_floor : (N_of_T T : ℝ)^2 ≤ T / (2 * Real.pi) := by
      have hN_sq : (N_of_T T : ℝ) ≤ Real.sqrt (T / (2 * Real.pi)) := by
        exact Nat.floor_le ( Real.sqrt_nonneg _ ) |> le_trans ( mod_cast by aesop );
      exact le_trans ( pow_le_pow_left₀ ( Nat.cast_nonneg _ ) hN_sq 2 ) ( by rw [ Real.sq_sqrt ( by positivity ) ] );
    exact le_trans ( off_diagonal_sum_bound_le _ ) ( by rw [ Real.sq_sqrt ( by positivity ) ] ; nlinarith );
  exact le_trans ( norm_off_diagonal_le_bound _ _ <| by linarith ) <| h_bound.trans_eq <| by rw [ Real.sq_sqrt <| by positivity ] ; ring;

/-
There exist constants c1 and T1 such that for T >= T1, the mean square of the partial sum is at least c1 * T * log T.
-/
lemma mean_square_partial_sum_lower_asymptotic :
    ∃ c₁ > 0, ∃ T₁ ≥ 10, ∀ T : ℝ, T ≥ T₁ →
      ∫ t in Set.Ioc 1 T, ‖partialZetaSum (N_of_T T) t‖^2 ≥ c₁ * T * Real.log T := by
  -- By Lemma~\ref{lem:diagonal_lower}, the diagonal term is at least $(1/20)T\log T$.
  have diagonal_lower_bound : ∀ T : ℝ, T ≥ 10 → (T - 1) * ∑ n ∈ Finset.range (N_of_T T), (1 : ℝ) / (n + 1) ≥ (1 / 20) * T * Real.log T := by
    exact diagonal_lower;
  -- By Lemma~\ref{lem:off_diagonal_bound}, the off-diagonal terms are bounded by $C * T$ for some constant $C$.
  obtain ⟨C, hC⟩ : ∃ C : ℝ, ∀ T : ℝ, T ≥ 10 → ‖offDiagonalSum (N_of_T T) T‖ ≤ C * T := by
    exact off_diagonal_bound;
  -- So, for $T \geq T₁$, the integral is at least $(1/20)T\log T - CT$.
  have integral_lower_bound : ∀ T : ℝ, T ≥ 10 → ∫ t in Set.Ioc 1 T, ‖partialZetaSum (N_of_T T) t‖ ^ 2 ≥ (1 / 20) * T * Real.log T - C * T := by
    intros T hT
    have h_integral_split : ∫ t in Set.Ioc 1 T, ‖partialZetaSum (N_of_T T) t‖ ^ 2 = (T - 1) * ∑ n ∈ Finset.range (N_of_T T), (1 : ℝ) / (n + 1) + ∑ n ∈ Finset.range (N_of_T T), ∑ m ∈ Finset.range (N_of_T T), if n = m then 0 else (1 / Real.sqrt ((n + 1) * (m + 1))) * ∫ t in Set.Ioc 1 T, Complex.exp (Complex.I * t * Real.log ((m + 1) / (n + 1))) := by
      convert integral_norm_sq_partial_sum ( N_of_T T ) T ( by linarith ) using 1;
    -- Applying the bound on the off-diagonal sum, we get:
    have h_off_diagonal_bound : ‖∑ n ∈ Finset.range (N_of_T T), ∑ m ∈ Finset.range (N_of_T T), if n = m then 0 else (1 / Real.sqrt ((n + 1) * (m + 1))) * ∫ t in Set.Ioc 1 T, Complex.exp (Complex.I * t * Real.log ((m + 1) / (n + 1)))‖ ≤ C * T := by
      convert hC T hT using 1;
    norm_num [ Complex.ext_iff ] at *;
    norm_num [ Complex.normSq, Complex.norm_def ] at *;
    rw [ Real.sqrt_le_iff ] at h_off_diagonal_bound ; nlinarith [ diagonal_lower_bound T hT ];
  -- We need to show that $(1/20)T\log T - CT \geq c₁T\log T$ for some $c₁ > 0$ and $T \geq T₁$.
  have h_ineq : ∃ c₁ : ℝ, 0 < c₁ ∧ ∃ T₁ : ℝ, 10 ≤ T₁ ∧ ∀ T : ℝ, T ≥ T₁ → (1 / 20) * T * Real.log T - C * T ≥ c₁ * T * Real.log T := by
    -- We can choose $c₁ = 1/40$ and $T₁$ such that for all $T \geq T₁$, $(1/20) \log T - C \geq (1/40) \log T$.
    use 1 / 40;
    norm_num;
    exact ⟨ Max.max 10 ( Real.exp ( 40 * |C| ) ), le_max_left _ _, fun T hT => by cases abs_cases C <;> nlinarith [ le_max_right 10 ( Real.exp ( 40 * |C| ) ), Real.add_one_le_exp ( 40 * |C| ), Real.log_exp ( 40 * |C| ), Real.log_le_log ( by positivity ) ( show T ≥ Real.exp ( 40 * |C| ) by linarith [ le_max_right 10 ( Real.exp ( 40 * |C| ) ) ] ) ] ⟩;
  exact ⟨ h_ineq.choose, h_ineq.choose_spec.1, h_ineq.choose_spec.2.choose, h_ineq.choose_spec.2.choose_spec.1, fun T hT => le_trans ( h_ineq.choose_spec.2.choose_spec.2 T hT ) ( integral_lower_bound T ( by linarith [ h_ineq.choose_spec.2.choose_spec.1 ] ) ) ⟩

end MeanSquarePartialSumAsymptotic
